This ARM Architecture Reference Manual is protected by copyright and the practice or implementation of the information herein may be protected by one or more patents or pending applications. No part of this ARM Architecture Reference Manual may be reproduced in any form by any means without the express prior written permission of ARM. No license, express or implied, by estoppel or otherwise to any intellectual property rights is granted by this ARM Architecture Reference Manual.

Your access to the information in this ARM Architecture Reference Manual is conditional upon your acceptance that you will not use or permit others to use the information for the purposes of determining whether implementations of the ARM architecture infringe any third party patents.

This ARM Architecture Reference Manual is provided “as is”. ARM makes no representations or warranties, either express or implied, included but not limited to, warranties of merchantability, fitness for a particular purpose, or non-infringement, that the content of this ARM Architecture Reference Manual is suitable for any particular purpose or that any practice or implementation of the contents of the ARM Architecture Reference Manual will not infringe any third party patents, copyrights, trade secrets, or other rights.

To the extent not prohibited by law, in no event will ARM be liable for any damages, including without limitation any direct loss, lost revenue, lost profits or data, special, indirect, consequential, incidental or punitive damages, however caused and regardless of the theory of liability, arising out of or related to any furnishing, practicing, modifying or any use of this ARM Architecture Reference Manual, even if ARM has been advised of the possibility of such damages.

Words and logos marked with ® or ™ are registered trademarks or trademarks of ARM Limited, except as otherwise stated below in this proprietary notice. Other brands and names mentioned herein may be the trademarks of their respective owners.

 The term ARM is also used to refer to versions of the ARM architecture, for example ARMv6 refers to version 6 of the ARM architecture. The context makes it clear when the term is used in this way.


• From February 2010, issue C of the ARMv7-M ARM is superseded by issue D of the document. ARM strongly recommends you to use issue D of the document in preference to using this errata PDF.

This preface describes the contents of this manual, then lists the conventions and terminology it uses.
• About this manual on page xviii
• Using this manual on page xix
• Conventions on page xxii
• Further reading on page xxiii
• Feedback on page xxiv.

This is the information required to program applications or to develop the toolchain components (compiler, linker, assembler and disassembler) excluding the debugger. For ARMv7-M, this is almost entirely a subset of material common to the other two profiles. Instruction set details which differ between profiles are clearly stated.

Part B The system level programming model and system level support instructions required for system correctness. The system level supports the ARMv7-M exception model. It also provides features for configuration and control of processor resources and management of memory access rights.

This is the information in addition to Part A required for an operating system (OS) and/or system support software. It includes details of register banking, the exception model, memory protection (management of access rights) and cache support.

Part B is profile specific. ARMv7-M introduces a new programmers’ model and as such has some fundamental differences at the system level from the other profiles. As ARMv7-M is a memory-mapped architecture, the system memory map is documented here.

Overview of the system address map and details of the architecturally defined features within the Private Peripheral Bus region. This chapter includes details of the memory-mapped support for a protected memory system.

The revised format for ARM architecture CPUID registers including the description and associated values of all attribute fields relevant to the ARMv7-M architecture. Attribute values are used to describe instruction set and memory model support of an architecture variant. Some attribute values reflect architectural choice for an implementation.

typewriter Is used for assembler syntax descriptions, pseudocode descriptions of instructions, and source code examples. For more details of the conventions used in assembler syntax descriptions see Assembler syntax on page A6-4. For more details of pseudocode conventions see Appendix G Pseudocode definition.

The typewriter font is also used in the main text for instruction mnemonics and for references to other items appearing in assembler syntax descriptions, pseudocode descriptions of instructions and source code examples.

This section lists publications that provide additional information on the ARM architecture and ARM family of processors. This manual provides architecture information, the contract between hardware and software for development of ARM compliant cores, compiler and debug tools development and software to run on the ARM targets. The Technical Reference Manual (TRM) for the implementation of interest provides details of the IMPLEMENTATION DEFINED architecture features in the ARM compliant core. The silicon partner’s device specification should be used for additional system details.

ARM periodically provides updates and corrections to its documentation. For the latest information and errata, some materials are published at http://www.arm.com. Alternatively, contact your distributor, or silicon partner who will have access to the latest published ARM information, as well as information specific to the device of interest. Your local ARM office has access to the latest published ARM information.

This document is specific to the ARMv7-M architecture. Other relevant publications relating to ARMv7-M implementations and ARM’s debug architecture are: 
• Cortex-M3 Technical Reference Manual (ARM DDI 0337)
• Procedure Call Standard for the ARM Architecture (ARM GENC 003534)
• ARM Debug Interface v5 Architecture Specification (ARM IHI 0031)
• CoreSight Architecture Specification (ARM IHI 0029)
• Embedded Trace Macrocell Architecture Specification (ARM DDI 0014).

If you notice any errors or omissions in this book, send email to errata@arm.com giving:
• the document title
• the document number
• the page number(s) to which your comments apply
• a concise explanation of the problem.

While profiles were formally introduced with the ARMv7 development, the A-profile and R-profile have implicitly existed in earlier versions, associated with the Virtual Memory System Architecture (VMSA) and Protected Memory System Architecture (PMSA) respectively.

The ARM architecture has evolved through several major revisions to a point where it supports implementations across a wide spectrum of performance points, with over a billion parts per annum being produced. The latest version (ARMv7) has seen the diversity formally recognized in a set of architecture profiles, the profiles used to tailor the architecture to different market requirements. A key factor is that the application level is consistent across all profiles, and the bulk of the variation is at the system level.

The introduction of Thumb-2 technology in ARMv6T2 provided a balance to the ARM and Thumb instruction sets, and the opportunity for the ARM architecture to be extended into new markets, in particular the microcontroller marketplace. To take maximum advantage of this opportunity a Thumb-only profile with a new programmers’ model (a system level consideration) has been introduced as a unique profile, complementing ARM’s strengths in the high performance and real-time embedded markets.

This chapter provides an application level view of the programmers’ model. This is the information necessary for application development, as distinct from the system information required to service and support application execution under an operating system. It contains the following sections:
• About the Application level programmers’ model on page A2-2
• ARM core data types and arithmetic on page A2-3
• Registers and execution state on page A2-11
• Exceptions, faults and interrupts on page A2-15
• Coprocessor support on page A2-16

The information in this chapter is distinct from the system information required to service and support application execution under an operating system. That information is given in Chapter B1 System Level Programmers’ Model.

System level support requires access to all features and facilities of the architecture, a level of access generally referred to as privileged operation. System code determines whether an application runs in a privileged or unprivileged manner. When an operating system supports both privileged and unprivileged operation, an application usually runs unprivileged. This:

Thread mode is the fundamental mode for application execution in ARMv7-M and is selected on reset. Thread mode can raise a supervisor call using the SVC instruction or handle system access and control directly. 

Processor registers are 32 bits in size. The instruction set contains instructions supporting the following data types held in registers:
• 32-bit pointers
• unsigned or signed 32-bit integers
• unsigned 16-bit or 8-bit integers, held in zero-extended form
• signed 16-bit or 8-bit integers, held in sign-extended form
• unsigned or signed 64-bit integers held in two registers.

Load and store operations can transfer bytes, halfwords, or words to and from memory. Loads of bytes or halfwords zero-extend or sign-extend the data as it is loaded, as specified in the appropriate load instruction.

The instruction set provides a wide variety of operations on the values in registers, including bitwise logical operations, shifts, additions, subtractions, multiplications, and many others. These operations are defined using the pseudocode described in Appendix G Pseudocode definition, usually in one of three ways:

(LSL) moves each bit of a bitstring left by a specified number of bits. Zeros are shifted in at the right end of the bitstring. Bits that are shifted off the left end of the bitstring are discarded, except that the last such bit can be produced as a carry output.

(LSR) moves each bit of a bitstring right by a specified number of bits. Zeros are shifted in at the left end of the bitstring. Bits that are shifted off the right end of the bitstring are discarded, except that the last such bit can be produced as a carry output.

(ASR) moves each bit of a bitstring right by a specified number of bits. Copies of the leftmost bit are shifted in at the left end of the bitstring. Bits that are shifted off the right end of the bitstring are discarded, except that the last such bit can be produced as a carry output.

Rotate Right (ROR) moves each bit of a bitstring right by a specified number of bits. Each bit that is shifted off the right end of the bitstring is re-introduced at the left end. The last bit shifted off the the right end of the bitstring can be produced as a carry output.

(RRX) moves each bit of a bitstring right by one bit. The carry input is shifted in at the left end of the bitstring. The bit shifted off the right end of the bitstring can be produced as a carry output.

In pseudocode, addition and subtraction can be performed on any combination of unbounded integers and bitstrings, provided that if they are performed on two bitstrings, the bitstrings must be identical in length. The result is another unbounded integer if both operands are unbounded integers, and a bitstring of the same length as the bitstring operand(s) otherwise. For the precise definition of these operations, see Addition and subtraction on page AppxG-15.

The main addition and subtraction instructions can produce status information about both unsigned carry and signed overflow conditions. This status information can be used to synthesize multi-word additions and subtractions. In pseudocode the AddWithCarry() function provides an addition with a carry input and carry and overflow outputs:


• If carry_in == '1', then result == x-y with overflow == '1' if signed overflow occurred during the subtraction and carry_out == '1' if unsigned borrow did not occur during the subtraction (that is, if 


• If carry_in == '0', then result == x-y-1 with overflow == '1' if signed overflow occurred during the subtraction and carry_out == '1' if unsigned borrow did not occur during the subtraction (that is, if x > y).

Some instructions perform saturating arithmetic, that is, if the result of the arithmetic overflows the destination signed or unsigned N-bit integer range, the result produced is the largest or smallest value in that range, rather than wrapping around modulo 2N. This is supported in pseudocode by the SignedSatQ() and 

SatQ(i, N, unsigned) returns either UnsignedSatQ(i, N) or SignedSatQ(i, N) depending on the value of its third argument, and Sat(i, N, unsigned) returns either UnsignedSat(i, N) or SignedSat(i, N) depending on the value of its third argument:

The application level programmers’ model provides details of the general-purpose and special-purpose registers visible to the application programmer, the ARM memory model, and the instruction set used to load registers from memory, store registers to memory, or manipulate data (data operations) within the registers. 

Applications often interact with external events. A summary of the types of events recognized in the architecture, along with the mechanisms provided in the architecture to interact with events, is included in Exceptions, faults and interrupts on page A2-15). How events are handled is a system level topic described in Exception model on page B1-14. 

SP stack pointer (R13), used as a pointer to the active stack. For usage restrictions see Use of 0b1101 as a register specifier on page A5-4. This is preset to the top of the Main stack on reset. See The SP registers on page B1-8 for additional information.

LR link register (R14), used to store a value (the Return Link) relating to the return address from a subroutine which is entered using a Branch with Link instruction. This register is set to an illegal value (all 1’s) on reset. The reset value will cause a fault condition to occur if a subroutine return call is attempted from it. The LR register is also updated on exception entry, see Exception entry behavior on page B1-21.

PC program counter. For details on the usage model of the PC see Use of 0b1111 as a register specifier on page A5-3. The PC is loaded with the Reset handler start address on reset.

For more details on the R[] function, see Pseudocode details for ARM core register access in the Thumb instruction set on page B1-12. Writing an address to the PC causes either a simple branch to that address or an interworking branch that, in ARMv7-M, must select the Thumb instruction set to execute after the branch.

The LoadWritePC() and ALUWritePC() functions are used for two cases where the behavior was systematically modified between architecture versions. The functions simplify to aliases of the branch functions in the M-profile architecture variants:


• Reserved bits are allocated to system features or are available for future expansion. Further information on currently allocated reserved bits is available in The special-purpose program status registers (xPSR) on page B1-8. Application level software must ignore values read from reserved bits, and preserve their value on a write. The bits are defined as UNK/SBZP.

N, bit [31] Negative condition code flag. Set to bit [31] of the result of the instruction. If the result is regarded as a two's complement signed integer, then N == 1 if the result is negative and N = 0 if it is positive or zero.

Z, bit [30] Zero condition code flag. Set to 1 if the result of the instruction is zero, and to 0 otherwise. A result of zero often indicates an equal result from a comparison.

Good system design practice requires the application developer to have a degree of knowledge of the underlying system architecture and the services it offers. System support requires a level of access generally referred to as privileged operation. The system support code determines whether applications run in a privileged or unprivileged manner. Where both privileged and unprivileged support is provided by an operating system, applications usually run unprivileged, allowing the operating system to allocate system resources for sole or shared use by the application, and to provide a degree of protection with respect to other processes and tasks. 

Thread mode is the fundamental mode for application execution in ARMv7-M. Thread mode is selected on reset, and can execute in a privileged or unprivileged manner depending on the system environment. Privileged execution is required to manage system resources in many cases. When code is executing unprivileged, Thread mode can execute an SVC instruction to generate a supervisor call exception. Privileged execution in Thread mode can raise a supervisor call using SVC or handle system access and control directly. 

All exceptions execute as privileged code in Handler mode. See Exception model on page B1-14 for details. Supervisor call handlers manage resources on behalf of the application such as interaction with peripherals, memory allocation and management of software stacks.

An exception can be caused by the execution of an exception generating instruction or triggered as a response to a system behavior such as an interrupt, memory management protection violation, alignment or bus fault, or a debug event. Synchronous and asynchronous exceptions can occur within the architecture.

Supervisor calls are used by application code to request a service from the underlying operating system. Using the SVC instruction, the application can instigate a supervisor call for a service requiring privileged access to the system.

Faults in general are synchronous with respect to the associated executing instruction. Some system errors can cause an imprecise exception where it is reported at a time bearing no fixed relationship to the instruction which caused it.

Interrupts are always treated as asynchronous events with respect to the program flow. System timer (SysTick), a Pending1 service call (PendSV2), and a controller for external interrupts (NVIC) are all defined. See System timer - SysTick on page B3-24 for information on the SysTick interrupt, and Nested Vectored Interrupt Controller (NVIC) on page B3-28 for information on the interrupt controller. PendSV is supported by the Interrupt Control State register (see Interrupt Control State Register (ICSR) on page B3-12).

For power or performance reasons it can be desirable to either notify the system that an action is complete, or provide a hint to the system that it can suspend operation of the current task. Instruction support is provided for the following:
• Send Event and Wait for Event instructions. See SEV on page A6-212 and WFE on page A6-276.
• Wait For Interrupt. See WFI on page A6-277.

An ARMv7-M implementation can optionally support coprocessors. If it does not support them, it treats all coprocessors as non-existent. Coprocessors 8 to 15 (CP8 to CP15) are reserved by ARM. Coprocessors 0 to 7 (CP0 to CP7) are IMPLEMENTATION DEFINED, subject to the coprocessor instruction constraints of the instruction set architecture.

This chapter covers the general principles which apply to the ARM memory model. The chapter contains the following sections:
• Address space on page A3-2
• Alignment support on page A3-3
• Endian support on page A3-5
• Synchronization and semaphores on page A3-8
• Memory types and attributes and the memory order model on page A3-18
• Access rights on page A3-28
• Memory access order on page A3-30
• Caches and memory hierarchy on page A3-38

This address space is regarded as consisting of 230 32-bit words, each of whose addresses is word-aligned, which means that the address is divisible by 4. The word whose word-aligned address is A consists of the four bytes with addresses A, A+1, A+2 and A+3. The address space can also be considered as consisting of 231 16-bit halfwords, each of whose addresses is halfword-aligned, which means that the address is divisible by 2. The halfword whose halfword-aligned address is A consists of the two bytes with addresses A and A+1.

While instruction fetches are always halfword-aligned, some load and store instructions support unaligned addresses. This affects the access address A, such that A[1:0] in the case of a word access and A[0] in the case of a halfword access can have non-zero values.

Address calculations are normally performed using ordinary integer instructions. This means that they normally wrap around if they overflow or underflow the address space. Another way of describing this is that any address calculation is reduced modulo 232.

after each instruction to determine which instruction to execute next. If this calculation overflows the top of the address space, the result is UNPREDICTABLE. In ARMv7-M this condition cannot occur because the top of memory is defined to always have the eXecute Never (XN) memory attribute associated with it. See The system address map on page B3-2 for more details. An access violation will be reported if this scenario occurs.

LDC, LDM, LDRD, POP, PUSH, STC, STRD, and STM instructions access a sequence of words at increasing memory addresses, effectively incrementing a memory address by 4 for each register load or store. If this calculation overflows the top of the address space, the result is UNPREDICTABLE.

Any unaligned load or store whose calculated address is such that it would access the byte at 0xFFFFFFFF and the byte at address 0x00000000 as part of the instruction is UNPREDICTABLE.

For register definitions see Appendix I Register Index.For ExceptionTaken() see Exception entry behavior on page B1-21.The other functions are local and descriptive only. For the actual memory access functionality, see MemU[] and MemA[] that are used in the instruction definitions (see Chapter A6 Thumb Instruction Details), and defined in Pseudocode details of general memory system operations on page B2-3.

The address space rules (Address space on page A3-2) require that for an address A:
• the word at address A consists of the bytes at addresses A, A+1, A+2 and A+3
• the halfword at address A consists of the bytes at addresses A and A+1
• the halfword at address A+2 consists of the bytes at addresses A+2 and A+3
• the word at address A therefore consists of the halfwords at addresses A and A+2.

However, this does not fully specify the mappings between words, halfwords and bytes. A memory system uses one of the following mapping schemes. This choice is known as the endianness of the memory system.

For a word address A, Table A3-3 and Table A3-4 show how the word at address A, the halfwords at address A and A+2, and the bytes at addresses A, A+1, A+2 and A+3 map onto each other for each endianness.

As an example, a load of a word (4 bytes) from address 0x1000 will result in an access of the bytes contained at memory locations 0x1000, 0x1001, 0x1002 and 0x1003, regardless of the mapping scheme used. The mapping scheme determines the significance of those bytes.

ARMv7-M supports a selectable endian model, that is configured to be big endian (BE) or little endian (LE) by a control input on a reset. The endian mapping has the following restrictions:

In instruction encoding diagrams, hw1 is shown to the left of hw2. This results in the encoding diagrams reading more naturally. The byte order of a 32-bit Thumb instruction is shown in Figure A3-1.

The effect of the endianness mapping on data applies to the size of the element(s) being transferred in the load and store instructions. Table A3-5 shows the element size of each of the load and store instructions:.

When an application or device driver has to interface to memory-mapped peripheral registers or shared-memory structures that are not the same endianness as that of the internal data structures, or the endianness of the Operating System, an efficient way of being able to explicitly transform the endianness of the data is required.

 This section describes the operation of a Load-Exclusive/Store-Exclusive pair of synchronization primitives using, as examples, the LDREX and STREX instructions. The same description applies to any other pair of synchronization primitives:
• LDREXB used with STREXB
• LDREXH used with STREXH.


• The corresponding Store-Exclusive instruction succeeds in writing back to memory address x only if no other processor or process has performed a more recent store of address x. The Store-Exclusive operation returns a status bit that indicates whether the memory write succeeded.

A Load-Exclusive instruction tags a small block of memory for exclusive access. The size of the tagged block is IMPLEMENTATION DEFINED, see Tagging and the size of the tagged memory block on page A3-15. A Store-Exclusive instruction to the same address clears the tag. 

For memory regions that do not have the Shareable attribute, the exclusive access instructions rely on a local monitor that tags any address from which the processor executes a Load-Exclusive. Any non-aborted attempt by the same processor to use a Store-Exclusive to modify any address is guaranteed to clear the tag.

A Load-Exclusive performs a load from memory, and:
• the executing processor tags the physical memory address for exclusive access
• the local monitor of the executing processor transitions to its Exclusive Access state. 


• If the address of the Store-Exclusive is the same as the address that has been tagged in the monitor by an earlier Load-Exclusive, then the store takes place, otherwise it is IMPLEMENTATION DEFINED whether the store takes place.

If the local monitor is in its Open Access state 
• no store takes place
• a status value of 1 is returned to a register.
• the local monitor remains in its Open Access state.

If the local monitor is in its Exclusive Access state and a processor performs a Store-Exclusive to any address other than the last one from which it has performed a Load-Exclusive, it is IMPLEMENTATION 

DEFINED whether the store succeeds, but in all cases the local monitor is reset to its Open Access state. In ARMv7-M, the store must be treated as a software programming error.

 It is UNPREDICTABLE whether a store to a tagged physical address causes a tag in the local monitor to be cleared if that store is by an observer other than the one that caused the physical address to be tagged.

 
• The IMPLEMENTATION DEFINED options for the local monitor are consistent with the local monitor being constructed so that it does not hold any physical address, but instead treats any access as matching the address of the previous LDREX.


• A local monitor for each processor in the system, that tags any address from which the processor executes a Load-Exclusive. The local monitor operates as described in Exclusive access instructions and Non-shareable memory regions on page A3-8, except that for Shareable memory, any Store-Exclusive described in that section as updating memory and/or returning the status value 0 is then subject to checking by the global monitor. The local monitor can ignore exclusive accesses from other processors in the system.


• A global monitor that tags a physical address as exclusive access for a particular processor. This tag is used later to determine whether a Store-Exclusive to the tagged address, that has not been failed by the local monitor,  can occur. Any successful write to the tagged address by any other observer in the shareability domain of the memory location is guaranteed to clear the tag.

Store represents any store operation other than a Store-Exclusive operation.t is the tagged address, bits [31:a] of the address of the last Load-Exclusive instruction. For more information see Tagging and the size of the tagged memory block on page A3-15.b.IMPLEMENTATION DEFINED alternative actions.

Load-Exclusive from Shareable memory performs a load from memory, and causes the physical address of the access to be tagged as exclusive access for the requesting processor. This access also causes the exclusive access tag to be removed from any other physical address that has been tagged by the requesting processor. The global monitor only supports a single outstanding exclusive access to Shareable memory per processor.


• The store is guaranteed to succeed only if the physical address accessed is tagged as exclusive access for the requesting processor and both the local monitor and the global monitor state machines for the requesting processor are in the Exclusive Access state. In this case:

—if the global monitor state machine for the processor was in the Exclusive Access state before the Store-Exclusive it is IMPLEMENTATION DEFINED whether that state machine transitions to the Open Access state.

In a shared memory system, the global monitor implements a separate state machine for each processor in the system. The state machine for accesses to Shareable memory by processor (n) can respond to all the Shareable memory accesses visible to it. This means it responds to:
• accesses generated by the associated processor (n)
• accesses generated by the other observers in the shared memory system (!n).

Figure A3-3 on page A3-13 shows the state machine for processor(n) in a global monitor. Table A3-7 on page A3-14 shows the effect of each of the operations shown in the figure.

 
• Whether a Store-Exclusive successfully updates memory or not depends on whether the address accessed matches the tagged Shareable memory address for the processor issuing the Store-Exclusive instruction. For this reason, Figure A3-3 and Table A3-7 on page A3-14 only show how the (!n) entries cause state transitions of the state machine for processor(n).

As shown in Figure A3-2 on page A3-10 and Figure A3-3 on page A3-13, when a LDREX instruction is executed, the resulting tag address ignores the least significant bits of the memory address:

The value of a in this assignment is IMPLEMENTATION DEFINED, between a minimum value of 2 and a maximum value of 11. For example, in an implementation where a = 4, a successful LDREX of address 

0x000341B4 gives a tag value of bits [31:4] of the address, giving 0x000341B. This means that the four words of memory from 0x000341B0 to 0x000341BF are tagged for exclusive access. Subsequently, a valid STREX to any address in this block will remove the tag.

The size of the tagged memory block is called the Exclusives Reservation Granule. The Exclusives Reservation Granule is IMPLEMENTATION DEFINED between:
• one word, in an implementation with a == 2
• 512 words, in an implementation with a == 11.

Store represents any store operation other than a Store-Exclusive operation.t is the tagged address for processor(n), bits [31:a] of the address of the last Load-Exclusive instruction issued by processor(n), see Tagging and the size of the tagged memory block.c.The result of a STREX(x,!n) or a STREX(t,!n) operation depends on the state machine and tagged address for the processor issuing the STREX instruction. This table shows how each possible outcome affects the state machine for processor(n).d. After a successful STREX to the tagged address, the state of the state machine is IMPLEMENTATION DEFINED. However, this state has no effect on the subsequent operation of the global monitor.e.Effect is IMPLEMENTATION DEFINED. The table shows all permitted implementations.

It is necessary to ensure that the local monitor is in the Open Access state after a context switch. In ARMv7-M, the local monitor is changed to Open Access automatically as part of an exception entry or exit sequence. The local monitor can also be forced to the Open Access state by a CLREX instruction. 

A context switch might cause a subsequent Store-Exclusive to fail, requiring a load … store sequence to be replayed. To minimize the possibility of this happening, ARM recommends that the Store-Exclusive instruction is kept as close as possible to the associated Load-Exclusive instruction, see Load-Exclusive and Store-Exclusive usage restrictions.

The Load-Exclusive and Store-Exclusive instructions are designed to work together, as a pair, for example a LDREX/STREX pair or a LDREXB/STREXB pair. As mentioned in Context switch support, ARM recommends that the Store-Exclusive instruction always follows within a few instructions of its associated Load-Exclusive instructions. In order to support different implementations of these functions, software must follow the notes and restrictions given here.


• The exclusives support a single outstanding exclusive access for each processor thread that is executed. The architecture makes use of this by not requiring an address or size check as part of the 

IsExclusiveLocal() function. If the target address of an STREX is different from the preceding LDREX in the same execution thread, behavior can be UNPREDICTABLE. As a result, an LDREX/STREX pair can only be relied upon to eventually succeed if they are executed with the same address.


• An explicit store to memory can cause the clearing of exclusive monitors associated with other processors, therefore, performing a store between the LDREX and the STREX can result in a livelock situation. As a result, code must avoid placing an explicit store between an LDREX and an STREX in a single code sequence.


• If two STREX instructions are executed without an intervening LDREX the second STREX returns a status value of 1. This means that:—every STREX must have a preceding LDREX associated with it in a given thread of execution—it is not necessary for every LDREX to have a subsequent STREX.


• An implementation of the Load-Exclusive and Store-Exclusive instructions can require that, in any thread of execution, the transaction size of a Store-Exclusive is the same as the transaction size of the preceding Load-Exclusive that was executed in that thread. If the transaction size of a Store-Exclusive is different from the preceding Load-Exclusive in the same execution thread, behavior can be UNPREDICTABLE. As a result, software can rely on a Load-Exclusive/Store-Exclusive pair to eventually succeed only if they are executed with the same address.


• An implementation might clear an exclusive monitor between the LDREX and the STREX, without any application-related cause. For example, this might happen because of cache evictions. Code written for such an implementation must avoid having any explicit memory accesses or cache maintenance operations between the LDREX and STREX instructions. 


• Implementations can benefit from keeping the LDREX and STREX operations close together in a single code sequence. This minimizes the likelihood of the exclusive monitor state being cleared between the LDREX instruction and the STREX instruction. Therefore, ARM recommends strongly a limit of 128 bytes between LDREX and STREX instructions in a single code sequence, for best performance.


• Implementations that implement coherent protocols, or have only a single master, might combine the local and global monitors for a given processor. The IMPLEMENTATION DEFINED and UNPREDICTABLE parts of the definitions in Pseudocode details of operations on exclusive monitors on page B2-8 are provided to cover this behavior. 


• The architecture sets an upper limit of 2048 bytes on the size of a region that can be marked as exclusive. Therefore, for performance reasons, ARM recommends that software separates objects that will be accessed by exclusive accesses by at least 2048 bytes. This is a performance guideline rather than a functional requirement.

The ordering of accesses for regions of memory, referred to as the memory order model, is defined by the memory attributes. This model is described in the following sections:
• Memory types
• Summary of ARMv7 memory attributes on page A3-19
• Atomicity in the ARM architecture on page A3-20
• Normal memory on page A3-22
• Device memory on page A3-24
• Strongly-ordered memory on page A3-25
• Memory access restrictions on page A3-26

In ARMv7, regions of the memory map for these accesses are defined as Device or Strongly-ordered memory. To ensure system correctness, access rules for Device and Strongly-ordered memory are more restrictive than those for Normal memory:
• both read and write accesses can have side effects
• accesses must not be repeated, for example, on return from an exception
• the number, order and sizes of the accesses must be maintained.


• After any number of write operations to an operand, the value of the operand is the value written by one of the write operations. It is impossible for part of the value of the operand to come from one write operation and another part of the value to come from a different write operation.


• When a read operation and a write operation are made to the same operand, the value obtained by the read operation is one of:—the value of the operand before the write operation—the value of the operand after the write operation.

It is never the case that the value of the read operation is partly the value of the operand before the write operation and partly the value of the operand after the write operation.

LDM, LDC, LDC2, LDRD, STM, STC, STC2, STRD, PUSH, and POP instructions are executed as a sequence of word-aligned word accesses. Each 32-bit word access is guaranteed to be single-copy atomic. A subsequence of two or more word accesses from the sequence might not exhibit single-copy atomicity.

If an instruction is executed as a sequence of accesses according to these rules, some exceptions can be taken in the sequence and cause execution of the instruction to be abandoned.

On exception return, the instruction that generated the sequence of accesses is re-executed and so any accesses that had already been performed before the exception was taken might be repeated, see Exceptions in LDM and STM operations on page B1-30.

Accesses to Normal memory have a weakly consistent model of memory ordering. See a standard text describing memory ordering issues for a description of weakly consistent memory models, for example chapter 2 of Memory Consistency Models for Shared Memory-Multiprocessors, Kourosh Gharachorloo, Stanford University Technical Report CSL-TR-95-685. In general, for Normal memory, barrier operations are required where the order of memory accesses observed by other observers must be controlled. This requirement applies regardless of the cacheability and shareability attributes of the Normal memory region.

An instruction that generates a sequence of accesses as described in Atomicity in the ARM architecture on page A3-20 might be abandoned as a result of an exception being taken during the sequence of accesses. On return from the exception the instruction is restarted, and therefore one or more of the memory locations might be accessed multiple times. This can result in repeated write accesses to a location that has been changed between the write accesses.

A region of memory marked as Non-shareable Normal does not have any requirement to make the effect of a cache transparent for data or instruction accesses. If other observers share the memory system, software must use cache maintenance operations if the presence of caches might lead to coherency issues when communicating between the observers. This cache maintenance requirement is in addition to the barrier operations that are required to ensure memory ordering.

A region of Normal memory with the Sharable attribute is one for which the effect of interposing a cache, or caches, on the memory system is entirely transparent to data accesses in the same shareability domain. Explicit software management is needed to ensure the coherency of instruction caches.

Implementations can use a variety of mechanisms to support this management requirement, from simply not caching accesses in Shareable regions to more complex hardware schemes for cache coherency for those regions.

 The Shareable concept enables system designers to specify the locations in Normal memory that must have coherency requirements. However, to facilitate porting of software, software developers must not assume that specifying a memory region as Non-shareable permits software to make assumptions about the incoherency of memory locations between different processors in a shared memory system. Such assumptions are not portable between different multiprocessing implementations that make use of the Shareable concept. Any multiprocessing implementation might implement caches that, inherently, are shared between different processing elements.

The cacheability attributes for a region are independent of the shareability attributes for the region. The cacheability attributes indicate the required handling of the data region if it is used for purposes other than the handling of shared data. This independence means that, for example, a region of memory that is marked as being cacheable and Shareable might not be held in the cache in an implementation where Shareable regions do not cache their data.

The Device memory type attribute defines memory locations where an access to the location can cause side effects, or where the value returned for a load can vary depending on the number of loads performed. memory-mapped peripherals and I/O locations are examples of memory regions that normally are marked as being Device.

An implementation must not repeat an access to a Device memory location if the program has only one access to that location. In other words, accesses to Device memory locations are not restartable.

Address locations marked as Device are Non-cacheable. While writes to Device memory can be buffered, writes can be merged only where the merge maintains:
• the number of accesses
• the order of the accesses
• the size of each access.

When a Device memory operation has side effects that apply to Normal memory regions, software must use a Memory Barrier to ensure correct execution. An example is programming the configuration registers of a memory controller with respect to the memory accesses it controls.

An instruction that generates a sequence of accesses as described in Atomicity in the ARM architecture on page A3-20 might be abandoned as a result of an exception being taken during the sequence of accesses. On return from the exception the instruction is restarted, and therefore one or more of the memory locations might be accessed multiple times. This can result in repeated write accesses to a location that has been changed between the write accesses. 

 Do not use an instruction that generates a sequence of accesses to access Device memory if the instruction might restart after an exception and repeat any write accesses, see Exceptions in LDM and STM operations on page B1-30 for more information.

Non-shareable Device memory is defined as only accessible by a single processor. An example of a system supporting Shareable and Non-shareable Device memory is an implementation that supports both:
• a local bus for its private peripherals
• system peripherals implemented on the main shared system bus. 

Such a system might have more predictable access times for local peripherals such as watchdog timers or interrupt controllers. In particular, a specific address in a Non-shareable Device memory region might access a different physical peripheral for each processor.

Memory regions with the Strongly-ordered memory type attribute have a strong memory-ordering model for all explicit memory accesses from a processor. Any access to memory with the Strongly-ordered attribute must act as if DMB UN instructions were inserted before and after the access from the processor. See Data Memory Barrier (DMB) on page A3-35.

An implementation must not repeat an access to a Strongly-ordered memory location if the program has only one access to that location. In other words, accesses to Strongly-ordered memory locations are not restartable.

An instruction that generates a sequence of accesses as described in Atomicity in the ARM architecture on page A3-20 might be abandoned as a result of an exception being taken during the sequence of accesses. On return from the exception the instruction is restarted, and therefore one or more of the memory locations might be accessed multiple times. This can result in repeated write accesses to a location that has been changed between the write accesses.

 Do not use an instruction that generates a sequence of accesses to access Strongly-ordered memory if the instruction might restart after an exception and repeat any write accesses, see Exceptions in LDM and STM operations on page B1-30 for more information.


• For any access X, the bytes accessed by X must all have the same memory type attribute, otherwise the behavior of the access is UNPREDICTABLE. That is, an unaligned access that spans a boundary between different memory types is UNPREDICTABLE.


• For any two memory accesses X and Y that are generated by the same instruction, the bytes accessed by X and Y must all have the same memory type attribute, otherwise the results are UNPREDICTABLE. For example, an LDC, LDM, LDRD, STC, STM, or STRD that spans a boundary between Normal and Device memory is UNPREDICTABLE.


• For instructions that generate accesses to Device or Strongly-ordered memory, implementations must not change the sequence of accesses specified by the pseudocode of the instruction. This includes not changing:—how many accesses there are—the time order of the accesses—the data sizes and other properties of each access. 

In addition, processor core implementations expect any attached memory system to be able to identify the memory type of an accesses, and to obey similar restrictions with regard to the number, time order, data sizes and other properties of the accesses.

—An implementation of a processor core can break this rule, provided that the information it supplies to the memory system enables the original number, time order, and other details of the accesses to be reconstructed. In addition, the implementation must place a requirement on attached memory systems to do this reconstruction when the accesses are to Device or Strongly-ordered memory.For example, an implementation with a 64-bit bus might pair the word loads generated by an 

LDM into 64-bit accesses. This is because the instruction semantics ensure that the 64-bit access is always a word load from the lower address followed by a word load from the higher address. However the implementation must permit the memory systems to unpack the two word loads when the access is to Device or Strongly-ordered memory.


• LDM and STM instructions that are used with the IT instruction are restartable if interrupted during execution. Restarting a load or store instruction is incompatible with the Device and Strongly Ordered memory access rules. For details on the architecture constraints associated with LDM and STM and the exception model see Exceptions in LDM and STM operations on page B1-30.


• Any instruction fetch must access only Normal memory. If it accesses Device or Strongly-ordered memory, the result is UNPREDICTABLE. For example, instruction fetches must not be performed to an area of memory that contains read-sensitive devices, because there is no ordering requirement between instruction fetches and explicit accesses.

The access privilege level is defined separately for explicit read and explicit write accesses. However, a system that defines the memory attributes is not required to support all combinations of memory attributes for read and write accesses.

An exception occurs if the processor attempts a data access that the access rights do not permit. For example, a MemManage exception occurs if the processor mode is Unprivileged and the processor attempts to access a memory region that is marked as only accessible to Privileged accesses. 

This means there is some linkage between the memory attributes that define the accessibility of a region to explicit memory accesses, and those that define that a region can be executed.

When considering memory access ordering, an important feature is the Shareable memory attribute that indicates whether a region of memory can be shared between multiple processors, and therefore requires an appearance of cache transparency in the ordering model.


• For software programmers, considering the model at the application level, the key factor is that for accesses to Normal memory, barriers are required in some situations where the order of accesses observed by other observers must be controlled.


• For silicon implementers, considering the model at the system level, the Strongly-ordered and Device memory attributes place certain restrictions on the system designer in terms of what can be built and when to indicate completion of an access.

Additional attributes and behaviors relate to the memory system architecture. These features are defined in the system level section of this manual, see Protected Memory System Architecture (PMSAv7) on page B3-35.

Each memory access is either a read or a write. Explicit memory accesses are the memory accesses required by the function of an instruction. The following can cause memory accesses that are not explicit:
• instruction fetches
• cache loads and writebacks

Synchronization primitives must ensure correct operation of system semaphores in the memory order model. The synchronization primitive instructions are defined as those instructions that are used to ensure memory synchronization:
• LDREX, STREX, LDREXB, STREXB, LDREXH, STREXH.

The Load-Exclusive and Store-Exclusive instructions are supported to Shareable and Non-shareable memory. Non-shareable memory can be used to synchronize processes that are running on the same processor. Shareable memory must be used to synchronize processes that might be running on different processors.


• a write to a location in memory is said to be observed by an observer when a subsequent read of the location by the same observer will return the value written by the write


• a write to a location in memory is said to be globally observed for a shareability domain when a subsequent read of the location by any observer within that shareability domain that is capable of observing the write will return the value written by the write


• a read of a location in memory is said to be observed by an observer when a subsequent write to the location by the same observer will have no effect on the value returned by the read


• a read of a location in memory is said to be globally observed for a shareability domain when a subsequent write to the location by any observer within that shareability domain that is capable of observing the write will have no effect on the value returned by the read.

The completion of a memory access in Strongly-ordered or Device memory is not guaranteed to be sufficient to determine that the side effects of the memory access are visible to all observers. The mechanism that ensures the visibility of side-effects of a memory access is IMPLEMENTATION DEFINED, for example provision of a status register that can be polled.

An address dependency exists when the value returned by a read access is used to compute the address of a subsequent read or write access. An address dependency exists even if the value read by the first read access does not change the address of the second read or write access. This might be the case if the value returned is masked off before it is used, or if it has no effect on the predicted address value for the second access.

A control dependency exists when the data value returned by a read access is used to determine the condition code flags, and the values of the flags are used for condition code evaluation to determine the address of a subsequent read access. This address determination might be through conditional execution, or through the evaluation of a branch

Figure A3-4 on page A3-34 shows the memory ordering between two explicit accesses A1 and A2, where A1 occurs before A2 in program order. The symbols used in the figure are as follows:


• If there is an address dependency then the two memory accesses are observed in program order.This ordering restriction does not apply if there is only a control dependency between the two read accesses.If there is both an address dependency and a control dependency between two read accesses the ordering requirements of the address dependency apply.

In Figure A3-4 on page A3-34, an access refers to a read or a write access to the specified memory type. For example, Device access, Non-shareable refers to a read or write access to Non-shareable Device memory.


• If A1 and A2 are two word loads generated by an LDMDB, LDMIA or POP instruction with a register list that includes the PC, the program order of the memory accesses is not defined.


• If A1 and A2 are two word loads generated by an LDRD instruction or two word stores generated by an STRD instruction, the program order of the memory accesses is not defined.


• For any instruction or operation not explicitly mentioned in this section, if the single-copy atomicity rules described in Single-copy atomicity on page A3-20 mean the operation becomes a sequence of accesses, then the time-ordering of those accesses is not defined.

Memory barrier is the general term applied to an instruction, or sequence of instructions, used to force synchronization events by a processor with respect to retiring load and store instructions in a processor core. A memory barrier is used to guarantee both:
• completion of preceding load and store instructions to the programmers’ model
• flushing of any prefetched instructions before the memory barrier event. 

ARMv7-M requires three explicit memory barriers to support the memory order model described in this chapter. The three memory barriers are:
• Data Memory Barrier, see Data Memory Barrier (DMB)
• Data Synchronization Barrier, see Data Synchronization Barrier (DSB) on page A3-36
• Instruction Synchronization Barrier, see Instruction Synchronization Barrier (ISB) on page A3-37.

The DMB instruction is a data memory barrier. The processor that executes the DMB instruction is referred to as the executing processor, Pe. The DMB instruction takes the required shareability domain and required access types as arguments.


• all explicit memory accesses of the required access types from observers within the same shareability domain as Pe that are observed by Pe before the DMB instruction. This includes any accesses of the required access types and required shareability domain performed by Pe.


• all loads of required access types from observers within the same shareability domain as Pe that have been observed by any given observer Py within the same required shareability domain as Pe before Py has performed a memory access that is a member of Group A.


• all explicit memory accesses of the required access types by any given observer Px within the same required shareability domain as Pe that can only occur after Px has observed a store that is a member of Group B.

Any observer with the same required shareability domain as Pe observes all members of Group A before it observes any member of Group B. Where members of Group A and Group B access the same memory-mapped peripheral, all members of Group A will be visible at the memory-mapped peripheral before any members of Group B are visible at that peripheral.


• The second part of the definition of Group A is recursive. Ultimately, membership of Group A derives from the observation by Py of a load before Py performs an access that is a member of Group A as a result of the first part of the definition of Group A. 


• The second part of the definition of Group B is recursive. Ultimately, membership of Group B derives from the observation by any observer of an access by Pe that is a member of Group B as a result of the first part of the definition of Group B. 

The DSB instruction is a special memory barrier, that synchronizes the execution stream with memory accesses. The DSB instruction takes the required shareability domain and required access types as arguments. A DSB behaves as a DMB with the same arguments, and also has the additional properties defined here. 


• all explicit memory accesses that are observed by Pe before the DSB is executed, are of the required access types, and are from observers in the same required shareability domain as Pe, are complete for the set of observers within the required shareability domain

An ISB instruction flushes the pipeline in the processor, so that all instructions that come after the ISB instruction in program order are fetched from cache or memory only after the ISB instruction has completed. Using an ISB ensures that the effects of context altering operations executed before the ISB are visible to the instructions fetched after the ISB instruction. Examples of context altering operations that might require the insertion of an ISB instruction to ensure the operations are complete are:
• ensuring a system control update has occurred
• branch predictor maintenance operations.

In addition, any branches that appear in program order after the ISB instruction are written into the branch prediction logic with the context that is visible after the ISB instruction. This is needed to ensure correct execution of the instruction stream.

An ARMv7-M implementation must choose how far ahead of the current point of execution it prefetches instructions. This can be either a fixed or a dynamically varying number of instructions. As well as choosing how many instructions to prefetch, an implementation can choose which possible future execution path to prefetch along. For example, after a branch instruction, it can prefetch either the instruction appearing in program order after the branch or the instruction at the branch target. This is known as branch prediction. 

A potential problem with all forms of instruction prefetching is that the instruction in memory might be changed after it was prefetched but before it is executed. If this happens, the modification to the instruction in memory does not normally prevent the already prefetched copy of the instruction from executing to completion. The memory barrier instructions, ISB, DMB or DSB as appropriate, are used to force execution ordering where necessary.

Support for caches in ARMv7-M is limited to memory attributes. These can be exported on a supporting bus protocol such as AMBA (AHB or AXI protocols) to support system caches. 

A cache is a block of high-speed memory locations containing both address information (commonly known as a TAG) and the associated data. The purpose is to increase the average speed of a memory access. Caches operate on two principles of locality:

To minimize the quantity of control information stored, the spatial locality property is used to group several locations together under the same TAG. This logical block is commonly known as a cache line. When data is loaded into a cache, access times for subsequent loads and stores are reduced, resulting in overall performance benefits. An access to information already in a cache is known as a cache hit, and other accesses are called cache misses.

Normally, caches are self-managing, with the updates occurring automatically. Whenever the processor wants to access a cacheable location, the cache is checked. If the access is a cache hit, the access occurs immediately, otherwise a location is allocated and the cache line loaded from memory. Different cache topologies and access policies are possible, however they must comply with the memory coherency model of the underlying architecture. 

Caches introduce a number of potential problems, mainly because of:
• memory accesses occurring at times other than when the programmer would normally expect them
• the existence of multiple physical locations where a data item can be held.

In systems with a DMA that reads memory locations which are held in the data cache of a processor, a breakdown of coherency occurs when the processor has written new data in the data cache, but the DMA reads the old data held in memory.

In a Harvard architecture of caches, a breakdown of coherency occurs when new instruction data has been written into the data cache and/or to memory, but the instruction cache still contains the old instruction data.

The ARM architecture provides memory system hints PLD (Preload Data) and PLI (Preload instruction) to permit software to communicate the expected use of memory locations to the hardware. The memory system can respond by taking actions that are expected to speed up the memory accesses if and when they do occur. The effect of these memory system hints is IMPLEMENTATION DEFINED. Typically, implementations will use this information to bring the data or instruction locations into caches that have faster access times than Normal memory.

The Preload instructions are hints, and so implementations can treat them as NOPs without affecting the functional behavior of the device. The instructions do not generate exceptions, but the memory system operations might generate an imprecise fault (asynchronous exception) due to the memory access.

This chapter describes the Thumb instruction set as it applies to ARMv7-M. It contains the following sections:
• About the instruction set on page A4-2
• Unified Assembler Language on page A4-4
• Branch instructions on page A4-7
• Data-processing instructions on page A4-8
• Status register access instructions on page A4-15
• Load and store instructions on page A4-16
• Load/store multiple instructions on page A4-19
• Miscellaneous instructions on page A4-20
• Exception-generating instructions on page A4-21
• Coprocessor instructions on page A4-22

ARMv7-M supports a large number of 32-bit instructions that were introduced as Thumb-2 technology into the Thumb instruction set. Much of the functionality available is identical to the ARM instruction set supported alongside the Thumb instruction set in ARMv6T2 and other ARMv7 profiles. This chapter describes the functionality available in the ARMv7-M Thumb instruction set, and the Unified Assembler Language (UAL) that can be assembled to either the Thumb or ARM instruction sets.

Thumb instructions are either 16-bit or 32-bit, and are aligned on a two-byte boundary. 16-bit and 32-bit instructions can be intermixed freely. Many common operations are most efficiently executed using 16-bit instructions. However:


• Most 16-bit instructions can only access eight of the general purpose registers, R0-R7. These are known as the low registers. A small number of 16-bit instructions can access the high registers, R8-R15.

The ARM and Thumb instruction sets are designed to interwork freely. Because ARMv7-M only supports Thumb instructions, interworking instructions in ARMv7-M must only reference Thumb state execution, see ARMv7-M and interworking support for more details.

Thumb interworking is held as bit [0] of an interworking address. Interworking addresses are used in the following instructions: BX, BLX, or an LDR or LDM that loads the PC. 

ARMv7-M only supports the Thumb instruction execution state, therefore the value of address bit [0] must be 1 in interworking instructions, otherwise a fault occurs. All instructions ignore bit [0] and write bits [31:1]:’0’ when updating the PC.

Conditionally executed means that the instruction only has its normal effect on the programmers’ model operation, memory and coprocessors if the N, Z, C and V flags in the APSR satisfy a condition specified in the instruction. If the flags do not satisfy this condition, the instruction acts as a NOP, that is, execution advances to the next instruction as normal, including any relevant checks for exceptions being taken, but has no other effect.


• A 16-bit conditional branch instruction, with a branch range of –256 to +254 bytes. See B on page A6-40 for details. Before the additional instruction support in ARMv6T2, this was the only mechanism for conditional execution in Thumb code.


• A 16-bit If-Then instruction that makes up to four following instructions conditional. See IT on page A6-78 for details. The instructions that are made conditional by an IT instruction are called its IT block. Instructions in an IT block must either all have the same condition, or some can have one condition, and others can have the inverse condition.

UAL describes the syntax for the mnemonic and the operands of each instruction. In addition, it assumes that instructions and data items can be given labels. It does not specify the syntax to be used for labels, nor what assembler directives and options are available. See your assembler documentation for these details.

UAL includes instruction selection rules that specify which instruction encoding is selected when more than one can provide the required functionality. For example, both 16-bit and 32-bit encodings exist for an 

ADD R0,R1,R2 instruction. The most common instruction selection rule is that when both a 16-bit encoding and a 32-bit encoding are available, the 16-bit encoding is selected, to optimize code density.

Syntax options exist to override the normal instruction selection rules and ensure that a particular encoding is selected. These are useful when disassembling code, to ensure that subsequent assembly produces the original code, and in some other situations.

Although other Thumb instructions are unconditional, all instructions that are made conditional by an IT instruction must be written with a condition. These conditions must match the conditions imposed by the IT instruction. For example, an ITTEE EQ instruction imposes the EQ condition on the first two following instructions, and the NE condition on the next two. Those four instructions must be written with EQ, EQ, NE and NE conditions respectively.

The branch instruction encodings that include a condition field cannot be made conditional by an IT instruction. If the assembler syntax indicates a conditional branch that correctly matches a preceding IT instruction, it is assembled using a branch instruction encoding that does not include a condition field.

The UAL syntax for some instructions includes the label of an instruction or a literal data item that is at a fixed offset from the instruction being specified. The assembler must:

 For instructions that encode a subtraction operation, if the instruction cannot encode the calculated offset, but can encode minus the calculated offset, the instruction encoding specifies a subtraction of minus the calculated offset.


• B, BL, and BLX (immediate). The assembler syntax for these instructions always specifies the label of the instruction that they branch to. Their encodings specify a sign-extended immediate offset that is added to the PC value of the instruction to form the target address of the branch.


• CBNZ and CBZ. The assembler syntax for these instructions always specifies the label of the instruction that they branch to. Their encodings specify a zero-extended immediate offset that is added to the PC value of the instruction to form the target address of the branch. They do not support backward branches.


• LDC, LDC2, LDR, LDRB, LDRD, LDRH, LDRSB, LDRSH, PLD, and PLI. The normal assembler syntax of these load instructions can specify the label of a literal data item that is to be loaded. The encodings of these instructions specify a zero-extended immediate offset that is either added to or subtracted from the 

Align(PC,4) value of the instruction to form the address of the data item. A few such encodings perform a fixed addition or a fixed subtraction and must only be used when that operation is required, but most contain a bit that specifies whether the offset is to be added or subtracted.

When the assembler calculates an offset of 0 for the normal syntax of these instructions, it must assemble an encoding that adds 0 to the Align(PC,4) value of the instruction. Encodings that subtract 0 from the Align(PC,4) value cannot be specified by the normal syntax.


• ADR. The normal assembler syntax for this instruction can specify the label of an instruction or literal data item whose address is to be calculated. Its encoding specifies a zero-extended immediate offset that is either added to or subtracted from the Align(PC,4) value of the instruction to form the address of the data item, and some opcode bits that determine whether it is an addition or subtraction.

When the assembler calculates an offset of 0 for the normal syntax of this instruction, it must assemble the encoding that adds 0 to the Align(PC,4) value of the instruction. The encoding that subtracts 0 from the Align(PC,4) value cannot be specified by the normal syntax.

SUB <Rd>,PC,#<imm>. This alternative syntax makes it possible to assemble the encoding that subtracts 0 from the Align(PC,4) value, and to disassemble it to a syntax that can be re-assembled correctly.

These instructions generally have a destination register Rd, a first operand register Rn, and a second operand. The second operand can be either another register Rm, or a modified immediate constant.

In addition to placing a result in the destination register, these instructions can optionally set the condition code flags, according to the result of the operation. If they do not set the flags, existing flag settings from a previous instruction are preserved.

Table A4-2 on page A4-9 summarizes the main data-processing instructions in the Thumb instruction set. Generally, each of these instructions is described in two sections in Chapter A6 Thumb Instruction Details, one section for each of the following:
• INSTRUCTION (immediate) where the second operand is a modified immediate constant.
• INSTRUCTION (register) where the second operand is a register, or a register shifted by a constant.

MOVCopies operand to destinationHas only one operand, with the same options as the second operand in most of these instructions. If the operand is a shifted register, the instruction is an LSL, LSR, ASR, or ROR instruction instead. See Shift instructions on page A4-10 for details.Thumb permits use of a modified immediate constant or a zero-extended 16-bit immediate constant.

In the ARMv7-M profile, the Thumb instruction set includes signed and unsigned integer divide instructions that are implemented in hardware. For details of the instructions see:
• SDIV on page A6-210
• UDIV on page A6-267.

The condition flags in the APSR are normally set by executing data-processing instructions, and are normally used to control the execution of conditional instructions. However, you can set the flags explicitly using the MSR instruction, and you can read the current state of the flags explicitly using the MRS instruction.

The LDR instruction can be used to load a value into the PC. The value loaded is treated as an interworking address, as described by the LoadWritePC() pseudocode function in Pseudocode details of ARM core register operations on page A2-11.

Halfword and byte stores store the least significant halfword or byte from the register, to 16 or 8 bits of memory respectively. There is no distinction between signed and unsigned stores.

Halfword and byte loads load 16 or 8 bits from memory into the least significant halfword or byte of a register. Unsigned loads zero-extend the loaded value to 32 bits, and signed loads sign-extend the value to 32 bits.

In an unprivileged mode, unprivileged loads and stores operate in exactly the same way as the corresponding ordinary operations. In a privileged mode, unprivileged loads and stores are treated as though they were executed in an unprivileged mode. See Privilege level access controls for data accesses on page A3-28 for more information.

For loads, the base register can be the PC. This permits PC-relative addressing for position-independent code. Instructions marked (literal) in their title in Chapter A6 Thumb Instruction Details are PC-relative loads.

Immediate The offset is an unsigned number that can be added to or subtracted from the base register value. Immediate offset addressing is useful for accessing data elements that are a fixed distance from the start of the data object, such as structure fields, stack offsets and input/output registers.

Register The offset is a value from a general-purpose register. This register cannot be the PC. The value can be added to, or subtracted from, the base register value. Register offsets are useful for accessing arrays or blocks of data. 

Scaled register  The offset is a general-purpose register, other than the PC, shifted by an immediate value, then added to or subtracted from the base register. This means an array index can be scaled by the size of each array element. 

Pre-indexed The offset is added to or subtracted from the base register to form the memory address. The base register is then updated with this new address, to permit automatic indexing through an array or memory block. 

Post-indexed The value of the base register alone is used as the memory address. The offset is then added to or subtracted from the base register. and this value is stored back in the base register, to permit automatic indexing through an array or memory block. 

 Not every variant is available for every instruction, and the range of permitted immediate values and the options for scaled registers vary from instruction to instruction. See Chapter A6 Thumb Instruction Details for full details for each instruction.

The memory locations are consecutive word-aligned words. The addresses used are obtained from a base register, and can be either above or below the value in the base register. The base register can optionally be updated by the total size of the data transferred.

The LDM, LDMDB, and POP instructions can be used to load a value into the PC. The value loaded is treated as an interworking address, as described by the LoadWritePC() pseudocode function in Pseudocode details of ARM core register operations on page A2-11.


• The Supervisor Call (SVC, formerly SWI) instruction is used to cause an SVC exception to occur. This is the main mechanism for unprivileged (User) code to make calls to privileged Operating System code. See Exception model on page B1-14 for details.


• The Breakpoint (BKPT) instruction provides for software breakpoints. It can generate a debug monitor exception or cause a running system to halt depending on the debug configuration. See Debug event behavior on page C1-14 for more details.

Coprocessors execute the same instruction stream as the core processor, ignoring non-coprocessor instructions and coprocessor instructions for other coprocessors. Coprocessor instructions that cannot be executed by any coprocessor hardware generate a UsageFault exception and record the reason as follows:

This chapter introduces the Thumb instruction set and describes how it uses the ARM programmers’ model. It contains the following sections:
• Thumb instruction set encoding on page A5-2
• 16-bit Thumb instruction encoding on page A5-5
• 32-bit Thumb instruction encoding on page A5-13.

The Thumb instruction stream is a sequence of halfword-aligned halfwords. Each Thumb instruction is either a single 16-bit halfword in that stream, or a 32-bit instruction consisting of two consecutive halfwords in that stream.

An instruction is UNPREDICTABLE if:
• a bit marked (0) or (1) in the encoding diagram of an instruction is not 0 or 1 respectively, and the pseudocode for that encoding does not indicate that a different special case applies
• it is declared as UNPREDICTABLE in an instruction description or in this chapter.

The use of 0b1111 as a register specifier is not normally permitted in Thumb instructions. When a value of 0b1111 is permitted, a variety of meanings is possible. For register reads, these meanings are:


• Read the PC value, that is, the address of the current instruction + 4. The base register of the table branch instructions TBB and TBH can be the PC. This enables branch tables to be placed in memory immediately after the instruction. (Some instructions read the PC value implicitly, without the use of a register specifier, for example the conditional branch instruction B<cond>.)


• Read the word-aligned PC value, that is, the address of the current instruction + 4, with bits [1:0] forced to zero. The base register of LDC, LDR, LDRB, LDRD (pre-indexed, no writeback), LDRH, LDRSB, and 

LDRSH instructions can be the word-aligned PC. This enables PC-relative data addressing. In addition, some encodings of the ADD and SUB instructions permit their source registers to be 0b1111 for the same purpose.


• Read zero. This is done in some cases when one instruction is a special case of another, more general instruction, but with one operand zero. In these cases, the instructions are listed on separate pages, with a special case in the pseudocode for the more general instruction cross-referencing the other page.


• The PC can be specified as the destination register of an LDR instruction. This is done by encoding Rt as 0b1111. The loaded value is treated as an address, and the effect of execution is a branch to that address. bit [0] of the loaded value selects the execution state after the branch and must have the value 1.

Some other instructions write the PC in similar ways, either implicitly (for example, B<cond>) or by using a register mask rather than a register specifier (LDM). The address to branch to can be a loaded value (for example, LDM), a register value (for example, BX), or the result of a calculation (for example, 


• Discard the result of a calculation. This is done in some cases when one instruction is a special case of another, more general instruction, but with the result discarded. In these cases, the instructions are listed on separate pages, with a special case in the pseudocode for the more general instruction cross-referencing the other page.


• If the destination register specifier of an MRC instruction is 0b1111, bits [31:28] of the value transferred from the coprocessor are written to the N, Z, C, and V flags in the APSR, and bits [27:0] are discarded.

R13 is defined in the Thumb instruction set so that its use is primarily as a stack pointer, and R13 is normally identified as SP in Thumb instructions. In 32-bit Thumb instructions, if you use R13 as a general purpose register beyond the architecturally defined constraints described in this section, the results are 


• R13 as a base register (Rn) of any load or store instruction. This supports SP-based addressing for load, store, or memory hint instructions, with positive or negative offsets, with and without writeback.


• R13 as the first operand (Rn) in any ADD{S}, CMN, CMP, or SUB{S} instruction. The add and subtract instructions support SP-based address generation, with the address going into a general-purpose register. CMN and CMP are useful for stack checking in some circumstances.

For 16-bit data processing instructions that affect high registers, R13 can only be used as described in 32-bit Thumb instruction support for R13. Any other use is deprecated. This affects the high register forms of CMP and ADD, where the use of R13 as Rm is deprecated.

These instructions all have modified immediate constants, rather than a simple 12-bit binary number. This provides a more useful range of values. See Modified immediate constants in Thumb instructions on page A5-15 for details.

Table A5-11 shows the range of modified immediate constants available in Thumb data processing instructions, and how they are encoded in the a, b, c, d, e, f, g, h, i, and imm3 fields in the instruction.

A logical operation with i:imm3:a == ’00xxx’ does not affect the carry flag. Otherwise, a logical operation that sets the flags sets the Carry flag to the value of bit [31] of the modified immediate constant.

Table A5-14 shows the allocation of encodings in this space. Other encodings in this space are unallocated hints that execute as NOPs. These unallocated hint encodings are reserved and software must not use them.

This chapter describes Thumb® instruction support in ARMv7-M. It contains the following sections:
• Format of instruction descriptions on page A6-2
• Standard assembler syntax fields on page A6-7
• Conditional execution on page A6-8
• Shifts applied to a register on page A6-12
• Memory accesses on page A6-15
• Hint Instructions on page A6-16.
• Alphabetical list of ARMv7-M Thumb instructions on page A6-17.

The instruction descriptions in the alphabetical lists of instructions in Alphabetical list of ARMv7-M Thumb instructions on page A6-17 normally use the following format:
• instruction section title
• introduction to the instruction
• instruction encoding(s) with architecture information
• assembler syntax
• pseudocode describing how the instruction operates
• exception information
• notes (where applicable).

The instruction section title gives the base mnemonic for the instructions described in the section. When one mnemonic has multiple forms described in separate instruction sections, this is followed by a short description of the form in parentheses. The most common use of this is to distinguish between forms of an instruction in which one of the operands is an immediate value and forms in which it is a register.

The instruction section title is followed by text that briefly describes the main features of the instruction. This description is not necessarily complete and is not definitive. If there is any conflict between it and the more detailed information that follows, the latter takes priority.

—ARMv7-M means a Thumb-only variant of the ARM architecture microcontroller profile that provides enhanced performance and functionality with respect to ARMv6-M through Thumb-2 technology and additional system features such as fault handling support.


• An assembly syntax that ensures that the assembler selects the encoding in preference to any other encoding. In some cases, multiple syntaxes are given. The correct one to use is sometimes indicated by annotations to the syntax, such as Inside IT block and Outside IT block. In other cases, the correct one to use can be determined by looking at the assembler syntax description and using it to determine which syntax corresponds to the instruction being disassembled.

There is usually more than one syntax that ensures re-assembly to any particular encoding, and the exact set of syntaxes that do so usually depends on the register numbers, immediate constants and other operands to the instruction. For example, when assembling to the Thumb instruction set, the syntax AND R0,R0,R8 ensures selection of a 32-bit encoding but AND R0,R0,R1 selects a 16-bit encoding.

The assembly syntax documented for the encoding is chosen to be the simplest one that ensures selection of that encoding for all operand combinations supported by that encoding. This often means that it includes elements that are only necessary for a small subset of operand combinations. For example, the assembler syntax documented for the 32-bit Thumb AND (register) encoding includes the 

The assembly syntax given for an encoding is therefore a suitable one for a disassembler to disassemble that encoding to. However, disassemblers may wish to use simpler syntaxes when they are suitable for the operand combination, in order to produce more readable disassembled code.


• An encoding diagram. This is half-width for 16-bit Thumb encodings and full-width for 32-bit Thumb encodings. The 32-bit Thumb encodings use a double vertical line between the two halfwords to act as a reminder that 32-bit Thumb encodings use the byte order of a sequence of two halfwords rather than of a word, as described in Instruction alignment and byte ordering on page A3-6.


• Encoding-specific pseudocode. This is pseudocode that translates the encoding-specific instruction fields into inputs to the encoding-independent pseudocode in the later Operation subsection, and that picks out any special cases in the encoding. For a detailed description of the pseudocode used and of the relationship between the encoding diagram, the encoding-specific pseudocode and the encoding-independent pseudocode, see Appendix G Pseudocode definition.


• One or more syntax prototype lines written in a typewriter font, using the conventions described in Assembler syntax prototype line conventions on page A6-5. Each prototype line documents the mnemonic and (where appropriate) operand parts of a full line of assembler code. When there is more than one such line, each prototype line is annotated to indicate required results of the encoding-specific pseudocode. For each instruction encoding, this information can be used to determine whether any instructions matching that encoding are available when assembling that syntax, and if so, which ones.

The description of a syntax field that specifies a register sometimes extends or restricts the permitted range of registers or document other differences from the default rules for such fields. Typical extensions are to allow the use of the SP and/or the PC (using register numbers 13 and 15 respectively). 

< > Any item bracketed by < and > is a short description of a type of value to be supplied by the user in that position. A longer description of the item is normally supplied by subsequent text. Such items often correspond to a similarly named field in an encoding diagram for an instruction. When the correspondence simply requires the binary encoding of an integer value or register number to be substituted into the instruction encoding, it is not described explicitly. For example, if the assembler syntax for a Thumb instruction contains an item 

If the correspondence between the assembler syntax item and the instruction encoding is more complex than simple binary encoding of an integer or register number, the item description indicates how it is encoded. This is often done by specifying a required output from the encoding-specific pseudocode, such as add = TRUE. The assembler must only use encodings that produce that output.

{ } Any item bracketed by { and } is optional. A description of the item and of how its presence or absence is encoded in the instruction is normally supplied by subsequent text.

Many instructions have an optional destination register. Unless otherwise stated, if such a destination register is omitted, it is the same as the immediately following source register in the instruction syntax.

All other characters must be encoded precisely as they appear in the assembler syntax. Apart from { and }, the special characters described above do not appear in the basic forms of assembler instructions documented in this manual. The { and } characters need to be encoded in a few places as part of a variable item. When this happens, the description of the variable item indicates how they must be used.

The Operation subsection contains encoding-independent pseudocode that describes the main operation of the instruction. For a detailed description of the pseudocode used and of the relationship between the encoding diagram, the encoding-specific pseudocode and the encoding-independent pseudocode, see Appendix G Pseudocode definition.


• Resets and interrupts (including NMI, PendSV and SysTick) are not listed. They can occur before or after the execution of any instruction, and in some cases during the execution of an instruction, but they are not in general caused by the instruction concerned.

<c>Is an optional field. It specifies the condition under which the instruction is executed. If <c> is omitted, it defaults to always (AL). For details see Conditional execution on page A4-3. 

If neither .W nor .N is specified, the assembler can select either 16-bit or 32-bit encodings. If both are available, it must select a 16-bit encoding. In a few cases, more than one encoding of the same length can be available for an instruction. The rules for selecting between such encodings are instruction-specific and are part of the instruction description.

In Thumb instructions, the condition (if it is not AL) is normally encoded in a preceding IT instruction, see Conditional instructions on page A4-4, ITSTATE on page A6-10 and IT on page A6-78 for details. Some conditional branch instructions do not require a preceding IT instruction, and include a condition code in their encoding.

a.Unordered means at least one NaN operand.b. ARMv7-M does not currently support floating point instructions. This column can be ignored.c.HS (unsigned higher or same) is a synonym for CS.d.LO (unsigned lower) is a synonym for CC.e.AL is an optional mnemonic extension for always, except in IT instructions. See IT on page A6-78 for details.


• The size of the IT block. This is the number of instructions that are to be conditionally executed. The size of the block is implied by the position of the least significant 1 in this field, as shown in Table A6-2 on page A6-11.

When an IT instruction is executed, these bits are set according to the condition in the instruction, and the Then and Else (T and E) parameters in the instruction, see IT on page A6-78 for more information.

An instruction in an IT block is conditional, see Conditional instructions on page A4-4. The condition used is the current value of IT[7:4]. When an instruction in an IT block completes its execution normally, ITSTATE is advanced to the next line of Table A6-2 on page A6-11.

 Instructions that can complete their normal execution by branching are only permitted in an IT block as its last instruction, and so always result in ITSTATE advancing to normal execution.

ARM register offset load/store word and unsigned byte instructions can apply a wide range of different constant shifts to the offset register. Both Thumb and ARM data-processing instructions can apply the same range of different constant shifts to the second operand register. See Constant shifts for details.

The offset value is added to or subtracted from an address obtained from the base register. The result is used as the address for the memory access. The base register is unaltered.

The offset value is applied to an address obtained from the base register. The result is used as the address for the memory access, and written back into the base register.

The address obtained from the base register is used, unaltered, as the address for the memory access. The offset value is applied to the address, and written back into the base register.

Some load instructions with Rt == 0b1111 are memory hints. Memory hints allow you to provide advance information to memory systems about future memory accesses, without actually loading or storing any data.

PLD, PLDW and PLI are the only memory hint instructions currently defined, see Load byte, memory hints on page A5-24. For instruction details, see:
• PLD, PLDW (immediate) on page A6-176
• PLD (literal) on page A6-178
• PLD (register) on page A6-180
• PLI (immediate, literal) on page A6-182
• PLI (register) on page A6-184.

Other memory hints are currently unallocated, see Load halfword, unallocated memory hints on page A5-23. The effect of a memory hint insturction is IMPLEMENTATION DEFINED. Unallocated memory hints must be implemented as NOP, and software must not use them.

Hint instructions which are not associated with memory accesses are part of a separate category of hint instructions known as NOP-compatible hints. NOP-compatible hints provide IMPLEMENTATION DEFINED behavior or act as a NOP. Both 16-bit and 32-bit encodings are reserved: 

Add with Carry (immediate) adds an immediate value and the carry flag value to a register value, and writes the result to the destination register. It can optionally update the condition flags based on the result.

Add with Carry (register) adds a register value, the carry flag value, and an optionally-shifted register value, and writes the result to the destination register. It can optionally update the condition flags based on the result.

<shift>Specifies the shift to apply to the value read from <Rm>. If <shift> is omitted, no shift is applied and both encodings are permitted. If <shift> is specified, only encoding T2 is permitted. The possible shifts and how they are encoded are described in Shifts applied to a register on page A6-12.

A special case is that if ADC<c> <Rd>,<Rn>,<Rd> is written with <Rd> and <Rn> both in the range R0-R7, it will be assembled using encoding T2 as though ADC<c> <Rd>,<Rn> had been written. To prevent this happening, use the .W qualifier.

<Rn>Specifies the register that contains the first operand. If the SP is specified for <Rn>, see ADD (SP plus immediate) on page A6-26. If the PC is specified for <Rn>, see ADR on page A6-30.

<const>Specifies the immediate value to be added to the value obtained from <Rn>. The range of allowed values is 0-7 for encoding T1, 0-255 for encoding T2 and 0-4095 for encoding T4. See Modified immediate constants in Thumb instructions on page A5-15 for the range of allowed values for encoding T3.

When multiple encodings of the same length are available for an instruction, encoding T3 is preferred to encoding T4 (if encoding T4 is required, use the ADDW syntax). Encoding T1 is preferred to encoding T2 if <Rd> is specified and encoding T2 is preferred to encoding T1 if <Rd> is omitted.

<Rd>Specifies the destination register. If <Rd> is omitted, this register is the same as <Rn> and encoding T2 is preferred to encoding T1 if both are available (this can only happen inside an IT block). If <Rd> is specified, encoding T1 is preferred to encoding T2.

<shift>Specifies the shift to apply to the value read from <Rm>. If <shift> is omitted, no shift is applied and all encodings are permitted. If <shift> is specified, only encoding T3 is permitted. The possible shifts and how they are encoded are described in Shifts applied to a register on page A6-12.

Inside an IT block, if ADD<c> <Rd>,<Rn>,<Rd> cannot be assembled using encoding T1, it is assembled using encoding T2 as though ADD<c> <Rd>,<Rn> had been written. To prevent this happening, use the .W qualifier.

<const>Specifies the immediate value to be added to the value obtained from <Rn>. Allowed values are multiples of 4 in the range 0-1020 for encoding T1, multiples of 4 in the range 0-508 for encoding T2 and any value in the range 0-4095 for encoding T4. See Modified immediate constants in Thumb instructions on page A5-15 for the range of allowed values for encoding T3.

<shift>Specifies the shift to apply to the value read from <Rm>. If <shift> is omitted, no shift is applied and all encodings are permitted. If <shift> is specified, only encoding T3 is permitted. The possible shifts and how they are encoded are described in Shifts applied to a register on page A6-12.

If the offset is positive, encodings T1 and T3 are permitted with imm32 equal to the offset. Allowed values of the offset are multiples of four in the range 0 to 1020 for encoding T1 and any value in the range 0 to 4095 for encoding T3.

<const>Specifies the offset value for the ADD form and minus the offset value for the SUB form. Allowed values are multiples of four in the range 0 to 1020 for encoding T1 and any value in the range 0 to 4095 for encodings T2 and T3.

This instruction performs a bitwise AND of a register value and an optionally-shifted register value, and writes the result to the destination register. It can optionally update the condition flags based on the result.

<shift>Specifies the shift to apply to the value read from <Rm>. If <shift> is omitted, no shift is applied and both encodings are permitted. If <shift> is specified, only encoding T2 is permitted. The possible shifts and how they are encoded are described in Shifts applied to a register on page A6-12.

A special case is that if AND<c> <Rd>,<Rn>,<Rd> is written with <Rd> and <Rn> both in the range R0-R7, it will be assembled using encoding T2 as though AND<c> <Rd>,<Rn> had been written. To prevent this happening, use the .W qualifier.

Arithmetic Shift Right (immediate) shifts a register value right by an immediate number of bits, shifting in copies of its sign bit, and writes the result to the destination register. It can optionally update the condition flags based on the result.

Arithmetic Shift Right (register) shifts a register value right by a variable number of bits, shifting in copies of its sign bit, and writes the result to the destination register. The variable number of bits is read from the bottom byte of a register. It can optionally update the condition flags based on the result.

For encodings T1 and T3, <c> is not allowed to be AL or omitted. The 4-bit encoding of the condition is placed in the instruction and not in a preceding IT instruction, and the instruction is not allowed to be in an IT block. As a result, encodings T1 and T2 are never both available to the assembler, nor are encodings T3 and T4.

<label>Specifies the label of the instruction that is to be branched to. The assembler calculates the required value of the offset from the PC value of the B instruction to this label, then selects an encoding that will set imm32 to that offset.

Allowed offsets are even numbers in the range -256 to 254 for encoding T1, -2048 to 2046 for encoding T2, -1048576 to 1048574 for encoding T3, and -16777216 to 16777214 for encoding T4.

Bit Clear (immediate) performs a bitwise AND of a register value and the complement of an immediate value, and writes the result to the destination register. It can optionally update the condition flags based on the result.

Bit Clear (register) performs a bitwise AND of a register value and the complement of an optionally-shifted register value, and writes the result to the destination register. It can optionally update the condition flags based on the result.

<shift>Specifies the shift to apply to the value read from <Rm>. If <shift> is omitted, no shift is applied and both encodings are permitted. If <shift> is specified, only encoding T2 is permitted. The possible shifts and how they are encoded are described in Shifts applied to a register on page A6-12.

<imm8>Specifies an 8-bit value that is stored in the instruction. This value is ignored by the ARM hardware, but can be used by a debugger to store additional information about the breakpoint.

The assembler calculates the required value of the offset from the PC value of the BL instruction to this label, then selects an encoding that will set imm32 to that offset. Allowed offsets are even numbers in the range -16777216 to 16777214.

Before the introduction of Thumb-2 technology, J1 and J2 in encodings T1 and T2 were both 1, resulting in a smaller branch range. The instructions could be executed as two separate 16-bit instructions, with the first instruction instr1 setting LR to PC + SignExtend(instr1<10:0>:'000000000000', 32) and the second instruction completing the operation. It is not possible to split the BL instruction into two 16-bit instructions in ARMv6-M and ARMv7-M.

Branch with Link and Exchange calls a subroutine at an address and instruction set specified by a register. ARMv7-M only supports the Thumb instruction set. An attempt to change the instruction execution state causes an exception.

Branch and Exchange causes a branch to an address and instruction set specified by a register. ARMv7-M only supports the Thumb instruction set. An attempt to change the instruction execution state causes an exception.

Compare and Branch on Non-Zero and Compare and Branch on Zero compares the value in a register with zero, and conditionally branches forward a constant value. They do not affect the condition flags.

<label>The label of the instruction that is to be branched to. The assembler calculates the required value of the offset from the PC value of the CB{N}Z instruction to this label, then selects an encoding that will set imm32 to that offset. Allowed offsets are even numbers in the range 0 to 126.

if ConditionPassed() then    EncodingSpecificOperations();    if !Coproc_Accepted(cp, ThisInstr()) then        GenerateCoprocessorException();    else        Coproc_InternalOperation(cp, ThisInstr());

<shift>Specifies the shift to apply to the value read from <Rm>. If <shift> is omitted, no shift is applied and both encodings are permitted. If <shift> is specified, only encoding T2 is permitted. The possible shifts and how they are encoded are described in Shifts applied to a register on page A6-12.

<const>Specifies the immediate value to be added to the value obtained from <Rn>. The range of allowed values is 0-255 for encoding T1. See Modified immediate constants in Thumb instructions on page A5-15 for the range of allowed values for encoding T2.

<shift>Specifies the shift to apply to the value read from <Rm>. If <shift> is omitted, no shift is applied and all encodings are permitted. If shift is specified, only encoding T3 is permitted. The possible shifts and how they are encoded are described in Shifts applied to a register on page A6-12.

Data Memory Barrier acts as a memory barrier. It ensures that all explicit memory accesses that appear in program order before the DMB instruction are observed before any explicit memory accesses that appear in program order after the DMB instruction. It does not affect the ordering of any other instructions executing on the processor.

Data Synchronization Barrier acts as a special kind of memory barrier. No instruction in program order after this instruction can execute until this instruction completes. This instruction completes when:
• All explicit memory accesses before this instruction complete. 
• All Cache, Branch predictor and TLB maintenance operations before this instruction complete.

Exclusive OR (immediate) performs a bitwise Exclusive OR of a register value and an immediate value, and writes the result to the destination register. It can optionally update the condition flags based on the result.

Exclusive OR (register) performs a bitwise Exclusive OR of a register value and an optionally-shifted register value, and writes the result to the destination register. It can optionally update the condition flags based on the result.

<shift>Specifies the shift to apply to the value read from <Rm>. If <shift> is omitted, no shift is applied and both encodings are permitted. If <shift> is specified, only encoding T2 is permitted. The possible shifts and how they are encoded are described in Shifts applied to a register on page A6-12.

A special case is that if EOR<c> <Rd>,<Rn>,<Rd> is written with <Rd> and <Rn> both in the range R0-R7, it will be assembled using encoding T2 as though EOR<c> <Rd>,<Rn> had been written. To prevent this happening, use the .W qualifier.

Instruction Synchronization Barrier flushes the pipeline in the processor, so that all instructions following the ISB are fetched from cache or memory, after the instruction has been completed. It ensures that the effects of context altering operations, such as changing the ASID, or completed TLB maintenance operations, or branch predictor maintenance operations, as well as all changes to the CP15 registers, executed before the 

In addition, the ISB instruction ensures that any branches that appear in program order after it are always written into the branch prediction logic with the context that is visible after the ISB instruction. This is required to ensure correct execution of the instruction stream.

If Then makes up to four following instructions (the IT block) conditional. The conditions for the instructions in the IT block can be the same, or some of them can be the inverse of others.

16-bit instructions in the IT block, other than CMP, CMN and TST, do not set the condition code flags. The AL condition can be specified to get this changed behavior without conditional execution.

E Else. The condition attached to the instruction is the inverse of <firstcond>. The condition code is the same as <firstcond>, except that the least significant bit is inverted. E must not be specified if <firstcond> is AL.

This is a generic coprocessor instruction. Some of the fields have no functionality defined by the architecture and are free for use by the coprocessor instruction set designer. These fields are the D bit, the CRd field, and in the Unindexed addressing mode only, the imm8 field.

+/-Is + or omitted if the immediate offset is to be added to the base register value (add == TRUE), or – if it is to be subtracted (add == FALSE). #0 and #-0 generate different instructions.

<imm>The immediate offset applied to the value of <Rn> to form the address. Allowed values are multiples of 4 in the range 0-1020. For the offset addressing syntax, <imm> can be omitted, meaning an offset of +0.

This is a generic coprocessor instruction. The D bit and the CRd field have no functionality defined by the architecture and are free for use by the coprocessor instruction set designer.

<label>The label of the literal data item that is to be loaded into <Rt>. The assembler calculates the required value of the offset from the PC value of this instruction to the label. Permitted values of the offset are multiples of 4 in the range -1020 to 1020.

The alternative syntax permits the addition or subtraction of the offset and the immediate offset to be specified separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more information, see Use of labels in UAL instruction syntax on page A4-5.

Load Multiple Increment After loads multiple registers from consecutive memory locations using an address from a base register. The sequential memory locations start at this address, and the address just above the last of those locations can optionally be written back to the base register.

The registers loaded can include the PC. If they do, the word loaded for the PC is treated as an address or exception return value and a branch occurs. Bit<0> complies with the ARM architecture interworking rules for branches to Thumb state execution and must be 1. If bit<0> is 0, a UsageFault exception occurs.

<registers>Is a list of one or more registers to be loaded, separated by commas and surrounded by { and }. The lowest-numbered register is loaded from the lowest memory address, through to the highest-numbered register from the highest memory address. If the PC is specified in the register list, the instruction causes a branch to the address (data) loaded into the PC.

Encoding T2 does not support a list containing only one register. If an LDMIA instruction with just one register <Rt> in the list is assembled to Thumb and encoding T1 is not available, it is assembled to the equivalent LDR<c><q> <Rt>,[<Rn>]{,#4} instruction.

If the PC is in the list, the LR must not be in the list and the instruction must either be outside an IT block or the last instruction in an IT block.

Load Multiple Decrement Before (Load Multiple Empty Ascending) loads multiple registers from sequential memory locations using an address from a base register. The sequential memory locations end just below this address, and the address of the first of those locations can optionally be written back to the base register.

The registers loaded can include the PC. If they do, the word loaded for the PC is treated as an address or exception return value and a branch occurs. Bit<0> complies with the ARM architecture interworking rules for branches to Thumb state execution and must be 1. If bit<0> is 0, a UsageFault exception occurs.

Is a list of one or more registers, separated by commas and surrounded by { and }. It specifies the set of registers to be loaded. The registers are loaded with the lowest-numbered register from the lowest memory address, through to the highest-numbered register from the highest memory address. If the PC is specified in the register list, the instruction causes a branch to the address (data) loaded into the PC.

Encoding T1 does not support a list containing only one register. If an LDMDB instruction with just one register <Rt> in the list is assembled to Thumb, it is assembled to the equivalent 

If the PC is in the list, the LR must not be in the list and the instruction must either be outside an IT block or the last instruction in an IT block.

Load Register (immediate) calculates an address from a base register value and an immediate offset, loads a word from memory, and writes it to a register. It can use offset, post-indexed, or pre-indexed addressing. See Memory accesses on page A6-15 for information about memory accesses.

The register loaded can be the PC. If it is, the word loaded for the PC is treated as an address or exception return value and a branch occurs. Bit<0> complies with the ARM architecture interworking rules for branches to Thumb state execution and must be 1. If bit<0> is 0, a UsageFault exception occurs.

<Rt>Specifies the destination register. This register is allowed to be the SP. It is also allowed to be the PC, provided the instruction is either outside an IT block or the last instruction of an IT block. If it is the PC, it causes a branch to the address (data) loaded into the PC.

+/-Is + or omitted to indicate that the immediate offset is added to the base register value (add == TRUE), or – to indicate that the offset is to be subtracted (add == FALSE). Different instructions are generated for #0 and #-0.

<imm>Specifies the immediate offset added to or subtracted from the value of <Rn> to form the address. Allowed values are multiples of 4 in the range 0-124 for encoding T1, multiples of 4 in the range 0-1020 for encoding T2, any value in the range 0-4095 for encoding T3, and any value in the range 0-255 for encoding T4. For the offset addressing syntax, <imm> can be omitted, meaning an offset of 0.

Load Register (literal) calculates an address from the PC value and an immediate offset, loads a word from memory, and writes it to a register. See Memory accesses on page A6-15 for information about memory accesses.

The register loaded can be the PC. If it is, the word loaded for the PC is treated as an address or exception return value and a branch occurs. Bit<0> complies with the ARM architecture interworking rules for branches to Thumb state execution and must be 1. If bit<0> is 0, a UsageFault exception occurs.

<Rt>The destination register. The SP can be used. The PC can be used, provided the instruction is either outside an IT block or the last instruction of an IT block. If the PC is used, the instruction branches to the address (data) loaded into the PC.

<label>The label of the literal data item that is to be loaded into <Rt>. The assembler calculates the required value of the offset from the PC value of this instruction to the label. Permitted values of the offset are:

 In code examples in this manual, the syntax =<value> is used for the label of a memory word whose contents are constant and equal to <value>. The actual syntax for such a label is assembler-dependent.

The alternative syntax permits the addition or subtraction of the offset and the immediate offset to be specified separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more information, see Use of labels in UAL instruction syntax on page A4-5.

Load Register (register) calculates an address from a base register value and an offset register value, loads a word from memory, and writes it to a register. The offset register value can be shifted left by 0, 1, 2, or 3 bits. See Memory accesses on page A6-15 for information about memory accesses.

The register loaded can be the PC. If it is, the word loaded for the PC is treated as an address or exception return value and a branch occurs. Bit<0> complies with the ARM architecture interworking rules for branches to Thumb state execution and must be 1. If bit<0> is 0, a UsageFault exception occurs.

<Rt>Specifies the destination register. This register is allowed to be the SP. It is also allowed to be the PC, provided the instruction is either outside an IT block or the last instruction of an IT block. If it is the PC, it causes a branch to the address (data) loaded into the PC.

<shift>Specifies the number of bits the value from <Rm> is shifted left, in the range 0-3. If this option is omitted, a shift by 0 is assumed and both encodings are permitted. If this option is specified, only encoding T2 is permitted.

Load Register Byte (immediate) calculates an address from a base register value and an immediate offset, loads a byte from memory, zero-extends it to form a 32-bit word, and writes it to a register. It can use offset, post-indexed, or pre-indexed addressing. See Memory accesses on page A6-15 for information about memory accesses.

+/-Is + or omitted to indicate that the immediate offset is added to the base register value (add == TRUE), or – to indicate that the offset is to be subtracted (add == FALSE). Different instructions are generated for #0 and #-0.

<imm>Specifies the immediate offset added to or subtracted from the value of <Rn> to form the address. The range of allowed values is 0-31 for encoding T1, 0-4095 for encoding T2, and 0-255 for encoding T3. For the offset addressing syntax, <imm> can be omitted, meaning an offset of 0.

Load Register Byte (literal) calculates an address from the PC value and an immediate offset, loads a byte from memory, zero-extends it to form a 32-bit word, and writes it to a register. See Memory accesses on page A6-15 for information about memory accesses.

<label>The label of the literal data item that is to be loaded into <Rt>. The assembler calculates the required value of the offset from the PC value of this instruction to the label. Permitted values of the offset are -4095 to 4095.

The alternative syntax permits the addition or subtraction of the offset and the immediate offset to be specified separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more information, see Use of labels in UAL instruction syntax on page A4-5.

Load Register Byte (register) calculates an address from a base register value and an offset register value, loads a byte from memory, zero-extends it to form a 32-bit word, and writes it to a register. The offset register value can be shifted left by 0, 1, 2, or 3 bits. See Memory accesses on page A6-15 for information about memory accesses.

<shift>Specifies the number of bits the value from <Rm> is shifted left, in the range 0-3. If this option is omitted, a shift by 0 is assumed and both encodings are permitted. If this option is specified, only encoding T2 is permitted.

Load Register Byte Unprivileged calculates an address from a base register value and an immediate offset, loads a byte from memory, zero-extends it to form a 32-bit word, and writes it to a register. See Memory accesses on page A6-15 for information about memory accesses.

Load Register Dual (immediate) calculates an address from a base register value and an immediate offset, loads two words from memory, and writes them to two registers. It can use offset, post-indexed, or pre-indexed addressing. See Memory accesses on page A6-15 for information about memory accesses.

+/-Is + or omitted to indicate that the immediate offset is added to the base register value (add == TRUE), or – to indicate that the offset is to be subtracted (add == FALSE). Different instructions are generated for #0 and #-0.

<imm>Specifies the immediate offset added to or subtracted from the value of <Rn> to form the address. Allowed values are multiples of 4 in the range 0-1020. For the offset addressing syntax, <imm> can be omitted, meaning an offset of 0.

Load Register Dual (literal) calculates an address from the PC value and an immediate offset, loads two words from memory, and writes them to two registers. See Memory accesses on page A6-15 for information about memory accesses.

<label>The label of the literal data item that is to be loaded into <Rt>. The assembler calculates the required value of the offset from the PC value of this instruction to the label. Permitted values of the offset are multiples of 4 in the range -1020 to 1020.

The alternative syntax permits the addition or subtraction of the offset and the immediate offset to be specified separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more information, see Use of labels in UAL instruction syntax on page A4-5.

<imm>Specifies the immediate offset added to the value of <Rn> to form the address. Allowed values are multiples of 4 in the range 0-1020. <imm> can be omitted, meaning an offset of 0.

Load Register Halfword (immediate) calculates an address from a base register value and an immediate offset, loads a halfword from memory, zero-extends it to form a 32-bit word, and writes it to a register. It can use offset, post-indexed, or pre-indexed addressing. See Memory accesses on page A6-15 for information about memory accesses.

+/-Is + or omitted to indicate that the immediate offset is added to the base register value (add == TRUE), or – to indicate that the offset is to be subtracted (add == FALSE). Different instructions are generated for #0 and #-0.

<imm>Specifies the immediate offset added to or subtracted from the value of <Rn> to form the address. Allowed values are multiples of 2 in the range 0-62 for encoding T1, any value in the range 0-4095 for encoding T2, and any value in the range 0-255 for encoding T3. For the offset addressing syntax, <imm> can be omitted, meaning an offset of 0.

If the Rt field is '1111' in encoding T2, or if the Rt field and P, U, and W bits in encoding T3 are '1111', '1', '0' and '0' respectively, the instruction is an unallocated memory hint.

Load Register Halfword (literal) calculates an address from the PC value and an immediate offset, loads a halfword from memory, zero-extends it to form a 32-bit word, and writes it to a register. See Memory accesses on page A6-15 for information about memory accesses.

<label>The label of the literal data item that is to be loaded into <Rt>. The assembler calculates the required value of the offset from the PC value of the ADR instruction to this label. Permitted values of the offset are -4095 to 4095.

The alternative syntax permits the addition or subtraction of the offset and the immediate offset to be specified separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more information, see Use of labels in UAL instruction syntax on page A4-5.

Load Register Halfword (register) calculates an address from a base register value and an offset register value, loads a halfword from memory, zero-extends it to form a 32-bit word, and writes it to a register. The offset register value can be shifted left by 0, 1, 2, or 3 bits. See Memory accesses on page A6-15 for information about memory accesses.

<shift>Specifies the number of bits the value from <Rm> is shifted left, in the range 0-3. If this option is omitted, a shift by 0 is assumed and both encodings are permitted. If this option is specified, only encoding T2 is permitted.

Load Register Halfword Unprivileged calculates an address from a base register value and an immediate offset, loads a halfword from memory, zero-extends it to form a 32-bit word, and writes it to a register. See Memory accesses on page A6-15 for information about memory accesses.

Load Register Signed Byte (immediate) calculates an address from a base register value and an immediate offset, loads a byte from memory, sign-extends it to form a 32-bit word, and writes it to a register. It can use offset, post-indexed, or pre-indexed addressing. See Memory accesses on page A6-15 for information about memory accesses.

+/-Is + or omitted to indicate that the immediate offset is added to the base register value (add == TRUE), or – to indicate that the offset is to be subtracted (add == FALSE). Different instructions are generated for #0 and #-0.

<imm>Specifies the immediate offset added to or subtracted from the value of <Rn> to form the address. The range of allowed values is 0-4095 for encoding T1, and 0-255 for encoding T2. For the offset addressing syntax, <imm> can be omitted, meaning an offset of 0.

Load Register Signed Byte (literal) calculates an address from the PC value and an immediate offset, loads a byte from memory, sign-extends it to form a 32-bit word, and writes it to a register. See Memory accesses on page A6-15 for information about memory accesses.

<label>The label of the literal data item that is to be loaded into <Rt>. The assembler calculates the required value of the offset from the PC value of the ADR instruction to this label. Permitted values of the offset are -4095 to 4095.

The alternative syntax permits the addition or subtraction of the offset and the immediate offset to be specified separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more information, see Use of labels in UAL instruction syntax on page A4-5.

Load Register Signed Byte (register) calculates an address from a base register value and an offset register value, loads a byte from memory, sign-extends it to form a 32-bit word, and writes it to a register. The offset register value can be shifted left by 0, 1, 2, or 3 bits. See Memory accesses on page A6-15 for information about memory accesses.

<shift>Specifies the number of bits the value from <Rm> is shifted left, in the range 0-3. If this option is omitted, a shift by 0 is assumed and both encodings are permitted. If this option is specified, only encoding T2 is permitted.

Load Register Signed Byte Unprivileged calculates an address from a base register value and an immediate offset, loads a byte from memory, sign-extends it to form a 32-bit word, and writes it to a register. See Memory accesses on page A6-15 for information about memory accesses.

Load Register Signed Halfword (immediate) calculates an address from a base register value and an immediate offset, loads a halfword from memory, sign-extends it to form a 32-bit word, and writes it to a register. It can use offset, post-indexed, or pre-indexed addressing. See Memory accesses on page A6-15 for information about memory accesses.

+/-Is + or omitted to indicate that the immediate offset is added to the base register value (add == TRUE), or – to indicate that the offset is to be subtracted (add == FALSE). Different instructions are generated for #0 and #-0.

<imm>Specifies the immediate offset added to or subtracted from the value of <Rn> to form the address. The range of allowed values is 0-4095 for encoding T1, and 0-255 for encoding T2. For the offset addressing syntax, <imm> can be omitted, meaning an offset of 0.

Load Register Signed Halfword (literal) calculates an address from the PC value and an immediate offset, loads a halfword from memory, sign-extends it to form a 32-bit word, and writes it to a register. See Memory accesses on page A6-15 for information about memory accesses.

<label>The label of the literal data item that is to be loaded into <Rt>. The assembler calculates the required value of the offset from the PC value of the ADR instruction to this label. Permitted values of the offset are -4095 to 4095.

The alternative syntax permits the addition or subtraction of the offset and the immediate offset to be specified separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more information, see Use of labels in UAL instruction syntax on page A4-5.

Load Register Signed Halfword (register) calculates an address from a base register value and an offset register value, loads a halfword from memory, sign-extends it to form a 32-bit word, and writes it to a register. The offset register value can be shifted left by 0, 1, 2, or 3 bits. See Memory accesses on page A6-15 for information about memory accesses.

<shift>Specifies the number of bits the value from <Rm> is shifted left, in the range 0-3. If this option is omitted, a shift by 0 is assumed and both encodings are permitted. If this option is specified, only encoding T2 is permitted.

Load Register Signed Halfword Unprivileged calculates an address from a base register value and an immediate offset, loads a halfword from memory, sign-extends it to form a 32-bit word, and writes it to a register. See Memory accesses on page A6-15 for information about memory accesses.

<imm>Specifies the immediate offset added to the value of <Rm> to form the address. The range of allowed values is 0-255.  <imm> can be omitted, meaning an offset of 0. 

Load Register Unprivileged calculates an address from a base register value and an immediate offset, loads a word from memory, and writes it to a register. See Memory accesses on page A6-15 for information about memory accesses.

Logical Shift Left (immediate) shifts a register value left by an immediate number of bits, shifting in zeros, and writes the result to the destination register. It can optionally update the condition flags based on the result.

Logical Shift Left (register) shifts a register value left by a variable number of bits, shifting in zeros, and writes the result to the destination register. The variable number of bits is read from the bottom byte of a register. It can optionally update the condition flags based on the result.

Logical Shift Right (immediate) shifts a register value right by an immediate number of bits, shifting in zeros, and writes the result to the destination register. It can optionally update the condition flags based on the result.

Logical Shift Right (register) shifts a register value right by a variable number of bits, shifting in zeros, and writes the result to the destination register. The variable number of bits is read from the bottom byte of a register. It can optionally update the condition flags based on the result.

if ConditionPassed() then    EncodingSpecificOperations();    if !Coproc_Accepted(cp, ThisInstr()) then        GenerateCoprocessorException();    else        Coproc_SendOneWord(R[t], cp, ThisInstr());

if ConditionPassed() then    EncodingSpecificOperations();    if !Coproc_Accepted(cp, ThisInstr()) then        GenerateCoprocessorException();    else        Coproc_SendTwoWords(R[t], R[t2], cp, ThisInstr());

Multiply Accumulate multiplies two register values, and adds a third register value. The least significant 32 bits of the result are written to the destination register. These 32 bits do not depend on whether signed or unsigned calculations are performed.

Multiply and Subtract multiplies two register values, and subtracts the least significant 32 bits of the result from a third register value. These 32 bits do not depend on whether signed or unsigned calculations are performed. The result is written to the destination register.

<const>Specifies the immediate value to be placed in <Rd>. The range of allowed values is 0-255 for encoding T1 and 0-65535 for encoding T3. See Modified immediate constants in Thumb instructions on page A5-15 for the range of allowed values for encoding T2.

If <Rd> is the PC, then only encoding T1 is permitted, and the instruction causes a branch to the address moved to the PC. The instruction must either be outside an IT block or the last instruction of an IT block.

 ARM deprecates the use of the following MOV (register) instructions:
• ones in which <Rd> is the SP or PC and <Rm> is also the SP or PC is deprecated.
• ones in which S is specified and <Rm> is the SP, or <Rm> is the PC.

See the following sections for details:
• ASR (immediate) on page A6-36
• ASR (register) on page A6-38
• LSL (immediate) on page A6-134
• LSL (register) on page A6-136
• LSR (immediate) on page A6-138
• LSR (register) on page A6-140
• ROR (immediate) on page A6-194
• ROR (register) on page A6-196
• RRX on page A6-198.

<Rt>Is the destination ARM register. This register is allowed to be R0-R14 or APSR_nzcv. The last form writes bits<31:28> of the transferred value to the N, Z, C and V condition flags and is specified by setting the Rt field of the encoding to 0b1111. In pre-UAL assembler syntax, PC was written instead of APSR_nzcv to select this form.

if ConditionPassed() then    EncodingSpecificOperations();    if !Coproc_Accepted(cp, ThisInstr()) then        GenerateCoprocessorException();    else        (R[t], R[t2]) = Coproc_GetTwoWords(cp, ThisInstr());

Multiply multiplies two register values. The least significant 32 bits of the result are written to the destination register. These 32 bits do not depend on whether signed or unsigned calculations are performed.

It can optionally update the condition flags based on the result. This option is limited to only a few forms of the instruction in the Thumb instruction set, and use of it will adversely affect performance on many processor implementations. 

<shift>Specifies the shift to apply to the value read from <Rm>. If <shift> is omitted, no shift is applied and both encodings are permitted. If <shift> is specified, only encoding T2 is permitted. The possible shifts and how they are encoded are described in Shifts applied to a register on page A6-12.

Logical OR NOT (immediate) performs a bitwise (inclusive) OR of a register value and the complement of an immediate value, and writes the result to the destination register. It can optionally update the condition flags based on the result.

Logical OR NOT (register) performs a bitwise (inclusive) OR of a register value and the complement of an optionally-shifted register value, and writes the result to the destination register. It can optionally update the condition flags based on the result.

<shift>Specifies the shift to apply to the value read from <Rm>. If <shift> is omitted, no shift is applied. The possible shifts and how they are encoded are described in Shifts applied to a register on page A6-12.

Logical OR (immediate) performs a bitwise (inclusive) OR of a register value and an immediate value, and writes the result to the destination register. It can optionally update the condition flags based on the result.

Logical OR (register) performs a bitwise (inclusive) OR of a register value and an optionally-shifted register value, and writes the result to the destination register. It can optionally update the condition flags based on the result.

<shift>Specifies the shift to apply to the value read from <Rm>. If <shift> is omitted, no shift is applied and both encodings are permitted. If <shift> is specified, only encoding T2 is permitted. The possible shifts and how they are encoded are described in Shifts applied to a register on page A6-12.

A special case is that if ORR<c> <Rd>,<Rn>,<Rd> is written with <Rd> and <Rn> both in the range R0-R7, it will be assembled using encoding T2 as though ORR<c> <Rd>,<Rn> had been written. To prevent this happening, use the .W qualifier.

Preload Data signals the memory system that data memory accesses from a specified address are likely in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as pre-loading the cache line containing the specified address into the data cache. See Preloading caches on page A3-39 and Memory hints on page A6-16 for additional information.

Where both the PLD and PLDW instructions are implemented, the PLD instruction signals that the likely memory access is a read, and the PLDW instruction signals that it is a write.

+/-Is + or omitted to indicate that the immediate offset is added to the base register value (add == TRUE), or – to indicate that the offset is to be subtracted (add == FALSE). Different instructions are generated for #0 and #-0.

if ConditionPassed() then    EncodingSpecificOperations();    address = if add then (R[n] + imm32) else (R[n] - imm32);    if is_pldw then        Hint_PreloadDataForWrite(address);    else        Hint_PreloadData(address);

Preload Data signals the memory system that data memory accesses from a specified address are likely in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as pre-loading the cache line containing the specified address into the data cache. See Preloading caches on page A3-39 and Memory hints on page A6-16 for additional information.

<label>The label of the literal item that is likely to be accessed in the near future. The assembler calculates the required value of the offset from the PC value of this instruction to the label. The offset must be in the range -4095 to 4095.

+/-Is + or omitted to indicate that the immediate offset is added to the base register value (add == TRUE), or – to indicate that the offset is to be subtracted (add == FALSE). Different instructions are generated for #0 and #-0.

The alternative syntax permits the addition or subtraction of the offset and the immediate offset to be specified separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more information, see Use of labels in UAL instruction syntax on page A4-5.

Preload Data is a memory hint instruction that can signal the memory system that data memory accesses from a specified address are likely in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as pre-loading the cache line containing the specified address into the data cache. See Preloading caches on page A3-39 and Memory hints on page A6-16 for additional information.

if ConditionPassed() then    EncodingSpecificOperations();    offset = Shift(R[m], shift_t, shift_n, APSR.C);    address = if add then (R[n] + offset) else (R[n] - offset);    Hint_PreloadData(address);

Preload Instruction is a memory hint instruction that can signal the memory system that instruction memory accesses from a specified address are likely in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as pre-loading the cache line containing the specified address into the instruction cache. See Preloading caches on page A3-39 and Memory hints on page A6-16 for additional information.

+/-Is + or omitted to indicate that the immediate offset is added to the base register value (add == TRUE), or – to indicate that the offset is to be subtracted (add == FALSE). Different instructions are generated for #0 and #-0.

if ConditionPassed() then    EncodingSpecificOperations();    base = if n == 15 then Align(PC,4) else R[n];    address = if add then (base + imm32) else (base - imm32);    Hint_PreloadInstr(address);

Preload Instruction is a memory hint instruction that can signal the memory system that instruction memory accesses from a specified address are likely in the near future. The memory system can respond by taking actions that are expected to speed up the memory accesses when they do occur, such as pre-loading the cache line containing the specified address into the instruction cache.  See Preloading caches on page A3-39 and Memory hints on page A6-16 for additional information.

if ConditionPassed() then    EncodingSpecificOperations();    offset = Shift(R[m], shift_t, shift_n, APSR.C);    address = if add then (R[n] + offset) else (R[n] - offset);    Hint_PreloadInstr(address);

If the registers loaded include the PC, the word loaded for the PC is treated as an address or an exception return value and a branch occurs. Bit<0> complies with the ARM architecture interworking rules for branches to Thumb state execution and must be 1. If bit<0> is 0, a UsageFault exception occurs.

Is a list of one or more registers, separated by commas and surrounded by { and }. It specifies the set of registers to be loaded. The registers are loaded in sequence, the lowest-numbered register from the lowest memory address, through to the highest-numbered register from the highest memory address. If the PC is specified in the register list, the instruction causes a branch to the address (data) loaded into the PC.

Encoding T2 does not support a list containing only one register. If a POP instruction with just one register <Rt> in the list is assembled to Thumb and encoding T1 is not available, it is assembled to the equivalent LDR<c><q> <Rt>,[SP],#-4 instruction.

Is a list of one or more registers, separated by commas and surrounded by { and }. It specifies the set of registers to be stored. The registers are stored in sequence, the lowest-numbered register to the lowest memory address, through to the highest-numbered register to the highest memory address.

Encoding T2 does not support a list containing only one register. If a PUSH instruction with just one register <Rt> in the list is assembled to Thumb and encoding T1 is not available, it is assembled to the equivalent STR<c><q> <Rt>,[SP,#-4]! instruction.

Rotate Right (immediate) provides the value of the contents of a register rotated by a constant value. The bits that are rotated off the right end are inserted into the vacated bit positions on the left. It can optionally update the condition flags based on the result.

Rotate Right (register) provides the value of the contents of a register rotated by a variable number of bits. The bits that are rotated off the right end are inserted into the vacated bit positions on the left. The variable number of bits is read from the bottom byte of a register. It can optionally update the condition flags based on the result.

<const>Specifies the immediate value to be added to the value obtained from <Rn>. The only allowed value for encoding T1 is 0. See Modified immediate constants in Thumb instructions on page A5-15 for the range of allowed values for encoding T2.

Reverse Subtract (register) subtracts a register value from an optionally-shifted register value, and writes the result to the destination register. It can optionally update the condition flags based on the result.

<shift>Specifies the shift to apply to the value read from <Rm>. If <shift> is omitted, no shift is applied. The possible shifts and how they are encoded are described in Shifts applied to a register on page A6-12.

Subtract with Carry (immediate) subtracts an immediate value and the value of NOT(Carry flag) from a register value, and writes the result to the destination register. It can optionally update the condition flags based on the result.

Subtract with Carry (register) subtracts an optionally-shifted register value and the value of NOT(Carry flag) from a register value, and writes the result to the destination register. It can optionally update the condition flags based on the result.

<shift>Specifies the shift to apply to the value read from <Rm>. If <shift> is omitted, no shift is applied and both encodings are permitted. If <shift> is specified, only encoding T2 is permitted. The possible shifts and how they are encoded are described in Shifts applied to a register on page A6-12.

Signed Divide divides a 32-bit signed integer register value by a 32-bit signed integer register value, and writes the result to the destination register. The condition code flags are not affected.

Overflow If the signed integer division 0x80000000 / 0xFFFFFFFF is performed, the pseudocode produces the intermediate integer result +231, which overflows the 32-bit signed integer range. No indication of this overflow case is produced, and the 32-bit result written to R[d] is required to be the bottom 32 bits of the binary representation of +231. So the result of the division is 0x80000000.

Send Event is a hint instruction. It causes an event to be signaled to all CPUs within the multiprocessor system. See Wait For Event and Send Event on page B1-49 for more details.

+/-Is + or omitted to indicate that the immediate offset is added to the base register value (add == TRUE), or – to indicate that the offset is to be subtracted (add == FALSE). Different instructions are generated for #0 and #-0.

<imm>Specifies the immediate offset added to or subtracted from the value of <Rn> to form the address. Allowed values are multiples of 4 in the range 0-1020. For the offset addressing syntax, <imm> can be omitted, meaning an offset of 0.

Store Multiple Increment After (Store Multiple Empty Ascending) stores multiple registers to consecutive memory locations using an address from a base register. The consecutive memory locations start at this address, and the address just above the last of those locations can optionally be written back to the base register.

Encoding T2 does not support a list containing only one register. If an STM instruction with just one register <Rt> in the list is assembled to Thumb and encoding T1 is not available, it is assembled to the equivalent STR<c><q> <Rt>,[<Rn>]{,#4} instruction.

Encoding T2 is not available for instructions with the base register in the list and ! specified, and the use of such instructions is deprecated. If the base register is not the lowest-numbered register in the list, such an instruction stores an UNKNOWN value for the base register.

Store Multiple Decrement Before (Store Multiple Full Descending) stores multiple registers to consecutive memory locations using an address from a base register. The consecutive memory locations end just below this address, and the address of the first of those locations can optionally be written back to the base register.

Encoding T1 does not support a list containing only one register. If an STMDB instruction with just one register <Rt> in the list is assembled to Thumb, it is assembled to the equivalent 

Store Register (immediate) calculates an address from a base register value and an immediate offset, and stores a word from a register to memory. It can use offset, post-indexed, or pre-indexed addressing. See Memory accesses on page A6-15 for information about memory accesses.

+/-Is + or omitted to indicate that the immediate offset is added to the base register value (add == TRUE), or – to indicate that the offset is to be subtracted (add == FALSE). Different instructions are generated for #0 and #-0.

<imm>Specifies the immediate offset added to or subtracted from the value of <Rn> to form the address. Allowed values are multiples of 4 in the range 0-124 for encoding T1, multiples of 4 in the range 0-1020 for encoding T2, any value in the range 0-4095 for encoding T3, and any value in the range 0-255 for encoding T4. For the offset addressing syntax, <imm> can be omitted, meaning an offset of 0.

Store Register (register) calculates an address from a base register value and an offset register value, stores a word from a register to memory. The offset register value can be shifted left by 0, 1, 2, or 3 bits. See Memory accesses on page A6-15 for information about memory accesses.

<shift>Specifies the number of bits the value from <Rm> is shifted left, in the range 0-3. If this option is omitted, a shift by 0 is assumed and both encodings are permitted. If this option is specified, only encoding T2 is permitted.

Store Register Byte (immediate) calculates an address from a base register value and an immediate offset, and stores a byte from a register to memory. It can use offset, post-indexed, or pre-indexed addressing. See Memory accesses on page A6-15 for information about memory accesses.

+/-Is + or omitted to indicate that the immediate offset is added to the base register value (add == TRUE), or – to indicate that the offset is to be subtracted (add == FALSE). Different instructions are generated for #0 and #-0.

<imm>Specifies the immediate offset added to or subtracted from the value of <Rn> to form the address. The range of allowed values is 0-31 for encoding T1, 0-4095 for encoding T2, and 0-255 for encoding T3. For the offset addressing syntax, <imm> can be omitted, meaning an offset of 0.

Store Register Byte (register) calculates an address from a base register value and an offset register value, and stores a byte from a register to memory. The offset register value can be shifted left by 0, 1, 2, or 3 bits. See Memory accesses on page A6-15 for information about memory accesses.

<shift>Specifies the number of bits the value from <Rm> is shifted left, in the range 0-3. If this option is omitted, a shift by 0 is assumed and both encodings are permitted. If this option is specified, only encoding T2 is permitted.

Store Register Byte Unprivileged calculates an address from a base register value and an immediate offset, and stores a byte from a register to memory. See Memory accesses on page A6-15 for information about memory accesses.

Store Register Dual (immediate) calculates an address from a base register value and an immediate offset, and stores two words from two registers to memory. It can use offset, post-indexed, or pre-indexed addressing. See Memory accesses on page A6-15 for information about memory accesses.

+/-Is + or omitted to indicate that the immediate offset is added to the base register value (add == TRUE), or – to indicate that the offset is to be subtracted (add == FALSE). Different instructions are generated for #0 and #-0.

<imm>Specifies the immediate offset added to or subtracted from the value of <Rn> to form the address. Allowed values are multiples of 4 in the range 0-1020. For the offset addressing syntax, <imm> can be omitted, meaning an offset of 0.

Store Register Exclusive calculates an address from a base register value and an immediate offset, and stores a word from a register to memory if the executing processor has exclusive access to the memory addressed.

<imm>Specifies the immediate offset added to the value of <Rn> to form the address. Allowed values are multiples of 4 in the range 0-1020. <imm> can be omitted, meaning an offset of 0.

Store Register Exclusive Byte derives an address from a base register value, and stores a byte from a register to memory if the executing processor has exclusive access to the memory addressed.

Store Register Exclusive Halfword derives an address from a base register value, and stores a halfword from a register to memory if the executing processor has exclusive access to the memory addressed.

Store Register Halfword (immediate) calculates an address from a base register value and an immediate offset, and stores a halfword from a register to memory. It can use offset, post-indexed, or pre-indexed addressing. See Memory accesses on page A6-15 for information about memory accesses.

+/-Is + or omitted to indicate that the immediate offset is added to the base register value (add == TRUE), or – to indicate that the offset is to be subtracted (add == FALSE). Different instructions are generated for #0 and #-0.

<imm>Specifies the immediate offset added to or subtracted from the value of <Rn> to form the address. Allowed values are multiples of 2 in the range 0-62 for encoding T1, any value in the range 0-4095 for encoding T2, and any value in the range 0-255 for encoding T3. For the offset addressing syntax, <imm> can be omitted, meaning an offset of 0.

Store Register Halfword (register) calculates an address from a base register value and an offset register value, and stores a halfword from a register to memory. The offset register value can be shifted left by 0, 1, 2, or 3 bits. See Memory accesses on page A6-15 for information about memory accesses.

<shift>Specifies the number of bits the value from <Rm> is shifted left, in the range 0-3. If this option is omitted, a shift by 0 is assumed and both encodings are permitted. If this option is specified, only encoding T2 is permitted.

Store Register Halfword Unprivileged calculates an address from a base register value and an immediate offset, and stores a halfword from a register to memory. See Memory accesses on page A6-15 for information about memory accesses.

Store Register Unprivileged calculates an address from a base register value and an immediate offset, and stores a word from a register to memory. See Memory accesses on page A6-15 for information about memory accesses.

<Rn>Specifies the register that contains the first operand. If the SP is specified for <Rn>, see SUB (SP minus immediate) on page A6-248. If the PC is specified for <Rn>, see ADR on page A6-30.

<const>Specifies the immediate value to be subtracted from the value obtained from <Rn>. The range of allowed values is 0-7 for encoding T1, 0-255 for encoding T2 and 0-4095 for encoding T4. See Modified immediate constants in Thumb instructions on page A5-15 for the range of allowed values for encoding T3.

When multiple encodings of the same length are available for an instruction, encoding T3 is preferred to encoding T4 (if encoding T4 is required, use the SUBW syntax). Encoding T1 is preferred to encoding T2 if <Rd> is specified and encoding T2 is preferred to encoding T1 if <Rd> is omitted.

<shift>Specifies the shift to apply to the value read from <Rm>. If <shift> is omitted, no shift is applied and both encodings are permitted. If <shift> is specified, only encoding T2 is permitted. The possible shifts and how they are encoded are described in Shifts applied to a register on page A6-12.

<const>Specifies the immediate value to be added to the value obtained from SP. Allowed values are multiples of 4 in the range 0-508 for encoding T1 and any value in the range 0-4095 for encoding T3. See Modified immediate constants in Thumb instructions on page A5-15 for the range of allowed values for encoding T2.

<shift>Specifies the shift to apply to the value read from <Rm>. If <shift> is omitted, no shift is applied. The possible shifts and how they are encoded are described in Shifts applied to a register on page A6-12.

Signed Extend Byte extracts an 8-bit value from a register, sign extends it to 32 bits, and writes the result to the destination register. You can specify a rotation by 0, 8, 16, or 24 bits before extracting the 8-bit value.

Signed Extend Halfword extracts a 16-bit value from a register, sign extends it to 32 bits, and writes the result to the destination register. You can specify a rotation by 0, 8, 16, or 24 bits before extracting the 16-bit value.

Table Branch Byte causes a PC-relative forward branch using a table of single byte offsets. A base register provides a pointer to the table, and a second register supplies an index into the table. The branch length is twice the value of the byte returned from the table.

Table Branch Halfword causes a PC-relative forward branch using a table of single halfword offsets. A base register provides a pointer to the table, and a second register supplies an index into the table. The branch length is twice the value of the halfword returned from the table.

<shift>Specifies the shift to apply to the value read from <Rm>. If <shift> is omitted, no shift is applied. The possible shifts and how they are encoded are described in Shifts applied to a register on page A6-12.

<shift>Specifies the shift to apply to the value read from <Rm>. If <shift> is omitted, no shift is applied and both encodings are permitted. If <shift> is specified, only encoding T2 is permitted. The possible shifts and how they are encoded are described in Shifts applied to a register on page A6-12.

Unsigned Divide divides a 32-bit unsigned integer register value by a 32-bit unsigned integer register value, and writes the result to the destination register. The condition code flags are not affected.

Unsigned Extend Byte extracts an 8-bit value from a register, zero extends it to 32 bits, and writes the result to the destination register. You can specify a rotation by 0, 8, 16, or 24 bits before extracting the 8-bit value.

Unsigned Extend Halfword extracts a 16-bit value from a register, zero extends it to 32 bits, and writes the result to the destination register. You can specify a rotation by 0, 8, 16, or 24 bits before extracting the 16-bit value.

Wait For Event is a hint instruction. If the Event Register is clear, it suspends execution in the lowest power state available consistent with a fast wakeup without the need for software restoration, until a reset, exception or other event occurs. See Wait For Event and Send Event on page B1-49 for more details.

if ConditionPassed() then    EncodingSpecificOperations();    if EventRegistered() then        ClearEventRegister();    else        WaitForEvent();

Wait For Interrupt is a hint instruction. It suspends execution, in the lowest power state available consistent with a fast wakeup without the need for software restoration, until a reset, asynchronous exception or other  event occurs. See Wait For Interrupt on page B1-51 for more details.

PRIMASK If PRIMASK is set and FAULTMASK is clear, an asynchronous exception that has a higher group priority than any active exception and a higher group priority than BASEPRI results in a WFI instruction exit. If the group priority of the exception is less than or equal to the execution group priority, the exception is ignored.

YIELD is a hint instruction. It allows software with a multithreading capability to indicate to the hardware that it is performing a task, for example a spinlock, that could be swapped out to improve overall system performance. Hardware can use this hint to suspend and resume multiple code threads if it supports the capability.

This chapter contains information on the system programmers’ model. It covers the registers, exception model and fault handling capabilities. The chapter is made up of the following sections:
• Introduction to the system level on page B1-2
• ARMv7-M: a memory mapped architecture on page B1-3
• System level operation and terminology overview on page B1-4
• Registers on page B1-8
• Exception model on page B1-14

The ARM architecture is defined in a hierarchical manner, where the features are described in Chapter A2 Application Level Programmers’ Model at the application level, with underlying system support. What features are available and how they are supported is defined in the architecture profiles, making the system level support profile specific. Deprecated features can be found in an appendix to this manual. See page AppxD-1.

As stated in Privileged execution on page A2-13, programs can execute in a privileged or unprivileged manner. System level support requires privileged access, allowing it the access permissions to configure and control the resources. This is typically supported by an operating system, which provides system services to the applications, either transparently, or through application initiated service calls. The operating system is also responsible for servicing interrupts and other system events, making exceptions a key component of the system level programmers’ model. 

In addition, ARMv7-M is a departure from the normal architecture evolution in that it has been designed to take the ARM architecture to lower cost/performance points than previously supported as well as having a strong migration path to ARMv7-R and the broad spectrum of embedded processing.

ARMv7-M is a memory-mapped architecture, meaning physical addresses as well as processor registers are architecturally assigned to provide event entry points (vectors), system control and configuration. Exception handler entry points are maintained in a table of address pointers. 

The address space 0xE0000000 to 0xFFFFFFFF is reserved for system level use. The first 1MB of the system address space (0xE0000000 to 0xE00FFFFF) is reserved by ARM and known as the Private Peripheral Bus (PPB), with the rest of the address space (from 0xE0100000) IMPLEMENTATION DEFINED with some memory attribute restrictions. See The system address map on page B3-2 for more details. 

Mode The microcontroller profile supports two modes (Thread and Handler modes). Handler mode is entered as a result of an exception. An exception return can only be issued in Handler mode.

Privilege Code can execute as privileged or unprivileged. Unprivileged execution limits or excludes access to some resources. Privileged execution has access to all resources. Handler mode is always privileged. Thread mode can be privileged or unprivileged.

Stack Pointer Two separate banked stack pointers exist, the Main Stack Pointer, and the Process Stack pointer. The Main Stack Pointer can be used in either Thread or Handler mode. The Process Stack Pointer can only be used in Thread mode. See The SP registers on page B1-8 for more details.

Reset Reset is a special form of exception which terminates current execution in a potentially unrecoverable way when reset is asserted. When reset is de-asserted execution is restarted from a fixed point. 

Supervisor call (SVCall) An exception which is explicitly caused by the SVC instruction. A supervisor call is used by application code to make a system (service) call to an underlying operating system. The SVC instruction enables the application to issue a system call that requires privileged access to the system and will execute in program order with respect to the application. ARMv7-M also supports an interrupt driven service calling mechanism PendSV (see Interrupts in Overview of the exceptions supported on page B1-14 for more details).

Fault A fault is an exception which results from an error condition due to instruction execution. Faults can be reported synchronously or asynchronously to the instruction which caused them. In general, faults are reported synchronously. The Imprecise BusFault is an asynchronous fault supported in the ARMv7-M profile.

Thread PrivilegedProcessExecution of a privileged process/thread using a stack reserved for that process/thread in a system that only supports privileged access, or where a mix of privileged and unprivileged threads exist.

A synchronous fault is always reported with the instruction which caused the fault. An asynchronous fault does not guarantee how it is reported with respect to the instruction which caused the fault. 

Interrupt An interrupt is an exception, other than a reset, fault or a supervisor call. All interrupts are asynchronous to the instruction stream. Typically interrupts are used by other elements within the system which wish to communicate with the processor, including software running on other processors.


• an Active exception is one whose handler has been started on a processor, but processing is not complete. An Active exception can be either running or pre-empted by a higher priority exception.

Asynchronous exceptions can be in one of the three possible states or both Pending and Active at the same time, where one instance of the exception is Active, and a second instance of the exception is Pending. 

All exceptions are assigned a priority level, the exception priority. Three exceptions have fixed values, while all others can be altered by privileged software. In addition, the instruction stream executing on the processor has a priority level associated with it, the execution priority. An exception whose exception priority is sufficiently1 higher than the execution priority will become active. In this case, the currently running instruction stream is pre-empted, and the exception that is taken is activated.

When an instruction stream is pre-empted by an exception other than reset, key context information is saved onto the stack automatically. Execution branches to the code pointed to by the exception vector that has been activated.

The execution priority can be boosted by software using registers provided for this purpose, otherwise it is the highest priority of all the exceptions that are active. See Execution priority and priority boosting within the core on page B1-18 for more details. 

Exceptions can occur during the exception activation, for example as a result of a memory fault while pushing context information. Late-arrival exception optimizations are permissible. The behavior of these cases is described in Exceptions on exception entry on page B1-33.

When in handler mode, an exception handler can return. If the exception is both Active and Pending (a second instance of the exception has occurred while it is being serviced), it is re-entered or becomes Pending according to the prioritization rules. If the exception is Active only, it becomes Inactive. The key information that was stacked is restored, and execution returns to the code pre-empted by the exception. The target of the exception return is determined by the Exception Return Link, a value stored in the link register on exception entry. 

On an exception return, there can be a pending exception which is of sufficiently high priority that the pending exception will pre-empt the execution being returned to. This will result in an exception entry sequence immediately after an exception return sequence. This condition is referred to as chaining of the exceptions. Hardware can optimize chaining of exceptions to remove the need to restore and re-save the key context state; this optimization is referred to as Tail-chaining. See Tail-chaining and exceptions on exception return on page B1-35 for details.

Faults can occur during the exception return, for example as a result of a memory fault while popping previous state off the stack. The behavior in this and other cases is explained in Derived exceptions on page B1-34.

ARMv7-M only executes Thumb instructions, both 16-bit and 32-bit instructions as described in The ARM Architecture – M profile on page A1-2, and hence is always executing in Thumb state. Thumb state is indicated by an execution status bit (EPSR.T == 1) within the architecture, see The special-purpose program status registers (xPSR) on page B1-8. ARMv7-M is consistent with the software programming model and interworking support of additional execution states in other profiles. Setting EPSR.T to zero in ARMv7-M causes a fault when the next instruction executes, because all instructions in this state are undefined. 

The ARMv7-M profile has the following registers closely coupled to the core: 
• general purpose registers R0-R12
• 2 Stack Pointer registers, SP_main and SP_process (banked versions of R13)
• the Link Register, LR (R14)
• the Program Counter, PC
• status registers for flags, exception/interrupt level, and execution state bits
• mask registers associated with managing the prioritization scheme for exceptions and interrupts
• a control register (CONTROL) to identify the current stack and thread mode privilege level.

 Register access restrictions where stated apply to normal execution. Debug restrictions can differ, see General rules applying to debug register access on page C1-6, Debug Core Register Selector Register (DCRSR) on page C1-22 and Debug Core Register Data Register (DCRDR) on page C1-23.

The stack pointer that is used in exception entry and exit is described in the pseudocode sequences of the exception entry and exit, see Exception entry behavior on page B1-21 and Exception return behavior on page B1-25 for more details. SP_main is selected and initialized on reset, see Reset behavior on page B1-20.

Program status at the system level breaks down into three categories. They can be accessed as individual registers, a combination of any two from three, or a combination of all three using the MRS and MSR instructions.

The APSR, IPSR and EPSR registers are allocated as mutually exclusive bitfields within a 32-bit register. The combination of the APSR, IPSR and EPSR registers is referred to as the xPSR register.

The APSR is modified by flag setting instructions and used to evaluate conditional execution in IT and conditional branch instructions. The flags (NZCVQ) are as described in ARM core registers on page A2-11. The flags are UNPREDICTABLE on reset. 

The IPSR is written on exception entry and exit. It can be read using an MRS instruction. Writes to the IPSR by an MSR instruction are ignored. The IPSR Exception Number field is defined as follows:

On reset, the core is in Thread mode and the Exception Number field of the IPSR is cleared. As a result, the value 1 (the Reset Exception Number) is a transitory value, and not a valid IPSR Exception Number.

The EPSR contains the T-bit and overlaid IT/ICI execution state bits to support the IT instruction or interrupt-continue load/store instructions. All fields read as zero using an MRS instruction. MSR writes are ignored. 

The EPSR T-bit supports the ARM architecture interworking model, however, as ARMv7-M only supports execution of Thumb instructions, it must always be maintained with the value T-bit == 1. Updates to the PC which comply with the Thumb instruction interworking rules must update the T-bit accordingly. The execution of an instruction with the EPSR T-bit clear will cause an invalid state (INVSTATE) UsageFault. The T-bit is set and the IT/ICI bits cleared on reset (see Reset behavior on page B1-20 for details).


• The IT bits provide context information for the conditional execution of a sequence of instructions such that it can be interrupted and restarted at the appropriate point. See the IT instruction definition in Chapter A6 Thumb Instruction Details for more information.

The IT feature takes precedence over the ICI feature if an exception-continuable instruction is used within an IT construct. In this situation, the multi-cycle load or store instruction is treated as restartable. 

There are three special-purpose registers which are used for the purpose of priority boosting. Their function is explained in detail in Execution priority and priority boosting within the core on page B1-18:

Implementations can support an IMPLEMENTATION DEFINED number of priorities in powers of 2. Where fewer than 256 priorities are implemented, the low-order bits of the BASEPRI field corresponding to the unimplemented priority bits are RAZ/WI. 

These registers can be accessed using the MSR/MRS instructions. The MSR instruction includes an additional register mask value BASEPRI_MAX, which updates BASEPRI only where the new value increases the priority level (decreases BASEPRI to a non-zero value). See MSR (register) on page B4-8 for details.

In addition:
• FAULTMASK is set by the execution of the instruction: CPSID f
• FAULTMASK is cleared by the execution of the instruction: CPSIE f
• PRIMASK is set by the execution of the instruction: CPSID i
• PRIMASK is cleared by the execution of the instruction: CPSIE i.

The CONTROL register is cleared on reset. The MRS instruction is used to read the register, and the MSR instruction is used to write the register. Unprivileged write accesses are ignored.

All unused bits in special-purpose registers are reserved. MRS and MSR instructions that access reserved bits treat them as RAZ/WI. For future software compatibility, the bits are UNK/SBZP. Software should write them to zero when initializing the register for a new process, otherwise software should restore reserved bits when updating or restoring a special-purpose register.

// The physical array of core registers.//// _R[RName_PC] is defined to be the address of the current instruction.// The offset of 4 bytes is applied to it by the register access functions.

The exception model is central to the architecture and system correctness in the ARMv7-M profile. The ARMv7-M profile differs from the other ARMv7 profiles in using hardware saving and restoring of key context state on exception entry and exit, and using a table of vectors to determine the exception entry points. In addition, the exception categorization in the ARMv7-M profile is different from the other ARMv7 profiles.

Reset Two levels of reset are supported by the ARMv7-M profile. The levels of reset control which register bit fields are forced to their reset values on the de-assertion of reset.

HardFault HardFault is the generic fault that exists for all classes of fault that cannot be handled by any of the other exception mechanisms. HardFault will typically be used for unrecoverable system failure situations, though this is not required, and some uses of HardFault might be recoverable. HardFault is permanently enabled and has a fixed priority of -1.

MemManage The MemManage fault handles memory protection related faults which are determined by the Memory Protection Unit or by fixed memory protection constraints, for both instruction and data generated memory transactions. The fault can be disabled (in this case, a MemManage fault will escalate to HardFault). MemManage has a configurable priority. 

BusFault The BusFault fault handles memory related faults other than those handled by the MemManage fault for both instruction and data generated memory transactions. Typically these faults will arise from errors detected on the system buses. Implementations are permitted to report synchronous or asynchronous BusFaults according to the circumstances that trigger the exceptions. The fault can be disabled (in this case, a BusFault will escalate to HardFault). BusFault has a configurable priority.

Debug Monitor In general, a DebugMonitor exception is a synchronous exception and classified as a fault. Watchpoints are asynchronous and behave as an interrupt. Debug monitor exceptions occur when halting debug is disabled, and debug monitor support is enabled. DebugMonitor has a configurable priority. See Priority escalation on page B1-19 and Debug event behavior on page C1-14 for more details.

Interrupts The ARMv7-M profile supports two system level interrupts – PendSV for software generation of asynchronous system calls, and SysTick for a Timer integral to the ARMv7-M profile – along with up to 496 external interrupts. All interrupts have a configurable priority.

All other interrupts can be disabled. Interrupts can be set to or cleared from the Pending state by software, and interrupts other than PendSV can be set to the Pending state by hardware.

See Fault behavior on page B1-39 for a definitive list of all the possible causes of faults, the type of fault reported, and the fault status register bits used to identify the faults. 

The vector table contains the initialization value for the stack pointer on reset, and the entry point addresses for all exception handlers. The exception number (see above) defines the order of entries in the vector table associated with exception handler entry as illustrated in Table B1-6.

On reset (power-up and local reset, see Overview of the exceptions supported on page B1-14 and Reset management on page B1-47), the vector table is initialized to an IMPLEMENTATION DEFINED value in the CODE or SRAM partition of the ARMv7-M memory map. The table’s current location can be determined or relocated  using the Vector Table Offset Register (VTOR), see Vector Table Offset Register (VTOR) on page B3-13. 

The Vector table must be naturally aligned to a power of two whose alignment value is greater than or equal to (Number of Exceptions supported x 4), with a minimum alignment of 128 bytes.The entry at offset 0 is used to initialize the value for SP_main, see The SP registers on page B1-8. All other entries must have bit [0] set, as the bit is used to define the EPSR T-bit on exception entry (see Reset behavior on page B1-20 and Exception entry behavior on page B1-21 for details). 

On exception entry, if bit [0] of the associated vector table entry is clear, execution of the first instruction will cause an INVSTATE UsageFault (see The special-purpose program status registers (xPSR) on page B1-8 and Fault behavior on page B1-39, Table B1-9 on page B1-40). On reset, this will escalate to a HardFault (see Priority escalation on page B1-19) due to the UsageFault being disabled on reset.

The priority algorithm treats lower numbers as taking higher precedence, that is, the lower the assigned value the higher the priority level. Exceptions assigned the same priority level adopt a fixed priority order for selection within the architecture according to their exception number.

Reset, non-maskable interrupts (NMI) and HardFault execute at fixed priorities of -3, -2, and -1 respectively. All other exception priorities can be set under software control and are cleared on reset.

When multiple exceptions have the same priority number, the pending exception with the lowest exception number takes precedence. Once an exception is active, only exceptions with a higher priority (lower priority number) can pre-empt it.

The priority field is an 8-bit field. In systems supporting less than 256 priority levels, the most significant bits are used to define the priority. This aligns the use of the priority field with the priority grouping mechanism described below.

Exception priority is split into two parts, the group priority and the sub-priority. The allocation of bits to the two parts is controlled by the PRIGROUP field of the Application Interrupt and Reset Control Register (AIRCR). This is a 3-bit field which indicates how many of the most significant bits within the 8-bit priority field for a given exception number are allocated to priority grouping as illustrated in Table B1-7.

The priority group bit field is used to define the priority for pre-emption. The priority associated with this field is referred to as the group priority. Where multiple pending exceptions share the same group priority, the sub-priority bit field is then used to resolve the priority within a group. Where two pending exceptions have the same priority the lower pending exception number has priority over the higher pending exception number.

The execution priority is defined to be the highest priority formulated from a set of values:
• the priorities of all Active exceptions (lowest priority number)
• the impact of PRIMASK, FAULTMASK and BASEPRI values (see below)

 Note: If the priority of an active exception is changed it can affect the execution priority. Therefore, the execution priority can be different from the priority of the running exception. This ensures that dynamic priority management avoids priority inversion from a new exception with respect to the active exception stack. 


• PRIMASK: setting this mask bit raises the execution priority to 0. This prevents all exceptions with configurable priority from activating, other than through the fault escalation mechanism (see Priority escalation). This also has a special impact on WFI (see WFI on page A6-277). 


• FAULTMASK: setting this mask bit raises the execution priority to -1. FAULTMASK can only be set when the execution priority is not NMI or HardFault (the priority value is greater than or equal to zero). Setting the FaultMask raises the priority of the exception handler to the level of a HardFault. FAULTMASK is cleared automatically on all exception returns except a return from NMI. 


• BASEPRI: can be written with a value from N (lowest configurable priority) to 1. When this register is cleared to 0, it has no effect on the current priority. A non-zero value will act as a priority mask, affecting the execution priority when the priority defined by BASEPRI is higher than the current executing priority.

The priority boosting mechanisms only affect the group priority. They have no effect on the sub-priority. The sub-priority is only used to sort pending exception priorities, and does not affect active exceptions.


• when the group priority of a pending synchronous fault or supervisor call is lower than or equal to the currently executing group priority, inhibiting normal pre-emption. This applies to all synchronous exceptions (a fault or SVCall) including the BKPT instruction but excluding all other DebugMonitor faults.

A fault which is escalated to a HardFault retains the ReturnAddress() behavior of the original fault. See the pseudocode definition of ReturnAddress() in Exception entry behavior on page B1-21 for more details. For the behavior of the affected exceptions occuring when the currently executing group priority is that of a HardFault or higher, see Unrecoverable exception cases on page B1-44. 

Context switching typically requires a critical region of code where interrupts must be disabled to avoid context corruption of key data structures during the change. This can be a severe constraint on system design and deterministic performance. ARMv7-M can support context switching with no critical region such that interrupts never need to be disabled.

An example usage model supporting critical region avoidance is to configure both SVCall and PendSV with the same, lowest exception priority. SVCall can be used for supervisor calls from threads, and PendSV can be used to handle context critical work offloaded from the exception handlers, including the equal priority SVCall handler. Because SVCall and PendSV have the same execution priority they will never pre-empt each other, therefore one will always process to completion before the other starts. SVCall and PendSV exceptions are always enabled, which means they will each execute at some point once all other exceptions have been handled. In addition, the associated exception handlers do not need to check whether they are returning to a process on exit with this usage model, as the PendSV exception will occur when returning to a process.

The example has all context switch requests issued by setting PendSV to Pending, however, both SVCall and PendSV exceptions can be used for context switching because they do not interfere with each other. While not the only usage model, support of critical region software avoidance is a key feature of ARMv7-M, specifically the support provided by the SVCall and PendSV exception specifications.

The assertion of reset causes the current execution state to be abandoned without being saved. On the de-assertion of reset, all registers controlled by the reset assertion contain their reset values, and the following actions are performed.

integer NestedActivation;           /* used for Handler => Thread check when value == 1 */bit ExceptionActive[*];             /* conceptual array of 1-bit values for all exceptions */bits(32) vectortable = '00':VTOR<29:7>:'0000000';Mode CurrentMode;

ExceptionActive[*] is a conceptual array of active flag bits for all exceptions (fixed priority system exceptions, configurable priority system exceptions, and external interrupts). The fixed priority active flags are conceptual only, and are not required to exist in a system register. 

On pre-emption of an instruction stream, context state is saved by the hardware onto a stack pointed to by one of the SP registers (see The SP registers on page B1-8). The stack that is used depends on the mode of the processor at the time of the exception.

A full-descending stack format is used, where the stack pointer is decremented immediately before storing a 32-bit word (when pushing context) onto the stack, and incremented after reading a 32-bit word (popping context) from the stack. Eight 32-bit words are saved in descending order, with respect to their address in memory, as listed: 

// NOTE: PushStack() can abandon memory accesses if a fault occurs during the stacking//       sequence. //       Exception entry is modified according to the behavior of a derived exception,//       see DerivedLateArrival() and associated text.

For global declarations see Register related definitions for pseudocode on page B1-12.For a definition of ExceptionActive[*] and NestedActivation see Reset behavior on page B1-20.For helper functons and procedures see Miscellaneous helper procedures and functions on page AppxG-22.

For more details on the registers with UNKNOWN values, see Exceptions on exception entry on page B1-33. For updates to system status registers, see section System Control Space (SCS) on page B3-6. 

Bits(32) ReturnAddress() returns the following values based on the exception cause         // NOTE: ReturnAddress() is always halfword aligned - bit<0> is always zero          //       xPSR.IT bits saved to the stack are consistent with ReturnAddress()

// NMI:                      Address of Next Instruction to be executed// HardFault (precise):      Address of the Instruction causing fault// HardFault (imprecise):    Address of Next Instruction to be executed  // MemManage:                Address of the Instruction causing fault// BusFault (precise):       Address of the Instruction causing fault// BusFault (imprecise):     Address of Next Instruction to be executed// UsageFault:               Address of the Instruction causing fault // SVC:                      Address of the Next Instruction after the SVC// DebugMonitor (precise):   Address of the Instruction causing fault// DebugMonitor (imprecise): Address of Next Instruction to be executed // IRQ:                      Address of Next Instruction to be executed after an interrupt

 A fault which is escalated to the priority of a HardFault retains the ReturnAddress() behavior of the original fault. For a description of priority escalation see Priority escalation on page B1-19.

ARMv7-M supports a configuration option to ensure that all exceptions are entered with 8-byte stack alignment. The stack pointers in ARMv7-M are guaranteed to be at least 4-byte aligned. As exceptions can occur on any instruction boundary, it is possible that the current stack pointer is not 8-byte aligned when an exception activates. 

The AAPCS requires that the stack-pointer is 8-byte aligned on entry to a conforming function1. Since it is anticipated that exception handlers will be written as AAPCS conforming functions, the system must ensure natural alignment of the stack for all arguments passed. The 8-byte alignment requirement is guaranteed in hardware using a configuration feature.

The STKALIGN bit (see Configuration and Control Register (CCR) on page B3-16) is used to enable the 8-byte stack alignment feature. Whether the bit is programmable in software and its value on reset are 

 Software must ensure that any exception handler that can activate while CCR.STKALIGN == ’0’ does not require 8-byte alignment. An example is an NMI exception entered from reset, where the implementation resets to 4-byte alignment.

If the bit is cleared between the entry to and return from an exception, and if the stack was not 8-byte aligned on entry to the exception, system corruption can occur. Support of a 4-byte aligned stack (CCR.STKALIGN == ’0’) in ARMv7-M is deprecated.

On an exception entry when STKALIGN == 1, the stack pointer (SP_main or SP_process) in use before the exception entry is forced to have 8-byte alignment by adjusting its alignment as part of the exception entry sequence. The xPSR that is saved as part of the exception entry sequence records the alignment of this stack pointer prior to the exception entry sequence. The alignment status is merged and stored to memory as bit [9] of the xPSR (a reserved bit within the xPSR) in the saved context information.

On an exception exit when STKALIGN == 1, the stack pointer returned to takes its alignment from the value recovered from bit [9] of the xPSR in the restored context from the exception exit sequence. This reverses the forced stack alignment performed on the exception entry.

 Stack pointer alignment on exception exit is architecturally defined as an OR function. If the exception exit sequence is started with a stack pointer which is only 4 byte aligned, then this change has no effect. 

In the event that the exception exit causes a derived exception, the derived exception is entered with the same stack alignment as was in use before the exception exit sequence started. 

A side-effect when STKALIGN is enabled is that the amount of stack used on exception entry becomes a function of the alignment of the stack at the time that the exception is entered. As a result, the average and worst case stack usage will increase. The worst case increase is 4 bytes per exception entry.

Maintaining the stack alignment information in an unused bit within the saved xPSR makes the feature transparent to context switch code within operating systems, provided that the reserved status of unused bits with the xPSR have been respected.

Some operating systems can avoid saving and restoring R14 when switching between different processes in Thread mode if it is known that the values held in an EXC_RETURN value are invariant between the different processes. This provides a small improvement in context switch time, but at the cost of future compatibility. The STKALIGN feature does not affect the EXC_RETURN value. ARM does not guarantee that this software optimization will be possible in future revisions of the ARMv7-M architecture, and recommends for future compatibility that the R14 value is always saved and restored on a context switch.

Exception returns occur when one of the following instructions loads a value of 0xFXXXXXXX into the PC while in Handler mode:
• POP/LDM which includes loading the PC.
• LDR with PC as a destination.
• BX with any register.

EXC_RETURN[28:4] are reserved with the special condition that all bits should be written as one or preserved. Values other than all 1s are UNPREDICTABLE. EXC_RETURN[3:0] provide return information as defined in Table B1-8.

If an EXC_RETURN value is loaded into the PC when in Thread mode, or from the vector table, or by any other instruction, the value is treated as an address, not as a special value. This address range is defined to have eXecute Never (XN) permissions, and will result in a MemManage exception, an INVSTATE UsageFault1 exception, or the exception will escalate to a HardFault.

The ARMv7-M profile provides a number of integrity checks on an exception return. These exist as a guard against errors in the system software. Incorrect exception return information could be inconsistent with the state of execution which must be held in processor hardware or other state stored by the exception mechanisms. 


• If at least one exception other than the returning exception is active, under normal circumstances the mode being returned to must be Handler mode. This checks for a mismatch of the number of exception returns. This check can be disabled using the NONBASETHRDENA control bit in the SCB. 

For global declarations see Register related definitions for pseudocode on page B1-12.For ExceptionTaken() see Exception entry behavior on page B1-21.For a definition of ExceptionActive[*] and NestedActivation see Reset behavior on page B1-20.For helper functons and procedures see Miscellaneous helper procedures and functions on page AppxG-22.

DeActivate(integer ReturningExceptionNumber)    ExceptionActive[ReturningExceptionNumber] = '0';    /* PRIMASK and BASEPRI unchanged on exception exit */    if IPSR<8:0> != '000000010' then        FAULTMASK<0> = '0';                  // clear FAULTMASK on any return except NMI          NestedActivation = NestedActivation – 1;    return;

In order to allow implementations to have the best possible interrupt response, an interrupt can be taken during an LDM or STM and continued after the return from the interrupt. The continuation state of the LDM or 

STM is held in the ICI bits in the EPSR (see The special-purpose program status registers (xPSR) on page B1-8). It is IMPLEMENTATION DEFINED when interrupts are recognized, so the use of the ICI bits is 

The ARMv7-M architecture supports continuation of, or restarting from the beginning, an abandoned LDM or STM instruction as outlined below. Where an LDM or STM is abandoned and restarted (ICI bits are not supported), the instructions should not be used with volatile memory. To support instruction replay, the LDM, 

 LDM and STM instructions where the ICI bits are not supported are incompatible with the single-copy atomicity rules for Device and Strongly Ordered memory described in Memory access restrictions on page A3-26.

The ICI bits encode the number of the first register in the register list that must be loaded or stored on return to an LDM or STM instruction. When the LDM or STM is returned to, all registers of an equal or higher number in the instruction register list to the value held in the ICI bits are loaded/stored. 

If the ICI bit field is non-zero, and the instruction executed on an exception return is not an LDM, STM or within an IT block, a UsageFault (INVSTATE, see Fault behavior on page B1-39) is generated.

If a fault (BusFault or MemManage) occurs on any LDM or STM instruction (including PUSH and POP), the instruction is abandoned, and will be restarted from the beginning on return from the exception. If the instruction is not within an IT block, the ICI bits are cleared to zero.

 The IT feature takes precedence over the ICI feature if an exception-continuable instruction is used within an IT construct. In this situation, the multi-cycle load or store instruction is treated as restartable, and should not be used with Device or Strongly Ordered memory.

For the ARM architecture in general, the case of LDM with PC in the register list is defined to be unordered, allowing the registers to be loaded in a different order than the register mask implies. The usual use is to allow the PC to be loaded first.

For ARMv7-M, however, LDM operations with the PC in the register list can be interrupted during their operation, and the continuation state held in the ICI bits. On an exception return to an LDM instruction, the ICI bits indicate which register must be loaded next to continue properly; this can result in an LDM with the PC in the register list accessing the same location in memory twice. 

If the PC was loaded early, the PC presented to the exception entry sequence must be restored such that the return address from the exception taken is to the LDM instruction address; it is then loaded again when the LDM is continued. 

The base register can be changed as a result of a load or store multiple under the following situations:
• Base register write-back: see load/store instruction writeback details in Chapter A6 Thumb Instruction Details for more information.
• Base load: the base register is one of the registers in the register list of an LDM. 

—If the instruction is within an IT block, the ICI bits are not used to hold the continuation state as the IT bits indicate the position in the IT block. 

—The SP that is presented to the exception entry sequence is lower than any element pushed (STM) or not yet popped (LDM).For instructions decrementing before (DB), the SP is set to the final (lowest) value. For instructions incrementing after (IA), the SP is set to the initial (lowest) value. In all cases, the ICI bits hold the continuation state.

—If the instruction is in an IT block, the ICI bits cannot be used to hold the continuation state, as the IT bits indicate the position of the instruction in the IT block. It is IMPLEMENTATION DEFINED whether the instruction executes to completion or restarts.

—If the interrupt activates after the base register has been loaded, implementations must restore the base register to its original value. The ICI bits can be set to an IMPLEMENTATION DEFINED value that will load at least the base register and subsequent locations again on return.

During Exception Entry other exceptions can occur, either because of a fault on the operations involved in exception entry, or because of the arrival of an asynchronous exception, an interrupt, which is of higher priority than the exception entry sequence in progress.

The ARMv7-M profile does not specify the point at which the arrival of an asynchronous exception is recognized during an exception entry. However, in order to support implementations with very low interrupt latencies, the ARMv7-M profile provides some facilities to permit high priority interrupts arriving during an exception entry to activate during the exception entry, and for the entry sequence not to be repeated.

When an asynchronous interrupt activates during the exception entry sequence, the exception that caused the exception entry sequence is known as the original exception. The exception caused by the interrupt is known as the secondary exception. 

It is permissible in this case for the exception entry sequence that was started by the original exception to be used by the secondary exception. The original exception is taken after the secondary exception has returned. This is referred to as late-arrival pre-emption.

It is IMPLEMENTATION DEFINED what conditions, if any, lead to late arrival pre-emption. Late arrival pre-emption can only occur when the secondary exception is of higher priority than the original exception. Where late arrival exceptions are supported:

    integer OEpriority;  // original exception group priority    integer SEpriority;  // secondary exception group priority    integer OEnumber;    // ExceptionNumber for OE    integer SEnumber;    // ExceptionNumber for SE

Where an exception entry sequence itself causes a fault, the exception that caused the exception entry sequence is known as the original exception. The fault that is caused by the exception entry sequence is known as the derived exception. The code stream that was running at the time of the original exception is known as the pre-empted code whose execution priority is the pre-empted priority.

If the pre-empted group priority is higher than or equal to the group priority of the derived exception then:
• if the Derived Exception was DebugMonitorFault, the exception is ignored
• if the Derived Exception was not DebugMonitorFault, the derived exception is escalated to HardFault. 

Derived exceptions are treated similarly to late arriving exceptions and it is permissible for implementations to use late arrival pre-emption. Late arrival pre-emption can only occur when the derived exception (after escalation if appropriate) is of higher priority than the original exception, but it is IMPLEMENTATION 

    // xEpriority: the lower the value, the higher the priority    // PE: the pre-empted exception - before exception entry    // OE: the original exception - exception entry    // DE: the derived exception - fault on exception entry

    integer PEpriority;  // pre-empted exception group priority    integer OEpriority;  // group priority of the original exception    integer DEpriority;  // derived exception group priority

    integer PEnumber;    // ExceptionNumber for PE    integer OEnumber;    // ExceptionNumber for OE    integer DEnumber;    // ExceptionNumber for DE

 It is IMPLEMENTATION DEFINED whether late-arrival exceptions are supported and can affect derived exceptions. Where late-arrival exceptions are supported, DE maps to OE and the late-arrival exception maps to SE in the late-arrival pseudocode (see Late arriving exceptions on page B1-33).

During exception return, other exceptions can affect behavior, either because of a fault on the operations involved in exception return, or because of an asynchronous exception that is of higher priority than the priority level being returned to during the exception return. The asynchronous exception can be already Pending or arrive during the exception return.

The target of the exception return is described by the Exception Return Link. The target priority is the highest priority active exception, excluding the exception being returned from, or the boosted priority set by the special-purpose mask registers, whichever is higher.

If the target group priority is higher than or equal to the group priority of the derived exception, then:
• if the derived exception is a DebugMonitorFault, it is ignored
• if the derived exception is not a DebugMonitorFault, the derived exception is escalated to HardFault.


• As an optimization that implementations are permitted to use to improve interrupt response when there is a Pending exception which has a higher group priority than the target group priority. In this case, the architected behavior is that the Pending exception will be taken immediately on exception return, and tail-chaining permits the optimization of the return and entry sequences. 

In the tail-chaining optimization, the exception return and exception entry sequences are combined to form the following sequence, where the ReturningExceptionNumber is the number of the exception being returned from, and the ExceptionNumber is the number of the exception being tail-chained to. EXC_RETURN is the EXC_RETURN value that caused the original exception return to start. 

The use of tail-chaining as an optimization for performing exception returns when there are Pending exceptions has a behavior which is different from simply performing the exception return, followed by the Pending exception entry. The difference in behavior is that many of the derived exceptions that could occur as a result of the exception return and the exception entry might not occur. Instead, these derived exceptions will occur when the pending exception is returned from. 

The ARMv7-M profile does not specify the point at which arrival of asynchronous exceptions are recognized during an exception. The ARMv7-M profile permits exceptions of a higher priority than the priority of the exception to be tail-chained to, to be entered in place of that exception being tail-chained to, using late-arrival pre-emption. It is IMPLEMENTATION DEFINED what conditions, if any, lead to late arrival pre-emption.

Late-arrival pre-emption can occur during a tail-chaining execution sequence due to a derived exception on an exception return. The derived exception is marked as Pending when a late-arrival pre-emption of the derived exception occurs.

The System Control Block within the System Control Space (The System Control Block (SCB) on page B3-10) provides the register support required to manage the exception model. The registers break down into the following categories:

—System Handler Priority Registers – see System Handler Priority Register 1 (SHPR1) on page B3-17, System Handler Priority Register 2 (SHPR2) on page B3-17, and System Handler Priority Register 3 (SHPR3) on page B3-17

The Interrupt Control State Register (Interrupt Control State Register (ICSR) on page B3-12) provides the ability to set the Pending state in software for NMI, SysTick and PendSV. It also provides the ability to clear the Pending state in software for SysTick and PendSV, and provides status information of pending and active exceptions. 

The Application Interrupt and Reset Control Register (Application Interrupt and Reset Control Register (AIRCR) on page B3-14) provides priority grouping control for the exception model, endian status for data accesses, and reset controls (see Reset management on page B1-47 for more details). Endianness can only be configured at reset and not under software control. See Control of the Endian Mapping in ARMv7-M on page A3-6 for more details. The register includes a vector key field that must be written with the key value 

The Configuration Control Register (Configuration and Control Register (CCR) on page B3-16) provides configuration control for:
• Enabling divide by zero faults, alignment faults and some operation controls
• Disabling BusFaults at priority -1 and above

The System Handler Priority Registers (System Handler Priority Register 1 (SHPR1) on page B3-17, System Handler Priority Register 2 (SHPR2) on page B3-17 and System Handler Priority Register 3 (SHPR3) on page B3-17) provide mechanisms to program the priority of BusFault, MemManage, UsageFault, Debug Monitor Fault, SVCall, SysTick and PendSV. 

The System Handler Control and State Register (System Handler Control and State Register (SHCSR) on page B3-18) provides access to the Pending and Active status of faults and supervisor calls plus the active status of the SysTick and PendSV interrupts. This register provides the ability to read and write the state bits as part of a context switch. The register also provides the ability to enable the UsageFault, BusFault and MemManage exception handlers. When the fault handlers are disabled, the faults are escalated (see Priority escalation on page B1-19).


• The active and pending state bits are provided to support the save and restore of information on a context switch. In particular, for explicit (software) writes to the System Handler Control and State Register:

—setting a pending bit for an exception in this register when the execution group priority is lower than the group priority of the exception associated with the pending bit is UNPREDICTABLE.

The Software Trigger Interrupt Register (Software Trigger Interrupt Register (STIR) on page B3-23) is a write only register, which provides a general method for setting a pending register by its exception number. Only external interrupts can be pended by this method. Attempts to write an exception number in the range 0-15 are ignored. Attempts to trigger an interrupt number not supported by a core are also ignored.

The NVIC registers (NVIC register support in the SCS on page B3-30) provide the following functions for external interrupts:
• enabling and disabling
• setting and clearing the Pending state
• reading the Active state
• programming the priority. 

In all fault handling cases, the corresponding fault status register bit is set, and the fault handler will return according to the rules defined in ReturnAddress(), see Exception entry behavior on page B1-21 for more details.

Table B1-9 lists all faults. The information provided includes the cause, exception taken, the name of the associated fault status bit, and which debug vector catch bit (if any) is used to catch the associated fault. 

MemManageIACCVIOL Violation/fault on MPU due to instruction fetch. Includes fetches from XN memory when no MPU. Faults only if the processor attempts to execute the instruction.The MemManage Address Register is not written by this fault.

UsageFaultINVSTATEAttempt to execute in an invalid EPSR state (e.g. after a BX type instruction has changed state). This includes state change after entry to or return from exception, as well as from inter-working instructions.

Illegal unaligned load or storeUsageFaultUNALIGNEDThis will occur when any load-store multiple instruction attempts to access a non-word aligned location. It will also occur for any load-store if it is not naturally aligned and the UNALIGN_TRP bit is set. [Note 2]

The 32-bit Configurable Fault Status register (Configurable Fault Status Registers (UserFault, BusFault, and MemManage) on page B3-18) is a concatenation of fault status for the UsageFault, BusFault, and MemManage status registers. UsageFault, BusFault and MemManage exceptions are known as configurable faults, as they all support dynamic priority setting. Fault Status register bits are additive – each new fault sets a bit. All status flags are write-1-to-clear.

The BusFault and MemManage status registers include a valid bit which is set when the associated fault address register is updated. The MemManage Address register is updated with the faulting address for data access violations only. The BusFault Address register is updated with the faulting address in the case of precise data errors only. The address of the faulting instruction for UsageFault, MemManage and Precise BusFaults can be determined from the stacked ReturnAddress() as defined in Exception entry behavior on page B1-21.

 
• The escalation of BusFault or MemManage to HardFault can cause the associated fault address register to be overwritten by a derived exception (see Exceptions on exception entry on page B1-33 and Tail-chaining and exceptions on exception return on page B1-35). Fault handlers must ensure that the valid bit is checked and cleared by the HardFault handler when a derived exception causes this corruption.


• There are cases where the fault address register will not be valid. Handlers should check address validity by ensuring its associated VALID bit is set. An invalid address can occur due to pre-emption of a fault.

An example use is to allow autoconfiguration of bridges and devices where probing of disabled or non-existent elements can cause bus faults. Software must ensure the executing exception handler’s code and data space are valid for correct operation.

The standard exception entry mechanism does not apply where a fault or supervisor call occurs at a priority of -1 or above. ARMv7-M handles most of these cases using a mechanism called lock-up, otherwise the condition becomes Pending or is ignored. Lock-up suspends normal instruction execution and enters lock-up state. When in lock-up state, the behavior is:


• The instruction fetched is executed repeatedly if it is a valid instruction. If the lock-up is caused by a precise memory error on a load or store which has base write-back, the base register is restored by the fault.


• A halt command from a halt mode debug agent is issued. The core will enter Debug state with the PC set to the same value as is used for return context. See Table B1-10 on page B1-45 for details.

In most cases, once in lock-up state, the processor will continue in this manner until reset (such as from a watchdog). However, the reason for the lock-up state can be examined and corrected without a reset by one of the following mechanisms:


• If NMI pre-empts lock-up state in a HardFault exception, the NMI handler can fix the problem before returning (e.g. changing the return PC, changing the value in the FAULTMASK register and/or fixing the state bits in the saved xPSR).

Table B1-10 outlines the behavior of all faults or supervisor calls that can occur during HardFault or NMI handler execution. Where the system locks up at a priority of -1, it is IMPLEMENTATION DEFINED whether the EPSR indicates Hardfault and/or if the FAULTMASK bit is set.


• The control bit VECTRESET (a debug feature, see Reset and debug on page B1-48 below) causes a Local Reset. It is IMPLEMENTATION DEFINED whether other parts of the system are reset as a result of this control.

Usage Fault – INVPC On return from Priority -1Tailchains to HardFaultN/A The fault on the exception return causes re-entry to the HardFault exception handler. This is not a lock-up condition. 

a.See Configuration and Control Register (CCR) on page B3-16b. See Configurable Fault Status Registers (UserFault, BusFault, and MemManage) on page B3-18c.See MPU Control Register (MPU_CTRL) on page B3-40d.BKPT instruction or FPB (see Flash Patch and Breakpoint (FPB) support on page C1-61) generated

In addition the Application Interrupt and Reset Control register provides a mechanism, VECTCLRACTIVE to reset the active state of all exceptions. Writing 1 to the VECTCLRACTIVE bit clears the Active state of all exceptions and the Exception Number in the IPSR (see The special-purpose program status registers (xPSR) on page B1-8). Once complete, the IPSR and Active state of all exceptions will read as zero.

Debug logic is fully reset by a Power-On Reset. Debug logic is only partially reset by a Local Reset. See Debug and reset on page C1-13 for details. Debuggers must only use VECTRESET when the core is halted, otherwise the effect is UNPREDICTABLE.

ARMv7-M supports the use of Wait for Interrupt (WFI) and Wait for Event (WFE) instructions as part of a power management policy.   Wait for Interrupt provides a mechanism for hardware to support entry to one or more sleep states.  Hardware can suspend execution while waiting for a wakeup event. The levels of power saving and associated wakeup latency, while execution is suspended, are IMPLEMENTATION DEFINED.

Wait for Event provides a mechanism for software to suspend program execution with minimal or no impact on wakeup latency until a condition is met. Wait for Event allows some freedom for hardware to instigate power saving measures. Both WFI and WFE are hint instructions and can have no effect. They are generally used in software idle loops that resume program execution after an interrupt or event of interest has occurred.


• The transition of an interrupt from the Inactive to the Pending state can be configured as a wakeup event. This allows resumption of a Wait for Event instruction using a masked interrupt as the wakeup event.


• On an exception return, if no exceptions other than the returning exception are Active, there is a configuration bit to suspend execution. When the feature is enabled, the exception return is not performed. The subsequent activation of any exception behaves as a chained exception  (see Tail-chaining on page B1-36).

 If PRIMASK is set and FAULTMASK is clear, an asynchronous exception which has a higher group priority than BASEPRI is not required by the architecture to result in the suspended state caused by SLEEPONEXIT being left. This is different from the treatment of WFI in this case.


• A qualifier that indicates support of  different levels of sleep. The bit indicates that the wakeup time from the suspended execution can be longer than if the bit is not set. Typically this can be used to determine whether a PLL or other clock generator can be suspended.  The exact behavior is 

The Wait For Event system relies on hardware and software working together to achieve energy saving. For example, stalling execution of a processor until a device or another processor has set a flag:
• the hardware provides the mechanism to enter the Wait For Event low-power state
• software enters a polling loop to determine when the flag is set:—the polling processor issues a Wait For Event instruction as part of a polling loop if the flag is clear—an event is generated (hardware interrupt or Send Event instruction from another processor) when the flag is set.

The mechanism depends on the interaction of:
• WFE wake-up events, see WFE wake-up events
• the Event Register, see The Event Register on page B1-50
• the Send Event instruction, see The Send Event instruction on page B1-50
• the Wait For Event instruction, see The Wait For Event instruction on page B1-50.


• any exception entering the Pending state if SEVONPEND in the System Control Register is set
• an asynchronous exception at a priority that pre-empts any currently active exceptions
• a debug event with debug enabled.

The Event Register is a single bit register for each processor in a multiprocessor system. When set, an Event Register indicates that an event has occurred, since the register was last cleared, that might prevent the processor needing to suspend operation on issuing a WFE instruction. The following conditions apply to the Event Register:


• The Event Register is set by any WFE wake-up event or by the execution of an exception return instruction. For the definition of exception return instructions see Exception return behavior on page B1-25.

The Send Event instruction, see SEV on page A6-212, causes a wake up event to be signaled to all processors in a multiprocessor system. The mechanism used to signal the event to the processors is IMPLEMENTATION 


• If the Event Register is clear the processor can suspend execution and enter a low-power state. It can remain in that state until the processor detects a WFE wake-up event or a reset. When the processor detects a WFE wake-up event, or earlier if the implementation chooses, the WFE instruction completes.

The WaitForEvent() pseudocode procedure optionally suspends execution until a WFE wake-up event or reset occurs, or until some earlier time if the implementation chooses. It is IMPLEMENTATION DEFINED whether restarting execution after the period of suspension causes a ClearEventRegister() to occur.

When a processor issues a WFI instruction it can suspend execution and enter a low-power state. It can remain in that state until the processor detects a reset or one of the following WFI wake-up events:
• an asynchronous exception at a priority that pre-empts any currently active exceptions

 If PRIMASK is set and FAULTMASK is clear, an asynchronous exception that has a higher group priority than any active exception and a higher group priority than BASEPRI results in a WFI instruction exit. If the group priority of the exception is less than or equal to the execution group priority, the exception is ignored.

 Because debug entry is one of the WFI wake-up events, ARM recommends that Wait For Interrupt is used as part of an idle loop rather than waiting for a single specific interrupt event to occur and then moving forward. This ensures the intervention of debug while waiting does not significantly change the function of the program being debugged.

A common implementation practice is to complete any entry into power-down routines with a WFI instruction. Typically, the WFI instruction:1.forces the suspension of execution, and of all associated bus activity2.ceases to execute instructions from the processor.

The control logic required to do this typically tracks the activity of the bus interfaces of the processor. This means it can signal to an external power controller that there is no ongoing bus activity.

The exact nature of this interface is IMPLEMENTATION DEFINED, but the use of Wait For Interrupt as the only architecturally-defined mechanism that completely suspends execution makes it very suitable as the preferred power-down entry mechanism.

This chapter contains information on the memory model pseudocode, the pseudocode associated with memory accesses. The chapter is made up of the following sections: 
• Introduction on page B2-2
• Pseudocode details of general memory system operations on page B2-3


• memory attributes are determined from the default system address map or using an MPU as defined in The system address map on page B3-2 or Protected Memory System Architecture (PMSAv7) on page B3-35 respectively.

This section contains pseudocode describing general memory operations, in the subsections:
• Memory data type definitions.
• Basic memory accesses on page B2-4.
• Interfaces to memory system specific pseudocode on page B2-4.
• Aligned memory accesses on page B2-5
• Unaligned memory accesses on page B2-6
• Reverse endianness on page B2-7
• Pseudocode details of operations on exclusive monitors on page B2-8
• Access permission checking on page B2-10
• MPU access control decode on page B2-10
• Default memory access decode on page B2-11
• MemManage fault handling on page B2-13.

The attributes in memaddrdesc.memattrs are used by the memory system to determine the memory type and ordering behaviors as described in Memory types on page A3-18 and Memory access order on page A3-30.

boolean iswrite;            // TRUE for memory stores, FALSE for load accessesboolean ispriv;             // TRUE if the instruction executing with privileged accessboolean isinstrfetch;       // TRUE if the memory access is associated with an instruction fetch

FindPriv() is used to determine if a privileged access. ValidateAddress() is used to resolve the memory attributes associated with an address and check the validity of the access where memory protection is enabled.

The MemA[] function performs a memory access at the current privilege level, and the MemA_unpriv[] function performs an access that is always unprivileged. In both cases the architecture requires the access to be aligned, and generates an Alignment fault if it is not.

    // Sort out alignment    if address != Align(address, size) then        UFSR.UNALIGNED = ’1’;        ExceptionTaken(UsageFault);     // default address map or MPU    memaddrdesc = ValidateAddress(address, privileged, TRUE);

    // Sort out endianness, then memory array access    if AIRCR.ENDIANESS == ’1’ then        value = BigEndianReverse(value, size);    _Mem[memaddrdesc,size] = value;

    // It is IMPLEMENTATION DEFINED whether the detection of memory aborts happens    // before or after the check on the local Exclusive Monitor. As a result a failure    // of the local monitor can occur on some implementations even if the memory    // access would give a memory abort.

    passed = IsExclusiveLocal(memaddrdesc.physicaladdress, ProcessorID(), size);    if memaddrdesc.memattrs.shareable then        passed = passed && IsExclusiveGlobal(memaddrdesc.physicaladdress, ProcessorID(), size);    if passed then        ClearExclusiveLocal(ProcessorID());    return passed;

The MarkExclusiveGlobal() procedure takes as arguments an address, the processor identifier processorid and the size of the transfer. The procedure records that processor processorid has requested exclusive access covering at least size bytes from the address. The size of region marked as exclusive is IMPLEMENTATION 

DEFINED, up to a limit of 2KB, and no smaller than size, and aligned in the address space to the size of the region. It is UNPREDICTABLE whether this causes any previous request for exclusive access to any other address by the same processor to be cleared.

The MarkExclusiveLocal() procedure takes as arguments an address, the processor identifier processorid and the size of the transfer. The procedure records in a local record that processor processorid has requested exclusive access to an address covering at least size bytes from the address. The size of the region marked as exclusive is IMPLEMENTATION DEFINED, and can at its largest cover the whole of memory, but is no smaller than size, and is aligned in the address space to the size of the region. It is IMPLEMENTATION 

The IsExclusiveGlobal() function takes as arguments an address, the processor identifier processorid and the size of the transfer. The function returns TRUE if the processor processorid has marked in a global record an address range as exclusive access requested that covers at least the size bytes from the address. It is IMPLEMENTATION DEFINED whether it returns TRUE or FALSE if a global record has marked a different address as exclusive access requested. If no address is marked in a global record as exclusive access, 

The IsExclusiveLocal() function takes as arguments an address, the processor identifier processorid and the size of the transfer. The function returns TRUE if the processor processorid has marked an address range as exclusive access requested that covers at least the size bytes from the address. It is IMPLEMENTATION 

DEFINED whether this function returns TRUE or FALSE if the address marked as exclusive access requested does not cover all of the size bytes from the address. If no address is marked as exclusive access requested, then this function returns FALSE. It is IMPLEMENTATION DEFINED whether this result is ANDed with the result of IsExclusiveGlobal() with the same parameters.

processorid, for which an address region including any of the size bytes starting from the supplied address has had a request for an exclusive access. It is IMPLEMENTATION DEFINED whether the equivalent global record of the processor processorid is also cleared if any of the size bytes starting from the address has had a request for an exclusive access, or if any other address has had a request for an exclusive access.

The ClearExclusiveLocal() procedure takes the argument processor identifier processorid. The procedure clears the local record of processor processorid for which an address has had a request for an exclusive access. It is IMPLEMENTATION DEFINED whether this operation also clears the global record of processor 

The following pseudocode describes checking the access permission. Permissions are checked against access control information associated with a region when memory protection is supported and enabled, or against access control attributes associated with the default memory map.

The following pseudocode describes the default memory attribute decode, when memory protection is disabled, not supported, or cases where the protection control is overridden. See MPU pseudocode on page B3-36 for information on when DefaultMemoryAttributes() is called.

        // Outer attributes are the same as the inner attributes in all cases.        memattrs.outerattrs = memattrs.innerattrs;

Memory access violations are reported as MemManage faults. If the fault is disabled, the fault will escalate to a HardFault exception. See Overview of the exceptions supported on page B1-14 and Fault behavior on page B1-39 for more information.

This chapter contains information on the system address map. It contains the following sections:
• The system address map on page B3-2
• System Control Space (SCS) on page B3-6
• System timer - SysTick on page B3-24
• Nested Vectored Interrupt Controller (NVIC) on page B3-28
• Protected Memory System Architecture (PMSAv7) on page B3-35

For ARMv7-M, the 32-bit address space is predefined, with subdivision for code, data, and peripherals, as well as regions for on-chip (tightly coupled to the core) and off-chip resources.The address space supports 8 x 0.5GB primary partitions:
• Code
• SRAM
• Peripheral
• 2 x RAM regions
• 2 x Device regions
• System

Physical addresses are architecturally assigned for use as event entry points (vectors), system control, and configuration. The event entry points are all with respect to a table base address, where the base address is configured to an IMPLEMENTATION DEFINED value on reset, then maintained in an address space reserved for system configuration and control. To meet this and other system needs, the address space 0xE0000000 to 


• It is IMPLEMENTATION DEFINED which portions of the overall address space are designated read-write, which are read-only (for example Flash memory), and which are no-access (unpopulated parts of the address map).

To support a user (unprivileged) and supervisor (privileged) software model, a memory protection scheme is required to control the access rights. The Protected memory System Architecture for ARMv7-M (PMSAv7) is an optional system level feature described in Protected Memory System Architecture (PMSAv7) on page B3-35. An implementation of PMSAv7 is known as a Memory Protection Unit (MPU).

The address map described in Table B3-1 is the default map for an MPU when it is disabled, and the only address map supported when no MPU is present. The default map can be enabled as a background region for privileged accesses when the MPU is enabled. See the definition of PRIVDEFENA in MPU Control Register (MPU_CTRL) on page B3-40.

 When an MPU is enabled, the MPU is restricted in how it can change the default memory map attributes associated with System space (address 0xE0000000 or higher). System space is always marked as XN. System space which defaults to Device can be changed to Strongly-Ordered, but cannot be mapped to Normal memory. The PPB memory attributes cannot be remapped by an MPU.


• In general, registers support word accesses only, with byte and halfword access UNPREDICTABLE. Several registers (namely priority and fault status registers) are a concatenation of byte aligned bit fields affecting different resources. In these cases, the registers1 can be declared as 8-bit or 16-bit registers with an appropriate address offset within the 32-bit register base address.


• The term set means writing the value to 1, and the term clear(ed) means writing the value to 0. Where the term applies to multiple bits, all bits assume the written value.

 The Flash Patch and Breakpoint block (FPB, see Flash Patch and Breakpoint (FPB) support on page C1-61) is designated a debug resource. Alternatively, FPB resources can be used as a means of updating software as part of a product maintenance policy. The address remapping behavior of the FPB is not specific to debug operation. Debug functionality is reduced when FPB resources are allocated to software maintenance.

The System Control Space is a memory-mapped 4kB address space which is used along with the special-purpose registers to provide arrays of 32-bit registers for configuration, status reporting and control. The SCS breaks down into the following groups:

Detailed breakdown of the register groups is provided as part of the appropriate feature definition:
• System ID block in System ID register support in the SCS on page B3-10
• System control and configuration in The System Control Block (SCB) on page B3-10
• SysTick system timer in System timer - SysTick on page B3-24
• NVIC in Nested Vectored Interrupt Controller (NVIC) on page B3-28
• MPU in Chapter Protected Memory System Architecture (PMSAv7) on page B3-35
• Debug in Chapter C1 ARMv7-M Debug

The CPUID allows applications and debuggers to determine what kind of ARMv7-M processor they are using. The CPUID attribute ID registers can be read for specific details. This register is word accessible only.

A bank of registers is defined as a series of 4-bit attribute fields. These attributes provide information details on the instruction set, memory model, and debug support present. See Appendix A CPUID for the detailed definition of the register support. These registers are word accessible only.

[8:0]ROVECTACTIVEvalue == 0: Thread modevalue > 1: the exception numberc for the current executing                 exception 

a. An implementation can include configuration input signals that determine the reset value of the TBLOFF bit field. If there is no configuration input signals to determine the reset value of this field then it resets to 0. A non-zero value must comply with the alignment restrictions described in The vector table on page B1-16. TBLBASE resets to zero.

The offset address is 32-word aligned. Where more than 16 external interrupts are used, the offset word alignment must be increased to accommodate vectors for all the exceptions and interrupts supported and keep the required table size naturally aligned. See Interrupt Controller Type Register (ICTR) on page B3-32 for information on the number of interrupts supported.

[10:8]R/WPRIGROUPPriority grouping position (binary point). This field sets the interpretation of priority registers, both for handlers and standard interrupts. For a definition of how this bit field is interpreted to assign priority and priority sub-group bit fields to the System Handler and NVIC priority registers, see Priority grouping on page B1-18)

[9]R/WSTKALIGN1: on exception entry, the SP used prior to the exception is adjusted to be 8-byte aligned and the context to restore it is saved. The SP is restored on the associated exception return.

The 3 Configurable Fault Status Registers are one or two bytes each and packed into one word. The registers can be accessed collectively as a word as illustrated in Table B3-15 on page B3-1910-14, or individually as a byte or halfword:
• For the UsageFault Status Register, see Table B3-18 on page B3-20
• For the BusFault Status Register, see Table B3-17 on page B3-20
• For the MemManage Status Register, see Table B3-16 on page B3-19 

Note 1: Pending state bits: A bit is set when the exception started to invoke, but was replaced by a higher            priority exceptionNote 2: Active state bits: the bit is set when the associated exception is the current exception or a nested             (pre-empted) exception.

[31]R/W1CDEBUGEVTDebug event, and the Debug Fault Status Register has been updated. Only set when halting debug is disabled (C_DEBUGEN = 0) See Debug event behavior on page C1-14 for more information

[31:0]R/WADDRESSData address MPU faulted. This is the location which a load or store attempted to access which was faulted. The MemManage Status Register provides the cause, and indicates if the content of this register is valid.When an unaligned access faults, the address will be the actual address which faulted; since an access may be split into multiple parts (each aligned), this address therefore may be any offset in the range of the requested size.

[31:0]R/WADDRESSUpdated on precise data access faults. The value is the faulting address associated with the attempted access. The BusFault Status Register provides information on the reason, and indicates if the content of this register is valid.For unaligned access faults, the address is the address requested by the instruction, which is not necessarily the address which faulted. 

[9:0]WOINTIDThe value written in this field is the interrupt to be triggered. This acts the same as storing to the corresponding ISPR[x] set-pending NVIC register bit. See Interrupt Set-Pending and Clear-Pending Registers (NVIC_ISPRx and NVIC_ICPRx) on page B3-33.


• An internal clock source control based on missing/meeting durations. The COUNTFLAG bit-field in the control and status register can be used to determine if an action completed within a set duration, as part of a dynamic clock management control loop.

When enabled, the timer will count down from the reload value to zero, reload (wrap) to the value in the SysTick Reload Value Register on the next clock edge, then decrement on subsequent clocks. Writing a value of zero to the Reload Value Register disables the counter on the next wrap. When the counter transitions to zero, the COUNTFLAG status bit is set. The COUNTFLAG bit clears on reads.

Writing to the Current Value Register will clear the register and the COUNTFLAG status bit. The write does not trigger the SysTick exception logic. On a read, the current value is the value of the register at the time the register is accessed. 

The timer is clocked with respect to a reference clock. The reference clock can be the core clock or an external clock source. Where an external clock source is used, the implementation must document the relationship between the core clock and the external reference. This is required for system timing calibration, taking account of metastability, clock skew and jitter.

[16]ROCOUNTFLAGReturns 1 if timer counted to 0 since last time this register was read. COUNTFLAG is set by a count transition from 1 => 0. COUNTFLAG is cleared on read or by a write to the Current Value register.

[1]R/WTICKINTIf 1, counting down to 0 will cause the SysTick exception to be pended. Clearing the SysTick Current Value register by a register write in software will not cause SysTick to be pended.

[31:0]R/WCURRENTCurrent counter value. This is the value of the counter at the time it is sampled. The counter does not provide read-modify-write protection.The register is write-clear. A software write of any value will clear the register to 0. Unsupported bits RAZ (see SysTick Reload Value register).

[31]RONOREFIf reads as 1, the Reference clock is not provided – the CLKSOURCE bit of the SysTick Control and Status register will be forced to 1 and cannot be cleared to 0.

ARMv7-M provides an interrupt controller as an integral part of the ARMv7-M exception model. The interrupt controller operation aligns with ARM’s General Interrupt Controller (GIC) specification, promoted for use with other architecture variants and ARMv7 profiles.

The ARMv7-M NVIC architecture supports up to 496 (IRQ[495:0]) discrete interrupts. The number of external interrupt lines supported can be determined from the read-only Interrupt Controller Type Register (ICTR) accessed at address 0xE000E004 in the System Control Space. See Interrupt Controller Type Register (ICTR) on page B3-32 for the register detail. The general registers associated with the NVIC are all accessible from a block of memory in the System Control Space as described in Table B3-29 on page B3-30.

ARMv7-M supports level-sensitive and pulse-sensitive interrupt behavior. This means that both level-sensitive and pulse-sensitive interrupts can be handled. Pulse interrupt sources must be held long enough to be sampled reliably by the core clock to ensure they are latched and become Pending. A subsequent pulse can re-pend the interrupt while it is Active, however, multiple pulses which occur during the Active period will only register as a single event for interrupt scheduling. 

 A pulse must be cleared before the assertion of AIRCR.VECTCLRACTIVE or the associated exception return, otherwise the interrupt signal behaves as a level-sensitive input and the pending bit is asserted again. 


• Level based interrupts will pend and activate the interrupt. The Interrupt Service Routine (ISR) can then access the peripheral, causing the level to be de-asserted. If the interrupt is still asserted on return from the interrupt, it will be pended again.


• NVIC interrupts can be enabled and disabled by writing to their corresponding Interrupt Set-Enable or Interrupt Clear-Enable register bit-field. The registers use a write-1-to-enable and write-1-to-clear policy, both registers reading back the current enabled state of the corresponding (32) interrupts.

When an interrupt is disabled, interrupt assertion will cause the interrupt to become Pending, however, the interrupt will not activate. If an interrupt is Active when it is disabled, it remains in its Active state until cleared by reset or an exception return. Clearing the enable bit prevents new activations of the associated interrupt.


• NVIC interrupts can be pended/un-pended using a complementary pair of registers to those used to enable/disable the interrupts, named the Set-Pending Register and Clear-Pending Register respectively. The registers use a write-1-to-enable and write-1-to-clear policy, both registers reading back the current pended state of the corresponding (32) interrupts. The Clear-Pending Register has no effect on the execution status of an Active interrupt.


• NVIC interrupts are prioritized by updating an 8-bit field within a 32-bit register (each register supporting four interrupts). Priorities are maintained according to the ARMv7-M prioritization scheme. See Exception priorities and pre-emption on page B1-17.

In addition to an external hardware event or setting the appropriate bit in the Set-Pending registers, an external interrupt can be pended from software by writing its interrupt number (ExceptionNumber - 16) to the Software Trigger Interrupt Register described in Software Trigger Interrupt Register (STIR) on page B3-23.

NVIC[] is an array of active high external interrupt input signals;    // the type of signal (level or pulse) and its assertion level/sense is IMPLEMENTATION DEFINED    // and might not be the same for all inputs

The Interrupt Controller Type Register (ICTR) and Software Trigger Interrupt Register (STIR) reside in the system control region. The ICTR is a read-only register which provides information on the number of external interrupts supported by the implementation. The STIR is a write-only register which enables pending of external interrupts by software. The system control region also includes status and configuration registers which apply to the NVIC as part of the general exception model. 

INTLINESNUM is the total number of interrupt lines supported by an implementation, defined in groups of 32. This is encoded as follows:
• 0b0000: up to 32 interrupt lines supported(These interrupts are banked in a multi-processor system)
• 0b0001: up to 64 interrupt lines supported.
• 0b0010: up to 96 interrupt lines supported
• 0b0011: up to 128 interrupt lines supported
• …
• 0b1110: up to 480 interrupt lines supported
• 0b1111: up to 496 interrupt lines supported (a maximum of sixteen supported by this value).

[31:0]R/WSETPENDWriting a 1 to a bit pends the associated interrupt under software control. Each bit represents an interrupt number from N to N+31 (starting at interrupt 0, 32, 64, etc). 

[31:0]R/WCLRPENDWriting a 1 to a bit un-pends the associated interrupt under software control. Each bit represents an interrupt number from N to N+31 (starting at interrupt 0, 32, 64, etc). 

[31:0]ROACTIVEEach bit represents the current active state for the associated interrupt within a group of 32. Each bit represents an interrupt number from N to N+31 (starting at interrupt 0, 32, 64, etc).

To support a user (unprivileged) and supervisor (privileged) software model, a memory protection scheme is required to control the access rights. ARMv7-M supports the Protected Memory System Architecture (PMSAv7). The system address space of a PMSAv7 compliant system is protected by a Memory Protection Unit (MPU). The protected memory is divided up into a set of regions, with the number of regions supported 

IMPLEMENTATION DEFINED. While PMSAv7 supports region sizes as low as 32 bytes, finite register resources for the 4GB address space make the scheme inherently a coarse-grained protection scheme. The protection scheme is 100% predictive with all control information maintained in registers closely-coupled to the core. Memory accesses are only required for software control of the MPU register interface, see Register support for PMSAv7 in the SCS on page B3-38.


• When the MPU is disabled or not present, the system adopts the default system memory map listed in Table B3-1 on page B3-3.When the MPU is enabled, the enabled regions are used to define the system address map with the following provisos:

—the MPU is restricted in how it can change the default memory map attributes associated with System space (address 0xE0000000 or higher).System space is always marked as XN (eXecute Never). System space which defaults to Device can be changed to Strongly-Ordered, but cannot be mapped to Normal memory.

Memory regions can vary in size as a power of 2. The supported sizes are 2N, where 5 ≤ N ≤ 32. Where there is an overlap between two regions, the register with the highest region number takes priority. 

For regions of 256 bytes or larger, the region can be divided up into eight sub-regions of size 2(N-3). Sub-regions within a region can be disabled on an individual basis (8 disable bits) with respect to the associated region attribute register. When a sub-region is disabled, an access match is required from another region, or background matching if enabled. If an access match does not occur a fault is generated. Region sizes below 256 bytes do not support sub-regions. The sub-region disable field is SBZ/UNP for regions of less than 256 bytes in size.


• An optimized two register update model, where the region being updated can be selected by writing to the MPU Region Base Address Register. This optimization applies to the first sixteen memory regions (0 ≤ RegionNumber ≤ 0xF) only.


• The MPU Region Base Address Register and the MPU Region Attribute and Size Register pairs are aliased in three consecutive dual-word locations. Using the two register update model, up to four regions can be modified by writing the appropriate even number of words using a single STM multi-word store instruction.

The following pseudocode defines the operation of an ARMv7-M MPU. The terms used align with the MPU register names and bit field names described in Register support for PMSAv7 in the SCS on page B3-38.

    boolean isvectortablelookup;        // TRUE if address associated with exception entry    boolean isPPBaccess;                // TRUE if the address is to the PPB region    AddressDescriptor result;    Permissions perms;

    if isvectortablelookup OR isPPBaccess then       // bypass MPU for these accesses        result.memattrs = DefaultAttrs(PA);

Instruction or data access violations cause a MemManage exception to be generated. In the pseudocode, these are described by the pseudo-function MemManageFault(). See Fault behavior on page B1-39 for more details of MemManage exceptions. 

Table B3-37 on page B3-39 summarizes the register support for a memory Protection Unit (MPU) in the System Control Space. In common with the general policy, all registers are byte, halfword, and word accessible unless stated otherwise. All MPU register addresses are mapped as little endian. 


• The MPU Control Register specified in MPU Control Register (MPU_CTRL) on page B3-40. The MPU Control register includes a global enable bit which must be set to enable the MPU feature.


• The MPU Region Attribute and Size Register to control the region size, sub-region access, access permissions, memory type and other properties of the memory region in MPU Region Attribute and Size Register (MPU_RASR) on page B3-42.

The MPU Control Register is used to enable the MPU. The register is cleared on reset. If no regions are enabled and the PRIVDEFENA and ENABLE bits are set, only privileged code can execute from the system address map.

[2]R/WPRIVDEFENAWhen the bit is set along with the ENABLE bit, the Default memory map (as defined in The system address map on page B3-2) is enabled as a background region for privileged access. The background region acts as though it were region number -1. MPU configured regions will override (take priority over) the default memory map. 

DEFINED. It can be determined by writing all 1’s to the region’s MPURBAR[31:5] and reading back the bits set. The minimum size is determined from the number of trailing zeroes in the bit field. All regions support all size values from the minimum supported to 4GB (see SIZE in MPU Region Attribute and Size Register – (0xE000EDA0) on page B3-42). This register is UNPREDICTABLE if accessed other than as a word.

[7:0]R/WREGIONThis field selects the region specific MPURBAR and MPURASR. The MPURNR must be written before accessing the associated register pair, unless the alternative access feature (see MPURBAR.VALID description) is used on a write access.

[31:N]R/WADDRBase address of the region. The base address is naturally aligned according to the size of the region. N is defined as log2(SizeofRegion_in_bytes), where the size can be determined from the MPU Region Size Register.

The 8 Sub-Region Disable (SRD) bits allow the 1/8th sub-regions to be disabled individually. The least significant bit affects the 1/8th sub-region with the lowest address range, the most significant bit affects the highest addressed 1/8th sub-region. The sub-region disable bits are UNPREDICTABLE for region sizes of 32, 64, and 128 bytes. For further information on sub-region support, see Sub-region support on page B3-36.

[15:8]R/WSRDFor regions of 256 bytes or larger, the Sub-Region Disable bits are used to disable 1/8 of the region per bit. For any bit that is set, the relevant 1/8 of the region’s address range is disabled with respect to the attribute settings. 

The TEX, S, C and B bits control the device type and cacheability as shown in Table B3-45. Cache information is exported by the core on instruction fetches and data accesses. The information can be used to support system caches on a system bus.

The XN bit provides an eXecute Never capability. Instructions must have read access as defined by the AP bits and XN clear for correct execution, otherwise a MemManage fault is generated when the instruction is issued. 

The MPU Region Base Address Register and the MPU Region Attribute and Size Register form a pair of words in the address range of 0xE000ED9C to 0xE000EDA3. Three aliases of this address range are provided at addresses 0xE000D9C + 8, +16, and +24 as shown in Table B3-37 on page B3-39. Using the register aliases along with the REGION/VALID fields of the MPU Region Base Address Register, software can efficiently update the four regions with a stream of word writes, assuming all the regions accessed are in the range Region0 to Region15.

As previously stated, ARMv7-M only executes instructions in Thumb state. The full list of supported instructions is provided in Alphabetical list of ARMv7-M Thumb instructions on page A6-17. To support reading and writing the special-purpose registers under software control, ARMv7-M provides three system instructions:

f FAULTMASK. Raises the current priority to -1 (the same as HardFault) when it is set to 1. Thisis a 1-bit register, which can only be set by privileged code with a lower priority than -1. The register self-clears on return from any exception other than NMI.

The CPSIE and CPSID instructions are equivalent to using an MSR instruction:
• The  CPSIE i  instruction is equivalent to writing a 0 into PRIMASK
• The  CPSID i  instruction is equivalent to writing a 1 into PRIMASK
• The  CPSIE f  instruction is equivalent to writing a 0 into FAULTMASK
• The  CPSID f  instruction is equivalent to writing a 1 into FAULTMASK.

a.Raises the current priority to 0 when set to 1. This is a 1-bit register.b. Changes the current pre-emption priority mask to a value between 0 and N. 0 means the mask is disabled. The register only has an effect when the value (1 to N) is lower (higher priority) than the non-masked priority level of the executing instruction stream. The register can have up to 8 bits (depending on the number of priorities supported), and it is formatted exactly the same as other priority registers.The register is affected by the PRIGROUP (binary point) field. See Exception priorities and pre-emption on page B1-17 for more details. Only the pre-emption part of the priority is used by BASEPRI for masking.c.When used with the MSR instruction, it performs a conditional write.d. This register raises the current priority to -1 (the same as HardFault) when it is set to 1. This can only be set by privileged code with a priority below -1 (not NMI or HardFault), and self-clears on return from any exception other than NMI. This is a 1-bit register.e.The control register is composed of the following bits:[0] = Thread mode privilege: 0 means privileged, 1 means unprivileged (User). This bit resets to 0. [1] = Current stack pointer: 0 is Main stack (MSP), 1 is alternate stack (PSP if Thread mode, RESERVED if Handler mode). This bit resets to 0.

a.Raises the current priority to 0 when set to 1. This is a 1-bit register.b. Changes the current pre-emption priority mask to a value between 0 and N. 0 means the mask is disabled. The register only has an effect when the value (1 to N) is lower (higher priority) than the non-masked priority level of the executing instruction stream. The register can have up to 8 bits (depending on the number of priorities supported), and it is formatted exactly the same as other priority registers.The register is affected by the PRIGROUP (binary point) field. See Exception priorities and pre-emption on page B1-17 for more details. Only the pre-emption part of the priority is used by BASEPRI for masking.c.When used with the MSR instruction, it performs a conditional write. The BASEPRI value is only updated if the new priority is higher (lower number) than the current BASEPRI value.Zero is a special value for BASEPRI (it means disabled). If BASEPRI is 0, it always accepts the new value. If the new value is 0, it will never accept it. This means BASEPRI_MAX can always enable BASEPRI but never disable it. PRIGROUP has no effect on the values compared or written. All register bits are compared and conditionally written.d. This register raises the current priority to -1 (the same as HardFault) when it is enabled set to 1. This can only be set by privileged code with a priority below -1 (not NMI or HardFault), and self-clears on return from any exception other than NMI. This is a 1-bit register.The CPS instruction can also be used to update the FAULTMASK register.e.The control register is composed of the following bits:[0] = Thread mode privilege: 0 means privileged, 1 means unprivileged (User). This bit resets to 0. [1] = Current stack pointer: 0 is Main stack (MSP), 1 is alternate stack (PSP if Thread mode, RESERVED if Handler mode). This bit resets to 0.

Privilege Writes from unprivileged Thread mode to any stack pointer, the EPSR, the IPSR, the masks, or CONTROL, will be ignored. If privileged Thread mode software writes a 0 into CONTROL[0], the core will switch to unprivileged Thread mode (User) execution, and inhibit further writes to special-purpose registers. An ISB instruction is required to ensure instruction fetch correctness following a Thread mode privileged => unprivileged transition.

Bit positions The PSR bits are positioned in each PSR according to their position in the larger xPSR composite. This is defined in The special-purpose program status registers (xPSR) on page B1-8.

 This chapter covers all aspects of debug with respect to ARMv7-M. It is made up of the following sections:
• Introduction to debug on page C1-2
• The Debug Access Port (DAP) on page C1-4
• Overview of the ARMv7-M debug features on page C1-8
• Debug and reset on page C1-13
• Debug event behavior on page C1-14
• Debug register support in the SCS on page C1-19
• Instrumentation Trace Macrocell (ITM) support on page C1-27
• Data Watchpoint and Trace (DWT) support on page C1-33
• Embedded Trace (ETM) support on page C1-56
• Trace Port Interface Unit (TPIU) on page C1-57
• Flash Patch and Breakpoint (FPB) support on page C1-61.

Debug is normally accessed via the DAP (see The Debug Access Port (DAP) on page C1-4), which allows access to debug resources when the processor is running, halted, or held in reset. When a core is halted, the core is in Debug state.


• High level trace and logging using the Instrumentation Trace Macrocell (ITM). This uses a fixed low-intrusion overhead (non-blocking register writes) which can be added to an RTOS, application or exception handler/ISR. The instructions can be retained in product code avoiding probe effects where necessary.

As well as the Debug Control Block (DCB) within the System Control Space (SCS), other debug related resources are allocated fixed 4kB address regions within the Private Peripheral Bus (PPB) region of the ARMv7-M system address map:


• Flash Patch and Breakpoint (FPB) block. This block can remap sections of ROM (Flash memory) to regions of RAM and set breakpoints on code in ROM. This feature can be used for debug and provision of code and/or data patches to applications where updates or corrections to product ROM(s) are required in the field.


• There is a requirement for writes to the ITM stimulus ports not to cause an exception when the ITM feature is disabled or not present to ensure the feature is transparent to application code, see Theory of operation on page C1-27.


• In addition to the DWT and ITM, a TPIU is needed to export information off-chip for data trace, application trace, and profiling. The protocol used to communicate with an external software agent via the TPIU is described in Appendix E Debug ITM and DWT packet protocol. 


• The TPIU can be a shared resource in a complex debug system, or omitted where visibility of ITM stimuli, or ETM and DWT trace event output is not required. Where the TPIU is a shared resource, it can reside within the PPB memory map and under local processor control, or be an external system resource, controlled from elsewhere.

Debug access is through the Debug Access Port (DAP), an implementation of the ARM Debug Interface v5 Architecture Specification. A JTAG Debug Port (JTAG-DP) or Serial Wire Debug Port (SW-DP) can be used. The DAP specification includes details on how a system can be interrogated to determine what debug resources are available, and how to access any ARMv7-M device(s). A valid ARMv7-M system instantiation includes a ROM table of information as described in Table C1-3. The general format of a ROM table entry is described in Table C1-2.

A debugger can use a DAP interface to interrogate a system for memory access ports (MEM-APs). The BASE register in a memory access port provides the address of the ROM table (or a series of ROM tables within a ROM table hierarchy). The memory access port can then be used to fetch the ROM table entries. See ARM Debug Interface v5 Architecture Specification for more information.

0xFD0IMP DEFPID4CIDx values are fully defined for the ROM table, and are CoreSight compliant.PIDx values should be CoreSight compliant or RAZ.See Appendix B ARMv7-M infrastructure IDs for more information.CoreSight: ARM’s system debug architecture

a.Accesses cannot cause a non-existent memory exception.b. It is IMPLEMENTATION DEFINED whether a shared resource is managed by the local processor or a different resource.c.This location was formerly known as MEMTYPE.


• If using the watchpoint and trace features, set the TRCENA bit in the Debug Exception and Monitor Control Register (DEMCR) – see Debug Exception and Monitor Control Register (DEMCR) on page C1-24.

 System control and configuration fields (in particular registers in the SCB) can be changed via the DAP while software is executing. For example, resources designed for dynamic updates can be modified. This can have undesirable side-effects if both the application and debugger are updating the same or related resources. The consequences of updating a running system via a DAP in this manner have no guarantees, and can be worse than UNPREDICTABLE with respect to system behavior.


• The term set means assigning the value to 1 and the term clear(ed) means assigning the value to 0. Where the term applies to multiple bits, all bits assume the assigned value.

ARMv7-M defines a debug model specifically designed for the profile. The ARMv7-M debug model has control and configuration integrated into the memory map. The Debug Access Port defined in the ARM Debug Interface v5 Architecture Specification provides the interface to a host debugger. Debug resources within ARMv7-M are as listed in Table C1-1 on page C1-3.


• Core halt. Control register support to halt the processor. This can occur asynchronously by assertion of an external signal, execution of a BKPT instruction, or from a debug event (by example configured to occur on reset, or on exit from or entry to an ISR).


• Support of instruction tracing and the ability to add other system debug features such as a bus monitor or cross-trigger facility. ETM instruction trace requires a multiwire Trace Port Interface Unit (TPIU).

 CoreSight is the name given to ARM’s system debug architecture, incorporating a range of debug control, capture and system interface blocks. ARMv7-M does not require CoreSight compliance. The register definitions and address space allocations for the DWT, ITM, TPIU and FPB blocks in this specification are compatible. ARMv7-M allows these blocks to add support for CoreSight topology detection and operation as appropriate by extending them with CoreSight ID and management registers.

For ARMv7-M, the provision of DBGEN and NIDEN as actual signals is IMPLEMENTATION DEFINED. It is acceptable for DBGEN to be considered permanently enabled (DBGEN = HIGH), with control deferred to other enable bits within the profile specific debug architecture.

 ARMv7-M does not support the SPIDEN and SPNIDEN signals. These signals form part of the secure debug authentication scheme as used by ARMv6K with the Security Extensions and the ARMv7-A profile.

The EDBGRQ input is asserted by an external agent to signal an external debug request. An external debug request can cause a debug event and entry to Debug state as described in Debug event behavior on page C1-14. The debug event is reported in the DFSR.EXTERNAL status bit, see Debug Fault Status Register (DFSR) on page C1-19.

When the processor is in Debug state, the HALTED output signal is asserted. HALTED reflects the DHCSR.S_HALT bit, see Debug Halting Control and Status Register (DHCSR) on page C1-20. The signal can be used as a debug acknowledge for EDBGRQ.

It is IMPLEMENTATION DEFINED whether multiprocessing support is provided in the ARMv7-M Debug Extension. An implementation with multiprocessing debug support is required to provide the ability to perform a linked restart of multiple processors. Two signals are required to support the multiprocessing restart mechanism:
• a DBGRESTART input
• a DBGRESTARTED output.

There are three recommended levels of debug provision in ARMv7-M:
• a minimum level that only supports the DebugMonitor exception
• a basic level that requires a DAP and adds some halting debug support 
• a comprehensive level that includes the above with fully-featured ITM, DWT and FPB support.

 There is a requirement for writes to the ITM stimulus ports not to cause an exception when the ITM feature is disabled or not present to ensure the feature is transparent to application code, see Theory of operation on page C1-27.

Software can initiate a system reset as described in Reset management on page B1-47. The reset vector catch control bit (VC_CORERESET) can be used to generate a debug event when the core comes out of reset. A debug event causes the core to halt (enter Debug state) when halting debug is enabled. 


• Entry to Debug state. If halting debug is enabled (C_DEBUGEN in the DHCSR, Table C1-9 on page C1-20, is set), captured events will halt the processor in Debug state. See Table B1-9 on page B1-40 for a comprehensive application level fault table.


• A DebugMonitor exception. If halting debug is disabled (C_DEBUGEN is cleared) and the debug monitor is enabled (MON_EN in the DEMCR, Table C1-12 on page C1-24, is set), a debug event will cause a DebugMonitor exception when the group priority of DebugMonitor is higher than the current active group priority. 

If the DebugMonitor group priority is less than or equal to the current active group priority, a BKPT instruction will escalate to a HardFault and other debug events (watchpoints and external debug requests) are ignored. 


• A HardFault exception. If both halting debug and the monitor are disabled, a BKPT instruction will escalate to a HardFault and other debug events (watchpoints and external debug requests) are ignored.

The Debug Fault Status Register (Table C1-8 on page C1-19) contains status bits for each captured debug event. The bits are write-one-to-clear. These bits are set when a debug event causes the processor to halt or generate an exception. It is IMPLEMENTATION DEFINED whether the bits are updated when an event is ignored.

If DHCSR.C_DEBUGEN  is clear and a breakpoint occurs in an NMI or HardFault exception handler, the system locks up with an unrecoverable error. Handling of unrecoverable exceptions in general is described in Unrecoverable exception cases on page B1-44. The breakpoint can be due to a BKPT instruction or generated by the FPB, see Flash Patch and Breakpoint (FPB) support on page C1-61.

ARMv7-M supports debug stepping in both halting debug and monitor debug. Stepping from Debug state is supported by writing to the C_STEP and C_HALT control bits in the Debug Halt Control and Status Register (see Debug Halting Control and Status Register (DHCSR) on page C1-20 for the control bit definitions). 


• An exception entry sequence occurs that stacks the next instruction context. The processor halts on the first instruction of the exception handler entered according to the exception priority and late-arrival rules. 

—If the executed instruction is an exception return instruction, tail-chaining can cause entry to a new exception handler. The processor halts ready to execute the first instruction of the exception handler taken.

The debugger can optionally set the C_MASKINTS bit in the DHCSR to inhibit (mask) PendSV, Systick and external configurable interrupts from occurring. Where C_MASKINTS is set, permitted exception handlers which activate will execute along with the stepped instruction. See Table C1-6 for a summary of stepping control.

Stepping by a debug monitor is supported by the MON_STEP control bit in the Debug Exception and Monitor Control Register (see Debug Exception and Monitor Control Register (DEMCR) on page C1-24). When MON_STEP is set (with C_DEBUGEN clear), the step request is a Pending request that will activate on return from the DebugMonitor handler to the code being debugged (the debug target code). 


• An exception entry sequence occurs that stacks the next instruction context. The processor halts on the first instruction of the exception handler entered according to the exception priority and late-arrival rules. 

—If the executed instruction is an exception return instruction, tail-chaining can cause entry to a new exception handler. The processor halts ready to execute the first instruction of the exception handler taken.

The debug provision in the System Control Block consists of two handler-related flag bits (ISRPREEMPT and ISRPENDING) in the Interrupt Control and State Register (Interrupt Control and State Register – (0xE000ED04) on page B3-12), and the Debug Fault Status Register (DFSR).

[31:16]WDBGKEYDebug Key. The value 0xA05F must be written to enable write accesses to bits [15:0], otherwise the write access will be ignored. Read behavior of bits [31:16] is as listed below.

[24]RS_RETIRE_STInstruction has completed (retired) since last read. This is a sticky bit, which clears on read. This bit can be used to determine if the core is stalled on a load/store or fetch.

[19]RS_LOCKUPCore is locked up due to an unrecoverable exception. See Unrecoverable exception cases on page B1-44 for details. This bit can only be read as set by a remote debugger (via the DAP) while the core is running and locked up. The bit is cleared on entry to Debug state when the core halts.

[16]RS_REGRDYA handshake flag. The bit is cleared to ’0’ on a write to the Debug Core Register Selector Register and is set to ’1’ when the transfer to/from the Debug Core Register Data Register is complete. Otherwise the bit is UNKNOWN.

The DCRSR write-only register generates a handshake to the core to transfer the selected register to/from the DCRDR. The DHCSR S_REGRDY bit is cleared when the DCRSR is written, and remains clear until the core transaction completes. This register is only accessible from Debug state.

For all other debug events, including PC match watchpoints, the address is that of an instruction which in a simple execution model is one which executes after the instruction which caused the event, but which itself has not executed. All instructions prior to this instruction in the model have executed.

The DCRDR is used with the DCRSR to provide access to the general-purpose and special-purpose registers in the core. The DCRDR is read or written (depending on REGWnR) to/from the selected register (defined by REGSEL) on a write to the DCRSR.

Bits [23:16] are used for DebugMonitor exception control, and bits [15:0] are associated with Debug state (halting debug). All register bits are reset by a power-on reset. Only the DebugMonitor related bits (MONxxx) are cleared on a Local Reset, see Reset behavior on page B1-20 for the definition of Local Reset. 

[24]R/WTRCENAGlobal enable for all features configured and controlled by the DWT and ITM blocks. The bit can be used to gate the ETM and TPIU blocks too. Clearing the bit does not in itself guarantee stopping all events. The feature enables in the DWT and ITM blocks must be cleared before clearing TRCENA to ensure everything is stopped. This bit is cleared on a Power-up reset only. TRCENA is not cleared by a software initiated reset.When TRCENA == ’0’:
• DWT registers return UNKNOWN values on reads. It is IMPLEMENTATION DEFINED whether writes to the DWT unit are ignored.
• ITM registers return UNKNOWN values on reads. It is IMPLEMENTATION DEFINED whether writes to the ITM unit are ignored.If the ITM and DWT blocks are not implemented, TRCENA is RAZ/WI.

[18]R/WMON_STEPWhen MON_EN is set, this bit is used to step the core. When MON_EN is clear, this feature is disabled. This is the debug monitor equivalent of C_STEP in Debug state. MON_STEP is cleared on a Local Reset.

If C_DEBUGEN in the DHCSR is set, at least one VC* enable bit is set in the DEMCR, and the associated exception activates, then a debug event occurs. This causes Debug state to be entered (execution halted) on the first instruction of the exception handler.

 Fault status bits are set on exception entry and are available to the debugger to help determine the source of the error (see Configurable Fault Status Registers (UserFault, BusFault, and MemManage) on page B3-18, HardFault Status register (HFSR) on page B3-21 and Debug Fault Status Register (DFSR) on page C1-19).

A vector catch guarantees to enter Debug state without executing any additional instructions. However, saved context might include information on a lockup situation or a higher priority pending exception, for example a pending NMI exception detected on reset.

a.It is IMPLEMENTATION DEFINED whether an FPB generated breakpoint takes a HardFault or is ignored. An FPB generated breakpoint can only be ignored where the breakpointed instruction exhibits its normal architectural behavior.b. The vector catch (VC prefixed) bits are cleared on a power-up reset. They are not altered by a software initiated reset.

The Instrumentation Trace Macrocell (ITM) provides a memory-mapped register interface to allow applications to write logging/event words to the optional external Trace Port Interface Unit (TPIU). The ITM also supports control and generation of timestamp information packets.

The event words and timestamp information are formed into packets and multiplexed with hardware event packets from the Data Watchpoint and Trace (DWT) block according to the packet protocol described in Appendix E Debug ITM and DWT packet protocol.

The number of Stimulus Port registers is an IMPLEMENTATION DEFINED multiple of eight. Writing all 1s to the Trace Privilege Register then reading how many bits are set can be used to determine the number of Stimulus Ports supported.

The Trace Privilege Register defines whether the associated Stimulus Ports (in groups of 8) and their corresponding Trace Enable Register bits can be written by an unprivileged (User) access. User code can always read the Stimulus Ports. 

Stimulus Port registers are 32-bit registers that support word-aligned (address[1:0] == 0b00) byte (bits [7:0]), halfword (bits [15:0]), or word accesses. Non-word-aligned accesses are UNPREDICTABLE. There is a global enable, ITMENA, in the control register and additional mask bits, which enable the Stimulus Port registers individually, in the Trace Enable Register.

When an enabled Stimulus Port is written to, the identity of the port, the size of the write access, and the data written are copied into a FIFO for emission to a trace sink, such as a TPIU. 

A minimum of a single-entry Stimulus Port output buffer, that is shared by all the Stimulus port registers, must be provided. The size of the output buffer is IMPLEMENTATION DEFINED. When the Stimulus Port output buffer is full, a write to a Stimulus Port is ignored, and an overflow packet is generated.

A Stimulus Port read indicates the output buffer status. The output buffer status reads return “full” when ITMENA or the Stimulus Port’s enable bit is clear (the port is disabled). ITMENA is cleared by a power-on reset.

 To ensure system correctness, a software polling scheme can use exclusive accesses to manage Stimulus Port writes with respect to the Stimulus Port output buffer status. Software must test the status by reading from the Stimulus Port that it intends to write.

All ITM registers can be read by unprivileged (User) and privileged code at all times. Privileged write accesses are ignored unless ITMENA is set. Unprivileged write accesses to the Trace Control and Trace Privilege registers are always ignored. Unprivileged write accesses to the Stimulus Port and Trace Enable registers are allowed or ignored according to the setting in the Trace Privilege Register. Trace Enable registers are byte-wise enabled for user access, according to the Trace Privilege Register setting.

Timestamps provide information on the timing of event generation with respect to their visibility at a trace output port. The timestamp counter size, clock frequency, and whether the timestamp reference clock is synchronous or asynchronous with respect to the core clock are IMPLEMENTATION DEFINED. Timestamp packets are generated within the following constraints:


• Timestamp packet generation is enabled by the TSENA bit in the Trace Control Register (see Trace Control Register – ITM_TCR (0xE0000E80) on page C1-31). Synchronous versus Asynchronous operation is determined by the SWOENA control bit.

The relationship between the timestamp reference clock and an asynchronous TPIU port (see Trace Port Interface Unit (TPIU) on page C1-57) is fixed by the effective lineout clock rate of the asynchronous port, the rate dependent on the output encoding scheme (NRZ or Manchester).


• When asynchronous configuration is selected, the timestamp counter is held in reset (cleared) while the asynchronous interface is idle. This means that a timestamp is not generated on the first packet after idle on an asynchronous interface.


• If the timestamp counter overflows, an overflow packet is generated and a timestamp packet is transmitted at the earliest opportunity (can be a value other than zero if delayed due to higher priority trace packets).

A timestamp packet can be generated and appended to a single event packet, or a stream of back-to-back packets where multiple events generate a packet stream with no idle time. Timestamp status information is merged with the timestamp packets to indicate if the timestamp packet transfer is delayed by the FIFO, or if there is a delay in the associated event packet transfer to the output FIFO. The timestamp count continues until it can be sampled and delivered in a packet to the FIFO.

Timestamp packets are combined with synchronization packets (see below) plus the ITM and Data Watchpoint and Trace (DWT, see Data Watchpoint and Trace (DWT) support on page C1-33) event packets according to the packet protocol prioritization rules described in Multiple Source Arbitration on page AppxE-7.

Synchronization packets are independent of timestamp packets. They are used to recover bit to byte alignment information. The packets are required on synchronous TPIU ports that are dedicated to an ARMv7-M core or in complex systems where multiple trace streams are formatted into a single output. See CoreSight Architecture Specification for more details on synchronization and trace formatting. When enabled, synchronization packets are emitted on a regular basis and can be used as a system heartbeat. Synchronization packets should be disabled on asynchronous TPIU ports.

Synchronization packets are enabled by the SYNCENA bit in the Trace Control Register (see Trace Control Register – ITM_TCR (0xE0000E80) on page C1-31). The frequency of generation (the TPIU output heartbeat) is controlled by the SYNCTAP bitfield in the DWT Control Register (see Control Register (DWT_CTRL) on page C1-48).

[31:0]R/WPRIVMASKBit mask to enable unprivileged (User) access to ITM stimulus ports. Bit [N] of PRIVMASK controls stimulus ports 8N to 8N+7.0: User access allowed to stimulus ports1: Privileged access only to stimulus ports    Unused bits are RAZ/WI.    The register is cleared on Power-up reset.

[9:8]R/WTSPrescaleTimestamp prescaler, used with the trace packet reference clock. The reference clock source is selected by SWOENA. 00: no prescaling01: divide by 410: divide by 1611: divide by 64These bits are cleared on Power-up reset.

The CoreSight compliant TraceBusID field is required in systems supporting multiple trace streams, for example an ARMv7-M core with ETM. This is the ID used to identify the ITM/DWT trace stream. The ID to identify the ETM trace stream is programmed in the ETM traceBusID register (see Embedded Trace macrocell Architecture Specification). To avoid trace stream corruption, the ITM must be disabled (ITMENA clear) and the BUSY bit polled until it is clear (reads zero) before the TraceBusID is modified.

[4]R/WSWOENAEnables asynchronous-specific usage model for timestamps (when TSENA ==1) 0: mode disabled. Timestamp counter uses system clock from    the core and counts continuously.1: Timestamp counter uses lineout (data related) clock from    TPIU interface. The timestamp counter is held in reset    while the output line is idle.

Apart from exception tracing and an external agent PC sampling feature (DWT_PCSR, see Program counter sampling support on page C1-36), DWT functionality is counter or comparator based. Supported features can be determined from the debug ROM table, DEMCR.TRCENA master enable bit and feature availability bits in the DWT_CTRL register, see Debug support in ARMv7-M on page C1-10.

Watchpoint and data trace support use a set of compare, mask and function registers (see Comparator Register (DWT_COMPx) on page C1-53, Mask Register (DWT_MASKx) on page C1-53, and Function Register (DWT_FUNCTIONx) on page C1-54 for details).


• generation of a Hardware Source packet. Packets are generated and combined with other event, control and timestamp packets according to the packet protocol described in Appendix E Debug ITM and DWT packet protocol.

 DWT hardware event packet transmission is enabled in the ITM block (Trace Control Register), which also controls the timestamp support. For timestamp provision, the ITM stimulus ports can be disabled. However, the ITMENA and TSENA in the ITM Trace Control Register must be set to provide a timestamp capability.

Exception tracing is enabled using the EXCTRCENA bit in the DWT_CTRL register. When the bit is set, the DWT emits an exception trace packet under the following conditions:
• exception entry (from Thread mode or pre-emption of thread or handler).
• exception exit when exiting a handler with an EXC_RETURN vector. See Exception return behavior on page B1-25.
• exception return when re-entering a pre-empted thread or handler code sequence.


• bit [24], bit [26] or bit [28], as selected by the SYNCTAP bits in the DWT_CTRL register, is used as an input to the ITM block to generate synchronization packets (see Trace Control Register – ITM_TCR (0xE0000E80) on page C1-31).

When POSTCNT is non-zero, transitions (0 ➝ 1 or 1 ➝ 0) on the tap port selected by CYCTAP cause POSTCNT to decrement. When POSTCNT is zero and the selected tap port transitions, the action which occurs is as described in Table C1-18.


• DWT_CPICNT: the general counter for instruction cycle count estimation. The counter increments on any additional cycles (the first cycle is not counted) required to execute multi-cycle instructions except those recorded by DWT_LSUCNT. The counter also increments on any instruction fetch stalls.


• DWT_SLEEPCNT: the sleep overhead counter. The counter increments on any cycles associated with power saving, initiated by the WFI or WFE instructions, or by use of the SLEEPONEXIT control feature. See Power management on page B1-48 for more details.

All 8-bit counters have separate enable bits in the DWT_CTRL register, and each counter is initialized to zero when it is enabled. The counters wrap when they overflow (every 256th cycle counted), and have counting suppressed when they are disabled. Counter overflow causes an event packet (see Event Packets – Discriminator ID0 on page AppxE-8) to be emitted by the DWT, with the appropriate counter flag(s) set. 

The counters are designed to provide approximately accurate performance count information, but in order to keep the implementation and validation cost low, a reasonable degree of inaccuracy in the counts is acceptable. There is no exact definition of “reasonable degree of inaccuracy”, but the following guidelines should be followed.


• While the counters can be used with halting debug, they are primarily intended for non-intrusive operation. Entry or exit from Debug state can be a source of inaccuracy. Counters will not increment when halted. The overhead associated with STEP and RUN commands from and to the halt condition in Debug state is IMPLEMENTATION DEFINED.


• The intention is that where an instruction is used to enter or exit exceptions and sleep state (for example SVC and WFI), the cycle count associated with the instruction is minimal, with the balance of cycles associated with the exception overhead. The exact division is IMPLEMENTATION DEFINED.

The permissibility of inaccuracy will limit the possible uses of the performance counters. In particular, the point in a pipeline where the performance counter is incremented is not defined relative to the point at which a read of the performance counters is made, so allowing for some imprecision due to pipelining effects. Counter size and the event generation model are designed primarily for non-intrusive operation, where the information is traced, processed and analysed remotely, and not subject to the system overhead of software reads and processing on the core itself.

The DWT Program Counter Sampling Register (DWT_PCSR) is an IMPLEMENTATION DEFINED option in ARMv7-M. The register is defined such that it can be accessed by a debugger without changing the behavior of any code currently executing on the device. This provides a mechanism for coarse-grained non-intrusive profiling of code executing on the core. The DWT_PCSR is a word-accessible read-only register, writes to the register are ignored. Byte or halfword reads are UNPREDICTABLE. When the register is read it returns one of the following:

 There is no architectural definition of recently executed. The delay between an instruction being executed by the core and its address appearing in the DWT_PCSR is not defined. For example, if a piece of code reads the DWT_PCSR of the processor it is running on, there is no guaranteed relationship between the program counter for that piece of code and the value read. The DWT_PCSR is intended for use only by an external agent to provide statistical information for code profiling. Read accesses made to the DWT_PCSR directly by the ARM core can return an UNKNOWN value.

A debug agent should not rely on a return value of 0xFFFFFFFF to indicate that the core is halted. The S_HALT bit in the Debug Halting Control and Status Register should be used for this purpose.

The value read always references a committed instruction, where a committed instruction is defined as an instruction which is both fetched and committed for execution. It is IMPLEMENTATION DEFINED whether instructions that do not pass their condition codes are considered as committed instructions. ARM recommends that these instructions are treated as committed instructions.

An implementation must not sample values that reference instructions that are fetched but not committed for execution. A read access from the DWT_PCSR returns an UNKNOWN value when the TRCENA bit in the Debug Exception and Monitor Control Register is clear. 

For address matching (watchpoint data or instruction address) the input value is masked. The number of input value bits masked (MASK) is defined in DWT MASKx[4:0]. The maximum address mask range supported (up to 2GB) is IMPLEMENTATION DEFINED.

DWT_FUNCTIONx defines the matching conditions and control information for the comparator inputs and what information/action is returned on a match. One of three types of action can be taken on successful matches:


• Return sampled information in a hardware source packet through the ITM - see Hardware Source Packet on page AppxE-6 and DWT packet formats on page AppxE-8. Packets will be generated and transmitted where transmit FIFO space exists, otherwise an overflow packet (see Overflow Packet on page AppxE-3) will be generated where appropriate for each source to indicate packet loss.

Where a multiple match occurs, a HALT or CMPMATCH[N] match action will always be generated. Event packet generation on a multiple match is UNPREDICTABLE. An overflow packet is generated when a DWT event cannot create a DWT packet, because the DWT output buffer is full.

FUNCTION:   bits [3:0]b. The address of the executing instruction or data access.c.Supported on DWT_FUNCTION0 only. For other comparators bit [7] is RAZ/WI.d. Two 4-bit fields providing pointers to 1 or 2 linked address comparators. If LNK1ENA == 0, only LNKADDR0 support is implemented. See LinkAddr() support on page C1-43 for more information.e.See DWT_FUNCTIONx on page C1-54.f.Optional support, otherwise RAZ/WI.g. Word and halfword values are in little endian data format. A halfword value must be replicated in bits [15:0] and bits [31:16]. A byte value must be replicated in all (four) byte lanes.

a.Shortform of DATAVMATCH:CYCMATCH.b.Daddr: data access address match.      Iaddr: instruction address match.c.See LinkAddr() support on page C1-43 for more details. In the LinkAddr() case, the input is Daddr, the data access address.d. This is the matched address of the executing instruction.e.Sampled information is emitted as hardware event packets. See DWT packet formats on page AppxE-8 for packet format information. The behavior of this feature is UNPREDICTABLE if DWT_CTRL.NOTRCPKT == 1.f.PC watchpoints can match on a range of addresses. Breakpoints only match on a specific instruction address.g. DebugMonitor exception or Halt. The address of the next instruction to execute on a halt (DebugReturnAddress() is 

Support of explicit watchpoint read and watchpoint write functionality can be determined by writing the appropriate value to DWT_FUNCTIONx[FUNCTION] and reading back the result. Read-only or write-only watchpoint requests convert to read/write watchpoints where the requested feature is not supported.

c.This is the matched address of the executing instruction. Sampled information is emitted as hardware event packets. See DWT packet formats on page AppxE-8 for packet format information. The behavior of this feature is UNPREDICTABLE if DWT_CTRL.NOTRCPKT == 1.

Support of explicit watchpoint read and watchpoint write functionality can be determined by writing the appropriate value to DWT_FUNCTIONx[FUNCTION] and reading back the result. Read-only or write-only watchpoint requests convert to read/write watchpoints where the requested feature is not supported.

a.For details on data matching see Comparator support - watchpoint data value matching on page C1-45.b. Support of explicit watchpoint read and write functionality is IMPLEMENTATION DEFINED.c.The address of the next instruction to execute on a halt (DebugReturnAddress(), see Table C1-10 on page C1-22 on page page C1-22) is IMPLEMENTATION DEFINED. A halt is imprecise with respect to the instruction which caused it.d. CMPMATCH events are for use external to the DWT block. The behavior of this feature is 

Where LNK1ENA == 1, a single link address can be configured by configuring both to the same link address comparator or disabling one of them by configuring the feature as not used.

Instruction address matching is supported on all comparators. DWT_COMPx must be halfword aligned, and the mask register must be applied by software to the comparator reference value before it is written to DWT_COMPx, otherwise the comparator operation is UNPREDICTABLE.

Where a data value comparator is linked using the LinkAddr() support, an address match occurs if either the first or second linked data address comparator matches. If LinkAddr() is configured as not used, a data value match can occur on any data access.

For data address compares, the implementation must address match all memory accesses, where the range of watched addresses lie between the start address of the transaction and the next word aligned address. It is IMPLEMENTATION DEFINED whether the comparison matches some or all unaligned memory accesses that access a watched location across a word boundary. Data address matching comparator behavior is defined as follows:

Support of data value matching is an architecture option. It is IMPLEMENTATION DEFINED how many of the available comparators support it. Non-zero values of DWT_MASK with data value matching are 

Data value matching generates a match where the data value to be matched is the same as the data access value, or is a partial match where the size of the access is larger than that specified in the DATAVSIZE bit field.

DEFINED whether the data value matching is exact on the data address. If matching is exact, a match is only generated if the data value in DWT_COMPx precisely matches the value in memory at the address specified in the linked address comparator DWT_COMPy. Inexact matches are permitted. The conditions which generate inexact matches are IMPLEMENTATION DEFINED.

For example, if DWT_FUNCTIONx.DATAVSIZE specifies a halfword, and linked address comparator DWT_COMPy specifies a halfword aligned address with DWT_MASKy specifying a 1-bit address mask, then an exact match would match only those accesses made where the halfword location at DWT_COMPy is accessed with the value DWT_COMPx. However, an inexact match can be generated for a word access which accesses either or both bytes of [DWT_COMPy…DWT_COMPy+1], and is such that bits [15:0], bits [23:8] or bits [31:16] of the access value match DWT_COMPx, even if this value is not the value in memory at DWT_COMPy.

[11:10]R/WSYNCTAPUNKNOWNSelects a synchronization packet rate. CYCCNTENA and ITM_TCR.SYNCENA must also be enabled for this feature.00: Disabled. No synchronization packets.01: Tap at CYCCNT bit 2410: Tap at CYCCNT bit 2611: Tap at CYCCNT bit 28Synchronization packets (if enabled) generated on tap transitions (0 to1 or 1 to 0)

[31:0]R/WCYCCNT32-bit, incrementing (up) cycle counter. When enabled, this counter counts the number of core cycles. Counting is suspended when the core is halted in Debug state. The counter is UNKNOWN on reset. 

The counter can be used by applications and debuggers to measure elapsed execution time by taking the difference between sampled start and stop values within the 232 clock tick dynamic range of the counter.

[7:0]R/WCPICNTThe base CPI counter. The counter increments on any additional cycles (the first cycle is not counted) required to execute multi-cycle instructions except those recorded by DWT_LSUCNT. The counter also increments on any instruction fetch stalls. An event is emitted when the counter overflows. 

[7:0]R/WSLEEPCNTSleep counter. This counts the total number of cycles that the processor is sleeping (initiated by WFI, WFE, Sleep on exit). An event is emitted on counter overflow (every 256 cycles).

[7:0]R/WLSUCNTThe load-store count. The counter increments on the additional cycles (the first cycle is not counted) required to execute all load-store instructions.An event is emitted on counter overflow (every 256 cycles).

0000: disabled or LinkAddr() - see LinkAddr() support on page C1-43.For non-zero values:If CYCMATCH clear, see Table C1-20 on page C1-39If CYCMATCH set, see Table C1-21 on page C1-41If DATAVMATCH set, see Table C1-22 on page C1-42

a.See the footnotes in Table C1-24 on page C1-48 for details of comparator matching configurations affecting this bit that are UNPREDICTABLE.b. If DWT_FUNCx.DATAVMATCH == 1 and neither link address is configured all data transactions are tested for a data value match.c.otherwise the bit is ignored.d. Only applies if DWT_CTRL.NOCYCCNT == 0 to indicate cycle counting supported, otherwise the bit is RAZ/WI.e.Only applies if DWT_CTRL.NOTRCPKT == 0, otherwise the bit is RAZ/WI.

ETM is an optional feature in ARMv7-M. Where it is supported, a Trace Port Interface Unit must be provided that is capable of formatting an output packet stream from the ETM and DWT/ITM packet sources. 

An ETM implementation must be compliant with the ETM architecture v3.4 or a later version as defined in the Embedded Trace Macrocell Architecture Specification. The CMPMATCH[N] signals from the DWT block (see Table C1-20 on page C1-39 in Comparator support on page C1-37) are exported and available as control inputs to the ETM block. The associated TPIU implementation should be CoreSight compliant (see the CoreSight Architecture Specification) and align with the TPIU architecture for compatibility with ARM and other CoreSight compatible debug solutions.

TRCENA from the Debug Exception and Monitor Control Register (see Debug Exception and Monitor Control Register (DEMCR) on page C1-24) can be used as an enable signal for the ETM block.

Hardware events from the DWT block and software events from the ITM block are multiplexed with timestamp information into a packet stream. Control and Configuration of the timestamp information and the packet stream is part of the DWT and ITM blocks. It is IMPLEMENTATION DEFINED whether the packets are made visible (requires pins or a trace buffer and access mechanism to be provided) or terminate within the core. Where a trace buffer is implemented, an Embedded Trace Buffer (ETB) solution should be CoreSight Architecture compliant as described in the CoreSight Architecture Specification. 

External visibility requires an implementation to provide a Trace Port Interface Unit (TPIU). The ARMv7-M TPIU programmers’ model includes support for an asynchronous Serial Wire Output (SWO) or a synchronous (single or multi-bit data path) trace port. The combination of the DWT/ITM packet stream and a SWO is known as a Serial Wire Viewer (SWV). 

The minimum TPIU support for ARMv7-M provides an output path for a DWT/ITM generated packet stream of hardware and/or software generated event information. This is known as TPIU support for debug trace with the TPIU operating in pass-through mode.

Synchronous trace ports can be supported in data path widths from 1 to 32 bits. Asynchronous serial ports can be supported in two options:
• A low speed asynchronous mode (NRZ encoding). This operates like a traditional UART.
• A medium-speed asynchronous mode (Manchester encoding).

An implementation can support both synchronous and asynchronous interfaces, the active interface selected by the Selected Pin Protocol Register as defined in Table C1-38 on page C1-59. It is recommended that both synchronous and asynchronous ports are provided for maximum flexibility with external capture devices. The reference clock for the synchronous port is generated internally, while the reference clock for the asynchronous port is generated from the effective lineout clock rate. A prescale counter is defined in the TPIU for the asynchronous port as part of the clock generation scheme for asynchronous operation.

TRCENA from the Debug Exception and Monitor Control register (see Debug Exception and Monitor Control Register (DEMCR) on page C1-24) can be used as an enable signal for the TPIU block.

This has the same format as the Supported Port Sizes Register but only one bit is set (all others must be zero). Writing values with more than one bit set is UNPREDICTABLE. Writes to unsupported bits are 

This register is used to scale the baud rate of the Serial Wire Output. The asynchronous port reference clock is prescaled according to the value of bits [15:0]. When the register is written, the prescale counter is automatically updated (it is IMPLEMENTATION DEFINED whether it is preset and counts down or reset and counts up), affecting the baud-rate of the serial data output immediately.

The number of literal and instruction comparators are IMPLEMENTATION DEFINED and can be read from the FP_CTRL register (see FlashPatch Control Register (FP_CTRL) on page C1-64). The valid combinations of support are:
• no comparator support
• instruction comparator(s) with breakpoint support only
• instruction comparator(s) with breakpoint and remapping support
• a full feature set provided by instruction and literal comparator support. 

The FlashPatch Remap Register is used to program the base address for the remap vectors. Comparator N will remap to address Remap_Base + 4N when configured for remapping and a match occurs. Bit [29] can be used to determine if remapping (instruction or data) is supported, see FlashPatch Remap Register (FP_REMAP) on page C1-64.

The instruction-matching FlashPatch Comparator Registers can be configured to remap the instruction or generate a breakpoint. The literal-matching comparators have fixed functionality, only supporting the remapping feature on data read accesses. Each comparator has its own enable bit which comes into effect when the global enable bit is set.

All comparators match word-aligned addresses (mask out address bits [1:0]) within the Code memory region (1st GB of the memory map), and only operate on read accesses. Data writes never match and will go to the original location.

Instruction matching where remapping is configured will always compare a word and remap a word for instruction issue. When instruction matching is configured to generate a breakpoint event, address matching is  performed on the upper halfword, lower halfword or both halfwords. A halfword match generates a breakpoint event for a 16-bit instruction, and where the halfword match is on at least the first halfword of a 32-bit instruction. A halfword match on only the second halfword of a 32-bit instruction might generate a breakpoint event.

 It is IMPLEMENTATION DEFINED whether breakpoint events are generated when debug is disabled (DHCSR.C_DEBUGEN == 0 and DEMCR.MON_EN == 0). When the breakpoint is not generated, the breakpointed instruction exhibits its normal architectural behavior.


• Where an MPU is enabled, the MPU checking is performed on the original address, and the attributes applied to the remapped location. The remapped address is not checked by the MPU.


• Instruction matches on 32-bit instructions configured as a breakpoint must be configured to match the first halfword or both halfwords of the instruction. It is UNPREDICTABLE whether breakpoint matches on only the address of the second halfword of a 32-bit instruction generate a debug event.

[28:5]R/WREMAPRemap base address in SRAM. The remap base address must be naturally aligned with respect to the number of words required to support (NUM_CODE+NUM_LIT-1) comparators, with a minimum 8-word alignment boundary.

[31:30]R/WREPLACEDefines the behavior when the COMP address is matched:00a: remap to remap address. See FP_REMAP register.01: breakpoint on lower halfword, upper is unaffected10: breakpoint on upper halfword, lower is unaffected11: breakpoint on both lower and upper halfwords.The field is UNKNOWN on reset.

The CPUID scheme used on ARMv7-M aligns with the revised format ARM Architecture CPUID scheme. An architecture variant of 0xF specified in the Main ID Register (see System ID register support in the SCS on page B3-10) indicates the revised format is being used. All ID registers are privileged access only. Privileged writes are ignored, and unprivileged data accesses cause a BusFault error. The appendix is made up of the following sections:

Where attribute fields or specific values apply only to other ARM Architecture profiles, they are marked as N/A (not applicable). All N/A values should be ignored, and the associated feature considered as not present.

N/A Not Applicable. The specific value of this attribute has been assigned within the ARM architecture but does not apply to ARMv7-M. The attribute value definition has been suppressed to minimize confusion.

This register provides some freedom for IMPLEMENTATION DEFINED features to be registered against the CPUID. The field definitions are SUBJECT TO CHANGE, particularly across architecture licensees. Features can migrate over time if they get absorbed into the main architecture.

This section provides background information on the instructions which form the basic instruction set, and some rules about the allocation of instructions to the different attribute fields in the Instruction Set Attribute registers.

These instructions only depend on an "instruction encoding" attribute in the CPUID – i.e. if an instruction encoding is present, all basic instructions that have encodings in that instruction set *must* be present.

The rules about an instruction being basic do not guarantee that it is available in any particular instruction set - for instance, MOV R0,#123456789 is a basic instruction by the rules below, but is not available in any ARM instruction sets to date.

They are basic because they are fundamental to good code generation. In particular, PUSH and POP both have the implied addressing mode FD R13! and are essential for good procedure prologues and epilogues. The other addressing modes listed can make a considerable difference to the code density of structure copy, load and store, and also to their performance on low-end implementations.

Coproc_instrs:
• 0 if no coprocessor support, other than for separately attributed architectures such as CP15 or VFP
• 1 adds generic CDP, LDC, MCR, MRC, STC
• 2 adds generic CDP2, LDC2, MCR2, MRC2, STC2
• 3 adds generic MCRR, MRRC, 
• 4 adds generic MCRR2, MRRC2

ARMv7-M implementations support SCS, FPB, DWT and ITM blocks along with a ROM table as illustrated in Table C1-3 on page C1-4. The CoreSight architecture programmers’ model is defined in [3] with each 4KB register space subdivided into four sections:
• A component ID (offset 0xFF0 to 0xFFF)
• A peripheral ID (offset 0xFD0 to 0xFEF)
• CoreSight management registers (offset 0xF00 to 0xFCF)
• Device specific registers (offset 0x000 to 0xEFF)

For ARMv7-M, the component ID registers are required for the ROM table, and the CoreSight management lock access mechanism is defined for the DWT, ITM, FPB and TPIU blocks. Otherwise all ID and management registers are reserved, with the recommendation that they are CoreSight compliant or RAZ to encourage commonality of support across debug toolchains.

 The lock mechanism only applies to software access from the core to the affected block. DAP access is always allowed, meaning the lock status register must RAZ from the DAP. 

To determine the topology of the ARMv7-M debug infrastructure, ROM table entries indicate whether a block is present. Presence of a block guarantees support of the ARMv7-M programming requirements for DWT, ITM, FPB and TPIU. Additional functionality requires additional support, where CoreSight is the recommended framework.

ARM recommends that all reserved space is CoreSight compliant or RAZ. See the programmers’ model in the CoreSight Architecture Specification for a complete CoreSight management register list and register format details.

The following table shows the pre-UAL assembly syntax used for Thumb instructions before the introduction of Thumb-2 technology and the equivalent UAL syntax for each instruction. It can be used to translate correctly-assembling pre-UAL Thumb assembler code into UAL assembler code.

In this table, 3-operand forms of the equivalent UAL syntax are used, except in one case where a 2-operand form needs to be used to ensure that the same instruction encoding is selected by a UAL assembler as was selected by a pre-UAL Thumb assembler.

Some features of the Thumb instruction set are deprecated in ARMv7. Deprecated features affecting instructions supported by ARMv7-M are as follows:
• use of the PC as <Rd> or <Rm> in a 16-bit ADD (SP plus register) instruction
• use of the SP as <Rm> in a 16-bit ADD (SP plus register) instruction
• use of the SP as <Rm> in a 16-bit CMP (register) instruction
• use of MOV (register) instructions in which both <Rd> and <Rm> are the SP or PC.
• use of <Rn> as the lowest-numbered register in the register list of a 16-bit STM instruction with base register writeback

The DWT emits packets when a data trace event triggers, PC sampling occurs, or one of the profile counters wraps. The packet protocol used is described in this appendix. This appendix consists of the following sections:

Apart from synchronization, the maximum packet size is five bytes. A maximum of four continuation bits can be set within a packet. Packets with five or more continuation bits set are UNPREDICTABLE.

All packets are transmitted over a serial port least significant bit (LSB) first. Where bytes are illustrated in the following subsections, the figure convention is to indicate the most significant bit (MSB) to the left, and the LSB to the right.

Sync packets are unique patterns in the bit-stream that allow capture hardware to identify bit-to-byte alignment. While Sync packets can be emitted on an asynchronous interface, they are only necessary on a synchronous port. See the CoreSight Architecture Specification for more information. A sync packet is at least forty-seven 1’b0 followed by one 1’b1. Any page event register (see Software Instrumentation Packet on page AppxE-5) is cleared when a sync packet is generated.

Overflow packets are generated under the following conditions:
• a Stimulus Port register write when the Stimulus port  output buffer is full
• timestamp counter overflow
• DWT (Hardware Source) packet generation when the DWT output buffer is full.

Time stamp packets encode timestamp information, generic control and synchronization. The compression scheme uses delta timestamps, where the timestamp value represents the interval since the previous timestamp packet value was output.  Each time a timestamp packet is output, the timestamp counter is cleared to zero. 

1 The timestamp value emitted is delayed with respect to the event data. The value in the TS[] field is the timestamp counter value at the time the timestamp packet is generated. 

2 The emission of the ITM/DWT packet that is associated with this timestamp packet was delayed with respect to the event. The value in the TS[] field is the timestamp counter value at the time the ITM/DWT packet(s) is/are generated. 

3 The associated ITM/DWT packet is delayed with respect to the event and this timestamp packet is delayed with respect to the event packet. This is a combination of the events indicated by values 1 and 2. 

 If the trace system is fully utilized by higher priority trace data, then timestamp packets might be lost. This can result in a block (or blocks) of ITM/DWT data that do not have any timestamp information available. Timing information is then uncertain until the next timestamp packet is output.

The TS[2:0] field is interpreted as follows:0 See Sync Packet on page AppxE-3.1 to 6 The timestamp value is emitted synchronously to ITM/DWT data. The value in the TS[] field is the timestamp counter value at the time the ITM/DWT packet(s) is/are generated.7 See Overflow Packet on page AppxE-3.

Trace packets are generated from three sources – ITM derived software events, timestamps (TS) and DWT derived hardware events. When multiple sources are trying to emit data, arbitration is performed in accordance with the following priority assignments. 

DWT generated packets adopt the general Hardware Source packet format defined in Hardware Source Packet on page AppxE-6. No extension packets are defined for ARMv7-M, all packets reside in the primary A[4:0] packet ID address space.

An event packet contains a set of bits to show which event counters have overflowed (wrapped). The packet is emitted when a counter overflows. Typically a single counter will overflow, however combinations of counter overflow can occur causing multiple bits to be set. The event counters each have an enable bit in the DWT_CTRL register. The event packet format is shown below:

An Interrupt trace packet is emitted whenever an exception is entered, exited (returned-from), and returned-to. The packet contains the exception number (see Exception number definition on page B1-16) and an indicator of which action it is (A). Exception tracing is enabled using the EXCTRCENA bit.

PC samples are emitted at fixed time intervals (accurate to a clock cycle). The rate per second can be configured using the CYCTAP control field and the POSTCNT counter in DWT_CTRL (see Control Register (DWT_CTRL) on page C1-48). PC Sampling is enabled using PCSAMPLENA. Each sample contains the PC address or a sleep marker (if the processor is asleep).

Data trace packets are emitted when a data trace directive as specified in the DWT_FUNCTIONx registers requires sampled data to be captured on a comparator match. For information on the comparator support, and the directives that generate data trace packets, see Table C1-20 on page C1-39 and Table C1-21 on page C1-41.

While Thumb-2 technology is common across all the ARMv7 profiles, there are other key similarities between the ARMv7-M and ARMv7-R profiles. By understanding the similarities and differences, it is possible to minimize the effort in supporting software on both profiles, or to generate a system architecture allowing straightforward migration from one profile to the other.

ARMv7-R supports instruction fetches in big and little endian formats, using the IE bit in the ARMv7-R System Control register. ARMv7-M only supports instruction fetches in little endian format. Where a big endian instruction format is required with ARMv7-M, byte swapping within a halfword is required in the bus fabric. The byte swap is required for instruction fetches only and must not occur on data accesses. 

A configurable endian model (see Endian support on page A3-5) is supported by both ARMv7-M and ARMv7-R. While ARMv7-R supports dynamic endian control via a control bit in its xPSR and System Control register EE bit, ARMv7-M is statically configured on reset. 

At the application level, ARMv7-M can be considered as a subset of ARMv7-R. All the ARMv7-M application level instructions are supported in ARMv7-R, along with the same flag and general purpose register support. However, the LDM and STM instructions are always restartable in ARMv7-R and do not support the continuation (xPSR ICI bits) feature. Privileged access execution will expose the system level differences.


• ARMv7-R supports banked registers and a modal system with fixed entry points (addresses) for exception handling. Control and configuration is through the System Coprocessor interface. Stacking and unstacking is under software control.


• ARMv7-M only banks the stack pointer. It uses a combination of special-purpose registers and memory mapped resources for system configuration and execution management. Auto-stacking/unstacking on exception entry and exit is a key difference from ARMv7-R.

System level instruction support is different, reflecting the different programmers’ models. CPS, MRS and MSR are common instructions, but execute differently. There are additional system level instructions in ARMv7-R, for example SRS and RFE. WFE and WFI behavior differs too due to the exception model differences.

Both profiles support the Protected Memory System Architecture (PMSAv7), offering the same features sets where implemented. The register access mechanisms are different, however, the register layouts are generally the same with the notable exception of fault handling. Fault handling differences are due to the different exception models. When PMSAv7 is not supported or is disabled, both profiles have a default memory map. The default memory maps offer similar breakdown of memory with different attributes, but the maps are not identical.

Interrupt control is an integral part of the ARMv7-M exception model. While not part of the ARMv7-R architecture, ARM’s General Interrupt Controller (GIC) offers a common prioritization and interrupt handling model to ARMv7-M. Use of a GIC with an ARMv7-R processor mitigates many of the exception model differences. 

Both profiles logically support halting and monitor debug. The mechanisms for breakpoint and watchpoint handling are different. There are also different degrees of counter support for profiling. Both support an optional trace (ETM) feature. ARMv7-M is generally less invasive in its debug support, and offers additional software and hardware event generation trace capabilities as part of the basic architecture.

This appendix provides a formal definition of the pseudocode used in this book, and lists the helper procedures and functions used by pseudocode to perform useful architecture-specific jobs. It contains the following sections:
• Instruction encoding diagrams and pseudocode on page AppxG-2
• Data Types on page AppxG-5
• Expressions on page AppxG-9
• Operators and built-in functions on page AppxG-11
• Statements and program structure on page AppxG-17
• Miscellaneous helper procedures and functions on page AppxG-22.


• An Encoding section, containing one or more encoding diagrams, each followed by some encoding-specific pseudocode that translates the fields of the encoding into inputs for the common pseudocode of the instruction, and picks out any encoding-specific special cases.


• An Operation section, containing common pseudocode that applies to all of the encodings being described. The Operation section pseudocode contains a call to the EncodingSpecificOperations() function, either at its start or after only a condition check performed by if ConditionPassed() then.

In a few cases, the encoding diagram contains more than one bit or field with the same name. When this occurs, the values of all of those bits or fields are expected to be identical, and the encoding-specific pseudocode contains a special case using the Consistent() function to specify what happens if this is not the case. This function returns TRUE if all instruction bits or fields with the same name as its argument have the same value, and FALSE otherwise.

If there are multiple matching encoding diagrams, all but one of the corresponding pieces of pseudocode must contain a special case that indicates that it does not apply. Discard the results of all such pieces of pseudocode and their corresponding encoding diagrams.

There is now one remaining piece of pseudocode and its corresponding encoding diagram left to consider. This pseudocode might also contain a special case (most commonly one indicating that it is UNPREDICTABLE). If so, abandon this execution model and treat the instruction according to the special case.

The pseudocode descriptions of instruction functionality have a number of limitations. These are mainly due to the fact that, for clarity and brevity, the pseudocode is a sequential and mostly deterministic language.


• Pseudocode does not describe the ordering requirements when an instruction generates multiple memory accesses. For a description of the ordering requirements on memory accesses see Memory access order on page A3-30.

The type of a constant is determined by its syntax. The type of a variable is normally determined by assignment to the variable, with the variable being implicitly declared to be of the same type as whatever is assigned to it. For example, the assignments x = 1, y = '1', and z = TRUE implicitly declare the variables 

Variables can also have their types declared explicitly by preceding the variable name with the name of the type. This is most often done in function definitions for the arguments and the result of the function.

Bitstring constants are written as a single quotation mark, followed by the string of 0s and 1s, followed by another single quotation mark. For example, the two constants of type bit are '0' and '1'. Spaces can be included in the bitstring for clarity.

Every bitstring value has a left-to-right order, with the bits being numbered in standard little-endian order. That is, the leftmost bit of a bitstring of length N is bit N-1 and its rightmost bit is bit 0. This order is used as the most-significant-to-least-significant bit order in conversions to and from integers. For bitstring constants and bitstrings derived from encoding diagrams, this order matches the way they are printed.

Bitstrings are the only concrete data type in pseudocode, in the sense that they correspond directly to the contents of registers, memory locations, instructions, and so on. All of the remaining data types are abstract.

Pseudocode integers are unbounded in size and can be either positive or negative. That is, they are mathematical integers rather than what computer languages and architectures commonly call integers. Computer integers are represented in pseudocode as bitstrings of the appropriate length, associated with suitable functions to interpret those bitstrings as integers.

Integer constants are normally written in decimal, such as 0, 15, -1234. They can also be written in C-style hexadecimal, such as 0x55 or 0x80000000. Hexadecimal integer constants are treated as positive unless they have a preceding minus sign. For example, 0x80000000 is the integer +231. If -231 needs to be written in hexadecimal, it should be written as -0x80000000.

Pseudocode reals are unbounded in size and precision. That is, they are mathematical real numbers, not computer floating-point numbers. Computer floating-point numbers are represented in pseudocode as bitstrings of the appropriate length, associated with suitable functions to interpret those bitstrings as reals.

Enumerations must be declared explicitly, though a variable of an enumeration type can be declared implicitly as usual by assigning one of the symbolic constants to it. By convention, each of the symbolic constants starts with the name of the enumeration followed by an underscore. The name of the enumeration is its type name, and the symbolic constants are its possible constants.

Lists are often used as the return type for a function that returns multiple results. For example, this particular list is the return type of the function Shift_C() that performs a standard ARM shift or rotation, when its first operand is of type bits(32).

Each combination of data types in a list is a separate type, with type name given by just listing the data types (that is, (bits(32),bit) in the above example). The general principle that types can be declared by assignment extends to the types of the individual list items within a list. For example:

the elements of the resulting list can then be referred to as "abc.shift" and "abc.amount". This sort of qualified naming of list elements is only permitted for variables that have been explicitly declared, not for those that have been declared by assignment only.

ShiftSpec and (bits(2),integer) are two different names for the same type, not the names of two different types. In order to avoid ambiguity in references to list elements, it is an error to declare a list variable multiple times using different names of its type or to qualify it with list element names not associated with the name by which it was declared.

Arrays are always explicitly declared, and there is no notation for a constant array. Arrays always contain at least one element, because enumerations always contain at least one symbolic constant and integer ranges always contain at least one integer.

Arrays do not usually appear directly in pseudocode. The items that syntactically look like arrays in pseudocode are usually array-like functions such as R[i], MemU[address,size] or Element[i,type]. These functions package up and abstract additional operations normally performed on accesses to the underlying arrays, such as register banking, memory protection, endian-dependent byte ordering, exclusive-access housekeeping and vector element processing.

An expression is one of the following:
• a constant
• a variable, optionally preceded by a data type name to declare its type
• the word UNKNOWN preceded by a data type name to declare its type
• the result of applying a language-defined operator to other expressions
• the result of applying a function to other expressions.

Each register described in the text is to be regarded as declaring a correspondingly named bitstring variable, and that variable has the stated behavior of the register. For example, if a bit of a register is stated to read as 0 and ignore writes, then the corresponding bit of its variable reads as 0 and ignore writes.

An expression like "bits(32) UNKNOWN" indicates that the result of the expression is a value of the given type, but the architecture does not specify what value it is and software must not rely on such values. The value produced must not constitute a security hole and must not be promoted as providing any useful information to software. (This was called an UNPREDICTABLE value in previous ARM Architecture documentation. It is related to but not the same as UNPREDICTABLE, which says that the entire architectural state becomes similarly unspecified.)


• The results of applying some operators to other expressions. The description of each language-defined operator that can generate an assignable expression specifies the circumstances under which it does so. (For example, those circumstances might include one or more of the expressions the operator operates on themselves being assignable expressions.)

It is a pseudocode error if none of these data type sources exists for a variable, or if more than one of them exists and they do not agree about the type.

Operators and functions in pseudocode can be polymorphic, producing different functionality when applied to different data types. Each of the resulting forms of an operator or function has a different prototype definition. For example, the operator + has forms that act on various combinations of integers, reals and bitstrings.

Any two values x and y of the same type can be tested for equality by the expression x == y and for non-equality by the expression x != y. In both cases, the result is of type boolean.

A special form of comparison with a bitstring constant that includes 'x' bits as well as '0' and '1' bits is permitted. The bits corresponding to the 'x' bits are ignored in determining the result of the comparison. For example, if opcode is a 4-bit bitstring, opcode == '1x0x' is equivalent to opcode<3> == '1' && opcode<1> 

If x and y are two values of the same type and t is a value of type boolean, then if t then x else y is an expression of the same type as x and y that produces x if t is TRUE and y if t is FALSE.

If x and y are booleans, then x && y is the result of ANDing them together. As in the C language, if x is FALSE, the result is determined to be FALSE without evaluating y.

If x and y are booleans, then x || y is the result of ORing them together. As in the C language, if x is TRUE, the result is determined to be TRUE without evaluating y.

If x is a bitstring and n is an integer with n > 0, Replicate(x,n) is the bitstring of length n*Len(x) consisting of n copies of x concatenated together and:
• Zeros(n) = Replicate(’0’,n)
• Ones(n) = Replicate(’1’,n)

x<integer_list>, where x is the integer or bitstring being extracted from, and <integer_list> is a list of integers enclosed in angle brackets rather than the usual parentheses. The length of the resulting bitstring is equal to the number of integers in <integer_list>.

In <integer_list>, the notation i:j with i >= j is shorthand for the integers in order from i down to j, both ends inclusive. For example, instr<31:28> is shorthand for instr<31,30,29,28>.

The expression x<integer_list> is assignable provided x is an assignable bitstring and no integer appears more than once in <integer_list>. In particular, x<i> is assignable if x is an assignable bitstring and 0 <= i 

Encoding diagrams for registers frequently show named bits or multi-bit fields. For example, the encoding diagram for the APSR shows its bit<31> as N. In such cases, the syntax APSR.N is used as a more readable synonym for APSR<31>.

If x and y are bitstrings of the same length, x AND y, x OR y, and x EOR y are the bitstrings of that same length obtained by logically ANDing, ORing, and exclusive-ORing corresponding bits of x and y together.

If x is a bitstring, IsZero(x) produces TRUE if all of the bits of x are zeros and FALSE if any of them are ones, and IsZeroBit(x) produces '1' if all of the bits of x are zeros and '0' if any of them are ones. IsOnes(x) and IsOnesBit(x) work in the corresponding way. So:


• CountLeadingSignBits(x) = CountLeadingZeroBits(x<N-1:1> EOR x<N-2:0>) is the number of copies of the sign bit of x at the left end of x, excluding the sign bit itself, and is in the range 0 to N-1.

If x is a bitstring and i is an integer, then ZeroExtend(x,i) is x extended to a length of i bits, by adding sufficient zero bits to its left. That is, if i == Len(x), then ZeroExtend(x,i) = x, and if i > Len(x), then:

If x is a bitstring and i is an integer, then SignExtend(x,i) is x extended to a length of i bits, by adding sufficient copies of its leftmost bit to its left. That is, if i == Len(x), then SignExtend(x,i) = x, and if i > 

Most pseudocode arithmetic is performed on integer or real values, with operands being obtained by conversions from bitstrings and results converted back to bitstrings afterwards. As these data types are the unbounded mathematical types, no issues arise about overflow or similar errors.

If x is an integer or real, then +x is x unchanged, -x is x with its sign reversed, and ABS(x) is the absolute value of x. All three are of the same type as x.

If x and y are integers or reals, x+y and x-y are their sum and difference. Both are of type integer if x and y are both of type integer, and real otherwise.

If x and y are bitstrings of the same length N = Len(x) = Len(y), then x+y and x-y are the least significant N bits of the results of converting them to integers and adding or subtracting them. Signed and unsigned conversions produce the same result:

If x and y are integers or reals, then x == y, x != y, x < y, x <= y, x > y, and x >= y are equal, not equal, less than, less than or equal, greater than, and greater than or equal comparisons between them, producing boolean results. In the case of == and !=, this extends the generic definition applying to any two values of the same type to also act between integers and reals. 

If x and y are integers or reals, then x * y is the product of x and y, of type integer if both x and y are of type 

Align(x,y) is only used with y a constant power of two, and the bitstring form used with y = 2^n has the effect of producing its argument with its n low-order bits forced to zero.

If x and y are integers or reals, then Max(x,y) and Min(x,y) are their maximum and minimum respectively. Both are of type integer if both x and y are of type integer and of type real otherwise.

indicates a special case that replaces the behavior defined by the current pseudocode (apart from behavior required to determine that the special case applies). The replacement behavior is that the Undefined Instruction exception is taken.

indicates a special case that replaces the behavior defined by the current pseudocode (apart from behavior required to determine that the special case applies). The replacement behavior is not architecturally defined and must not be relied upon by software. It must not constitute a security hole or halt or hang the system, and must not be promoted as providing any useful information to software.

indicates a special case that replaces the behavior defined by the current pseudocode (apart from behavior required to determine that the special case applies). The replacement behavior is that nothing occurs as a result of the current pseudocode because some other piece of pseudocode defines the required behavior. The 

where <constant values> consists of one or more constant values of the same type as <expression>, separated by commas. Abbreviated one line forms of when and otherwise parts can be used when they contain only simple statements.

The functions described in this section are not part of the pseudocode specification. They are helper procedures and functions used by pseudocode to perform useful architecture-specific jobs. Each has a brief description and a pseudocode prototype. Some have had a pseudocode definition added.

This appendix provides an index to pseudocode operators and functions that occur elsewhere in the document. It contains the following sections:
• Pseudocode operators and keywords on page AppxH-2
• Pseudocode functions and procedures on page AppxH-5.

This appendix provides an index to the descriptions of the ARM registers (core and memory mapped) in the document. It contains the following sections:
• ARM core registers on page AppxI-2
• Memory mapped system registers on page AppxI-3
• Memory mapped debug registers on page AppxI-5

Table I-2 provides an index to the main descriptions of the memory mapped system control registers defined in ARMv7-M. The registers are listed in the order they are described in this manual.

Table I-3 provides an index to the main descriptions of the memory mapped debug registers defined in the ARMv7-M Debug Extension. The registers are listed in the order they are described in this manual.

AlignedRefers to data items stored in such a way that their address is divisible by the highest power of 2 that divides their size. Aligned halfwords, words and doublewords therefore have addresses that are divisible by 2, 4 and 8 respectively.

Application Program Status RegisterThe register containing those bits that deliver status information about the results of instructions, the N, Z, C, and V bits of the xPSR. See The special-purpose program status registers (xPSR) on page B1-8.

Atomicity Is a term that describes either single-copy atomicity or multi-copy atomicity. The forms of atomicity used in the ARM architecture are defined in Atomicity in the ARM architecture on page A3-20.

Base registerIs a register specified by a load/store instruction that is used as the base value for the instruction's address calculation. Depending on the instruction and its addressing mode, an offset can be added to or subtracted from the base register value to form the virtual address that is sent to memory.

A non-blocking operation can permit following instructions to be executed before the operation is completed, and in the event of encountering an exception do not signal an exception to the core. This enables implementations to retire following instructions while the non-blocking operation is executing, without the need to retain precise processor state.

Branch predictionIs where a processor chooses a future execution path to prefetch along (see Prefetching). For example, after a branch instruction, the processor can choose to prefetch either the instruction following the branch or the instruction at the branch target. 

BreakpointIs a debug event triggered by the execution of a particular instruction, specified in terms of the address of the instruction and/or the state of the processor when the instruction is executed.

CacheIs a block of high-speed memory locations whose addresses are changed automatically in response to which memory locations the processor is accessing, and whose purpose is to increase the average speed of a memory access.

Cache contentionIs when the number of frequently-used memory cache lines that use a particular cache set exceeds the set-associativity of the cache. In this case, main memory activity goes up and performance drops.

Cache lineIs the basic unit of storage in a cache. Its size is always a power of two (usually 4 or 8 words), and must be aligned to a suitable memory boundary. A memory cache line is a block of memory locations with the same size and alignment as a cache line. Memory cache lines are sometimes loosely just called cache lines.

Callee-save registersAre registers that a called procedure must preserve. To preserve a callee-save register, the called procedure would normally either not use the register at all, or store the register to the stack during procedure entry and re-load it from the stack during procedure exit.

Context switchIs the saving and restoring of computational state when switching between different threads or processes. In this manual, the term context switch is used to describe any situations where the context is switched by an operating system and might or might not include changes to the address space.

Digital signal processing (DSP)Refers to a variety of algorithms that are used to process signals that have been sampled and converted to digital form. Saturated arithmetic is often used in such algorithms.

Do-not-modify fields (DNM)Means the value must not be altered by software. DNM fields read as UNKNOWN values, and can only be written with the same value read from the same field on the same processor.

Explicit accessA read from memory, or a write to memory, generated by a load or store instruction executed in the CPU. Reads and writes generated by L1 DMA accesses or hardware translation table accesses are not explicit accesses.

General-purpose registerIs one of the 32-bit general-purpose integer registers, R0 to R15. Note that R15 holds the Program Counter, and there are often limitations on its use that do not apply to R0 to R14.

Immediate values Are values that are encoded directly in the instruction and used as numeric data when the instruction is executed. Many ARM and Thumb instructions permit small numeric values to be encoded as immediate values in the instruction that operates on them.

Index registerIs a register specified in some load/store instructions. The value of this register is used as an offset to be added to or subtracted from the base register value to form the address that is sent to memory. Some addressing modes optionally permit the index register value to be shifted before the addition or subtraction.

Inline literalsThese are constant addresses and other data items held in the same area as the code itself. They are automatically generated by compilers, and can also appear in assembler code.

Interrupt Program Status RegisterThe register that provides status information on whether an application thread or exception handler is currently executing on the processor. If an exception handler is executing, the register provides information on the exception type. The register is part of the xPSR. See The special-purpose program status registers (xPSR) on page B1-8.

IT blockAn IT block is a block of up to four instructions following an If-Then (IT) instruction. Each instruction in the block is conditional. The conditions for the instructions are either all the same, or some can be the inverse of others. See IT on page A6-78 for additional information.

Memory coherencyIs the problem of ensuring that when a memory location is read (either by a data read or an instruction fetch), the value actually obtained is always the value that was most recently written to the location. This can be difficult when there are multiple possible physical locations, such as main memory, a write buffer and/or cache(s).

Memory hintA memory hint instruction allows you to provide advance information to memory systems about future memory accesses, without actually loading or storing any data to or from the register file. PLD and PLI are the only memory hint instructions defined in ARMv7-M.

Post-indexed addressingMeans that the memory address is the base register value, but an offset is added to or subtracted from the base register value and the result is written back to the base register.

Privileged accessMemory systems typically check memory accesses from privileged modes against supervisor access permissions rather than the more restrictive user access permissions. The use of some instructions is also restricted to privileged modes.

Pseudo-instructionUAL assembler syntax that assembles to an instruction encoding that is expected to disassemble to a different assembler syntax, and is described in this manual under that other syntax. For example, 

R/W1Cregister bits marked R/W1C can be read normally and support write-one-to-clear. A read then write of the result back to the register will clear all bits set. R/W1C protects against read-modify-write errors occurring on bits set between reading the register and writing the value back (since they are written as zero, they will not be cleared).

Saturated arithmetic Is integer arithmetic in which a result that would be greater than the largest representable number is set to the largest representable number, and a result that would be less than the smallest representable number is set to the smallest representable number. Signed saturated arithmetic is often used in DSP algorithms. It contrasts with the normal signed integer arithmetic used in ARM processors, in which overflowing results wrap around from +231–1 to –231 or vice versa.

SetRelates to registers or register fields. Indicates the bit has a value of 1 (or bit field all 1s), or is being written with 1 or all 1s, unless explicitly stated otherwise.

Self-modifying codeIs code that writes one or more instructions to memory and then executes them. This type of code cannot be relied on without the use of barrier instructions to ensure synchronization.

Should-Be-One-or-Preserved fields (SBOP)Should be written as 1 (or all 1s for a bit field) by software if the value is being written without having been previously read, or if the register has not been initialized. Where the register was previously read, the value in the field should be preserved by writing the same value that has been previously read from the same field on the same processor.

If a value is written to the field that is neither 1 (or all 1s for a bit field), nor a value previously read for the same field on the same processor, the result is UNPREDICTABLE.

Should-Be-Zero-or-Preserved fields (SBZP)Should be written as 0 (or all 0s for a bit field) by software if the value is being written without having been previously read, or if the register has not been initialized. Where the register was previously read, the value in the field should be preserved by writing the same value that has been previously read from the same field on the same processor.

If a value is written to the field that is neither 0 (or all 0s for a bit field), nor a value previously read for the same field on the same processor, the result is UNPREDICTABLE.

Spatial localityIs the observed effect that after a program has accessed a memory location, it is likely to also access nearby memory locations in the near future. Caches with multi-word cache lines exploit this effect to improve performance.

SUBARCHITECTURE DEFINEDMeans that the behavior is expected to be specified by a subarchitecture definition. Typically, this will be shared by multiple implementations, but it must only be relied on by specified types of code. This minimizes the software changes required when a new subarchitecture has to be developed.

Temporal localityIs the observed effect that after a program has accesses a memory location, it is likely to access the same memory location again in the near future. Caches exploit this effect to improve performance. 

UnallocatedExcept where otherwise stated, an instruction encoding is unallocated if the architecture does not assign a specific function to the entire bit pattern of the instruction, but instead describes it as UNDEFINED, 

Unindexed addressingMeans addressing in which the base register value is used directly as the address to send to memory, without adding or subtracting an offset. In most types of load/store instruction, unindexed addressing is performed by using offset addressing with an immediate offset of 0. The LDC, LDC2, STC, and STC2 instructions have an explicit unindexed addressing mode that permits the offset field in the instruction to be used to specify additional coprocessor options.

UNKNOWNAn UNKNOWN value does not contain valid data, and can vary from moment to moment, instruction to instruction, and implementation to implementation. An UNKNOWN value must not be a security hole. 

WYSIWYGWhat You See Is What You Get, an acronym for describing predictable behavior of the output generated. Display to printed form and software source to executable code are examples of common use.

xPSRIs the term used to describe the combination of the APSR, EPSR and IPSR into a single 32-bit Program Status Register. See The special-purpose program status registers (xPSR) on page B1-8.
The Cortex-M3 processor is built on a high-performance processor core, with a 3-stage pipeline Harvard architecture, making it ideal for demanding embedded applications. The processor delivers exceptional power efficiency through an efficient instruction set and extensively optimized design, providing high-end processing hardware including single-cycle 32x32 multiplication and dedicated hardware division.

To facilitate the design of cost-sensitive devices, the Cortex-M3 processor implements tightly-coupled system components that reduce processor area while significantly improving interrupt handling and system debug capabilities. The Cortex-M3 processor implements a version of the Thumb® instruction set, ensuring high code density and reduced program memory requirements. The Cortex-M3 instruction set provides the exceptional performance expected of a modern 32-bit architecture, with the high code density of 8-bit and 16-bit microcontrollers.

The Cortex-M3 processor closely integrates a configurable nested interrupt controller (NVIC), to deliver industry-leading interrupt performance. The NVIC includes a non-maskable interrupt (NMI), and provides up to 256 interrupt priority levels. The tight integration of the processor core and NVIC provides fast execution of interrupt service routines (ISRs), dramatically reducing the interrupt latency. This is achieved through the hardware stacking of registers, and the ability to suspend load-multiple and store-multiple operations. Interrupt handlers do not require any assembler stubs, removing any code overhead from the ISRs. Tail-chaining optimization also significantly reduces the overhead when switching from one ISR to another.

® technology to provide high speed, low latency memory accesses. It supports unaligned data accesses and implements atomic bit manipulation that enables faster peripheral controls, system spinlocks and thread-safe Boolean data handling.

The Cortex-M3 processor implements a complete hardware debug solution. This provides high system visibility of the processor and memory through either a traditional JTAG port or a 2-pin Serial Wire Debug (SWD) port that is ideal for small package devices. 

For system trace the processor integrates an Instrumentation Trace Macrocell (ITM) alongside data watchpoints and a profiling unit. To enable simple and cost-effective profiling of the system events these generate, a Serial Wire Viewer (SWV) can export a stream of software-generated messages, data trace, and profiling information through a single pin.

Only privileged software can write to the CONTROL register to change the privilege level for software execution in Thread mode. Unprivileged software can use the SVC instruction to make a supervisor call to transfer control to privileged software.

The processor uses a full descending stack. This means the stack pointer indicates the last stacked item on the stack memory. When the processor pushes a new item onto the stack, it decrements the stack pointer and then writes the item to the new memory location. The processor implements two stacks, the main stack and the process stack, with independent copies of the stack pointer, see Stack pointer on page 15.

In Thread mode, the CONTROL register controls whether the processor uses the main stack or the process stack, see CONTROL register on page 21. In Handler mode, the processor always uses the main stack. The options for processor operations are:

The Program Counter (PC) is register R15. It contains the current program address. Bit[0] is always 0 because instruction fetches must be halfword aligned. On reset, the processor loads the PC with the value of the reset vector, which is at address 0x00000004. 

The APSR contains the current state of the condition flags from previous instruction executions. See the register summary in Table 2 on page 15 for its attributes. The bit assignments are:

Bit 29C: Carry or borrow flag:0: Add operation did not result in a carry bit or subtract operation resulted in a borrow bit1: Add operation resulted in a carry bit or subtract operation did not result in a borrow bit.

Bit 27Q: Sticky saturation flag:0: Indicates that saturation has not occurred since reset or since the bit was last cleared to zero1: Indicates when an SSAT or USAT instruction results in saturation.This bit is cleared to zero by software using an MRS instruction.

The IPSR contains the exception type number of the current Interrupt Service Routine (ISR). See the register summary in Table 2 on page 15 for its attributes. The bit assignments are:

The If-Then block contains up to four instructions following a 16-bit IT instruction. Each instruction in the block is conditional. The conditions for the instructions are either all the same, or some can be the inverse of others. See IT on page 94 for more information.

To access the exception mask registers use the MSR and MRS instructions, or the CPS instruction to change the value of PRIMASK or FAULTMASK. See MRS on page 100, MSR on page 101, and CPS on page 98 for more information.

The FAULTMASK register prevents activation of all exceptions except for Non-Maskable Interrupt (NMI). See the register summary in Table 2 on page 15 for its attributes. Figure 6 shows the bit assignments.

The BASEPRI register defines the minimum priority for exception processing. When BASEPRI is set to a nonzero value, it prevents the activation of all exceptions with same or lower priority level as the BASEPRI value. See the register summary in Table 2 on page 15 for its attributes. Figure 7 shows the bit assignments.

The CONTROL register controls the stack used and the privilege level for software execution when the processor is in Thread mode. See the register summary in Table 2 on page 15 for its attributes. Figure 8 shows the bit assignments.

Bits 7:4BASEPRI[7:4] Priority mask bits(1) 0x00: no effect Nonzero: defines the base priority for exception processing. The processor does not process any exception with a priority value greater than or equal to BASEPRI.

The Handler mode always uses the MSP, so the processor ignores explicit writes to the active stack pointer bit of the CONTROL register when in Handler mode. The exception entry and return mechanisms update the CONTROL register.

By default, Thread mode uses the MSP. To switch the stack pointer used in Thread mode to the PSP, use the MSR instruction to set the Active stack pointer bit to 1, see MSR on page 101.

When changing the stack pointer, software must use an ISB instruction immediately after the MSR instruction. This ensures that instructions after the ISB execute using the new stack pointer. See ISB on page 100

The Cortex-M3 processor supports interrupts and system exceptions. The processor and the Nested Vectored Interrupt Controller (NVIC) prioritize and handle all exceptions. An exception changes the normal flow of software control. The processor uses handler mode to handle all exceptions except for reset. See Exception entry on page 37 and Exception return on page 38 for more information. 

Bit 1ASPSEL: Active stack pointer selectionSelects the current stack:0: MSP is the current stack pointer 1: PSP is the current stack pointer.In Handler mode this bit reads as zero and ignores writes.

The CMSIS includes address definitions and data structures for the core peripherals in the Cortex-M3 processor. It also includes optional interfaces for middleware components comprising a TCP/IP stack and a Flash file system.

CMSIS simplifies software development by enabling the reuse of template code and the combination of CMSIS-compliant software components from various middleware vendors. Software vendors can expand the CMSIS to include their peripheral definitions and access functions for those peripherals.

This section describes the processor memory map, the behavior of memory accesses, and the bit-banding features. The processor has a fixed memory map that provides up to 4 GB of addressable memory. 

The memory map splits the memory map into regions. Each region has a defined memory type, and some regions have additional memory attributes. The memory type and attributes determine the behavior of accesses to the region.

However, the memory system does guarantee some ordering of accesses to Device and Strongly-ordered memory. For two memory access instructions A1 and A2, if A1 occurs before A2 in program order, the ordering of the memory accesses caused by two instructions is:

The Code, SRAM, and external RAM regions can hold programs. However, it is recommended that programs always use the Code region. This is because the processor has separate buses that enable instruction fetches and data accesses to occur simultaneously. 


• Vector table. If the program changes an entry in the vector table, and then enables the corresponding exception, use a DMB instruction between the operations. This ensures that if the exception is taken immediately after being enabled the processor uses the new exception vector.


• Memory map switching. If the system contains a memory map switching mechanism, use a DSB instruction after switching the memory map in the program. This ensures subsequent instruction execution uses the updated memory map.


• Dynamic exception priority change. When an exception priority has to change when the exception is pending or active, use DSB instructions after the change. This ensures the change takes effect on completion of the DSB instruction.


• Using a semaphore in multi-master system. If the system contains more than one bus master, for example, if another processor is present in the system, each processor must use a DMB instruction after any semaphore instructions, to ensure other bus masters see the memory transactions in the order in which they were executed.

A bit-band region maps each word in a bit-band alias region to a single bit in the bit-band region. The bit-band regions occupy the lowest 1 MB of the SRAM and peripheral memory regions.

Bit[0] of the value written to a word in the alias region determines the value written to the targeted bit in the bit-band region. Writing a value with bit[0] set to 1 writes a 1 to the bit-band bit, and writing a value with bit[0] set to 0 writes a 0 to the bit-band bit.

The processor views memory as a linear collection of bytes numbered in ascending order from zero. For example, bytes 0-3 hold the first stored word, and bytes 4-7 hold the second stored word.

In little-endian format, the processor stores the least significant byte of a word at the lowest-numbered byte, and the most significant byte at the highest-numbered byte. See Figure 11 for an example.

The Cortex-M3 instruction set includes pairs of synchronization primitives. These provide a non-blocking mechanism that a thread or process can use to obtain exclusive access to a memory location. Software can use them to perform a guaranteed read-modify-write memory update sequence, or for a semaphore mechanism.

Active An exception that is being serviced by the processor but has not completed.Note: An exception handler can interrupt the execution of another exception handler. In this case both exceptions are in the active state.

Reset Reset is invoked on power up or a warm reset. The exception model treats reset as a special form of exception. When reset is asserted, the operation of the processor stops, potentially at any point in an instruction. When reset is deasserted, execution restarts from the address provided by the reset entry in the vector table. Execution restarts as privileged execution in Thread mode.

NMI A NonMaskable Interrupt (NMI) can be signalled by a peripheral or triggered by software. This is the highest priority exception other than reset. It is permanently enabled and has a fixed priority of -2. NMIs cannot be: 

Hard fault A hard fault is an exception that occurs because of an error during exception processing, or because an exception cannot be managed by any other exception mechanism. Hard faults have a fixed priority of -1, meaning they have higher priority than any exception with configurable priority.

Memory management fault A memory management fault is an exception that occurs because of a memory protection related fault. The fixed memory protection constraints determines this fault, for both instruction and data memory transactions. This fault is used to abort instruction accesses to Execute Never (XN) memory regions.

Bus fault A bus fault is an exception that occurs because of a memory related fault for an instruction or data memory transaction. This might be from an error detected on a bus in the memory system.

SVCall A supervisor call (SVC) is an exception that is triggered by the SVC instruction. In an OS environment, applications can use SVC instructions to access OS kernel functions and device drivers.

SysTick A SysTick exception is an exception the system timer generates when it reaches zero. Software can also generate a SysTick exception. In an OS environment, the processor can use this exception as system tick.

Interrupt (IRQ) A interrupt, or IRQ, is an exception signalled by a peripheral, or generated by a software request. All interrupts are asynchronous to instruction execution. In the system, peripherals use interrupts to communicate with the processor.

The vector table contains the reset value of the stack pointer, and the start addresses, also called exception vectors, for all exception handlers. Figure 12 on page 35 shows the order of the exception vectors in the vector table. The least-significant bit of each vector must be 1, indicating that the exception handler is Thumb code. 

On system reset, the vector table is fixed at address 0x00000000. Privileged software can write to the VTOR to relocate the vector table start address to a different memory location, in the range 0x00000080 to 0x3FFFFF80, see Vector table offset register (SCB_VTOR) on page 133.

Configurable priority values are in the range 0-15. This means that the Reset, Hard fault, and NMI exceptions, with fixed negative priority values, always have higher priority than any other exception.

For example, assigning a higher priority value to IRQ[0] and a lower priority value to IRQ[1] means that IRQ[1] has higher priority than IRQ[0]. If both IRQ[1] and IRQ[0] are asserted, IRQ[1] is processed before IRQ[0].

If multiple pending exceptions have the same priority, the pending exception with the lowest exception number takes precedence. For example, if both IRQ[0] and IRQ[1] are pending and have the same priority, then IRQ[0] is processed before IRQ[1].

When the processor is executing an exception handler, the exception handler is preempted if a higher priority exception occurs. If an exception occurs with the same priority as the exception being handled, the handler is not preempted, irrespective of the exception number. However, the status of the new interrupt changes to pending.

Only the group priority determines preemption of interrupt exceptions. When the processor is executing an interrupt exception handler, another interrupt with the same group priority as the interrupt being handled does not preempt the handler,

If multiple pending interrupts have the same group priority, the subpriority field determines the order in which they are processed. If multiple pending interrupts have the same group priority and subpriority, the interrupt with the lowest IRQ number is processed first.

Sufficient priority means the exception has more priority than any limits set by the mask registers, see Exception mask registers on page 19. An exception with less priority than this is pending but is not handled by the processor.

Tail-chaining This mechanism speeds up exception servicing. On completion of an exception handler, if there is a pending exception that meets the requirements for exception entry, the stack pop is skipped and control transfers to the new exception handler.

Late-arriving This mechanism speeds up preemption. If a higher priority exception occurs during state saving for a previous exception, the processor switches to handle the higher priority exception and initiates the vector fetch for that exception. State saving is not affected by late arrival because the state saved is the same for both exceptions. Therefore the state saving continues uninterrupted. The processor can accept a late arriving exception until the first instruction of the exception handler of the original exception enters the execute stage of the processor. On return from the exception handler of the late-arriving exception, the normal tail-chaining rules apply.

Immediately after stacking, the stack pointer indicates the lowest address in the stack frame. Unless stack alignment is disabled, the stack frame is aligned to a double-word address. If the STKALIGN bit of the Configuration Control Register (CCR) is set to 1, stack align adjustment is performed during stacking. 

The stack frame includes the return address. This is the address of the next instruction in the interrupted program. This value is restored to the PC at exception return so that the interrupted program resumes.

In parallel to the stacking operation, the processor performs a vector fetch that reads the exception handler start address from the vector table. When stacking is complete, the processor starts executing the exception handler. At the same time, the processor writes an EXC_RETURN value to the LR. This indicates which stack pointer corresponds to the stack frame and what operation mode the was processor was in before the entry occurred.

If another higher priority exception occurs during exception entry, the processor starts executing the exception handler for this exception and does not change the pending status of the earlier exception. This is the late arrival case.

EXC_RETURN is the value loaded into the LR on exception entry. The exception mechanism relies on this value to detect when the processor has completed an exception handler. The lowest four bits of this value provide information on the return stack and processor mode. Table 17 shows the EXC_RETURN[3:0] values with a description of the exception return behavior. 

The processor sets EXC_RETURN bits[31:4] to 0xFFFFFFF. When this value is loaded into the PC it indicates to the processor that the exception is complete, and the processor initiates the exception return sequence.

Table 18 shows the types of fault, the handler used for the fault, the corresponding fault status register, and the register bit that indicates that the fault has occurred. See Configurable fault status register (SCB_CFSR) on page 142 for more information about the fault status registers.

All faults exceptions except for hard fault have configurable exception priority, see System handler priority registers (SHPRx) on page 138. Software can disable execution of the handlers for these faults, see System handler control and state register (SCB_SHCSR) on page 140.

Usually, the exception priority, together with the values of the exception mask registers, determines whether the processor enters the fault handler, and whether a fault handler can preempt another fault handler. as described in Section 2.3: Exception model on page 32.

In some situations, a fault with configurable priority is treated as a hard fault. This is called priority escalation, and the fault is described as escalated to hard fault. Escalation to hard fault occurs when:


• A fault handler causes the same kind of fault as the one it is servicing. This escalation to hard fault occurs because a fault handler cannot preempt itself because it must have the same priority as the current priority level.


• A fault handler causes a fault with the same or lower priority as the fault it is servicing. This is because the handler for the new fault cannot preempt the currently executing fault handler.

If a bus fault occurs during a stack push when entering a bus fault handler, the bus fault does not escalate to a hard fault. This means that if a corrupted stack causes a fault, the fault handler executes even though the stack push for the handler failed. The fault handler operates but the stack contents are corrupted.

The fault status registers indicate the cause of a fault. For bus faults and memory management faults, the fault address register indicates the address accessed by the operation that caused the fault, as shown in Table 19.

The processor enters a lockup state if a hard fault occurs when executing the NMI or hard fault handlers. When the processor is in lockup state it does not execute any instructions. The processor remains in lockup state until either:


• Deep sleep mode stops most of the STM32 system and peripheral clocks. At product level, this corresponds to either the Stop or the Standby mode. For more details, please refer to the “Power modes” Section in the STM32 reference manual.

The SLEEPDEEP bit of the SCR selects which sleep mode is used, see System control register (SCB_SCR) on page 136. For more information about the behavior of the sleep modes see the STM32 product reference manual.

The system can generate spurious wakeup events, for example a debug operation wakes up the processor. Therefore software must be able to put the processor back into sleep mode after such an event. A program might have an idle loop to put the processor back to sleep mode. 

The wait for interrupt instruction, WFI, causes immediate entry to sleep mode. When the processor executes a WFI instruction it stops executing instructions and enters sleep mode. See WFI on page 104 for more information.

The wait for event instruction, WFE, causes entry to sleep mode conditional on the value of an one-bit event register. When the processor executes a WFE instruction, it checks this register:

If the event register is 1, this indicate that the processor must not enter sleep mode on execution of a WFE instruction. Typically, this is because an external event signal is asserted, or a processor in the system has executed an SEV instruction, see SEV on page 102. Software cannot access this register directly.

If the SLEEPONEXIT bit of the SCR is set to 1, when the processor completes the execution of an exception handler it returns to Thread mode and immediately enters sleep mode. Use this mechanism in applications that only require the processor to run when an exception occurs.

Some embedded systems might have to execute system restore tasks after the processor wakes up, and before it executes an interrupt handler. To achieve this set the PRIMASK bit to 1 and the FAULTMASK bit to 0. If an interrupt arrives that is enabled and has a higher priority than current exception priority, the processor wakes up but does not execute the 

In addition, if the SEVONPEND bit in the SCR is set to 1, any new pending interrupt triggers an event and wakes up the processor, even if the interrupt is disabled or has insufficient priority to cause exception entry. For more information about the SCR see System control register (SCB_SCR) on page 136.

The processor provides an external event input signal. This signal can be generated by the up to 16 external input lines, by the PVD, RTC alarm or by the USB wakeup event, configured through the external interrupt/event controller (EXTI). 

This signal can wakeup the processor from WFE, or set the internal WFE event register to one to indicate that the processor must not enter sleep mode on a later WFE instruction, see Wait for event on page 42. Fore more details please refer to the STM32 reference manual, section 4.3 Low power modes.

ANSI cannot directly access some Cortex-M3 instructions. This section describes intrinsic functions that can generate these instructions, provided by the CMIS and that might be provided by a C compiler. If a C compiler does not support an appropriate intrinsic function, you might have to use an inline assembler to access some instructions.

An instruction operand can be an Arm register, a constant, or another instruction-specific parameter. Instructions act on the operands and often store the result in a destination register. When there is a destination register in the instruction, it is usually specified before the operands. 

Bit[0] of any address written to the PC with a BX, BLX, LDM, LDR, or POP instruction must be 1 for correct execution, because this bit indicates the required instruction set, and the Cortex-M3 processor only supports thumb instructions.

When an operand2 constant is used with the instructions MOVS, MVNS, ANDS, ORRS, ORNS, EORS, BICS, TEQ or TST, the carry flag is updated to bit[31] of the constant, if the constant is greater than 255 and can be produced by shifting an 8-bit value. These instructions do not affect the carry flag if operand2 is any other constant.

Your assembler might be able to produce an equivalent instruction in cases where you specify a constant that is not permitted. For example, an assembler might assemble the instruction CMP Rd, #0xFFFFFFFE as the equivalent instruction CMN Rd, #0x2.

If you specify a shift, the shift is applied to the value in Rm, and the resulting 32-bit value is used by the instruction. However, the contents in the register Rm remains unchanged. Specifying a register with shift also updates the carry flag when used with certain instructions. For information on the shift operations and how they affect the carry flag, see Shift operations.


• During the calculation of operand2 by the instructions that specify the second operand as a register with shift (see Flexible second operand on page 51). The result is used by the instruction.

The permitted shift lengths depend on the shift type and the instruction (see the individual instruction description or Flexible second operand). If the shift length is 0, no shift occurs. Register shift operations update the carry flag except when the specified shift length is 0. The following sub-sections describe the various shift operations and how they affect the carry flag. In these descriptions, Rm is the register containing the value to be shifted, and n is the shift length.

Arithmetic shift right by n bits moves the left-hand 32-n bits of the register Rm, to the right by n places, into the right-hand 32-n bits of the result. And it copies the original bit[31] of the register into the left-hand n bits of the result (see Figure 13: ASR#3 on page 53).

When the instruction is ASRS or when ASR #n is used in operand2 with the instructions MOVS, MVNS, ANDS, ORRS, ORNS, EORS, BICS, TEQ or TST, the carry flag is updated to the last bit shifted out, bit[n-1], of the register Rm.

Logical shift right by n bits moves the left-hand 32-n bits of the register Rm, to the right by n places, into the right-hand 32-n bits of the result. And it sets the left-hand n bits of the result to 0 (see Figure 14).

When the instruction is LSRS or when LSR #n is used in operand2 with the instructions MOVS, MVNS, ANDS, ORRS, ORNS, EORS, BICS, TEQ or TST, the carry flag is updated to the last bit shifted out, bit[n-1], of the register Rm.

Logical shift left by n bits moves the right-hand 32-n bits of the register Rm, to the left by n places, into the left-hand 32-n bits of the result. And it sets the right-hand n bits of the result to 0 (see Figure 15: LSL#3 on page 54).

You can use the LSL #n operation to multiply the value in the register Rm by 2n, if the value is regarded as an unsigned integer or a two’s complement signed integer. Overflow can occur without warning.

When the instruction is LSLS or when LSL #n, with non-zero n, is used in operand2 with the instructions MOVS, MVNS, ANDS, ORRS, ORNS, EORS, BICS, TEQ or TST, the carry flag is updated to the last bit shifted out, bit[32-n], of the register Rm. These instructions do not affect the carry flag when used with LSL #0.

Rotate right by n bits moves the left-hand 32-n bits of the register Rm, to the right by n places, into the right-hand 32-n bits of the result. It also moves the right-hand n bits of the register into the left-hand n bits of the result (see Figure 16).

When the instruction is RORS or when ROR #n is used in operand2 with the instructions MOVS, MVNS, ANDS, ORRS, ORNS, EORS, BICS, TEQ or TST, the carry flag is updated to the last bit rotation, bit[n-1], of the register Rm.

Note:1If n is 32, then the value of the result is same as the value in Rm, and if the carry flag is updated, it is updated to bit[31] of Rm. 

Rotate right with extend moves the bits of the register Rm to the right by one bit. And it copies the carry flag into bit[31] of the result (see Figure 17).

An aligned access is an operation where a word-aligned address is used for a word, dual word, or multiple word access, or where a halfword-aligned address is used for a halfword access. Byte accesses are always aligned.

All other load and store instructions generate a usage fault exception if they perform an unaligned access, and therefore their accesses must be address aligned. For more information about usage faults see Fault handling on page 39.

Unaligned accesses are usually slower than aligned accesses. In addition, some memory regions might not support unaligned accesses. Therefore, Arm recommends that programmers ensure that accesses are aligned. To avoid accidental generation of unaligned accesses, use the UNALIGN_TRP bit in the configuration and control register to trap all unaligned accesses, see Configuration and control register (SCB_CCR) on page 137.

A PC-relative expression or label is a symbol that represents the address of an instruction or literal data. It is represented in the instruction as the PC value plus or minus a numeric offset. The assembler calculates the required offset from the label and the address of the current instruction. If the offset is too big, the assembler produces an error.


• For all other instructions that use labels, the value of the PC is the address of the current instruction plus four bytes, with bit[1] of the result cleared to 0 to make it word-aligned.

Most data processing instructions can optionally update the condition flags in the application program status register (APSR) according to the result of the operation (see Application program status register on page 17). Some instructions update all flags, and some only update a subset. If a flag is not updated, the original value is preserved. See the instruction descriptions for the flags they affect.

Conditional execution is available by using conditional branches or by adding condition code suffixes to instructions. See Table 23: Condition code suffixes on page 57 for a list of the suffixes to add to instructions to make them conditional instructions. The condition code suffix enables the processor to test a condition based on the flags. If the condition test of a conditional instruction fails, the instruction:

Conditional instructions, except for conditional branches, must be inside an If-then instruction block. See IT on page 94 for more information and restrictions when using the IT instruction. Depending on the vendor, the assembler might automatically insert an IT instruction if you have conditional instructions outside the IT block.

The instructions that can be conditional have an optional condition code, shown in syntax descriptions as {cond}. Conditional execution requires a preceding IT instruction. An instruction with a condition code is only executed if the condition code flags in the APSR meet the specified condition. Table 23 shows the condition codes to use. 

Specific example 2: Compare and update value shows the use of conditional instructions to update the value of R4 if the signed value R0 and R2 are greater than R1 and R3 respectively.

CMP R0, R1 ; compare R0 and R1, setting flagsITT GT ; IT instruction for the two GT conditionsCMPGT R2, R3; if 'greater than', compare R2 and R3, setting flagsMOVGT R4, R5 ; if still 'greater than', do R4 = R5

There are many instructions that can generate either a 16-bit encoding or a 32-bit encoding depending on the operands and destination register specified. For some of these instructions, you can force a specific instruction size by using an instruction width suffix.  The .W suffix forces a 32-bit instruction encoding. The .N suffix forces a 16-bit instruction encoding.

In some cases it might be necessary to specify the .W suffix, for example if the operand is the label of an instruction or literal data, as in the case of branch instructions. This is because the assembler might not automatically generate the right size encoding. 

To use an instruction width suffix, place it immediately after the instruction mnemonic and condition code, if any. Specific example 3: Instruction width selection shows instructions with the instruction width suffix.

If you use ADR to generate a target address for a BX or BLX instruction, you must ensure that bit[0] of the address you generate is set to1 for correct execution.

The offset value is added to or subtracted from the address obtained from the register Rn. The result is used as the address for the memory access. The register Rn is unaltered. The assembly language syntax for this mode is: [Rn, #offset].

The offset value is added to or subtracted from the address obtained from the register Rn. The result is used as the address for the memory access and written back into the register Rn. The assembly language syntax for this mode is: [Rn, #offset]!

The address obtained from the register Rn is used as the address for the memory access. The offset value is added to or subtracted from the address, and written back into the register Rn. The assembly language syntax for this mode is: [Rn], #offset.

LDRR8, [R10]; loads R8 from the address in R10.LDRNER2, [R5, #960]!; loads (conditionally) R2 from a word; 960 bytes above the address in R5, and; increments R5 by 960.STRR2, [R9,#const-struc]; const-struc is an expression evaluating; to a constant in the range 0-4095.STRHR3, [R4], #4; Store R3 as halfword data into address in; R4, then increment R4 by 4LDRD R8, R9, [R3, #0x20]; Load R8 from a word 32 bytes above the; address in R3, and load R9 from a word 36; bytes above the address in R3STRDR0, R1, [R8], #-16; Store R0 to address in R8, and store R1 to; a word 4 bytes above the address in R8, ; and then decrement R8 by 16.

The memory address to load from or store to is at an offset from the register Rn. The offset is specified by the register Rm and can be shifted left by up to 3 bits using LSL.

The value to load or store can be a byte, halfword, or word. For load instructions, bytes and halfwords can either be signed or unsigned (see Address alignment on page 55).

STRR0, [R5, R1]; store value of R0 into an address equal to; sum of R5 and R1LDRSBR0, [R5, R1, LSL #1]; read byte value from an address equal to; sum of R5 and two times R1, sign extended it; to a word value and put it in R0STRR0, [R1, R2, LSL #2]; stores R0 to an address equal to sum of R1; and four times R2

These load and store instructions perform the same function as the memory access instructions with immediate offset (see LDR and STR, immediate offset on page 61). The difference is that these instructions have only unprivileged access even when used in privileged software.

STRBTEQR4, [R7]; conditionally store least significant byte in; R4 to an address in R7, with unprivileged accessLDRHTR2, [R2, #8]; load halfword value from an address equal to; sum of R2 and 8 into R2, with unprivileged access 

The value to load or store can be a byte, halfword, or word. For load instructions, bytes and halfwords can either be signed or unsigned (see Address alignment on page 55).

LDRR0, LookUpTable; load R0 with a word of data from an address; labelled as LookUpTableLDRSBR7, localdata; load a byte value from an address labelled; as localdata, sign extend it to a word; value, and put it in R7


• ‘reglist’ is a list of one or more registers to be loaded or stored, enclosed in braces. It can contain register ranges. It must be comma-separated if it contains more than one register or register range (see Examples on page 68).

For LDM, LDMIA, LDMFD, STM, STMIA, and STMEA the memory addresses used for the accesses are at 4-byte intervals ranging from Rn to Rn + 4 * (n-1), where n is the number of registers in reglist. The accesses happen in order of increasing register numbers, with the lowest numbered register using the lowest memory address and the highest number register using the highest memory address. If the writeback suffix is specified, the value of Rn + 4 * (n-1) is written back to Rn.

For LDMDB, LDMEA, STMDB, and STMFD the memory addresses used for the accesses are at 4-byte intervals ranging from Rn to Rn - 4 * (n-1), where n is the number of registers in reglist. The accesses happen in order of decreasing register numbers, with the highest numbered register using the highest memory address and the lowest number register using the lowest memory address. If the writeback suffix is specified, the value Rn - 4 * (n-1) is written back to Rn.


• ‘reglist’ is a non-empty list of registers, enclosed in braces. It can contain register ranges. It must be comma-separated if it contains more than one register or register range (see Examples on page 68).

PUSH and POP are synonyms for STMDB and LDM (or LDMIA) with the memory addresses for the access based on SP, and with the final address for the access written back to the SP. PUSH and POP are the preferred mnemonics in these cases.

PUSH stores registers on the stack in order of decreasing register numbers, with the highest numbered register using the highest memory address and the lowest numbered register using the lowest memory address.

POP loads registers from the stack in order of increasing register numbers, with the lowest numbered register using the lowest memory address and the highest numbered register using the highest memory address. 

STREX, STREXB, and STREXH attempt to store a word, byte, and halfword respectively to a memory address. The address used in any store-exclusive instruction must be the same as the address in the most recently executed load-exclusive instruction. The value stored by the Store-exclusive instruction must also have the same data size as the value loaded by the preceding load-exclusive instruction. This means software must always use a load-exclusive instruction and a matching store-exclusive instruction to perform a synchronization operation, see Synchronization primitives on page 30.

If a store-exclusive instruction performs the store, it writes 0 to its destination register. If it does not perform the store, it writes 1 to its destination register. If the store-exclusive instruction writes 0 to the destination register, it is guaranteed that no other process in the system has accessed the memory location between the load-exclusive and store-exclusive instructions.

MOVR1, #0x1; initialize the ‘lock taken’ value tryLDREXR0, [LockAddr]; load the lock valueCMPR0, #0; is the lock free?ITTEQ; IT instruction for STREXEQ and CMPEQSTREXEQR0, R1, [LockAddr]; try and claim the lockCMPEQR0, #0; did this succeed?BNEtry; no – try again; yes – we have the lock

Use CLREX to make the next STREX, STREXB, or STREXH instruction write 1 to its destination register and fail to perform the store. It is useful in exception handler code to force the failure of the store exclusive if the exception occurs between a load exclusive instruction and the matching store exclusive instruction in a synchronization operation.

2If you want to generate the address of an instruction, you have to adjust the constant based on the value of the PC. Arm recommends that you use the ADR instruction instead of ADD or SUB with Rn equal to the PC, because your assembler automatically calculates the correct constant for the ADR instruction. 

ADDR2, R1, R3SUBSR8, R6, #240; sets the flags on the resultRSBR4, R4, #1280; subtracts contents of R4 from 1280ADCHIR11, R0, R3; only executed if C flag set and Z; flag clear

Specific example 4: 64-bit addition shows two instructions that add a 64-bit integer contained in R2 and R3 to another 64-bit integer contained in R0 and R1, and place the result in R4 and R5.

Multiword values do not have to use consecutive registers. Specific example 5: 96-bit subtraction shows instructions that subtract a 96-bit integer contained in R9, R1, and R11 from another contained in R6, R2, and R8. The example stores the result in R6, R9, and R2.

In all these instructions, the result is written to Rd, but the value in register Rm remains unchanged. For details on what result is generated by the different instructions (see Shift operations on page 52).

ASRR7, R8, #9; arithmetic shift right by 9 bitsLSLSR1, R2, #3; logical shift left by 3 bits with flag updateLSRR4, R5, #6; logical shift right by 6 bitsRORR4, R5, R6; rotate right by the value in the bottom byte of R6RRXR4, R5; rotate right with extend

The CLZ instruction counts the number of leading zeros in the value in Rm and returns the result in Rd. The result value is 32 if no bits are set in the source register, and zero if bit[31] is set.

Note:Though it is possible to use MOV as a branch instruction, Arm strongly recommends the use of a BX or BLX instruction to branch for software portability to the Arm instruction set.

MOVSR11, #0x000B; write value of 0x000B to R11, flags get updatedMOVR1, #0xFA05; write value of 0xFA05 to R1, flags are not updatedMOVSR10, R12; write value in R12 to R10, flags get updatedMOVR3, #23; write value of 23 to R3MOVR8, SP; write value of stack pointer to R8MVNSR2, #0xF; write value of 0xFFFFFFF0 (bitwise inverse of 0xF); to the R2 and update flags

REVSH R0, R5 ; reverse Signed HalfwordREVHS R3, R7 ; reverse with Higher or Same conditionRBIT R7, R8 ; reverse bit order of value in R8 and write the result to R7

The TST instruction performs a bitwise AND operation on the value in Rn and the value of operand2. This is the same as the ANDS instruction, except that it discards the result.

To test whether a bit of Rn is 0 or 1, use the TST instruction with an operand2 constant that has that bit set to 1 and all other bits cleared to 0.

The TEQ instruction performs a bitwise exclusive OR operation on the value in Rn and the value of operand2. This is the same as the EORS instruction, except that it discards the result.

TSTR0, #0x3F8; perform bitwise AND of R0 value to 0x3F8,; APSR is updated but result is discardedTEQEQR10, R9; conditionally test if value in R10 is equal to ; value in R9, APSR is updated but result is discarded

MULR10, R2, R5; multiply, R10 = R2 x R5MLAR10, R2, R1, R5; multiply with accumulate, R10 = (R2 x R1) + R5MULSR0, R2, R2; multiply with flag update, R0 = R2 x R2MULLTR2, R3, R2; conditionally multiply, R2 = R3 x R2MLSR4, R5, R6, R7; multiply with subtract, R4 = R7 - (R5 x R6)

The UMULL instruction interprets the values from Rn and Rm as unsigned integers. It multiplies these integers and places the least significant 32 bits of the result in RdLo, and the most significant 32 bits of the result in RdHi.

The UMLAL instruction interprets the values from Rn and Rm as unsigned integers. It multiplies these integers, adds the 64-bit result to the 64-bit unsigned integer contained in RdHi and RdLo, and writes the result back to RdHi and RdLo.

The SMULL instruction interprets the values from Rn and Rm as two’s complement signed integers. It multiplies these integers and places the least significant 32 bits of the result in RdLo, and the most significant 32 bits of the result in RdHi.

The SMLAL instruction interprets the values from Rn and Rm as two’s complement signed integers. It multiplies these integers, adds the 64-bit result to the 64-bit signed integer contained in RdHi and RdLo, and writes the result back to RdHi and RdLo.

If the returned result is different from the value to be saturated, it is called saturation. If saturation occurs, the instruction sets the Q flag to 1 in the APSR. Otherwise, it leaves the Q flag unchanged. To clear the Q flag to 0, you must use the MSR instruction, see MSR on page 101.

SSATR7, #16, R7, LSL #4; logical shift left value in R7 by 4, then ; saturate it as a signed 16-bit value and; write it back to R7USATNER0, #7, R5; conditionally saturate value in R5 as an ; unsigned 7 bit value and write it to R0

BFI copies a bitfield into one register from another register. It replaces width bits in Rd starting at the low bit position lsb, with width bits from Rn starting at bit[0]. Other bits in Rd are unchanged.


• ‘Rm’ is a register that indicates an address to branch to. Bit[0] of the value in Rm must be 1, but the address to branch to is created by changing bit[0] to 0.

B cond label is the only conditional instruction that can be either inside or outside an IT block. All other branch instructions must be conditional inside an IT block, and must be unconditional outside the IT block, see IT on page 94.

a) It is possible to use AL (the always condition) for cond in an IT instruction. If this is done, all of the instructions in the IT block must be unconditional, and each of x, y, and z must be T or omitted but not E.

The IT instruction makes up to four following instructions conditional. The conditions can be all the same, or some of them can be the logical inverse of the others. The conditional instructions following the IT instruction form the IT block.

Your assembler might be able to generate the required IT instructions for conditional instructions automatically, so that you do not need to write them yourself. See your assembler documentation for details.

Exceptions can be taken between an IT instruction and the corresponding IT block, or within an IT block. Such an exception results in entry to the appropriate exception handler, with suitable return information in LR and stacked PSR.

Instructions designed for use for exception returns can be used as normal to return from the exception, and execution of the IT block resumes correctly. This is the only way that a PC-modifying instruction is permitted to branch to an instruction in an IT block.


• All conditional instructions except Bcond must be inside an IT block. Bcond can be either outside or inside an IT block but has a larger branch range if it is inside one

These instructions cause a PC-relative forward branch using a table of single byte offsets for TBB, or halfword offsets for TBH. Rn provides a pointer to the table, and Rm supplies an index into the table. For TBB the branch offset is twice the unsigned value of the byte returned from the table. and for TBH the branch offset is twice the unsigned value of the halfword returned from the table. The branch occurs to the address at that offset from the address of the byte immediately after the TBB or TBH instruction.

    BKPT 0xAB   ; Breakpoint with immediate value set to 0xAB (debugger can                 ; extract the immediate value by locating it using the PC)  

    CPSID i  ; Disable interrupts and configurable fault handlers (set PRIMASK)     CPSID f  ; Disable interrupts and all fault handlers (set FAULTMASK)     CPSIE i  ; Enable interrupts and configurable fault handlers (clear PRIMASK)     CPSIE f  ; Enable interrupts and fault handlers (clear FAULTMASK)

DMB acts as a data memory barrier. It ensures that all explicit memory accesses that appear, in program order, before the DMB instruction are completed before any explicit memory accesses that appear, in program order, after the DMB instruction. DMB does not affect the ordering or execution of instructions that do not access memory.

DSB acts as a special data synchronization memory barrier. Instructions that come after the DSB, in program order, do not execute until the DSB instruction completes. The DSB instruction completes when all explicit memory accesses before it complete.

ISB acts as an instruction synchronization barrier. It flushes the pipeline of the processor, so that all instructions following the ISB are fetched from cache or memory again, after the ISB instruction has been completed.

In process swap code, the programmers model state of the process being swapped out must be saved, including relevant PSR contents. Similarly, the state of the process being swapped in must also be restored. These operations use MRS in the state-saving instruction sequence and MSR in the state-restoring instruction sequence.

The register access operation in MSR depends on the privilege level. Unprivileged software can only access the APSR, see Table 4: APSR bit definitions on page 17. Privileged software can access all special registers.

SEV is a hint instruction that causes an event to be signaled to all processors within a multiprocessor system. It also sets the local event register to 1, see Power management on page 41.

This section describes the Memory protection unit (MPU) which is implemented in some STM32 microcontrollers. Refer to the corresponding device datasheet to see if the MPU is present in the STM32 type you are using. 

When memory regions overlap, a memory access is affected by the attributes of the region with the highest number. For example, the attributes for region 7 take precedence over the attributes of any region that overlaps region 7.

If a program accesses a memory location that is prohibited by the MPU, the processor generates a memory management fault. This causes a fault exception, and might cause termination of the process in an OS environment. 

This section describes the MPU access permission attributes. The access permission bits, TEX, C, B, S, AP, and XN, of the MPU_RASR register, control access to the corresponding memory region. If an access is made to an area of memory without the required permissions, then the MPU generates a permission fault.

To update the attributes for an MPU region, update the MPU_RNR, MPU_RBAR and MPU_RASR registers. You can program each register separately, or use a multiple-word write to program all of these registers. You can use the MPU_RBAR and MPU_RASR aliases to program up to four regions simultaneously using an STM instruction.

Disable a region before writing new region settings to the MPU if you have previously enabled the region being changed. For example:; R1 = region number; R2 = size/enable; R3 = attributes; R4 = addressLDR R0,=MPU_RNR           ; 0xE000ED98, MPU region number registerSTR R1, [R0, #0x0]        ; Region NumberBIC R2, R2, #1            ; DisableSTRH R2, [R0, #0x8]       ; Region Size and EnableSTR R4, [R0, #0x4]        ; Region Base Address

However, memory barrier instructions are not required if the MPU setup process starts by entering an exception handler, or is followed by an exception return, because the exception entry and exception return mechanism cause memory barrier behavior.

For example, if you want all of the memory access behavior to take effect immediately after the programming sequence, use a DSB instruction and an ISB instruction. A DSB is required after changing MPU settings, such as at the end of context switch. An ISB is required if the code that programs the MPU region or regions is entered using a branch or call. If the programming sequence is entered using a return from exception, or by taking an exception, then you do not require an ISB.

You can program directly using multi-word writes, depending on how the information is divided. Consider the following reprogramming:; R1 = region number; R2 = address; R3 = size, attributes in oneLDR R0, =MPU_RNR    ; 0xE000ED98, MPU region number registerSTR R1, [R0, #0x0]  ; Region NumberSTR R2, [R0, #0x4]  ; Region Base AddressSTR R3, [R0, #0x8]  ; Region Attribute, Size and Enable

Use an STM instruction to optimize this:; R1 = region number; R2 = address; R3 = size, attributes in oneLDR R0, =MPU_RNR    ; 0xE000ED98, MPU region number registerSTM R0, {R1-R3}     ; Region Number, address, attribute, size and enable

You can do this in two words for pre-packed information. This means that the RBAR contains the required region number and had the VALID bit set to 1, see MPU region base address register (MPU_RBAR) on page 114. Use this when the data is statically packed, for example in a boot loader:; R1 = address and region number in one; R2 = size and attributes in oneLDR R0, =MPU_RBAR   ; 0xE000ED9C, MPU Region Base registerSTR R1, [R0, #0x0]  ; Region base address and                     ; region number combined with VALID (bit 4) set to 1STR R2, [R0, #0x4]  ; Region Attribute, Size and Enable

Use an STM instruction to optimize this:; R1 = address and region number in one; R2 = size and attributes in oneLDR R0,=MPU_RBAR    ; 0xE000ED9C, MPU Region Base registerSTM R0, {R1-R2}     ; Region base address, region number and VALID bit,                    ; and Region Attribute, Size and Enable

Two regions with the same base address overlap. Region one is 128KB, and region two is 512KB. To ensure the attributes from region one apply to the first128KB region, set the SRD field for region two to b00000011 to disable the first two subregions, as the figure shows.

In STM32 implementations, the shareability and cache policy attributes do not affect the system behavior. However, using these settings for the MPU regions can make the application code more portable. The values given are for typical situations. 

Note:The MPU attributes don't affect DMA data accesses to the memory/peripherals address spaces. therefore, in order to protect the memory areas against inadvertent DMA accesses, the MPU must control the SW/CPU access to the DMA registers.

Bits 23:16 IREGION[7:0]: Number of MPU instruction regions. These bits indicates the number of supported MPU instruction regions.Always contains 0x00. The MPU memory map is unified and is described by the DREGION field.


• For privileged accesses, the default memory map is as described in Section 2.2: Memory model on page 24. Any access by privileged software that does not address an enabled memory region behaves as defined by the default memory map.

When the ENABLE bit is set to 1, at least one region of the memory map must be enabled for the system to function unless the PRIVDEFENA bit is set to 1. If the PRIVDEFENA bit is set to 1 and no regions are enabled, then only privileged software can operate.

When the ENABLE bit is set to 0, the system uses the default memory map. This has the same memory attributes as if the MPU is not implemented, see Table 12: Memory access behavior on page 26. The default memory map applies to accesses from both privileged and unprivileged software.

When the MPU is enabled, accesses to the System Control Space and vector table are always permitted. Other areas are accessible based on regions and whether PRIVDEFENA is set to 1.

Unless HFNMIENA is set to 1, the MPU is not enabled when the processor is executing the handler for an exception with priority –1 or –2. These priorities are only possible when handling a hard fault or NMI exception, or when FAULTMASK is enabled. Setting the HFNMIENA bit to 1 enables the MPU when operating with these two priorities.

Bit 2 PRIVDEFENA: Enable privileged software access to default memory map. 0: If the MPU is enabled, disables use of the default memory map. Any memory access to a location not covered by any enabled region causes a fault.1: If the MPU is enabled, enables use of the default memory map as a background region for privileged software accesses.Note: When enabled, the background region acts as if it is region number -1. Any region that is defined and enabled has priority over this default map. If the MPU is disabled, the processor ignores this bit.

Bit 1 HFNMIENA: Enables the operation of MPU during hard fault, NMI, and FAULTMASK handlers. When the MPU is enabled:0: MPU is disabled during hard fault, NMI, and FAULTMASK handlers, regardless of the value of the ENABLE bit1: The MPU is enabled during hard fault, NMI, and FAULTMASK handlers.Note: When the MPU is disabled, if this bit is set to 1 the behavior is unpredictable.

Bits 7:0 REGION[7:0]: MPU region These bits indicate the MPU region referenced by the MPU_RBAR and MPU_RASR registers. The MPU supports 8 memory regions, so the permitted values of this field are 0-7.Normally, you write the required region number to this register before accessing the MPU_RBAR or MPU_RASR. However you can change the region number by writing to the MPU_RBAR register with the VALID bit set to 1, see MPU region base address register (MPU_RBAR). This write updates the value of the REGION field.

Bits 31:N ADDR[31:N]: Region base address fieldThe value of N depends on the region size. The region size, as specified by the SIZE field in the RASR, defines the value of N:    N = Log2(Region size in bytes), If the region size is configured to 4 GB, in the MPU_RASR register, there is no valid ADDR field. In this case, the region occupies the complete memory map, and the base address is 0x00000000.The base address is aligned to the size of the region. For example, a 64 KB region must be aligned on a multiple of 64 KB, for example, at 0x00010000 or 0x00020000.

Bits 15:8 SRD: Subregion disable bits.For each bit in this field:0: corresponding sub-region is enabled1: corresponding sub-region is disabledSee Subregions on page 110 for more information.Region sizes of 128 bytes and less do not support subregions. When writing the attributes for such a region, write the SRD field as 0x00.

The smallest permitted region size is 32B, corresponding to a SIZE value of 4. Table 4-45 gives example SIZE values, with the corresponding region size and value of N in the RBAR.

The processor automatically stacks its state on exception entry and unstacks this state on exception exit, with no instruction overhead. This provides low latency exception handling. The hardware implementation of the NVIC registers is:


• The 8-bit fields of the Interrupt Priority Registers map to an array of 8-bit integers, so that the array IP[0] to IP[67] corresponds to the registers IPR0-IPR67, and the array entry IP[n] holds the interrupt priority for interrupt n.

The CMSIS provides thread-safe code that gives atomic access to the Interrupt Priority Registers. For more information see the description of the NVIC_SetPriority function in NVIC programming hints on page 127. Table 41 shows how the interrupts, or IRQ numbers, map onto the interrupt registers and corresponding CMSIS variables that have one bit per interrupt.

Bits 31:0 SETENA[31:0]: Interrupt set-enable bits. Write:0: No effect 1: Enable interruptRead:0: Interrupt disabled 1: Interrupt enabled.See Table 41: Mapping of interrupts to the interrupt variables on page 119 for the correspondence of interrupts to each register bit.If a pending interrupt is enabled, the NVIC activates the interrupt based on its priority. If an interrupt is not enabled, asserting its interrupt signal changes the interrupt state to pending, but the NVIC never activates the interrupt, regardless of its priority.

Bits 31:0 CLRENA[31:0]: Interrupt clear-enable bits. Write:0: No effect 1: Disable interruptRead:0: Interrupt disabled 1: Interrupt enabled.See Table 41: Mapping of interrupts to the interrupt variables on page 119 for the correspondence of interrupts to each register bit.

Bits 31:0 SETPEND[31:0]: Interrupt set-pending bits Write:0: No effect1: Changes interrupt state to pendingRead:0: Interrupt is not pending1: Interrupt is pendingSee Table 41: Mapping of interrupts to the interrupt variables on page 119 for the correspondence of interrupts to each register bit.Writing 1 to the ISPR bit corresponding to an interrupt that is pending:–has no effect.Writing 1 to the ISPR bit corresponding to a disabled interrupt:–sets the state of that interrupt to pending.

Bits 31:0 CLRPEND[31:0]: Interrupt clear-pending bits Write:0: No effect1: Removes the pending state of an interrupt Read:0: Interrupt is not pending1: Interrupt is pendingSee Table 41: Mapping of interrupts to the interrupt variables on page 119 for the correspondence of interrupts to each register bit.Writing 1 to an ICPR bit does not affect the active state of the corresponding interrupt.

Bits 31:0 ACTIVE[31:0]: Interrupt active flags0: Interrupt not active1: Interrupt activeSee Table 41: Mapping of interrupts to the interrupt variables on page 119 for the correspondence of interrupts to each register bit.A bit reads as 1 if the status of the corresponding interrupt is active or active and pending.

The IPR0-IPR16 registers provide a 4-bit priority field for each interrupt. These registers are byte-accessible. Each register holds four priority fields, that map to four elements in the CMSIS interrupt priority array IP[0] to IP[67], as shown in Figure 19.

See The CMSIS mapping of the Cortex®-M3 NVIC registers on page 119 for more information about the IP[0] to IP[67] interrupt priority array, that provides the software view of the interrupt priorities.

[31:24] Priority, byte offset 3 Each priority field holds a priority value, 0-255. The lower the value, the greater the priority of the corresponding interrupt. The processor implements only bits[7:4] of each field, bits[3:0] read as zero and ignore writes.

A level-sensitive interrupt is held asserted until the peripheral deasserts the interrupt signal. Typically this happens because the ISR accesses the peripheral, causing it to clear the interrupt request. A pulse interrupt is an interrupt signal sampled synchronously on the rising edge of the processor clock. To ensure the NVIC detects the interrupt, the peripheral must assert the interrupt signal for at least one clock cycle, during which the NVIC detects the pulse and latches the interrupt. 

When the processor enters the ISR, it automatically removes the pending state from the interrupt, see Hardware and software control of interrupts. For a level-sensitive interrupt, if the signal is not deasserted before the processor returns from the ISR, the interrupt becomes pending again, and the processor must execute its ISR again. This means that the peripheral can hold the interrupt signal asserted until it no longer needs servicing.

NTID[8:0] Software generated interrupt IDWrite to the STIR to generate a Software Generated Interrupt (SGI). The value to be written is the Interrupt ID of the required SGI, in the range 0-239. For example, a value of 0b000000011 specifies interrupt IRQ3.

–For a level-sensitive interrupt, when the processor returns from the ISR, the NVIC samples the interrupt signal. If the signal is asserted, the state of the interrupt changes to pending, which might cause the processor to immediately re-enter the ISR. Otherwise, the state of the interrupt changes to inactive.

–For a pulse interrupt, the NVIC continues to monitor the interrupt signal, and if this is pulsed the state of the interrupt changes to pending and active. In this case, when the processor returns from the ISR the state of the interrupt changes to pending, which might cause the processor to immediately re-enter the ISR. If the interrupt signal is not pulsed while the processor is in the ISR, when the processor returns from the ISR the state of the interrupt changes to inactive.

The table provides shows the NVIC register map and reset values. The base address of the main NVIC register block is 0xE000E100. The NVIC_STIR register is located in a separate block at 0xE000EF00.

0x320NVIC_IPR20ReservedIP[80]Reset Value0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0SCB registers

          Bit 31 NMIPENDSET: NMI set-pending bit.Write:0: No effect1: Change NMI exception state to pending.Read:0: NMI exception is not pending1: NMI exception is pendingBecause NMI is the highest-priority exception, normally the processor enter the NMI exception handler as soon as it registers a write of 1 to this bit, and entering the handler clears this bit to 0. A read of this bit by the NMI exception handler returns 1 only if the NMI signal is reasserted while the processor is executing that handler.

Bit 28 PENDSVSET: PendSV set-pending bit.Write:0: No effect1: Change PendSV exception state to pending.Read:0: PendSV exception is not pending1: PendSV exception is pendingWriting 1 to this bit is the only way to set the PendSV exception state to pending.

Bits 21:12 VECTPENDING[9:0] Pending vectorIndicates the exception number of the highest priority pending enabled exception.0: No pending exceptionsOther values: The exception number of the highest priority pending enabled exception.The value indicated by this field includes the effect of the BASEPRI and FAULTMASK registers, but not any effect of the PRIMASK register.

Bit 11 RETOBASE: Return to base levelIndicates whether there are preempted active exceptions:0: There are preempted active exceptions to execute1: There are no active exceptions, or the currently-executing exception is the only active exception.

Bits 8:0 VECTACTIVE[8:0] Active vector Contains the active exception number:0: Thread modeOther values: The exception number(1) of the currently active exception.Note:Subtract 16 from this value to obtain the IRQ number required to index into the Interrupt Clear-Enable, Set-Enable, Clear-Pending, Set-Pending, or Priority Registers, see Table 5 on page 18.

Bits 29:9 TBLOFF[29:9]: Vector table base offset field.It contains bits [29:9] of the offset of the table base from memory address 0x00000000. When setting TBLOFF, you must align the offset to the number of exception entries in the vector table. The minimum alignment is 128 words. Table alignment requirements mean that bits[8:0] of the table offset are always zero.Bit 29 determines whether the vector table is in the code or SRAM memory region.0: Code1: SRAMNote: Bit 29 is sometimes called the TBLBASE bit.

Bit 2 SYSRESETREQ System reset requestThis is intended to force a large system reset of all major components except for debug.This bit reads as 0.0: No system reset request1: Asserts a signal to the outer system that requests a reset. 

The PRIGROUP field indicates the position of the binary point that splits the PRI_n fields in the Interrupt Priority Registers into separate group priority and subpriority fields. Table 45 shows how the PRIGROUP value controls this split.

Bit 4 SEVEONPEND Send Event on Pending bitWhen an event or interrupt enters pending state, the event signal wakes up the processor from WFE. If the processor is not waiting for an event, the event is registered and affects the next WFE. The processor also wakes up on execution of an SEV instruction or an external event0: Only enabled interrupts or events can wakeup the processor, disabled interrupts are excluded1: Enabled events and all interrupts, including disabled interrupts, can wakeup the processor.

Bit 1 SLEEPONEXIT Configures sleep-on-exit when returning from Handler mode to Thread mode. Setting this bit to 1 enables an interrupt-driven application to avoid returning to an empty main application.0: Do not sleep when returning to Thread mode.1: Enter sleep, or deep sleep, on return from an interrupt service routine. 

Bit 9 STKALIGNConfigures stack alignment on exception entry. On exception entry, the processor uses bit 9 of the stacked PSR to indicate the stack alignment. On return from the exception it uses this stacked bit to restore the correct stack alignment.0: 4-byte aligned1: 8-byte aligned 

Bit 8 BFHFNMIGN Enables handlers with priority -1 or -2 to ignore data bus faults caused by load and store instructions. This applies to the hard fault, NMI, and FAULTMASK escalated handlers. Set this bit to 1 only when the handler and its data are in absolutely safe memory. The normal use of this bit is to probe system devices and bridges to detect control path problems and fix them.0: Data bus faults caused by load and store instructions cause a lock-up1: Handlers running at priority -1 and -2 ignore data bus faults caused by load and store instructions.

Bit 4 DIV_0_TRP Enables faulting or halting when the processor executes an SDIV or UDIV instruction with a divisor of 0:0: Do not trap divide by 01: Trap divide by 0. When this bit is set to 0, a divide by zero returns a quotient of 0.

Bit 3 UNALIGN_ TRP Enables unaligned access traps:0: Do not trap unaligned halfword and word accesses1: Trap unaligned halfword and word accesses. If this bit is set to 1, an unaligned access generates a usage fault.Unaligned LDM, STM, LDRD, and STRD instructions always fault irrespective of whether UNALIGN_TRP is set to 1.

Bit 0 NONBASETHRDENAConfigures how the processor enters Thread mode.0: Processor can enter Thread mode only when no exception is active.1: Processor can enter Thread mode from any level under the control of an EXC_RETURN value, see Exception return on page 38.

You can write to this register to change the pending or active status of system exceptions. An OS kernel can write to the active bits to perform a context switch that changes the current exception type.


• Software that changes the value of an active bit in this register without correct adjustment to the stacked content can cause the processor to generate a fault exception. Ensure software that writes to this register retains and subsequently restores the current active status. 


• After you have enabled the system handlers, if you have to change the value of a bit in this register you must use a read-modify-write procedure to ensure that you change only the required bit.

Bit 25 DIVBYZERO: Divide by zero usage fault When the processor sets this bit to 1, the PC value stacked for the exception return points to the instruction that performed the divide by zero.Enable trapping of divide by zero by setting the DIV_0_TRP bit in the CCR to 1, see Configuration and control register (SCB_CCR) on page 137.0: No divide by zero fault, or divide by zero trapping not enabled1: The processor has executed an SDIV or UDIV instruction with a divisor of 0.

Bit 24 UNALIGNED: Unaligned access usage fault:Enable trapping of unaligned accesses by setting the UNALIGN_TRP bit in the CCR to 1, see Configuration and control register (SCB_CCR) on page 137.Unaligned LDM, STM, LDRD, and STRD instructions always fault irrespective of the setting of UNALIGN_TRP.0: No unaligned access fault, or unaligned access trapping not enabled1: the processor has made an unaligned memory access.

Bit 19 NOCP: No coprocessor usage fault. The processor does not support coprocessor instructions:0: No usage fault caused by attempting to access a coprocessor1: the processor has attempted to access a coprocessor.

Bit 18 INVPC: Invalid PC load usage fault, caused by an invalid PC load by EXC_RETURN:When this bit is set to 1, the PC value stacked for the exception return points to the instruction that tried to perform the illegal load of the PC.0: No invalid PC load usage fault1: The processor has attempted an illegal load of EXC_RETURN to the PC, as a result of an invalid context, or an invalid EXC_RETURN value. 

Bit 17 INVSTATE: Invalid state usage fault:When this bit is set to 1, the PC value stacked for the exception return points to the instruction that attempted the illegal use of the EPSR.This bit is not set to 1 if an undefined instruction uses the EPSR.0: No invalid state usage fault1: The processor has attempted to execute an instruction that makes illegal use of the EPSR.

Bit 16 UNDEFINSTR: Undefined instruction usage fault:When this bit is set to 1, the PC value stacked for the exception return points to the undefined instruction.An undefined instruction is an instruction that the processor cannot decode.0: No undefined instruction usage fault1: The processor has attempted to execute an undefined instruction.

Bit 15 BFARVALID: Bus Fault Address Register (BFAR) valid flag:The processor sets this bit to 1 after a bus fault where the address is known. Other faults can set this bit to 0, such as a memory management fault occurring later.If a bus fault occurs and is escalated to a hard fault because of priority, the hard fault handler must set this bit to 0. This prevents problems if returning to a stacked active bus fault handler whose BFAR value has been overwritten.0: Value in BFAR is not a valid fault address1: BFAR holds a valid fault address.

Bit 12 STKERR: Bus fault on stacking for exception entryWhen the processor sets this bit to 1, the SP is still adjusted but the values in the context area on the stack might be incorrect. The processor does not write a fault address to the BFAR.0: No stacking fault1: Stacking for an exception entry has caused one or more bus faults. 

Bit 11 UNSTKERR: Bus fault on unstacking for a return from exceptionThis fault is chained to the handler. This means that when the processor sets this bit to 1, the original return stack is still present. The processor does not adjust the SP from the failing return, does not performed a new save, and does not write a fault address to the BFAR.0: No unstacking fault1: Unstack for an exception return has caused one or more bus faults.

Bit 10 IMPRECISERR: Imprecise data bus error When the processor sets this bit to 1, it does not write a fault address to the BFAR.This is an asynchronous fault. Therefore, if it is detected when the priority of the current process is higher than the bus fault priority, the bus fault becomes pending and becomes active only when the processor returns from all higher priority processes. If a precise fault occurs before the processor enters the handler for the imprecise bus fault, the handler detects both IMPRECISERR set to 1 and one of the precise fault status bits set to 1.0: No imprecise data bus error1: A data bus error has occurred, but the return address in the stack frame is not related to the instruction that caused the error. 

Bit 9 PRECISERR: Precise data bus errorWhen the processor sets this bit is 1, it writes the faulting address to the BFAR.0: No precise data bus error1: A data bus error has occurred, and the PC value stacked for the exception return points to the instruction that caused the fault.

Bit 8 IBUSERR: Instruction bus errorThe processor detects the instruction bus error on prefetching an instruction, but it sets the IBUSERR flag to 1 only if it attempts to issue the faulting instruction. When the processor sets this bit is 1, it does not write a fault address to the BFAR.0: No instruction bus error1: Instruction bus error.

Bit 7 MMARVALID: Memory Management Fault Address Register (MMAR) valid flagIf a memory management fault occurs and is escalated to a hard fault because of priority, the hard fault handler must set this bit to 0. This prevents problems on return to a stacked active memory management fault handler whose MMAR value has been overwritten.0: Value in MMAR is not a valid fault address1: MMAR holds a valid fault address.

Bit 4 MSTKERR: Memory manager fault on stacking for exception entryWhen this bit is 1, the SP is still adjusted but the values in the context area on the stack might be incorrect. The processor has not written a fault address to the MMAR.0: No stacking fault1: Stacking for an exception entry has caused one or more access violations. 

Bit 3 MUNSTKERR: Memory manager fault on unstacking for a return from exceptionThis fault is chained to the handler. This means that when this bit is 1, the original return stack is still present. The processor has not adjusted the SP from the failing return, and has not performed a new save. The processor has not written a fault address to the MMAR.0: No unstacking fault1: Unstack for an exception return has caused one or more access violations.

Bit 1 DACCVIOL: Data access violation flagWhen this bit is 1, the PC value stacked for the exception return points to the faulting instruction. The processor has loaded the MMAR with the address of the attempted access.0: No data access violation fault1: The processor attempted a load or store at a location that does not permit the operation.

Bit 1 IACCVIOL: Instruction access violation flagThis fault occurs on any access to an XN region.When this bit is 1, the PC value stacked for the exception return points to the faulting instruction. The processor has not written a fault address to the MMAR.0: No instruction access violation fault1: The processor attempted an instruction fetch from a location that does not permit execution. 

Bit 30 FORCED: Forced hard faultIndicates a forced hard fault, generated by escalation of a fault with configurable priority that cannot be handles, either because of priority or because it is disabled:When this bit is set to 1, the hard fault handler must read the other fault status registers to find the cause of the fault.0: No forced hard fault1: Forced hard fault.

Bit 1 VECTTBL: Vector table hard faultIndicates a bus fault on a vector table read during exception processing:This error is always handled by the hard fault handler.When this bit is set to 1, the PC value stacked for the exception return points to the instruction that was preempted by the exception.0: No bus fault on vector table read1: Bus fault on vector table read.

Bits 31:0 MMFAR[31:0]: Memory management fault addressWhen the MMARVALID bit of the MMFSR is set to 1, this field holds the address of the location that generated the memory management fault.When an unaligned access faults, the address is the actual address that faulted. Because a single read or write instruction can be split into multiple aligned accesses, the fault address can be any address in the range of the requested access size.Flags in the MMFSR register indicate the cause of the fault, and whether the value in the MMFAR is valid. See Configurable fault status register (SCB_CFSR) on page 142.

Bits 31:0 BFAR[31:0]: Bus fault addressWhen the BFARVALID bit of the BFSR is set to 1, this field holds the address of the location that generated the bus fault.When an unaligned access faults the address in the BFAR is the one requested by the instruction, even if it is not the address of the fault. Flags in the BFSR register indicate the cause of the fault, and whether the value in the BFAR is valid. See Configurable fault status register (SCB_CFSR) on page 142.

Software must follow this sequence because another higher priority exception might change the MMFAR or BFAR value. For example, if a higher priority handler preempts the current fault handler, the other fault might change the MMFAR or BFAR value.

0x00SCB_ACTLRImplementerVariantConstantPartNoRevisionReset Value0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

0x00SCB_CPUIDImplementerVariantConstantPartNoRevisionReset Value0 1 0 0 0 0 0 1 0 0 0 1 1 1 1 1 1 1 0 0 0 0 1 0 0 0 1 1 0 0 0 1

The processor has a 24-bit system timer, SysTick, that counts down from the reload value to zero, reloads (wraps to) the value in the LOAD register on the next clock edge, then counts down on subsequent clocks.

Bit 1 TICKINT: SysTick exception request enable0: Counting down to zero does not assert the SysTick exception request1: Counting down to zero to asserts the SysTick exception request.Note: Software can use COUNTFLAG to determine if SysTick has ever counted to zero.

Bit 0 ENABLE: Counter enableEnables the counter. When ENABLE is set to 1, the counter loads the RELOAD value from the LOAD register and then counts down. On reaching 0, it sets the COUNTFLAG to 1 and optionally asserts the SysTick depending on the value of TICKINT. It then loads the RELOAD value again, and begins counting.0: Counter disabled1: Counter enabled

Bits 23:0 RELOAD[23:0]: RELOAD valueThe LOAD register specifies the start value to load into the VAL register when the counter is enabled and when it reaches 0.Calculating the RELOAD valueThe RELOAD value can be any value in the range 0x00000001-0x00FFFFFF. A start value of 0 is possible, but has no effect because the SysTick exception request and COUNTFLAG are activated when counting from 1 to 0.The RELOAD value is calculated according to its use:lTo generate a multi-shot timer with a period of N processor clock cycles, use a RELOAD value of N-1. For example, if the SysTick interrupt is required every 100 clock pulses, set RELOAD to 99.lTo deliver a single SysTick interrupt after a delay of N processor clock cycles, use a RELOAD of value N. For example, if a SysTick interrupt is required after 400 clock pulses, set RELOAD to 400.

Bits 23:0 CURRENT[23:0]: Current counter valueThe VAL register contains the current value of the SysTick counter.Reads return the current value of the SysTick counter.A write of any value clears the field to 0, and also clears the COUNTFLAG bit in the STK_CTRL register to 0.

Bit 30 SKEW: SKEW flagReads as one. Calibration value for the 1 ms inexact timing is not known because TENMS is not known. This can affect the suitability of SysTick as a software real time clock.

Bits 23:0 TENMS[23:0]: Calibration valueIndicates the calibration value when the SysTick counter runs on HCLK max/8 as external clock. The value is product dependent, please refer to the Product Reference Manual, SysTick Calibration Value section. When HCLK is programmed at the maximum frequency, the SysTick period is 1ms. If calibration information is not known, calculate the calibration value required from the frequency of the processor clock or external clock.

Modified Table 14: Peripheral memory bit-banding regions on page 28 (peripheral bit-band alias and peripheral bit-band region swapped)Added Section 4.2: Memory protection unit (MPU) on page 105. Modified Table 44: NVIC register map and reset values on page 128 supporting up to 81 interrupts

Added reference to STM32F20xxx, STM32F21xxx and STM32L1xx products in title and fisrt page.Modified NVIC_ISPR0 register base moved to offset 0x100 in Table 44: NVIC register map and reset values on page 128 .To support STM32L anf STM32F2 series based on r2p0 core:Added SCB_ACTLR register, modified SCB_CPUID and SCB_CCR registers .

STMicroelectronics NV and its subsidiaries (“ST”) reserve the right to make changes, corrections, enhancements, modifications, and improvements to ST products and/or to this document at any time without notice. Purchasers should obtain the latest relevant information on ST products before placing orders. ST products are sold pursuant to ST’s terms and conditions of sale in place at the time of order acknowledgement.
All the described limitations are minor and related to the revision r1p1-01rel0 of the Cortex®-M3 core. Table 3 summarizes these limitations and their implications on the behavior of medium-density STM32F10xxx devices.

All the other limitations described in the Arm errata notice (and summarized in Table 3 above) have no impact and are not related to the implementation of STM32F10xxx medium-density devices (Cortex-M3 r1p1-01rel0).

The Cortex-M3 Core has a limitation when executing an LDRD instruction from the system-bus area, with the base register in a list of the form LDRD Ra, Rb, [Ra, #imm]. The execution may not complete after loading the first destination register due to an interrupt before the second loading completes or due to the second loading getting a bus fault.

When interrupts related to a WFE occur before the WFE is executed, the event register used for WFE wakeup events is not set and the event is missed. Therefore, when the WFE is executed, the core does not wake up from WFE if no other event or interrupt occur.

A BKPT may be executed in debug monitor mode. This causes the debug monitor handler to be run. However, the bit 1 in the Debug fault status register (DFSR) at address 0xE000ED30 is not set to indicate that it was originated by a BKPT instruction. This only occurs if an interrupt other than the debug monitor is already being processed just before the BKPT is executed.

If the DFSR register does not have any bit set when the debug monitor is entered, this means that we must be in this “corner case” and so, that a BKPT instruction was executed in debug monitor mode.

If the Cortex-M3 SLEEPONEXIT functionality is used and the concerned interrupt service routine (ISR) contains only a single instruction, the core becomes frozen. This freezing may occur if only one interrupt is active and it is preempted by an interrupt whose handler only contains a single instruction.However, any new interrupt that causes a preemption would cause the core to become unfrozen and behave correctly again.

This scenario does not happen in real application systems since all enabled ISRs should at least contain one instruction. Therefore, if an empty ISR is used, then insert an NOP or any other instruction before the exit instruction (BX or BLX).

If an interrupt occurs during the data-phase of a single word load to the stack-pointer (SP/R13), erroneous behavior can occur. In all cases, returning from the interrupt results in the load instruction being executed an additional time. For all instructions performing an update to the base register, the base register is erroneously updated on each execution, resulting in the stack-pointer being loaded from an incorrect memory location.

If an SVC exception is generated by executing the SVC instruction while the following instruction fetch is faulted, then the MemManage or BusFault handler may be entered even though the faulted instruction which followed the SVC should not have been executed.

A workaround is only required if the SVC handler does not return to the return address that has been stacked for the SVC exception and the instruction access after the SVC faults. If this is the case then padding can be inserted between the SVC and the faulting area of code, for example, by inserting NOP instructions. 

A low-amplitude voltage glitch may be generated (on ADC input 0) on the PA0 pin, when the ADC is converting with injection trigger. It is generated by internal coupling and synchronized to the beginning and the end of the injection sequence, whatever the channel(s) to be converted.

The glitch amplitude is less than 150 mV with a typical duration of 10 ns (measured with the I/O configured as high-impedance input and left unconnected). If PA0 is used as a digital output, this has no influence on the signal. If PA0 is used has a digital input, it is not detected as a spurious transition, providing that PA0 is driven with an impedance lower than 5 k. This glitch does not have any influence on the remaining port A pin or on the ADC conversion injection results, in single ADC configuration.

When using the ADC in dual mode with injection trigger, and in order to avoid any side effect, it is advised to distribute the analog channels so that Channel 0 is configured as an injected channel.

If a WFI/WFE instruction is executed during a Flash memory access and the Sleep duration is very short (less than 2 clock cycles), the instruction fetch from the Flash memory may be corrupted on the next wakeup event.

When using the Flash memory with two wait states and prefetch on, the FLITF clock must not be stopped during the Sleep mode – the FLITFEN bit in the RCC_AHBENR register must be set (keep the reset value).

The DBGMCU_IDCODE and DBGMCU_CR debug registers are accessible only in debug mode (not accessible by the user software). When these registers are read in user mode, the returned value is 0x00.

However, if the application software uses the WFE instruction to enter Stop mode, after wakeup some instructions could be missed if the WFE is followed by sequential instructions. This affects only Stop debug mode with WFE entry.

The various wakeup sources are logically OR-ed in front of the rising-edge detector which generates the wakeup flag (WUF). The WUF flag needs to be cleared prior to the Standby mode entry, otherwise the MCU wakes up immediately. 

If one of the configured wakeup sources is kept high during the clearing of WUF flag (by setting the CWUF bit), it may mask further wakeup events on the input of the edge detector. As a consequence, the MCU could not be able to wake up from Standby mode. 

Be aware that, when applying this workaround, if one of the wakeup sources is still kept high, the MCU enters the Standby mode, but then it wakes up immediately generating the power reset. 

The LSE (Low Speed External) oscillator system has been designed to minimize the overall power consumption of the STM32F1 microcontroller. It is extremely important to take specific care in the design of the PCB to ensure this low power oscillator starts in harsh conditions. In some PCB designs without coating, an induced low leakage may prevent the LSE to start-up, regardless of the 32.768 KHz crystal used. This phenomenon is amplified in humid environments that create frost on the OSC32_IN/OSC32_OUT tracks. This unwanted behavior may happen only at the first back-up domain power-on of the device. 

It is recommended to mount an additional parallel feedback resistor (from 16 MΩ to 22 MΩ) on board to help the oscillation start-up in all cases (see Figure 1). For more details on compatible crystals and hardware techniques on PCB, refer to AN2867 application note.

When USART1_RTS is used, the CAN must be remapped to either another IO configuration when the CAN is used, or to the unused configuration (CAN_REMAP[1:0] set to “01”) when the CAN is not used.

USART2 cannot be used in synchronous mode (USART2_CK signal) if SPI1 is used in master mode and SP1_NSS is configured in software mode. In this case USART2_CK is not output on the pin.

USART3 cannot be used in synchronous mode (USART3_CK signal) if SPI2 is used in master mode and SP2_NSS is configured in software mode. In this case USART3_CK is not output on the pin.

In these cases the I/O port pin PB5 is set to 1 by default if the I/O alternate function output is selected and I2C1 is clocked. TIM3_CH2 cannot be used in output mode.

In USART receive-mode-only communication (TE = 0 in the USARTx_CR1 register), even when the USARTx_TX pin is not being used, the corresponding I/O port pin cannot be used to output another alternate function (in this mode the USARTx_TX output is set to 1 and thus no other alternate function output can be used).

Do not use the corresponding I/O port of the USARTx_TX pin in alternate function output mode. Only the input mode can be used (TE bit in the USARTx_CR1 has to be cleared).

PVD and USB Wakeup, which are internally linked to EXTI line16 and EXTI line18, respectively, cannot be used as event sources for the Cortex-M3 core. As a consequence, these signals cannot be used to exit the Sleep or the Stop mode (exit WFE).

Compilers with improved optimizations for the STM32F10xxx have been recently released on the market. Revisions Z and B of the medium-density STM32F10xxx devices (STM32F10xx8/B) do not support some of the sequences associated with the high-level optimizations done in these compilers. Revision Y and 1 are not affected by this limitation.

This behavior is fully deterministic, and should be detected during firmware development or the validation phase. Consequently, systems already developed, validated and delivered to the field with previous silicon revisions are not affected.

After the “capture IR” state of the boundary scan TAP, the two least significant bits in the instruction register should be loaded with “01” for them to be shifted out whenever a next 

The data shifted out, after the capture IR state, in the boundary scan flow should therefore be ignored and the software should check not only the two least significant bits (XXX01) but all register bits (XXXXX).

When the STRT bit in the Flash memory control register is set (to launch an erase operation), the BSY bit in the Flash memory status register goes high one cycle later.

When it is not possible to manage the EV7, EV7_1, EV6_1, EV6_3, EV2, EV8, and EV3 events before the current byte transfer and before the acknowledge pulse when changing the ACK control bit, it is recommended to:

If the user software is not able to read the data N-1 before the STOP condition is generated on the bus, the content of the shift register (data N) is corrupted (data N is shifted 1-bit to the left).

Stretch the SCL line by configuring SCL I/O as a general purpose I/O, open-drain output low level, before the SET STOP in sequence 1 and before the READ Data N-2 in séquence 2. Then configure back the SCL I/O as alternate function open-drain after the READ Data N-1. The sequences become:

Mask all active interrupts between the SET STOP and the READ data N-1 for sequence 1; and between the READ data N-2, the SET STOP and the READ data N-1 for Sequence 2.

If a void message is received (START condition immediately followed by a STOP): the BERR (bus error) flag is not set, and the I2C peripheral is not able to send a start condition on the bus after the write to the START bit in the I2C_CR2 register.

In the other cases of a misplaced STOP, the BERR flag is set. If the START bit is already set in I2C_CR2, the START condition is not correctly generated on the bus and can create bus errors.

In the I²C standard, it is allowed to send a Stop only at the end of the full byte (8 bits + acknowledge), so this scenario is not allowed. Other derived protocols like CBUS allow it, but they are not supported by the I²C peripheral.

In case of a noisy environment in which unwanted bus errors can occur, it is recommended to implement a timeout to ensure that after the START control bit is set, the SB (start bit) flag is set. In case the timeout has elapsed, the peripheral must be reset by setting the SWRST bit in the I2C_CR2 control register. It should also be reset in the same way if a BERR is detected while the START bit is set in I2C_CR2.

In case of a repeated Start, the “Setup time for a repeated Start condition” (named Tsu;sta in the I²C specification) can be slightly violated when the I²C operates in Master Standard mode at a frequency between 88 kHz and 100 kHz.

–If the slave does not stretch the clock and the SCL rise time is more than 300 ns (if the SCL rise time is less than 300 ns the issue cannot occur)

The data valid time (tVD;DAT, tVD;ACK) described by the I²C standard can be violated (as well as the maximum data hold time of the current data (tHD;DAT)) under the conditions described below. Moreover, if the data register is written too late and close to the SCL rising edge, an error can be generated on the bus (SDA toggles while SCL is high). These violations cannot be detected because the OVR flag is not set (no transmit buffer underrun is detected).

If the master device does not allow it, ensure that the software writes to the data register fast enough after TXE or ADDR events. For instance, use an interrupt on the TXE or ADDR flag and boost its priority to the higher level, or use DMA. Use this "NOSTRETCH" mode with a slow I2C bus speed.

Note:The first data byte to transmit must be written in the data register after the ADDR flag is cleared, and before the next SCL rising edge, so that the time window for writing the first data byte in the data register is less than tLOW.

The I2C analog filters embedded in the I2C I/Os may be tied to low level, whereas SCL and SDA lines are kept at high level. This can occur after an MCU power-on reset, or during ESD stress. Consequently, the I2C BUSY flag is set, and the I2C cannot enter master mode (START condition cannot be sent). The I2C BUSY flag cannot be cleared by the SWRST control bit, nor by a peripheral or a system reset. BUSY bit is cleared under reset, but it is set high again as soon as the reset is released, because the analog filter output is still at low level. This issue occurs randomly. 

Note:Under the same conditions, the I2C analog filters may also provide a high level, whereas SCL and SDA lines are kept to low level. This should not create issues as the filters output is correct after next SCL and SDA transition. 

The SCL and SDA analog filter output is updated after a transition occurs on the SCL and SDA line respectively. The SCL and SDA transition can be forced by software configuring the I2C I/Os in output mode. Then, once the analog filters are unlocked and output the SCL and SDA lines level, the BUSY flag can be reset with a software reset, and the I2C can enter master mode. Therefore, the following sequence must be applied: 

When the SPI is configured in slave mode with the CRC feature enabled, the CRC is calculated even if the NSS pin deselects the SPI (high level applied on the NSS pin).

The CRC has to be cleared on both Master and Slave sides between the slave deselection (high level on NSS) and the slave selection (low level on NSS), in order to resynchronize the Master and Slave for their respective CRC calculation.

The parity error flag (PE) is set at the end of the last data bit. It should be cleared by software by making a read access to the status register followed by reading the data in the data register.

Once the PE flag is set by hardware, if it is cleared by software before the middle of the stop bit, it is set again. Consequently, the software may jump several times to the same interrupt routine for the same parity error.

If the USART receives an idle frame followed by a character, and the clock of the transmitter device is faster than the USART receiver clock, the USART receive signal falls too early when receiving the character start bit, with the result that the idle frame is not detected (IDLE flag is not set).

In full duplex mode, when the Parity Error flag is set by the receiver at the end of a reception, it may be cleared while transmitting by reading the USART_SR register to check the TXE or TC flags and writing data in the data register.

The USART receiver is in Mute mode and is configured to exit the Mute mode using the address mark detection. When the USART receiver recognizes a valid address with a parity error, it exits the Mute mode without setting the Parity Error flag.

When CTS hardware flow control is enabled (CTSE = 1) and the Send Break bit (SBK) is set, the transmitter sends a break frame at the end of current transmission regardless of nCTS input line status.

When RTS hardware flow control is enabled, the nRTS signal goes high when a data is received. If this data was not read and a new data is sent to the USART (protocol violation), the nRTS signal goes back to low level at the end of this new data.

Note:These workarounds are needed only if the other UART device has violated the protocol. In most systems (no limitation on the other device), the USART works fine and no workaround is needed.

Workaround 1: After data reception and before reading the data in the data register, the software takes control of the nRTS pin using the GPIO registers and keeps it high as long as needed. If the application knows the USART is not ready and that further data received reception from the other device may be discarded, it keeps the nRTS pin at high level. It then releases the nRTS pin when the USART is ready to continue reception.

Workaround 2: Ensure that the received data is always read in a time window less than the duration of the 2nd data reception. One solution would be to handle all data reception by DMA.

In capture mode, when a capture occurs while the CCRx register is being read, the capture flag (CCxIF) may be cleared without the overcapture flag (CCxOF) being set. The new data are actually captured in the capture register.

An external interrupt can be enabled on the capture I/O just before reading the capture register (in the capture interrupt), and disabled just after reading the captured data. Possibly, a missed capture is detected by the EXTI peripheral.

If a capture occurs while the capture register is being read, an overcapture is detected even though the previously captured data are correctly read and the new data are correctly stored into the capture register.

When the OCREF_CLR functionality is activated, the OCxREF signal becomes de-asserted (and consequently OCx is deasserted / OCxN is asserted) when a high level is applied on the OCREF_CLR signal. The PWM then restarts (output re-enabled) at the next counter overflow.

The RVU and PVU flags in the IWDG_SR register are set by hardware after a write access to the IWDG_RLR or the IWDG_PR registers, respectively. If MCU enters Stop mode immediately after the write access, the RVU and PVU flags are not cleared by hardware. Consequently the next time the application attempts to write to the IWDG_RLR or the IWDG_PR registers, it waits in an infinite loop for the RVU and PVU flags to be cleared and the IWDG generates a reset after the programmed time-out period. 

It may however happen that, when OUT transactions are sent by the Host with a data payload size exactly equal to the maximum packet size already programmed in the COUNTn_RX packet buffer memory (via the BLSIZE and NUM_BLOCK[4:0] fields), the packet and all bytes from the Host are correctly received and stored into the packet buffer memory, but, the COUNTn_RX[9:0] field indicates an incorrect number (one byte less).

This limitation concerns applications that check the exact number of bytes received in the packet buffer memory. In order to avoid that these applications interpret a Host error and so, stall the OUT endpoint even if no data reception error actually occurred, it is recommended to:

Figure 2, Figure 3, Figure 4, Figure 5 and Figure 6 show the marking compositions for the LFBGA100, LQFP100, LQFP64, LQFP48 and VFQFPN36 / VFQFPN48 packages, respectively. Only the additional field containing the Revision code is shown.

The errata sheet also applies to Revision Y devices.Section 2.1: PD0 and PD1 use in output mode, Section 2.2: ADC auto-injection channel and Section 2.3: ADC combined injected simultaneous+interleaved removed from errata sheet.Section 2.3: Debug registers cannot be read by user software on page 13 added. Small text changes.

This errata sheet also applies to STM32F102xx medium-density devices. Though medium-density devices with 32 Kbyte of Flash were removed, the errata sheet still applies to devices whose commercial code does not contain an “A”.Section 2.11: Compatibility issue with latest compiler releases added.Figure 2: LFBGA100 package top view added. Figure 4: LQFP64 package top view and Figure 5: LQFP48 package top view corrected.

Section 1: Arm® 32-bit Cortex®-M3 limitations specified (Table 3: Cortex-M3 core limitations and impact on microcontroller behavior added limitations described).Added limitations:– Boundary scan TAP: wrong pattern sent out after the “capture IR” state– Flash memory BSY bit delay versus STRT bit setting– I2C peripheral – Timers– LSI clock stabilization timeTable 4: Summary of silicon limitations on page 11 added.

STMicroelectronics NV and its subsidiaries (“ST”) reserve the right to make changes, corrections, enhancements, modifications, and improvements to ST products and/or to this document at any time without notice. Purchasers should obtain the latest relevant information on ST products before placing orders. ST products are sold pursuant to ST’s terms and conditions of sale in place at the time of order acknowledgment.

ST and the ST logo are trademarks of ST. For additional information about ST trademarks, please refer to www.st.com/trademarks. All other product or service names are the property of their respective owners.
This datasheet provides the ordering information and mechanical device characteristics of the STM32F103x8 and STM32F103xB medium-density performance line microcontrollers. For more details on the whole STMicroelectronics STM32F103xx family, please refer to Section 2.2: Full compatibility throughout the family.

The medium-density STM32F103xx datasheet should be read in conjunction with the low-, medium- and high-density STM32F10xxx reference manual. The reference and Flash programming manuals are both available from the STMicroelectronics website www.st.com.

The STM32F103xx medium-density performance line family incorporates the high-performance ARM® Cortex®-M3 32-bit RISC core operating at a 72 MHz frequency, high-speed embedded memories (Flash memory up to 128 Kbytes and SRAM up to 20 Kbytes), and an extensive range of enhanced I/Os and peripherals connected to two APB buses. All devices offer two 12-bit ADCs, three general purpose 16-bit timers plus one PWM timer, as well as standard and advanced communication interfaces: up to two I2Cs and SPIs, three USARTs, an USB and a CAN. 

The devices operate from a 2.0 to 3.6 V power supply. They are available in both the –40 to +85 °C temperature range and the –40 to +105 °C extended temperature range. A comprehensive set of power-saving mode allows the design of low-power applications.

The STM32F103xx medium-density performance line family includes devices in six different package types: from 36 pins to 100 pins. Depending on the device chosen, different sets of peripherals are included, the description below gives an overview of the complete range of peripherals proposed in this family.

These features make the STM32F103xx medium-density performance line microcontroller family suitable for a wide range of applications such as motor drives, application control, medical and handheld equipment, PC and gaming peripherals, GPS platforms, industrial applications, PLCs, inverters, printers, scanners, alarm systems, video intercoms, and HVACs.

The STM32F103xx is a complete family whose members are fully pin-to-pin, software and feature compatible. In the reference manual, the STM32F103x4 and STM32F103x6 are identified as low-density devices, the STM32F103x8 and STM32F103xB are referred to as medium-density devices, and the STM32F103xC, STM32F103xD and STM32F103xE are referred to as high-density devices.

Low- and high-density devices are an extension of the STM32F103x8/B devices, they are specified in the STM32F103x4/6 and STM32F103xC/D/E datasheets, respectively. Low-density devices feature lower Flash memory and RAM capacities, less timers and peripherals. High-density devices have higher Flash memory and RAM capacities, and additional peripherals like SDIO, FSMC, I2S and DAC, while remaining fully compatible with the other members of the STM32F103xx family.

The STM32F103x4, STM32F103x6, STM32F103xC, STM32F103xD and STM32F103xE are a drop-in replacement for STM32F103x8/B medium-density devices, allowing the user to try different memory densities and providing a greater degree of freedom during the development cycle.

The ARM® Cortex®-M3 processor is the latest generation of ARM processors for embedded systems. It has been developed to provide a low-cost platform that meets the needs of MCU implementation, with a reduced pin count and low-power consumption, while delivering outstanding computational performance and an advanced system response to interrupts.

Among other applications, CRC-based techniques are used to verify data transmission or storage integrity. In the scope of the EN/IEC 60335-1 standard, they offer a means of verifying the Flash memory integrity. The CRC calculation unit helps compute a signature of the software during runtime, to be compared with a reference signature generated at link-time and stored at a given memory location.

The STM32F103xx performance line embeds a nested vectored interrupt controller able to handle up to 43 maskable interrupt channels (not including the 16 interrupt lines of Cortex®-M3) and 16 priority levels.

The external interrupt/event controller consists of 19 edge detector lines used to generate interrupt/event requests. Each line can be independently configured to select the trigger event (rising edge, falling edge, both) and can be masked independently. A pending register maintains the status of the interrupt requests. The EXTI can detect an external line with a pulse width shorter than the Internal APB2 clock period. Up to 80 GPIOs can be connected to the 16 external interrupt lines.

System clock selection is performed on startup, however the internal RC 8 MHz oscillator is selected as default CPU clock on reset. An external 4-16 MHz clock can be selected, in which case it is monitored for failure. If failure is detected, the system automatically switches back to the internal RC oscillator. A software interrupt is generated if enabled. Similarly, full interrupt management of the PLL clock entry is available when necessary (for example on failure of an indirectly used external crystal, resonator or oscillator).

Several prescalers allow the configuration of the AHB frequency, the high-speed APB (APB2) and the low-speed APB (APB1) domains. The maximum frequency of the AHB and the high-speed APB domains is 72 MHz. The maximum allowed frequency of the low-speed APB domain is 36 MHz. See Figure 2 for details on the clock tree.


• VSSA, VDDA = 2.0 to 3.6 V: external analog power supplies for ADC, reset blocks, RCs and PLL (minimum voltage to be applied to VDDA is 2.4 V when the ADC is used). VDDA and VSSA must be connected to VDD and VSS, respectively.

The device features an embedded programmable voltage detector (PVD) that monitors the VDD/VDDA power supply and compares it to the VPVD threshold. An interrupt can be generated when VDD/VDDA drops below the VPVD threshold and/or when VDD/VDDA is higher than the VPVD threshold. The interrupt service routine can then generate a warning message and/or put the MCU into a safe state. The PVD is enabled by software. 


• Power down is used in Standby mode: the regulator output is in high impedance: the kernel circuitry is powered down, inducing zero consumption (but the contents of the registers and SRAM are lost)

The Stop mode achieves the lowest power consumption while retaining the content of SRAM and registers. All clocks in the 1.8 V domain are stopped, the PLL, the HSI RC and the HSE crystal oscillators are disabled. The voltage regulator can also be put either in normal or in low-power mode.  The device can be woken up from Stop mode by any of the EXTI line. The EXTI line source can be one of the 16 external lines, the PVD output, the RTC alarm or the USB wakeup. 

The Standby mode is used to achieve the lowest power consumption. The internal voltage regulator is switched off so that the entire 1.8 V domain is powered off. The PLL, the HSI RC and the HSE crystal oscillators are also switched off. After entering Standby mode, SRAM and register contents are lost except for registers in the Backup domain and Standby circuitry. 

The flexible 7-channel general-purpose DMA is able to manage memory-to-memory, peripheral-to-memory and memory-to-peripheral transfers. The DMA controller supports circular buffer management avoiding the generation of interrupts when the controller reaches the end of the buffer.

Each channel is connected to dedicated hardware DMA requests, with support for software trigger on each channel. Configuration is made by software and transfer sizes between source and destination are independent.

The RTC and the backup registers are supplied through a switch that takes power either on VDD supply when present or through the VBAT pin. The backup registers are ten 16-bit registers used to store 20 bytes of user application data when VDD power is not present.

The real-time clock provides a set of continuously running counters which can be used with suitable software to provide a clock calendar function, and provides an alarm interrupt and a periodic interrupt. It is clocked by a 32.768 kHz external crystal, resonator or oscillator, the internal low-power RC oscillator or the high-speed external clock divided by 128. The internal low-power RC has a typical frequency of 40 kHz. The RTC can be calibrated using an external 512 Hz output to compensate for any natural crystal deviation. The RTC features a 32-bit programmable counter for long-term measurement using the Compare register to generate an alarm. A 20-bit prescaler is used for the time base clock and is by default configured to generate a time base of 1 second from a clock at 32.768 kHz. 

The advanced-control timer (TIM1) can be seen as a three-phase PWM multiplexed on 6 channels. It has complementary PWM outputs with programmable inserted dead-times. It can also be seen as a complete general-purpose timer. The 4 independent channels can be used for

Many features are shared with those of the general-purpose TIM timers which have the same architecture. The advanced-control timer can therefore work together with the TIM timers via the Timer Link feature for synchronization or event chaining. 

There are up to three synchronizable general-purpose timers embedded in the STM32F103xx performance line devices. These timers are based on a 16-bit auto-reload up/down counter, a 16-bit prescaler and feature 4 independent channels each for input capture/output compare, PWM or one-pulse mode output. This gives up to 12 input captures/output compares/PWMs on the largest packages. The general-purpose timers can work together with the advanced-control timer via the Timer Link feature for synchronization or event chaining. Their counter can be frozen in debug mode. Any of the general-purpose timers can be used to generate PWM outputs. They all have independent DMA request generation.

The independent watchdog is based on a 12-bit downcounter and 8-bit prescaler. It is clocked from an independent 40 kHz internal RC and as it operates independently of the main clock, it can operate in Stop and Standby modes. It can be used either as a watchdog to reset the device when a problem occurs, or as a free-running timer for application timeout management. It is hardware- or software-configurable through the option bytes. The counter can be frozen in debug mode.

The window watchdog is based on a 7-bit downcounter that can be set as free-running. It can be used as a watchdog to reset the device when a problem occurs. It is clocked from the main clock. It has an early warning interrupt capability and the counter can be frozen in debug mode.

One of the USART interfaces is able to communicate at speeds of up to 4.5 Mbit/s. The other available interfaces communicate at up to 2.25 Mbit/s. They provide hardware management of the CTS and RTS signals, IrDA SIR ENDEC support, are ISO 7816 compliant and have LIN Master/Slave capability.

Up to two SPIs are able to communicate up to 18 Mbits/s in slave and master modes in full-duplex and simplex communication modes. The 3-bit prescaler gives 8 master mode frequencies and the frame is configurable to 8 bits or 16 bits. The hardware CRC generation/verification supports basic SD Card/MMC modes. 

The CAN is compliant with specifications 2.0A and B (active) with a bit rate up to 1 Mbit/s. It can receive and transmit standard frames with 11-bit identifiers as well as extended frames with 29-bit identifiers. It has three transmit mailboxes, two receive FIFOs with 3 stages and 14 scalable filter banks.

The STM32F103xx performance line embeds a USB device peripheral compatible with the USB full-speed 12 Mbs. The USB interface implements a full-speed (12 Mbit/s) function interface. It has software-configurable endpoint setting and suspend/resume support. The dedicated 48 MHz clock is generated from the internal main PLL (the clock source must use a HSE crystal oscillator).

Each of the GPIO pins can be configured by software as output (push-pull or open-drain), as input (with or without pull-up or pull-down) or as peripheral alternate function. Most of the GPIO pins are shared with digital or analog alternate functions. All GPIOs are high current-capable.

Two 12-bit analog-to-digital converters are embedded into STM32F103xx performance line devices and each ADC shares up to 16 external channels, performing conversions in single-shot or scan modes. In scan mode, automatic conversion is performed on a selected group of analog inputs.

An analog watchdog feature allows very precise monitoring of the converted voltage of one, some or all selected channels. An interrupt is generated when the converted voltage is outside the programmed thresholds.

The events generated by the general-purpose timers (TIMx) and the advanced-control timer (TIM1) can be internally connected to the ADC start trigger, injection trigger, and DMA trigger respectively, to allow the application to synchronize A/D conversion and timers.

The temperature sensor has to generate a voltage that varies linearly with temperature. The conversion range is between 2 V < VDDA < 3.6 V. The temperature sensor is internally connected to the ADC12_IN16 input channel which is used to convert the sensor output voltage into a digital value.

The ARM SWJ-DP Interface is embedded. and is a combined JTAG and serial wire debug port that enables either a serial wire debug or a JTAG probe to be connected to the target. The JTAG TMS and TCK pins are shared with SWDIO and SWCLK, respectively, and a specific sequence on the TMS pin is used to switch between JTAG-DP and SW-DP.

Unless otherwise specified the minimum and maximum values are guaranteed in the worst conditions of ambient temperature, supply voltage and frequencies by tests in production on 100% of the devices with an ambient temperature at TA = 25 °C and TA = TAmax (given by the selected temperature range).

Data based on characterization results, design simulation and/or technology characteristics are indicated in the table footnotes and are not tested in production. Based on characterization, the minimum and maximum values refer to sample tests and represent the mean value plus or minus three times the standard deviation (mean±3σ).

Unless otherwise specified, typical data are based on TA = 25 °C, VDD = 3.3 V (for the 2 V ≤  VDD ≤  3.6 V voltage range). They are given only as design guidelines and are not tested.

Typical ADC accuracy values are determined by characterization of a batch of samples from a standard diffusion lot over the full temperature range, where 95% of the devices have an error less than or equal to the value indicated (mean±2σ).

Stresses above the absolute maximum ratings listed in Table 6: Voltage characteristics, Table 7: Current characteristics, and Table 8: Thermal characteristics may cause permanent damage to the device. These are stress ratings only and functional operation of the device at these conditions is not implied. Exposure to maximum rating conditions for extended periods may affect device reliability.

The current consumption is a function of several parameters and factors such as the operating voltage, ambient temperature, I/O pin loading, device software configuration, operating frequencies, I/O pin switching rate, program location in memory and executed binary code. The current consumption is measured as described in Figure 15: Current consumption measurement scheme. All Run-mode current consumption measurements given in this section are performed with a reduced code that gives a consumption equivalent to Dhrystone 2.1 code.


• The Flash memory access time is adjusted to the fHCLK frequency (0 wait state from 0 to 24 MHz, 1 wait state from 24 to 48 MHz and 2 wait states above)

The high-speed external (HSE) clock can be supplied with a 4 to 16 MHz crystal/ceramic resonator oscillator. All the information given in this paragraph are based on characterization results obtained with typical external components specified in Table 22. In the application, the resonator and the load capacitors have to be placed as close as possible to the oscillator pins in order to minimize output distortion and startup stabilization time. Refer to the crystal resonator manufacturer for more details on the resonator characteristics (frequency, package, accuracy).

For CL1 and CL2, it is recommended to use high-quality external ceramic capacitors in the 5 pF to 25 pF range (typ.), designed for high-frequency applications, and selected to match the requirements of the crystal or resonator (see Figure 24). CL1 and CL2 are usually the same size. The crystal manufacturer typically specifies a load capacitance which is the series combination of CL1 and CL2. PCB and MCU pin capacitance must be included (10 pF can be used as a rough estimate of the combined pin and board capacitance) when sizing CL1 and CL2. Refer to the application note AN2867 “Oscillator design guide for ST microcontrollers” available from the ST website www.st.com.

The low-speed external (LSE) clock can be supplied with a 32.768 kHz crystal/ceramic resonator oscillator. All the information given in this paragraph are based on characterization results obtained with typical external components specified in Table 23. In the application, the resonator and the load capacitors have to be placed as close as possible to the oscillator pins in order to minimize output distortion and startup stabilization time. Refer to the crystal resonator manufacturer for more details on the resonator characteristics (frequency, package, accuracy).

Note:For CL1 and CL2 it is recommended to use high-quality ceramic capacitors in the 5 pF to 15 pF range selected to match the requirements of the crystal or resonator. CL1 and CL2, are usually the same size. The crystal manufacturer typically specifies a load capacitance which is the series combination of CL1 and CL2. Load capacitance CL has the following formula: CL = CL1 x CL2 / (CL1 + CL2) + Cstray where Cstray is the pin capacitance and board or trace PCB-related capacitance. Typically, it is between 2 pF and 7 pF.

Caution:To avoid exceeding the maximum value of CL1 and CL2 (15 pF) it is strongly recommended to use a resonator with a load capacitance CL ≤  7 pF. Never use a resonator with a load capacitance of 12.5 pF. Example: if you choose a resonator with a load capacitance of CL = 6 pF, and Cstray = 2 pF, then CL1 = CL2 = 8 pF.

The wakeup times given in Table 26 is measured on a wakeup phase with a 8-MHz HSI RC oscillator. The clock source used to wake up the device depends from the current operating mode:

While a simple application is executed on the device (toggling 2 LEDs through I/O ports). the device is stressed by two electromagnetic events until a failure occurs. The failure is indicated by the LEDs:


• FTB: A Burst of Fast Transient voltage (positive and negative) is applied to VDD and VSS through a 100 pF capacitor, until a functional disturbance occurs. This test is compliant with the IEC 61000-4-4 standard.

EMC characterization and optimization are performed at component level with a typical application environment and simplified MCU software. It should be noted that good EMC performance is highly dependent on the user application and the software in particular.

Most of the common failures (unexpected reset and program counter corruption) can be reproduced by manually forcing a low state on the NRST pin or the Oscillator pins for 1 second.

To complete these trials, ESD stress can be applied directly on the device, over the range of specification values. When unexpected behavior is detected, the software can be hardened to prevent unrecoverable errors occurring (see application note AN1015).

The electromagnetic field emitted by the device are monitored while a simple application is executed (toggling 2 LEDs through the I/O ports). This emission test is compliant with IEC 61967-2 standard which specifies the test board and the pin loading.

Electrostatic discharges (a positive then a negative pulse separated by 1 second) are applied to the pins of each sample according to each pin combination. The sample size depends on the number of supply pins in the device (3 parts × (n+1) supply pins). This test conforms to the JESD22-A114/C101 standard.

As a general rule, current injection to the I/O pins, due to external voltage below VSS or above VDD (for standard, 3 V-capable I/O pins) should be avoided during normal product operation. However, in order to give an indication of the robustness of the microcontroller in cases when abnormal injection accidentally happens, susceptibility tests are performed on a sample basis during device characterization.

While a simple application is executed on the device,  the device is stressed by injecting current into the I/O pins programmed in floating input mode. While current is injected into the I/O pin, one at a time, the device is checked for functional failures. 

The failure is indicated by an out of range parameter: ADC error above a certain limit (>5 LSB TUE), out of spec current injection on adjacent pins or other functional failure (for example reset, oscillator frequency deviation). 

All I/Os are CMOS and TTL compliant (no software configuration required). Their characteristics cover more than the strict CMOS-technology or TTL parameters. The coverage of these requirements is shown in Figure 26 and Figure 27 for standard I/Os, and in Figure 28 and Figure 29 for 5 V tolerant I/Os. 

The GPIOs (general-purpose inputs/outputs) can sink or source up to ±8 mA, and sink or source up to ±20 mA (with a relaxed VOL/VOH) except PC13, PC14 and PC15 which can sink or source up to +/-3mA. When using the GPIOs PC13 to PC15 in output mode, the speed should not exceed 2 MHz with a maximum load of 30 pF.


• The sum of the currents sourced by all the I/Os on VDD, plus the maximum Run consumption of the MCU sourced on VDD, cannot exceed the absolute maximum rating IVDD (see Table 7). 


• The sum of the currents sunk by all the I/Os on VSS plus the maximum Run consumption of the MCU sunk on VSS cannot exceed the absolute maximum rating IVSS (see Table 7). 

Unless otherwise specified, the parameters given in Table 36 are derived from tests performed under ambient temperature and VDD supply voltage conditions summarized in Table 9. All I/Os are CMOS and TTL compliant.

The STM32F103xx performance line I2C interface meets the requirements of the standard I2C communication protocol with the following restrictions: the I/O pins SDA and SCL are mapped to are not “true” open-drain. When configured as open-drain, the PMOS connected between the I/O pin and VDD is disabled, but is still present.

Power supply decoupling should be performed as shown in Figure 39 or Figure 40, depending on whether VREF+ is connected to VDDA or not. The 10 nF capacitors should be ceramic (good quality). They should be placed them as close as possible to the chip.

In order to meet environmental requirements, ST offers these devices in different grades of ECOPACK® packages, depending on their level of environmental compliance. ECOPACK® specifications, grade definitions and product status are available at: www.st.com. ECOPACK® is an ST trademark.

          Table 51. VFQFPN36 - 36-pin, 6x6 mm, 0.5 mm pitch very thin profile fine pitch quad  flat package mechanical data 

          Table 53. LFBGA100 – 100-ball low-profile fine pitch ball grid array, 10 x 10 mm,0.8 mm pitch, package mechanical data 

          Table 56. UFBGA100 - 100-ball, 7 x 7 mm, 0.50 mm pitch, ultra fine pitch ball grid arraypackage mechanical data 

          Table 59. TFBGA64 – 64-ball, 5 x 5 mm, 0.5 mm pitch, thin profile fine pitch ball gridarray package mechanical data 

As applications do not commonly use the STM32F103xx at maximum dissipation, it is useful to calculate the exact power consumption and junction temperature to determine which temperature range will be best suited to the application.

Maximum ambient temperature TAmax = 82 °C (measured according to JESD51-2), IDDmax = 50 mA, VDD = 3.5 V, maximum 20 I/Os used at the same time in output at low level with IOL = 8 mA, VOL= 0.4 V and maximum 8 I/Os used at the same time in output at low level with IOL = 20 mA, VOL= 1.3 V

Using the same rules, it is possible to address applications that run at high ambient temperatures with a low dissipation, as long as junction temperature TJ remains within the specified range.

Maximum ambient temperature TAmax = 115 °C (measured according to JESD51-2), IDDmax = 20 mA, VDD = 3.5 V, maximum 20 I/Os used at the same time in output at low level with IOL = 8 mA, VOL= 0.4 V

Flash memory size modified in Note 9, Note 5, Note 7, Note 7 and BGA100 pins added to Table 5: Medium-density STM32F103xx pin definitions. Figure 3: STM32F103xx performance line LFBGA100 ballout added.THSE changed to TLSE in Figure 23: Low-speed external clock source AC timing diagram. VBAT ranged modified in Power supply schemes.tSU(LSE) changed to tSU(HSE) in Table 22: HSE 4-16 MHz oscillator characteristics. IDD(HSI) max value added to Table 24: HSI oscillator characteristics.Sample size modified and machine model removed in Electrostatic discharge (ESD).Number of parts modified and standard reference updated in Static latch-up. 25 °C and 85 °C conditions removed and class name modified in Table 33: Electrical sensitivities. RPU and RPD min and max values added to Table 35: I/O static characteristics. RPU min and max values added to Table 38: NRST pin characteristics.Figure 32: I2C bus AC waveforms and measurement circuit and Figure 31: Recommended NRST pin protection corrected.Notes removed below Table 9, Table 38, Table 44.IDD typical values changed in Table 11: Maximum current consumption in Run and Sleep modes. Table 39: TIMx characteristics modified.tSTAB, VREF+ value, tlat and fTRIG added to Table 46: ADC characteristics.In Table  : , typical endurance and data retention for TA = 85 °C added, data retention for TA = 25 °C removed.VBG changed to VREFINT in Table 12: Embedded internal reference voltage. Document title changed. Controller area network (CAN) section modified.Figure 14: Power supply scheme modified.Features on page 1 list optimized. Small text changes.

Document status promoted from preliminary data to datasheet. The STM32F103xx is USB certified. Small text changes. Power supply schemes on page 15 modified. Number of communication peripherals corrected for STM32F103Tx and number of GPIOs corrected for LQFP package in Table 2: STM32F103xx medium-density device features and peripheral counts. Main function and default alternate function modified for PC14 and PC15 in, Note 6 added and Remap column added in Table 5: Medium-density STM32F103xx pin definitions. VDD–VSS ratings and Note 1 modified in Table 6: Voltage characteristics, Note 1 modified in Table 7: Current characteristics. Note 1 and Note 2 added in Table 11: Embedded reset and power control block characteristics. IDD value at 72 MHz with peripherals enabled modified in Table 14: Maximum current consumption in Run mode, code with data processing  running from RAM. IDD value at 72 MHz with peripherals enabled modified in Table 15: Maximum current consumption in Sleep mode, code running from Flash or RAM on page 44. IDD_VBAT typical value at 2.4 V modified and IDD_VBAT maximum values added in Table 16: Typical and maximum current consumptions in Stop and Standby modes. Note added in Table 17 on page 48 and Table 18 on page 49. ADC1 and ADC2 consumption and notes modified in Table 19: Peripheral current consumption. tSU(HSE) and tSU(LSE) conditions modified in Table 22 and Table 23, respectively. Maximum values removed from Table 26: Low-power mode wakeup timings. tRET conditions modified in Table  : . Figure 14: Power supply scheme corrected. Figure 20: Typical current consumption in Stop mode with regulator in Low-power mode versus temperature at VDD = 3.3 V and 3.6 V added. Note removed below Figure 33: SPI timing diagram - slave mode and CPHA = 0. Note added below Figure 34: SPI timing diagram - slave mode and CPHA = 1(1). Details on unused pins removed from General input/output characteristics on page 62. Table 42: SPI characteristics updated. Table 43: USB startup time added. VAIN, tlat and tlatr modified, note added and Ilkg removed in Table 46: ADC characteristics. Test conditions modified and note added in Table 49: ADC accuracy. Note added below Table 47 and Table 50. Inch values corrected in Table 55: LQPF100, 14 x 14 mm 100-pin low-profile quad flat package mechanical data, Table 58: LQFP64 - 64-pin, 10 x 10 mm low-profile quad flat package mechanical data and Table 60: LQFP48, 7 x 7 mm, 48-pin low-profile quad flat package mechanical data. ΘJAvalue for VFQFPN36 package added in Table 62: Package thermal characteristics. Order codes replaced by Section 7: Ordering information scheme. MCU ‘s operating conditions modified in Typical current consumption on page 47. Avg_Slope and V25 modified in Table 50: TS characteristics. I2C interface characteristics on page 69 modified. Impedance specified in A.4: Voltage glitch on ADC input 0 on page 81.

Small text changes. Figure 11: Memory map clarified.In Table  : :– NEND tested over the whole temperature range– cycling conditions specified for tRET– tRET min modified at TA = 55 °CV25, Avg_Slope and TL modified in Table 50: TS characteristics.CRC feature removed.

CRC feature added back. Small text changes. Section 1: Introduction modified. Section 2.2: Full compatibility throughout the family added.IDD at TA max = 105 °C added to Table 16: Typical and maximum current consumptions in Stop and Standby modes on page 45.IDD_VBAT removed from Table 21: Typical current consumption in Standby mode on page 47.Values added to Table 41: SCL frequency (fPCLK1= 36 MHz.,VDD_I2C = 3.3 V) on page 70.Figure 33: SPI timing diagram - slave mode and CPHA = 0 on page 72 modified. Equation 1 corrected.tRET at TA = 105 °C modified in Table  :  on page 58. VUSB added to Table 44: USB DC electrical characteristics on page 74. Figure 65: LQFP100 PD max vs. TA on page 107 modified.Axx option added to Table 63: Ordering information scheme on page 108.

Power supply supervisor updated and VDDA added to Table 9: General operating conditions.Capacitance modified in Figure 14: Power supply scheme on page 36.Table notes revised in Section 5: Electrical characteristics.Table 16: Typical and maximum current consumptions in Stop and Standby modes modified.Data added to Table 16: Typical and maximum current consumptions in Stop and Standby modes and Table 21: Typical current consumption in Standby mode removed.fHSE_ext modified in Table 20: High-speed external user clock characteristics on page 51. fPLL_IN modified in Table 27: PLL characteristics on page 57.Minimum SDA and SCL fall time value for Fast mode removed from Table 40: I2C characteristics on page 69, note 1 modified.th(NSS) modified in Table 42: SPI characteristics on page 71 and Figure 33: SPI timing diagram - slave mode and CPHA = 0 on page 72.CADC modified in Table 46: ADC characteristics on page 75 and Figure 38: Typical connection diagram using the ADC modified.Typical TS_temp value removed from Table 50: TS characteristics on page 79.LQFP48 package specifications updated (see Table 60 and Table 64), Section 6: Package information revised.Axx option removed from Table 63: Ordering information scheme on page 108.Small text changes.

I/O information clarified on page 1. Figure 3: STM32F103xx performance line LFBGA100 ballout modified. Figure 11: Memory map modified. Table 4: Timer feature comparison added. PB4, PB13, PB14, PB15, PB3/TRACESWO moved from Default column to Remap column in Table 5: Medium-density STM32F103xx pin definitions.PD for LFBGA100 corrected in Table 9: General operating conditions.Note modified in Table 13: Maximum current consumption in Run mode, code with data processing  running from Flash and Table 15: Maximum current consumption in Sleep mode, code running from Flash or RAM.Table 20: High-speed external user clock characteristics and Table 21: Low-speed external user clock characteristics modified.Figure 20 shows a typical curve (title modified). ACCHSI max values modified in Table 24: HSI oscillator characteristics.TFBGA64 package added (see Table 59 and Table 60). Small text changes.

Updated Figure 53: UFBGA100 - 100-ball, 7 x 7 mm, 0.50 mm pitch, ultra fine pitch ball grid array package outline and Table 56: UFBGA100 - 100-ball, 7 x 7 mm, 0.50 mm pitch, ultra fine pitch ball grid array package mechanical dataUpdated Figure 47: LFBGA100 - 100-ball low-profile fine pitch ball grid array, 10 x10 mm, 0.8 mm pitch, package outline and Table 53: LFBGA100 – 100-ball low-profile fine pitch ball grid array, 10 x 10 mm,  0.8 mm pitch, package mechanical dataUpdated Figure 60: TFBGA64 - 8 x 8 active ball array, 5 x 5 mm, 0.5 mm pitch, package outline and Table 59: TFBGA64 - 8 x 8 active ball array, 5 x 5 mm, 0.5 mm pitch, package mechanical data

Updated the reference for ‘VESD(CDM)’ in Table 32: ESD absolute maximum ratingsCorrected ‘tf(IO)out’ in Figure 30: I/O AC characteristics definitionUpdated Table 52: UFQFPN48 - 48-lead, 7x7 mm, 0.5 mm pitch, ultra thin fine pitch quad flat package mechanical data

Updated Table 3: STM32F103xx family removing the note.Updated Table 63: Ordering information scheme removing the note.Updated Section 6: Package information and added Section : Marking of engineering samples for all packages.Updated I2C characteristics, added tSP parameter and note 4 in Table 40: I2C characteristics.Updated Figure 32: I2C bus AC waveforms and measurement circuit swapping SCLL and SCLH.Updated Figure 33: SPI timing diagram - slave mode and CPHA = 0.Updated min/max value notes replacing ‘Guaranteed by design, not tested in production” by “guaranteed by design”.Updated min/max value notes replacing ‘based on characterization, not tested in production” by “Guaranteed based on test during characterization”.Updated Table 19: Peripheral current consumption.

STMicroelectronics NV and its subsidiaries (“ST”) reserve the right to make changes, corrections, enhancements, modifications, and improvements to ST products and/or to this document at any time without notice. Purchasers should obtain the latest relevant information on ST products before placing orders. ST products are sold pursuant to ST’s terms and conditions of sale in place at the time of order acknowledgement.
For peripheral availability and number across all STM32F10xxx sales types, refer to the low-, medium-, high- and XL-density STM32F101xx and STM32F103xx datasheets, to the low- and medium-density STM32F102xx datasheets and to the connectivity line devices, STM32F105xx/STM32F107xx.

The BusMatrix manages the access arbitration between the core system bus and the DMA master bus. The arbitration uses a Round Robin algorithm. In connectivity line devices, the BusMatrix is composed of five masters (CPU DCode, System bus, Ethernet DMA, DMA1 and DMA2 bus) and three slaves (FLITF, SRAM and AHB2APB bridges). In other devices, the BusMatrix is composed of four masters (CPU DCode, System bus, DMA1 bus and DMA2 bus) and four slaves (FLITF, SRAM, FSMC and AHB2APB bridges).

The two AHB/APB bridges provide full synchronous connections between the AHB and the 2 APB buses. APB1 is limited to 36 MHz, APB2 operates at full speed (up to 72 MHz depending on the device).

After each device reset, all peripheral clocks are disabled (except for the SRAM and FLITF). Before using a peripheral you have to enable its clock in the RCC_AHBENR, RCC_APB2ENR or RCC_APB1ENR register.

Note:When a 16- or 8-bit access is performed on an APB register, the access is transformed into a 32-bit access: the bridge duplicates the 16- or 8-bit data to feed the 32-bit vector.

The bytes are coded in memory in Little Endian format. The lowest numbered byte in a word is considered the word’s least significant byte and the highest numbered byte the most significant.

The STM32F10xxx features up to 96 Kbytes of static SRAM. It can be accessed as bytes, half-words (16 bits) or full words (32 bits). The SRAM start address is 0x2000 0000.

The Cortex®-M3 memory map includes two bit-band regions. These regions map each word in an alias region of memory to a bit in a bit-band region of memory. Writing to a word in the alias region has the same effect as a read-modify-write operation on the targeted bit in the bit-band region.

In the STM32F10xxx both peripheral registers and SRAM are mapped in a bit-band region. This allows single bit-band write and read operations to be performed. The operations are only available for Cortex®-M3 accesses, not from other bus masters (e.g. DMA).

Flash memory instructions and data access are performed through the AHB bus. The prefetch block is used for instruction fetches through the ICode bus. Arbitration is performed in the Flash memory interface, and priority is given to data access on the DCode bus.


• Prefetch buffer (2 x 64-bit blocks): it is enabled after reset; a whole block can be replaced with a single read from the Flash memory as the size of the block matches the bandwidth of the Flash memory. Thanks to the prefetch buffer, faster CPU execution is possible as the CPU fetches one word at a time with the next word readily available in the prefetch buffer

Note:These options have to be used in accordance with the Flash memory access time. The wait states represent the ratio of the SYSCLK (system clock) period to the Flash memory access time:- 0 wait states, if 0 < SYSCLK ≤ 24 MHz- 1 wait state, if 24 MHz < SYSCLK ≤ 48 MHz- 2 wait states, if 48 MHz < SYSCLK ≤ 72 MHz

Half cycle configuration is not available in combination with a prescaler on the AHB. The system clock (SYSCLK) should be equal to the HCLK clock. This feature can therefore be 

The prefetch buffer must be switched on/off only when SYSCLK is lower than 24 MHz and no prescaler is applied on the AHB clock (SYSCLK must be equal to HCLK). The prefetch buffer is usually switched on/off during the initialization routine, while the microcontroller is running on the internal 8 MHz RC (HSI) oscillator.

Using DMA: DMA accesses Flash memory on the DCode bus and has priority over ICode instructions. The DMA provides one free cycle after each transfer. Some instructions can be performed together with DMA transfer.

The End of write operation (programming or erasing) can trigger an interrupt. This interrupt can be used to exit from WFI mode, only if the FLITF clock is enabled. Otherwise, the interrupt is served only after an exit from WFI.

The FLASH_ACR register is used to enable/disable prefetch and half cycle access, and to control the Flash memory access time according to the CPU frequency. The tables below provide the bit map and bit descriptions for this register.

Bits 2:0 LATENCY: LatencyThese bits represent the ratio of the SYSCLK (system clock) period to the Flash access time.000 Zero wait state, if 0 < SYSCLK≤ 24 MHz001 One wait state, if 24 MHz < SYSCLK ≤ 48 MHz010 Two wait states, if 48 MHz < SYSCLK ≤ 72 MHz

The values on the BOOT pins are latched on the 4th rising edge of SYSCLK after a reset. It is up to the user to set the BOOT1 and BOOT0 pins after Reset to select the required boot mode.

The BOOT pins are also re-sampled when exiting from Standby mode. Consequently they must be kept in the required Boot mode configuration in Standby mode. After this startup delay has elapsed, the CPU fetches the top-of-stack value from address 0x0000 0000, then starts code execution from the boot memory starting from 0x0000 0004.

Due to its fixed memory map, the code area starts from address 0x0000 0000 (accessed through the ICode/DCode buses) while the data area (SRAM) starts from address 0x2000 0000 (accessed through the system bus). The Cortex®-M3 CPU always fetches the reset vector on the ICode bus, which implies to have the boot space available only in the code area (typically, Flash memory). STM32F10xxx microcontrollers implement a special mechanism to be able to boot also from SRAM and not only from main Flash memory and System memory.


• Boot from main Flash memory: the main Flash memory is aliased in the boot memory space (0x0000 0000), but still accessible from its original memory space (0x800 0000). In other words, the Flash memory contents can be accessed starting from address 0x0000 0000 or 0x800 0000.


• Boot from system memory: the system memory is aliased in the boot memory space (0x0000 0000), but still accessible from its original memory space (0x1FFF B000 in connectivity line devices, 0x1FFF F000 in other devices).

For XL-density devices, when booting from the main Flash memory, you have an option to boot from any of two memory banks. By default, boot from Flash memory bank 1 is selected. You can choose to boot from Flash memory bank 2 by clearing the BFB2 bit in the user option bytes. When this bit is cleared and the boot pins are in the boot from main Flash memory configuration, the device boots from system memory, and the boot loader jumps to execute the user application programmed in Flash memory bank 2. For further details refer to AN2606.


• In connectivity line devices the boot loader can be activated through one of the following interfaces: USART1, USART2 (remapped), CAN2 (remapped) or USB OTG FS in Device mode (DFU: device firmware upgrade).

The USART peripheral operates with the internal 8 MHz oscillator (HSI). The CAN and USB OTG FS, however, can only function if an external 8 MHz, 14.7456 MHz or 25 MHz clock (HSE) is present. 

Among other applications, CRC-based techniques are used to verify data transmission or storage integrity. In the scope of the EN/IEC 60335-1 standard, they offer a means of verifying the Flash memory integrity. The CRC calculation unit helps compute a signature of the software during runtime, to be compared with a reference signature generated at link-time and stored at a given memory location.

Each write operation into the data register creates a combination of the previous CRC value and the new one (CRC computation is done on the whole 32-bit data word, and not byte per byte).

Bits 7:0 General-purpose 8-bit data register bitsCan be used as a temporary storage location for one byte.This register is not affected by CRC resets generated by the RESET bit in the CRC_CR register.

To ensure a better accuracy on low-voltage inputs and outputs, the user can connect a separate external reference voltage on VREF+. VREF+ is the highest voltage, represented by the full scale value, for an analog input (ADC) or output (DAC) signal. The voltage on VREF+ can range from 2.4 V to VDDA.

To retain the content of the Backup registers and supply the RTC function when VDD is turned off, VBAT pin can be connected to an optional standby voltage supplied by a battery or by another source.

The VBAT pin powers the RTC unit, the LSE oscillator and the PC13 to PC15 IOs, allowing the RTC to operate even when the main digital supply (VDD) is turned off. The switch to the VBAT supply is controlled by the Power Down Reset embedded in the Reset block.

Warning:During tRSTTEMPO (temporization at VDD startup) or after a PDR is detected, the power switch between VBAT and VDD remains connected to VBAT.During the startup phase, if VDD is established in less than tRSTTEMPO (Refer to the datasheet for the value of tRSTTEMPO) and VDD > VBAT + 0.6 V, a current may be injected into VBAT through an internal diode connected between VDD and the power switch (VBAT).If the power supply/battery connected to the VBAT pin cannot support this current injection, it is strongly recommended to connect an external low-drop diode between this power supply and the VBAT pin.

If no external battery is used in the application, it is recommended to connect VBAT externally to VDD with a 100 nF external ceramic decoupling capacitor (for more details refer to AN2586).

Note:Due to the fact that the switch only sinks a limited amount of current (3 mA), the use of GPIOs PC13 to PC15 in output mode is restricted: the speed has to be limited to 2 MHz with a maximum load of 30 pF and these IOs must not be used as a current source (e.g. to drive a LED).

The device remains in Reset mode when VDD/VDDA is below a specified threshold, VPOR/PDR, without the need for an external reset circuit. For more details concerning the power on/power down reset threshold, refer to the electrical characteristics of the datasheet. 

A PVDO flag is available, in the Power control/status register (PWR_CSR), to indicate if VDD/VDDA is higher or lower than the PVD threshold. This event is internally connected to the EXTI line16 and can generate an interrupt if enabled through the EXTI registers. The PVD output interrupt can be generated when VDD/VDDA drops below the PVD threshold and/or when VDD/VDDA rises above the PVD threshold depending on EXTI line16 rising/falling edge configuration. As an example the service routine could perform emergency shutdown tasks.

By default, the microcontroller is in Run mode after a system or a power Reset. Several low-power modes are available to save power when the CPU does not need to be kept running, for example when waiting for an external event. It is up to the user to select the mode that gives the best compromise between low-power consumption, short startup time and available wakeup sources.

In Run mode the speed of the system clocks (SYSCLK, HCLK, PCLK1, PCLK2) can be reduced by programming the prescaler registers. These prescalers can also be used to slow down peripherals before entering Sleep mode. 

The Sleep mode is entered by executing the WFI (Wait For Interrupt) or WFE (Wait for Event) instructions. Two options are available to select the Sleep mode entry mechanism, depending on the SLEEPONEXIT bit in the Cortex®-M3 System Control register: 


• enabling an interrupt in the peripheral control register but not in the NVIC, and enabling the SEVONPEND bit in the Cortex®-M3 System Control register. When the MCU resumes from WFE, the peripheral interrupt pending bit and the peripheral NVIC IRQ channel pending bit (in the NVIC interrupt clear pending register) have to be cleared.


• or configuring an external or internal EXTI line in event mode. When the CPU resumes from WFE, it is not necessary to clear the peripheral interrupt pending bit or the NVIC IRQ channel pending bit as the pending bit corresponding to the event line is not set.

The Stop mode is based on the Cortex®-M3 deepsleep mode combined with peripheral clock gating. The voltage regulator can be configured either in normal or low-power mode. In Stop mode, all clocks in the 1.8 V domain are stopped, the PLL, the HSI and the HSE RC oscillators are disabled. SRAM and register contents are preserved.

To further reduce power consumption in Stop mode, the internal voltage regulator can be put in low-power mode. This is configured by the LPDS bit of the Power control register (PWR_CR).


• Independent watchdog (IWDG): the IWDG is started by writing to its Key register or by hardware option. Once started it cannot be stopped except by a Reset. See Section 19.3: IWDG functional description.

The ADC or DAC can also consume power during the Stop mode, unless they are disabled before entering it. To disable them, the ADON bit in the ADC_CR2 register and the ENx bit in the DAC_CR register must both be written to 0.

Note:If the application needs to disable the external clock before entering Stop mode, the HSEON bit must first be disabled and the system clock switched to HSI. Otherwise, if the HSEON bit remains enabled and the external clock (external oscillator) is removed when entering Stop mode, the clock security system (CSS) feature must be enabled to detect any external oscillator failure and avoid a malfunction behavior when entering stop mode.

When the voltage regulator operates in low-power mode, an additional startup delay is incurred when waking up from Stop mode. By keeping the internal regulator ON during Stop mode, the consumption is higher although the startup time is reduced.

WFI (Wait for Interrupt) or WFE (Wait for Event) while:– Set SLEEPDEEP bit in Cortex®-M3 System Control register– Clear PDDS bit in Power Control register (PWR_CR)– Select the voltage regulator mode by configuring LPDS bit in PWR_CR

Note: To enter Stop mode, all EXTI Line pending bits (in Pending register (EXTI_PR)), all peripheral interrupt pending bits, and RTC Alarm flag must be reset. Otherwise, the Stop mode entry procedure is ignored and program execution continues. 

The Standby mode allows to achieve the lowest power consumption. It is based on the Cortex®-M3 deepsleep mode, with the voltage regulator disabled. The 1.8 V domain is consequently powered off. The PLL, the HSI oscillator and the HSE oscillator are also switched off. SRAM and register contents are lost except for registers in the Backup domain and Standby circuitry (see Figure 4).


• Independent watchdog (IWDG): the IWDG is started by writing to its Key register or by hardware option. Once started it cannot be stopped except by a reset. See Section 19.3: IWDG functional description.

The microcontroller exits the Standby mode when an external reset (NRST pin), an IWDG reset, a rising edge on the WKUP pin or the rising edge of an RTC alarm occurs (see Figure 179: RTC simplified block diagram). All registers are reset after wakeup from Standby except for Power control/status register (PWR_CSR). 

By default, the debug connection is lost if the application puts the MCU in Stop or Standby mode while the debug features are used. This is due to the fact that the Cortex®-M3 core is no longer clocked.

The RTC can be used to wakeup the MCU from low-power mode without depending on an external interrupt (Auto-wakeup mode). The RTC provides a programmable time base for waking up from Stop or Standby mode at regular intervals. For this purpose, two of the three alternative RTC clock sources can be selected by programming the RTCSEL[1:0] bits in the Backup domain control register (RCC_BDCR):


• Low-power internal RC Oscillator (LSI RC)This clock source has the advantage of saving the cost of the 32.768 kHz crystal. This internal RC Oscillator is designed to add minimum power consumption. 

Bit 8 DBP: Disable backup domain write protection.In reset state, the RTC and backup registers are protected against parasitic write access. This bit must be set to enable write access to these registers.0: Access to RTC and Backup registers disabled1: Access to RTC and Backup registers enabledNote: If the HSE divided by 128 is used as the RTC clock, this bit must remain set to 1.

Bits 7:5 PLS[2:0]: PVD level selection.These bits are written by software to select the voltage threshold detected by the Power Voltage Detector000: 2.2V001: 2.3V010: 2.4V011: 2.5V100: 2.6V101: 2.7V110: 2.8V111: 2.9VNote: Refer to the electrical characteristics of the datasheet for more details.

Bit 1 PDDS: Power down deepsleep.This bit is set and cleared by software. It works together with the LPDS bit. 0: Enter Stop mode when the CPU enters Deepsleep. The regulator status depends on the LPDS bit.1: Enter Standby mode when the CPU enters Deepsleep. 

Bit 0 LPDS: Low-power deepsleep.This bit is set and cleared by software. It works together with the PDDS bit.0: Voltage regulator on during Stop mode1: Voltage regulator in low-power mode during Stop mode

Bit 8 EWUP: Enable WKUP pinThis bit is set and cleared by software.0: WKUP pin is used for general purpose I/O. An event on the WKUP pin does not wakeup the device from Standby mode.1: WKUP pin is used for wakeup from Standby mode and forced in input pull down configuration (rising edge on WKUP pin wakes-up the system from Standby mode).Note: This bit is reset by a system Reset.

Bit 2 PVDO: PVD outputThis bit is set and cleared by hardware. It is valid only if PVD is enabled by the PVDE bit. 0: VDD/VDDA is higher than the PVD threshold selected with the PLS[2:0] bits. 1: VDD/VDDA is lower than the PVD threshold selected with the PLS[2:0] bits.Note: The PVD is stopped by Standby mode. For this reason, this bit is equal to 0 after Standby or reset until the PVDE bit is set.

Bit 1 SBF: Standby flagThis bit is set by hardware and cleared only by a POR/PDR (power on reset/power down reset) or by setting the CSBF bit in the Power control register (PWR_CR)

Bit 0 WUF: Wakeup flagThis bit is set by hardware and cleared by hardware, by a system reset or by setting the CWUF bit in the Power control register (PWR_CR)0: No wakeup event occurred1: A wakeup event was received from the WKUP pin or from the RTC alarmNote: An additional wakeup event is detected if the WKUP pin is enabled (by setting the EWUP bit) when the WKUP pin level is already high.

They are implemented in the backup domain that remains powered on by VBAT when the VDD power is switched off. They are not reset when the device wakes up from Standby mode or by a system reset or power reset.

After reset, access to the Backup registers and RTC is disabled and the Backup domain (BKP) is protected against possible parasitic write access. To enable access to the Backup registers and the RTC, proceed as follows:

The TAMPER pin generates a Tamper detection event when the pin changes from 0 to 1 or from 1 to 0 depending on the TPAL bit in the Backup control register (BKP_CR). A tamper detection event resets all data backup registers.

However to avoid losing Tamper events, the signal used for edge detection is logically ANDed with the Tamper enable in order to detect a Tamper event in case it occurs before the TAMPER pin is enabled.


• When TPAL=0: If the TAMPER pin is already high before it is enabled (by setting TPE bit), an extra Tamper event is detected as soon as the TAMPER pin is enabled (while there was no rising edge on the TAMPER pin after TPE was set)


• When TPAL=1: If the TAMPER pin is already low before it is enabled (by setting the TPE bit), an extra Tamper event is detected as soon as the TAMPER pin is enabled (while there was no falling edge on the TAMPER pin after TPE was set)

After a Tamper event has been detected and cleared, the TAMPER pin should be disabled and then re-enabled with TPE before writing to the backup data registers (BKP_DRx) again. This prevents software from writing to the backup data registers (BKP_DRx), while the TAMPER pin value still indicates a Tamper detection. This is equivalent to a level detection on the TAMPER pin.

Note:Tamper detection is still active when VDD power is switched off. To avoid unwanted resetting of the data backup registers, the TAMPER pin should be externally tied to the correct level.

For measurement purposes, the RTC clock with a frequency divided by 64  can be output on the TAMPER pin. This is enabled by setting the CCO bit in the RTC clock calibration register (BKP_RTCCR). 

Bits 15:0 D[15:0] Backup dataThese bits can be written with user data. Note: The BKP_DRx registers are not reset by a System reset or Power reset or when the device wakes up from Standby mode.They are reset by a Backup Domain reset or by a TAMPER pin event (if the TAMPER pin function is activated).

Bit 9 ASOS: Alarm or second output selectionWhen the ASOE bit is set, the ASOS bit can be used to select whether the signal output on the TAMPER pin is the RTC Second pulse signal or the Alarm pulse signal:0: RTC Alarm pulse output selected1: RTC Second pulse output selectedNote: This bit is reset only by a Backup domain reset.

Note:Setting the TPAL and TPE bits at the same time is always safe, however resetting both at the same time can generate a spurious Tamper event. For this reason it is recommended to change the TPAL bit only when the TPE bit is reset.

Bit 8 ASOE: Alarm or second output enableSetting this bit outputs either the RTC Alarm pulse signal or the Second pulse signal on the TAMPER pin depending on the ASOS bit.The output pulse duration is one RTC clock period. The TAMPER pin must not be enabled while the ASOE bit is set.Note: This bit is reset only by a Backup domain reset.

Bit 7 CCO: Calibration clock output 0: No effect1: Setting this bit outputs the RTC clock with a frequency divided by 64 on the TAMPER pin. The TAMPER pin must not be enabled while the CCO bit is set in order to avoid unwanted Tamper detection.Note: This bit is reset when the VDD supply is powered off.

Bit 6:0 CAL[6:0]: Calibration valueThis value indicates the number of clock pulses that will be ignored every 2^20 clock pulses. This allows the calibration of the RTC, slowing down the clock by steps of 1000000/2^20 PPM. The clock of the RTC can be slowed down from 0 to 121PPM.

Bit 1 TPAL: TAMPER pin active level0: A high level on the TAMPER pin resets all data backup registers (if TPE bit is set).1: A low level on the TAMPER pin resets all data backup registers (if TPE bit is set).

Bit 9 TIF: Tamper interrupt flag This bit is set by hardware when a Tamper event is detected and the TPIE bit is set. It is cleared by writing 1 to the CTI bit (also clears the interrupt). It is also cleared if the TPIE bit is reset. 0: No Tamper interrupt1: A Tamper interrupt occurredNote: This bit is reset only by a system reset and wakeup from Standby mode.

Bit 8 TEF: Tamper event flag This bit is set by hardware when a Tamper event is detected. It is cleared by writing 1 to the CTE bit.0: No Tamper event1: A Tamper event occurredNote: A Tamper event resets all the BKP_DRx registers. They are held in reset as long as the TEF bit is set. If a write to the BKP_DRx registers is performed while this bit is set, the value will not be stored.

Bit 2 TPIE: TAMPER pin interrupt enable0: Tamper interrupt disabled1: Tamper interrupt enabled (the TPE bit must also be set in the BKP_CR registerNote: A Tamper interrupt does not wake up the core from low-power modes.This bit is reset only by a system reset and wakeup from Standby mode.

The SYSRESETREQ bit in Cortex®-M3 Application Interrupt and Reset Control Register must be set to force a software reset on the device. Refer to the STM32F10xxx Cortex®-M3 programming manual (see Related documents) for more details. 

This type of reset is enabled by resetting nRST_STDBY bit in User Option Bytes. In this case, whenever a Standby mode entry sequence is successfully executed, the device is reset instead of entering Standby mode. 

This type of reset is enabled by resetting nRST_STOP bit in User Option Bytes. In this case, whenever a Stop mode entry sequence is successfully executed, the device is reset instead of entering Stop mode. 

These sources act on the NRST pin and it is always kept low during the delay phase. The RESET service routine vector is fixed at address 0x0000_0004 in the memory map. 

The system reset signal provided to the device is output on the NRST pin. The pulse generator guarantees a minimum reset pulse duration of 20 µs for each reset source (external or internal reset). In case of an external reset, the reset pulse is generated while the NRST pin is asserted low.

Several prescalers allow the configuration of the AHB frequency, the high speed APB (APB2) and the low speed APB (APB1) domains. The maximum frequency of the AHB and the APB2 domains is 72 MHz. The maximum allowed frequency of the APB1 domain is 36 MHz. The SDIO AHB interface is clocked with a fixed frequency equal to HCLK/2

The RCC feeds the Cortex® System Timer (SysTick) external clock with the AHB clock (HCLK) divided by 8. The SysTick can work either with this clock or with the Cortex® clock (HCLK), configurable in the SysTick Control and Status Register. The ADCs are clocked by the clock of the High Speed domain (APB2) divided by 2, 4, 6 or 8.

The resonator and the load capacitors have to be placed as close as possible to the oscillator pins in order to minimize output distortion and startup stabilization time. The loading capacitance values must be adjusted according to the selected oscillator.

In this mode, an external clock source must be provided. It can have a frequency of up to 25 MHz. You select this mode by setting the HSEBYP and HSEON bits in the Clock control register (RCC_CR). The external clock signal (square, sinus or triangle) with ~50% duty cycle has to drive the OSC_IN pin while the OSC_OUT pin should be left hi-Z. See Figure 9.

The HSERDY flag in the Clock control register (RCC_CR) indicates if the high-speed external oscillator is stable or not. At startup, the clock is not released until this bit is set by hardware. An interrupt can be generated if enabled in the Clock interrupt register (RCC_CIR).

The HSI clock signal is generated from an internal 8 MHz RC Oscillator and can be used directly as a system clock or divided by 2 to be used as PLL input. 

The HSI RC oscillator has the advantage of providing a clock source at low cost (no external components). It also has a faster startup time than the HSE crystal oscillator however, even with calibration the frequency is less accurate than an external crystal oscillator or ceramic resonator. 

RC oscillator frequencies can vary from one chip to another due to manufacturing process variations, this is why each device is factory calibrated by ST for 1% accuracy at TA=25°C. 

If the application is subject to voltage or temperature variations this may affect the RC oscillator speed. You can trim the HSI frequency in the application using the HSITRIM[4:0] bits in the Clock control register (RCC_CR).

The HSIRDY flag in the Clock control register (RCC_CR) indicates if the HSI RC is stable or not. At startup, the HSI RC output clock is not released until this bit is set by hardware. 

The PLL configuration (selection of HSI oscillator divided by 2 or HSE oscillator for PLL input clock, and multiplication factor) must be done before enabling the PLL. Once the PLL enabled, these parameters cannot be changed.

The LSE crystal is a 32.768 kHz Low Speed External crystal or ceramic resonator. It has the advantage providing a low-power but highly accurate clock source to the real-time clock peripheral (RTC) for clock/calendar or other timing functions. 

The LSERDY flag in the Backup domain control register (RCC_BDCR) indicates if the LSE crystal is stable or not. At startup, the LSE crystal output clock signal is not released until this bit is set by hardware. An interrupt can be generated if enabled in the Clock interrupt register (RCC_CIR).

In this mode, an external clock source must be provided. It can have a frequency of up to 1 MHz. You select this mode by setting the LSEBYP and LSEON bits in the Backup domain control register (RCC_BDCR). The external clock signal (square, sinus or triangle) with ~50% duty cycle has to drive the OSC32_IN pin while the OSC32_OUT pin should be left Hi-Z. See Figure 9. 

The LSI RC acts as an low-power clock source that can be kept running in Stop and Standby mode for the independent watchdog (IWDG) and Auto-wakeup unit (AWU). The clock frequency is around 40 kHz (between 30 kHz and 60 kHz). For more details, refer to the electrical characteristics section of the datasheets.

The LSIRDY flag in the Control/status register (RCC_CSR) indicates if the low-speed internal oscillator is stable or not. At startup, the clock is not released until this bit is set by hardware. An interrupt can be generated if enabled in the Clock interrupt register (RCC_CIR).

The frequency dispersion of the Low Speed Internal RC (LSI) oscillator can be calibrated to have accurate RTC time base and/or IWDG timeout (when LSI is used as clock source for these peripherals) with an acceptable accuracy.

This calibration is performed by measuring the LSI clock frequency with respect to TIM5 input clock (TIM5CLK). According to this measurement done at the precision of the HSE oscillator, the software can adjust the programmable 20-bit prescaler of the RTC to get an accurate time base or can compute accurate IWDG timeout.

After a system reset, the HSI oscillator is selected as system clock. When a clock source is used directly or through the PLL as system clock, it is not possible to stop it.

A switch from one clock source to another occurs only if the target clock source is ready (clock stable after startup delay or PLL locked). If a clock source which is not yet ready is selected, the switch will occur when the clock source will be ready. Status bits in the Clock control register (RCC_CR) indicate which clock(s) is (are) ready and which clock is currently used as system clock.

If a failure is detected on the HSE clock, the HSE oscillator is automatically disabled, a clock failure event is sent to the break input of the advanced-control timers (TIM1 and TIM8) and an interrupt is generated to inform the software about the failure (Clock Security System Interrupt CSSI), allowing the MCU to perform rescue operations. The CSSI is linked to the Cortex®-M3 NMI (Non-Maskable Interrupt) exception vector. 

Note:Once the CSS is enabled and if the HSE clock fails, the CSS interrupt occurs and an NMI is automatically generated. The NMI will be executed indefinitely unless the CSS interrupt pending bit is cleared. As a consequence, in the NMI ISR user must clear the CSS interrupt by setting the CSSC bit in the Clock interrupt register (RCC_CIR).

If the HSE oscillator is used directly or indirectly as the system clock (indirectly means: it is used as PLL input clock, and the PLL clock is used as system clock), a detected failure causes a switch of the system clock to the HSI oscillator and the disabling of the HSE oscillator. If the HSE clock (divided or not) is the clock entry of the PLL used as system clock when the failure occurs, the PLL is disabled too.

The RTCCLK clock source can be either the HSE/128, LSE or LSI clocks. This is selected by programming the RTCSEL[1:0] bits in the Backup domain control register (RCC_BDCR). This selection cannot be modified without resetting the Backup domain.

If the Independent watchdog (IWDG) is started by either hardware option or software access, the LSI oscillator is forced ON and cannot be disabled. After the LSI oscillator temporization, the clock is provided to the IWDG.

The microcontroller clock output (MCO) capability allows the clock to be output onto the external MCO pin. The configuration registers of the corresponding GPIO port must be programmed in alternate function mode. One of 4 clock signals can be selected as the MCO clock. 

Bit 24 PLLON: PLL enableSet and cleared by software to enable PLL.Cleared by hardware when entering Stop or Standby mode. This bit can not be reset if the PLL clock is used as system clock or is selected to become the system clock.0: PLL OFF1: PLL ON

Bit 19 CSSON: Clock security system enableSet and cleared by software to enable the clock security system. When CSSON is set, the clock detector is enabled by hardware when the HSE oscillator is ready, and disabled by hardware if a HSE clock failure is detected.0: Clock detector OFF1: Clock detector ON (Clock detector ON if the HSE oscillator is ready , OFF if not).

Bit 18 HSEBYP: External high-speed clock bypassSet and cleared by software to bypass the oscillator with an external clock. The external clock must be enabled with the HSEON bit set, to be used by the device.  The HSEBYP bit can be written only if the HSE oscillator is disabled. 0: external 4-16 MHz oscillator not bypassed1: external 4-16 MHz oscillator bypassed with external clock

Bit 17 HSERDY: External high-speed clock ready flagSet by hardware to indicate that the  HSE oscillator is stable. This bit needs 6 cycles of the HSE oscillator clock to fall down after HSEON reset.0: HSE oscillator not ready1: HSE oscillator ready 

Bit 16 HSEON: HSE clock enableSet and cleared by software.Cleared by hardware to stop the HSE oscillator when entering Stop or Standby mode. This bit cannot be reset if the HSE oscillator is used directly or indirectly as the system clock.0: HSE oscillator OFF1: HSE oscillator ON

Bits 7:3 HSITRIM[4:0]: Internal high-speed clock trimmingThese bits provide an additional user-programmable trimming value that is added to the HSICAL[7:0] bits. It can be programmed to adjust to variations in voltage and temperature that influence the frequency of the internal HSI RC.The default value is 16, which, when added to the HSICAL value, should trim the HSI to 8 MHz ± 1%. The trimming step (Fhsitrim) is around 40 kHz between two consecutive HSICAL steps.

Bit 1 HSIRDY: Internal high-speed clock ready flagSet by hardware to indicate that internal 8 MHz RC oscillator is stable. After the HSION bit is cleared, HSIRDY goes low after 6 internal 8 MHz RC oscillator clock cycles.0: internal 8 MHz RC oscillator not ready1: internal 8 MHz RC oscillator ready

Bit 0 HSION: Internal high-speed clock enableSet and cleared by software.Set by hardware to force the internal 8 MHz RC oscillator ON when leaving Stop or Standby mode or in case of failure of the external 4-16 MHz oscillator used directly or indirectly as system clock. This bit cannot be reset if the internal 8 MHz RC is used directly or indirectly as system clock or is selected to become the system clock.0: internal 8 MHz RC oscillator OFF1: internal 8 MHz RC oscillator ON

Bits 26:24 MCO: Microcontroller clock outputSet and cleared by software.0xx: No clock100: System clock (SYSCLK) selected101: HSI clock selected110: HSE clock selected111: PLL clock divided by 2 selectedNote: This clock output may have some truncated cycles at startup or during MCO clock source switching.When the System Clock is selected to output to the MCO pin, make sure that this clock does not exceed 50 MHz (the maximum IO speed). 

Bit 22 USBPRE: USB prescalerSet and cleared by software to generate 48 MHz USB clock. This bit must be valid before enabling the USB clock in the RCC_APB1ENR register. This bit can’t be reset if the USB clock is enabled.0: PLL clock is divided by 1.51: PLL clock is not divided

Bits 21:18 PLLMUL: PLL multiplication factorThese bits are written by software to define the PLL multiplication factor. These bits can be written only when PLL is disabled. Caution: The PLL output frequency must not exceed 72 MHz.0000: PLL input clock x 20001: PLL input clock x 30010: PLL input clock x 40011: PLL input clock x 50100: PLL input clock x 60101: PLL input clock x 70110: PLL input clock x 80111: PLL input clock x 91000: PLL input clock x 101001: PLL input clock x 111010: PLL input clock x 121011: PLL input clock x 131100: PLL input clock x 141101: PLL input clock x 151110: PLL input clock x 161111: PLL input clock x 16

Bit 17 PLLXTPRE: HSE divider for PLL entrySet and cleared by software to divide HSE before PLL entry. This bit can be written only when PLL is disabled.0: HSE clock not divided1: HSE clock divided by 2

Bit 16 PLLSRC: PLL entry clock sourceSet and cleared by software to select PLL clock source. This bit can be written only when PLL is disabled.0: HSI oscillator clock / 2 selected as PLL input clock1: HSE oscillator clock selected as PLL input clock

Bits 15:14 ADCPRE: ADC prescalerSet and cleared by software to select the frequency of the clock to the ADCs.00: PCLK2 divided by 201: PCLK2 divided by 410: PCLK2 divided by 611: PCLK2 divided by 8

Bits 13:11 PPRE2: APB high-speed prescaler (APB2)Set and cleared by software to control the division factor of the APB high-speed clock (PCLK2).0xx: HCLK not divided100: HCLK divided by 2101: HCLK divided by 4110: HCLK divided by 8111: HCLK divided by 16

Bits 10:8 PPRE1: APB low-speed prescaler (APB1)Set and cleared by software to control the division factor of the APB low-speed clock (PCLK1).Warning: the software has to set correctly these bits to not exceed 36 MHz on this domain.0xx: HCLK not divided100: HCLK divided by 2101: HCLK divided by 4110: HCLK divided by 8111: HCLK divided by 16

Bits 7:4 HPRE: AHB prescalerSet and cleared by software to control the division factor of the AHB clock.0xxx: SYSCLK not divided1000: SYSCLK divided by 21001: SYSCLK divided by 41010: SYSCLK divided by 81011: SYSCLK divided by 161100: SYSCLK divided by 641101: SYSCLK divided by 1281110: SYSCLK divided by 2561111: SYSCLK divided by 512Note: The prefetch buffer must be kept on when using a prescaler different from 1 on the AHB clock. Refer to Reading the Flash memory section for more details.

Bits 3:2 SWS: System clock switch statusSet and cleared by hardware to indicate which clock source is used as system clock.00: HSI oscillator used as system clock01: HSE oscillator used as system clock10: PLL used as system clock11: not applicable

Bits 1:0 SW: System clock switchSet and cleared by software to select SYSCLK source.Set by hardware to force HSI selection when leaving Stop and Standby mode or in case of failure of the HSE oscillator used directly or indirectly as system clock (if the Clock Security System is enabled).00: HSI selected as system clock01: HSE selected as system clock10: PLL selected as system clock11: not allowed

Bit 10 HSIRDYIE: HSI ready interrupt enableSet and cleared by software to enable/disable interrupt caused by the internal 8 MHz RC oscillator stabilization.0: HSI ready interrupt disabled1: HSI ready interrupt enabled

Bit 7 CSSF: Clock security system interrupt flagSet by hardware when a failure is detected in the external 4-16 MHz oscillator.Cleared by software setting the CSSC bit.0: No clock security interrupt caused by HSE clock failure1: Clock security interrupt caused by HSE clock failure

Bit 4 PLLRDYF: PLL ready interrupt flagSet by hardware when the PLL locks and PLLRDYDIE is set.Cleared by software setting the PLLRDYC bit.0: No clock ready interrupt caused by PLL lock1: Clock ready interrupt caused by PLL lock

Bit3 HSERDYF: HSE ready interrupt flagSet by hardware when External High Speed clock becomes stable and HSERDYDIE is set.Cleared by software setting the HSERDYC bit.0: No clock ready interrupt caused by the external 4-16 MHz oscillator1: Clock ready interrupt caused by the external 4-16 MHz oscillator

Bit 2 HSIRDYF: HSI ready interrupt flagSet by hardware when the Internal High Speed clock becomes stable and HSIRDYDIE is set.Cleared by software setting the HSIRDYC bit.0: No clock ready interrupt caused by the internal 8 MHz RC oscillator1: Clock ready interrupt caused by the internal 8 MHz RC oscillator

Bit 1 LSERDYF: LSE ready interrupt flagSet by hardware when the External Low Speed clock becomes stable and LSERDYDIE is set.Cleared by software setting the LSERDYC bit.0: No clock ready interrupt caused by the external 32 kHz oscillator1: Clock ready interrupt caused by the external 32 kHz oscillator

Bit 0 LSIRDYF: LSI ready interrupt flagSet by hardware when the internal low speed clock becomes stable and LSIRDYDIE is set.Cleared by software setting the LSIRDYC bit.0: No clock ready interrupt caused by the internal RC 40 kHz oscillator1: Clock ready interrupt caused by the internal RC 40 kHz oscillator

No wait states, except if the access occurs while an access to a peripheral in the APB2 domain is on going. In this case, wait states are inserted until the access to APB2 peripheral is finished.

Bit 2 SRAMEN: SRAM interface clock enableSet and cleared by software to disable/enable SRAM interface clock during Sleep mode.0: SRAM interface clock disabled during Sleep mode.1: SRAM interface clock enabled during Sleep mode

No wait state, except if the access occurs while an access to a peripheral on APB1 domain is on going. In this case, wait states are inserted until this access to APB1 peripheral is finished.

Address offset: 0x20Reset value: 0x0000 0000, reset by Backup domain Reset.Access: 0 ≤ wait state ≤ 3, word, half-word and byte accessWait states are inserted in case of successive accesses to this register.

Bits 9:8 RTCSEL[1:0]: RTC clock source selectionSet by software to select the clock source for the RTC. Once the RTC clock source has been selected, it cannot be changed anymore unless the Backup domain is reset. The BDRST bit can be used to reset them.00: No clock01: LSE oscillator clock used as RTC clock10: LSI oscillator clock used as RTC clock11: HSE oscillator clock divided by 128 used as RTC clock

Bit 2 LSEBYP: External low-speed oscillator bypassSet and cleared by software to bypass oscillator in debug mode. This bit can be written only when the external 32 kHz oscillator is disabled.0: LSE oscillator not bypassed1: LSE oscillator bypassed

Bit 1 LSERDY: External low-speed oscillator readySet and cleared by hardware to indicate when the external 32 kHz oscillator is stable. After the LSEON bit is cleared, LSERDY goes low after 6 external low-speed oscillator clock cycles.0: External 32 kHz oscillator not ready1: External 32 kHz oscillator ready

Bit 31 LPWRRSTF: Low-power reset flagSet by hardware when a Low-power management reset occurs.Cleared by writing to the RMVF bit.0: No Low-power management reset occurred1: Low-power management reset occurredFor further information on Low-power management reset, refer to Low-power management reset.

Bit 29 IWDGRSTF: Independent watchdog reset flagSet by hardware when an independent watchdog reset from VDD domain occurs.Cleared by writing to the RMVF bit.0: No watchdog reset occurred1: Watchdog reset occurred

Bit 26 PINRSTF: PIN reset flagSet by hardware when a reset from the NRST pin occurs.Cleared by writing to the RMVF bit.0: No reset from NRST pin occurred1: Reset from NRST pin occurred

Bit 1 LSIRDY: Internal low-speed oscillator readySet and cleared by hardware to indicate when the internal RC 40 kHz oscillator is stable. After the LSION bit is cleared, LSIRDY goes low after 3 internal RC 40 kHz oscillator clock cycles.0: Internal RC 40 kHz oscillator not ready1: Internal RC 40 kHz oscillator ready

The SYSRESETREQ bit in Cortex®-M3 Application Interrupt and Reset Control Register must be set to force a software reset on the device. Refer to the STM32F10xxx Cortex®-M3 programming manual (see Related documents) for more details.

This type of reset is enabled by resetting nRST_STDBY bit in User Option Bytes. In this case, whenever a Standby mode entry sequence is successfully executed, the device is reset instead of entering Standby mode. 

This type of reset is enabled by resetting nRST_STOP bit in User Option Bytes. In this case, whenever a Stop mode entry sequence is successfully executed, the device is reset instead of entering Stop mode. 

These sources act on the NRST pin and it is always kept low during the delay phase. The RESET service routine vector is fixed at address 0x0000_0004 in the memory map. For more details, refer to Table 63: Vector table for other STM32F10xxx devices.

The system reset signal provided to the device is output on the NRST pin. The pulse generator guarantees a minimum reset pulse duration of 20 µs for each reset source (external or internal reset). In case of an external reset, the reset pulse is generated while the NRST pin is asserted low.

The advanced clock controller features 3 PLLs to provide a high degree of flexibility to the application in the choice of the external crystal or oscillator to run the core and peripherals at the highest frequency and guarantee the appropriate frequency for the Ethernet and USB OTG FS.

A single 25 MHz crystal can clock the entire system and all peripherals including the Ethernet and USB OTG FS peripherals. In order to achieve high-quality audio performance, an audio crystal can be used. In this case, the I2S master clock can generate all standard sampling frequencies from 8 kHz to 96 kHz with less than 0.5% accuracy.For more details about clock configuration for applications requiring Ethernet, USB OTG FS and/or I2S (audio), refer to "Appendix A Applicative block diagrams" in your connectivity line device datasheet.

Several prescalers allow the configuration of the AHB frequency, the high speed APB (APB2) and the low speed APB (APB1) domains. The maximum frequency of the AHB and the APB2 domains is 72 MHz. The maximum allowed frequency of the APB1 domain is 36 MHz. 


• The USB OTG FS 48 MHz clock which is derived from the PLL VCO clock (2 × PLLCLK), followed by a programmable prescaler (divide by 3 or 2). This selection is made through the OTGFSPRE bit in the RCC_CFGR register. For proper USB OTG FS operation, the PLL should be configured to output 72 MHz or 48 MHz.

The RCC feeds the Cortex® System Timer (SysTick) external clock with the AHB clock (HCLK) divided by 8. The SysTick can work either with this clock or with the Cortex® clock (HCLK), configurable in the SysTick Control and Status Register. The ADCs are clocked by the clock of the High Speed domain (APB2) divided by 2, 4, 6 or 8.

The resonator and the load capacitors have to be placed as close as possible to the oscillator pins in order to minimize output distortion and startup stabilization time. The loading capacitance values must be adjusted according to the selected oscillator.

In this mode, an external clock source must be provided. It can have a frequency of up to 50 MHz. Select this mode by setting the HSEBYP and HSEON bits in the Clock control register (RCC_CR). The external clock signal (square, sinus or triangle) with ~50% duty cycle has to drive the OSC_IN pin while the OSC_OUT pin should be left hi-Z. See Figure 12.

The HSERDY flag in the Clock control register (RCC_CR) indicates if the high-speed external oscillator is stable or not. At startup, the clock is not released until this bit is set by hardware. An interrupt can be generated if enabled in the Clock interrupt register (RCC_CIR).

The HSI clock signal is generated from an internal 8 MHz RC Oscillator and can be used directly as a system clock or divided by 2 to be used as PLL input. 

The HSI RC oscillator has the advantage of providing a clock source at low cost (no external components). It also has a faster startup time than the HSE crystal oscillator however, even with calibration the frequency is less accurate than an external crystal oscillator or ceramic resonator. 

RC oscillator frequencies can vary from one chip to another due to manufacturing process variations, this is why each device is factory calibrated by ST for 1% accuracy at TA= 25 °C.

If the application is subject to voltage or temperature variations this may affect the RC oscillator speed. You can trim the HSI frequency in the application using the HSITRIM[4:0] bits in the Clock control register (RCC_CR).

The HSIRDY flag in the Clock control register (RCC_CR) indicates if the HSI RC is stable or not. At startup, the HSI RC output clock is not released until this bit is set by hardware. 

The configuration of each PLL (selection of clock source, predivision factor and multiplication factor) must be done before enabling the PLL. Each PLL should be enabled after its input clock becomes stable (ready flag). Once the PLL is enabled, these parameters can not be changed.

When changing the entry clock source of the main PLL, the original clock source must be switched off only after the selection of the new clock source (done through bit PLLSRC in the Clock configuration register (RCC_CFGR)).

The LSE crystal is a 32.768 kHz Low Speed External crystal or ceramic resonator. It has the advantage providing a low-power but highly accurate clock source to the real-time clock peripheral (RTC) for clock/calendar or other timing functions. 

The LSERDY flag in the Backup domain control register (RCC_BDCR) indicates if the LSE crystal is stable or not. At startup, the LSE crystal output clock signal is not released until this bit is set by hardware. An interrupt can be generated if enabled in the Clock interrupt register (RCC_CIR).

In this mode, an external clock source must be provided. It can have a frequency of up to 1 MHz. You select this mode by setting the LSEBYP and LSEON bits in the Backup domain control register (RCC_BDCR). The external clock signal (square, sinus or triangle) with ~50% duty cycle has to drive the OSC32_IN pin while the OSC32_OUT pin should be left Hi-Z. See Figure 12. 

The LSI RC acts as an low-power clock source that can be kept running in Stop and Standby mode for the independent watchdog (IWDG) and Auto-wakeup unit (AWU). The clock frequency is around 40 kHz (between 30 kHz and 60 kHz). For more details, refer to the electrical characteristics section of the datasheets.

The LSIRDY flag in the Control/status register (RCC_CSR) indicates if the low-speed internal oscillator is stable or not. At startup, the clock is not released until this bit is set by hardware. An interrupt can be generated if enabled in the Clock interrupt register (RCC_CIR).

The frequency dispersion of the Low Speed Internal RC (LSI) oscillator can be calibrated to have accurate RTC time base and/or IWDG timeout (when LSI is used as clock source for these peripherals) with an acceptable accuracy.

This calibration is performed by measuring the LSI clock frequency with respect to TIM5 input clock (TIM5CLK). According to this measurement done at the precision of the HSE oscillator, the software can adjust the programmable 20-bit prescaler of the RTC to get an accurate time base or can compute accurate IWDG timeout.

After a system reset, the HSI oscillator is selected as system clock. When a clock source is used directly or through the PLL as the system clock, it is not possible to stop it.

A switch from one clock source to another occurs only if the target clock source is ready (clock stable after startup delay or PLL locked). If a clock source which is not yet ready is selected, the switch will occur when the clock source will be ready. Status bits in the Clock control register (RCC_CR) indicate which clock(s) is (are) ready and which clock is currently used as system clock.

a failure is detected on the HSE clock, the HSE Oscillator is automatically disabled, a clock failure event is sent to the break input of the TIM1 Advanced control timer and an interrupt is generated to inform the software about the failure (Clock Security System Interrupt CSSI), allowing the MCU to perform rescue operations. The CSSI is linked to the Cortex®-M3 NMI (Non-Maskable Interrupt) exception vector. 

Note:Once the CSS is enabled and if the HSE clock fails, the CSS interrupt occurs and an NMI is automatically generated. The NMI will be executed indefinitely unless the CSS interrupt pending bit is cleared. As a consequence, in the NMI ISR user must clear the CSS interrupt by setting the CSSC bit in the Clock interrupt register (RCC_CIR).

If the HSE oscillator is used directly or indirectly as the system clock (indirectly means: it is used as PLL input clock directly or through PLL2, and the PLL clock is used as system clock), a detected failure causes a switch of the system clock to the HSI oscillator and the disabling of the external HSE oscillator. If the HSE oscillator clock (divided or not) is the clock entry of the PLL (directly or through PLL2) used as system clock when the failure occurs, the PLL is disabled too.

The RTCCLK clock source can be either the HSE/128, LSE or LSI clocks. This is selected by programming the RTCSEL[1:0] bits in the Backup domain control register (RCC_BDCR). This selection cannot be modified without resetting the Backup domain.

If the Independent watchdog (IWDG) is started by either hardware option or software access, the LSI oscillator is forced ON and cannot be disabled. After the LSI oscillator temporization, the clock is provided to the IWDG.

The microcontroller clock output (MCO) capability allows the clock to be output onto the external MCO pin. The configuration registers of the corresponding GPIO port must be programmed in alternate function mode. One of 8 clock signals can be selected as the MCO clock. 

Bit 26 PLL2ON: PLL2 enableSet and cleared by software to enable PLL2.Cleared by hardware when entering Stop or Standby mode. This bit can not be cleared if the PLL2 clock is used indirectly as system clock (i.e. it is used as PLL clock entry that is used as system clock).0: PLL2 OFF1: PLL2 ON

Bit 24 PLLON: PLL enableSet and cleared by software to enable PLL.Cleared by hardware when entering Stop or Standby mode. This bit can not be reset if the PLL clock is used as system clock or is selected to become the system clock. Software must disable the USB OTG FS clock before clearing this bit.0: PLL OFF1: PLL ON

Bit 19 CSSON: Clock security system enableSet and cleared by software to enable the clock security system. When CSSON is set, the clock detector is enabled by hardware when the HSE oscillator is ready, and disabled by hardware if a HSE clock failure is detected.0: Clock detector OFF1: Clock detector ON (Clock detector ON if the HSE oscillator is ready, OFF if not)

Bit 18 HSEBYP: External high-speed clock bypassSet and cleared by software to bypass the oscillator with an external clock. The external clock must be enabled with the HSEON bit set, to be used by the device.  The HSEBYP bit can be written only if the HSE oscillator is disabled. 0: external 3-25 MHz oscillator not bypassed1: external 3-25 MHz oscillator bypassed with external clock

Bit 17 HSERDY: External high-speed clock ready flagSet by hardware to indicate that the  HSE oscillator is stable. This bit needs 6 cycles of the HSE oscillator clock to fall down after HSEON reset.0: HSE oscillator not ready1: HSE oscillator ready 

Bit 16 HSEON: HSE clock enableSet and cleared by software.Cleared by hardware to stop the HSE oscillator when entering Stop or Standby mode. This bit cannot be reset if the HSE oscillator is used directly or indirectly as the system clock.0: HSE oscillator OFF1: HSE oscillator ON

Bits 7:3 HSITRIM[4:0]: Internal high-speed clock trimmingThese bits provide an additional user-programmable trimming value that is added to the HSICAL[7:0] bits. It can be programmed to adjust to variations in voltage and temperature that influence the frequency of the internal HSI RC.The default value is 16, which, when added to the HSICAL value, should trim the HSI to 8 MHz ± 1%. The trimming step (Fhsitrim) is around 40 kHz between two consecutive HSICAL steps.

Bit 1 HSIRDY: Internal high-speed clock ready flagSet by hardware to indicate that internal 8 MHz RC oscillator is stable. After the HSION bit is cleared, HSIRDY goes low after 6 internal 8 MHz RC oscillator clock cycles.0: Internal 8 MHz RC oscillator not ready1: Internal 8 MHz RC oscillator ready

Bit 0 HSION: Internal high-speed clock enableSet and cleared by software.Set by hardware to force the internal 8 MHz RC oscillator ON when leaving Stop or Standby mode or in case of failure of the external 3-25 MHz oscillator used directly or indirectly as system clock. This bit can not be cleared if the internal 8 MHz RC is used directly or indirectly as system clock or is selected to become the system clock.0: Internal 8 MHz RC oscillator OFF1: Internal 8 MHz RC oscillator ON

Bits 26:24 MCO[3:0]: Microcontroller clock outputSet and cleared by software. 00xx: No clock0100: System clock (SYSCLK) selected0101: HSI clock selected0110: HSE clock selected0111: PLL clock divided by 2 selected1000: PLL2 clock selected1001: PLL3 clock divided by 2 selected1010: XT1 external 3-25 MHz oscillator clock selected (for Ethernet)1011: PLL3 clock selected (for Ethernet)Note: This clock output may have some truncated cycles at startup or during MCO clock source switching.The selected clock to output onto the MCO pin must not exceed 50 MHz (the maximum I/O speed).

Bit 22 OTGFSPRE: USB OTG FS prescalerSet and cleared by software to generate the 48 MHz USB OTG FS clock. This bit must be valid before enabling the OTG FS clock in the RCC_APB1ENR register. This bit can not be cleared if the OTG FS clock is enabled.0: PLL VCO (2 × PLLCLK) clock is divided by 3 (PLL must be configured to output 72 MHz)1: PLL VCO (2 × PLLCLK) clock is divided by 2 (PLL must be configured to output 48 MHz)

Bits 21:18 PLLMUL[3:0]: PLL multiplication factorThese bits are written by software to define the PLL multiplication factor. They can be written only when PLL is disabled. 000x: Reserved0010: PLL input clock x 40011: PLL input clock x 50100: PLL input clock x 60101: PLL input clock x 70110: PLL input clock x 80111: PLL input clock x 910xx: Reserved1100: Reserved1101: PLL input clock x 6.5111x: Reserved

Bit 17 PLLXTPRE: LSB of division factor PREDIV1Set and cleared by software to select the least significant bit of the PREDIV1 division factor. It is the same bit as bit(0) in the RCC_CFGR2 register, so modifying bit(0) in the RCC_CFGR2 register changes this bit accordingly.If bits[3:1] in register RCC_CFGR2 are not set, this bit controls if PREDIV1 divides its input clock by 2 (PLLXTPRE=1) or not (PLLXTPRE=0).This bit can be written only when PLL is disabled.

Bit 16 PLLSRC: PLL entry clock sourceSet and cleared by software to select PLL clock source. This bit can be written only when PLL is disabled.0: HSI oscillator clock / 2 selected as PLL input clock1: Clock from PREDIV1 selected as PLL input clockNote: When changing the main PLL’s entry clock source, the original clock source must be switched off only after the selection of the new clock source.

Bits 14:14 ADCPRE[1:0]: ADC prescalerSet and cleared by software to select the frequency of the clock to the ADCs.00: PCLK2 divided by 201: PCLK2 divided by 410: PCLK2 divided by 611: PCLK2 divided by 8

Bits 13:11 PPRE2[2:0]: APB high-speed prescaler (APB2)Set and cleared by software to control the division factor of the APB High speed clock (PCLK2).0xx: HCLK not divided100: HCLK divided by 2101: HCLK divided by 4110: HCLK divided by 8111: HCLK divided by 16

Bits 10:8 PPRE1[2:0]: APB Low-speed prescaler (APB1)Set and cleared by software to control the division factor of the APB Low speed clock (PCLK1).0xx: HCLK not divided100: HCLK divided by 2101: HCLK divided by 4110: HCLK divided by 8111: HCLK divided by 16

Bits 7:4 HPRE[3:0]: AHB prescalerSet and cleared by software to control AHB clock division factor.0xxx: SYSCLK not divided1000: SYSCLK divided by 21001: SYSCLK divided by 41010: SYSCLK divided by 81011: SYSCLK divided by 161100: SYSCLK divided by 641101: SYSCLK divided by 1281110: SYSCLK divided by 2561111: SYSCLK divided by 512Note: The prefetch buffer must be kept on when using a prescaler different from 1 on the AHB clock. Refer to the section Reading the Flash memory for more details.

Bits 3:2 SWS[1:0]: System clock switch statusSet and cleared by hardware to indicate which clock source is used as system clock.00: HSI oscillator used as system clock01: HSE oscillator used as system clock10: PLL used as system clock11: Not applicable

Bits 1:0 SW[1:0]: System clock SwitchSet and cleared by software to select SYSCLK source.Set by hardware to force HSI selection when leaving Stop and Standby mode or in case of failure of the HSE oscillator used directly or indirectly as system clock (if the Clock Security System is enabled).00: HSI selected as system clock01: HSE selected as system clock10: PLL selected as system clock11: Not allowed

Bit 10 HSIRDYIE: HSI ready interrupt enableSet and cleared by software to enable/disable interrupt caused by the internal 8 MHz RC oscillator stabilization.0: HSI ready interrupt disabled1: HSI ready interrupt enabled

Bit 7 CSSF: Clock security system interrupt flagSet by hardware when a failure is detected in the external 3-25 MHz oscillator. It is cleared by software setting the CSSC bit.0: No clock security interrupt caused by HSE clock failure1: Clock security interrupt caused by HSE clock failure

Bit 6 PLL3RDYF: PLL3 Ready Interrupt flagSet by hardware when the PLL3 locks and PLL3RDYIE is set. It is cleared by software setting the PLL3RDYC bit.0: No clock ready interrupt caused by PLL3 lock1: Clock ready interrupt caused by PLL3 lock

Bit 5 PLL2RDYF: PLL2 Ready Interrupt flagSet by hardware when the PLL2 locks and PLL2RDYDIE is set. It is cleared by software setting the PLL2RDYC bit.0: No clock ready interrupt caused by PLL2 lock1: Clock ready interrupt caused by PLL2 lock

Bit 4 PLLRDYF: PLL ready interrupt flagSet by hardware when the PLL locks and PLLRDYDIE is set. It is cleared by software setting the PLLRDYC bit.0: No clock ready interrupt caused by PLL lock1: Clock ready interrupt caused by PLL lock

Bit3 HSERDYF: HSE ready interrupt flagSet by hardware when External High Speed clock becomes stable and HSERDYIE is set. It is cleared by software setting the HSERDYC bit.0: No clock ready interrupt caused by the external 3-25 MHz oscillator1: Clock ready interrupt caused by the external 3-25 MHz oscillator

Bit 2 HSIRDYF: HSI ready interrupt flagSet by hardware when the Internal High Speed clock becomes stable and HSIRDYIE is set. It is cleared by software setting the HSIRDYC bit.0: No clock ready interrupt caused by the internal 8 MHz RC oscillator1: Clock ready interrupt caused by the internal 8 MHz RC oscillator

Bit 1 LSERDYF: LSE ready interrupt flagSet by hardware when the External Low Speed clock becomes stable and LSERDYIE is set. It is cleared by software setting the LSERDYC bit.0: No clock ready interrupt caused by the external 32 kHz oscillator1: Clock ready interrupt caused by the external 32 kHz oscillator

Bit 0 LSIRDYF: LSI ready interrupt flagSet by hardware when Internal Low Speed clock becomes stable and LSIRDYIE is set. It is cleared by software setting the LSIRDYC bit. 0: No clock ready interrupt caused by the internal RC 40 kHz oscillator1: Clock ready interrupt caused by the internal RC 40 kHz oscillator

Bit 16 ETHMACRXEN: Ethernet MAC RX clock enableSet and cleared by software.0: Ethernet MAC RX clock disabled1: Ethernet MAC RX clock enabledNote: In the RMII mode, if this clock is enabled, the RMII clock of the MAC is also enabled.

Bit 15 ETHMACTXEN: Ethernet MAC TX clock enableSet and cleared by software.0: Ethernet MAC TX clock disabled1: Ethernet MAC TX clock enabledNote: In the RMII mode, if this clock is enabled, the RMII clock of the MAC is also enabled.

Bit 14 ETHMACEN: Ethernet MAC clock enableSet and cleared by software. Selection of PHY interface (MII/RMII) must be done before enabling the MAC clock.0: Ethernet MAC clock disabled1: Ethernet MAC clock enabled

No wait states, except if the access occurs while an access to a peripheral in the APB2 domain is on going. In this case, wait states are inserted until the access to APB2 peripheral is finished.

Bit 2 SRAMEN: SRAM interface clock enableSet and cleared by software to disable/enable SRAM interface clock during Sleep mode.0: SRAM interface clock disabled during Sleep mode1: SRAM interface clock enabled during Sleep mode

No wait state, except if the access occurs while an access to a peripheral on APB1 domain is on going. In this case, wait states are inserted until this access to APB1 peripheral is finished.

Bits 9:8 RTCSEL[1:0]: RTC clock source selectionSet by software to select the clock source for the RTC. Once the RTC clock source has been selected, it cannot be changed anymore unless the Backup domain is reset. The BDRST bit can be used to reset the RTCSEL[1:0] bits.00: No clock01: LSE oscillator clock used as RTC clock10: LSI oscillator clock used as RTC clock11: HSE oscillator clock divided by 128 used as RTC clock

Bit 2 LSEBYP: External Low Speed oscillator bypassSet and cleared by software to bypass oscillator in debug mode. This bit can be written only when the external 32 kHz oscillator is disabled.0: LSE oscillator not bypassed1: LSE oscillator bypassed

Bit 1 LSERDY: External Low Speed oscillator readySet and cleared by hardware to indicate when the external 32 kHz oscillator is stable. After the LSEON bit is cleared, LSERDY goes low after 6 external low speed oscillator clock cycles0: External 32 kHz oscillator not ready1: External 32 kHz oscillator ready

Bit 31 LPWRRSTF: Low-power reset flagSet by hardware when a Low-power management reset occurs. It is cleared by writing to the RMVF bit.0: No Low-power management reset occurred1: Low-power management reset occurredFor further information on Low-power management reset, refer to Low-power management reset.

Bit 30 WWDGRSTF: Window watchdog reset flagSet by hardware when a window watchdog reset occurs. It is cleared by writing to the RMVF bit.0: No window watchdog reset occurred1: Window watchdog reset occurred

Bit 29 IWDGRSTF: Independent watchdog reset flagSet by hardware when an independent watchdog reset from VDD domain occurs. It is cleared by writing to the RMVF bit.0: No watchdog reset occurred1: Watchdog reset occurred

Bit 26 PINRSTF: PIN reset flagSet by hardware when a reset from the NRST pin occurs. It is cleared by writing to the RMVF bit.0: No reset from NRST pin occurred1: Reset from NRST pin occurred

Bit 1 LSIRDY: Internal low speed oscillator readySet and cleared by hardware to indicate when the internal RC 40 kHz oscillator is stable. After the LSION bit is cleared, LSIRDY goes low after 3 internal 40 kHz RC oscillator clock cycles.0: Internal RC 40 kHz oscillator not ready1: Internal RC 40 kHz oscillator ready

Bit 18 I2S3SRC: I2S3 clock sourceSet and cleared by software to select I2S3 clock source. This bit must be valid before enabling I2S3 clock.0: System clock (SYSCLK) selected as I2S3 clock entry1: PLL3 VCO clock selected as I2S3 clock entry

Bit 17 I2S2SRC: I2S2 clock sourceSet and cleared by software to select I2S2 clock source. This bit must be valid before enabling I2S2 clock.0: System clock (SYSCLK) selected as I2S2 clock entry1: PLL3 VCO clock selected as I2S2 clock entry

Bit 16 PREDIV1SRC: PREDIV1 entry clock sourceSet and cleared by software to select PREDIV1 clock source. This bit can be written only when PLL is disabled.0: HSE oscillator clock selected as PREDIV1 clock entry1: PLL2 selected as PREDIV1 clock entry

Bits 15:12 PLL3MUL[3:0]: PLL3 Multiplication FactorSet and cleared by software to control PLL3 multiplication factor. These bits can be written only when PLL3 is disabled.00xx: Reserved010x: Reserved0110: PLL3 clock entry x 80111: PLL3 clock entry x 91000: PLL3 clock entry x 101001: PLL3 clock entry x 111010: PLL3 clock entry x 121011: PLL3 clock entry x 131100: PLL3 clock entry x 141101: Reserved1110: PLL3 clock entry x 161111: PLL3 clock entry x 20

Bits 11:8 PLL2MUL[3:0]: PLL2 Multiplication FactorSet and cleared by software to control PLL2 multiplication factor. These bits can be written only when PLL2 is disabled.00xx: Reserved010x: Reserved0110: PLL2 clock entry x 80111: PLL2 clock entry x 91000: PLL2 clock entry x 101001: PLL2 clock entry x 111010: PLL2 clock entry x 121011: PLL2 clock entry x 131100: PLL2 clock entry x 141101: Reserved1110: PLL2 clock entry x 161111: PLL2 clock entry x 20

Bits 7:4 PREDIV2[3:0]: PREDIV2 division factorSet and cleared by software to select PREDIV2 division factor. These bits can be written only when both PLL2 and PLL3 are disabled.0000: PREDIV2 input clock not divided0001: PREDIV2 input clock divided by 20010: PREDIV2 input clock divided by 30011: PREDIV2 input clock divided by 40100: PREDIV2 input clock divided by 50101: PREDIV2 input clock divided by 60110: PREDIV2 input clock divided by 70111: PREDIV2 input clock divided by 81000: PREDIV2 input clock divided by 91001: PREDIV2 input clock divided by 101010: PREDIV2 input clock divided by 111011: PREDIV2 input clock divided by 121100: PREDIV2 input clock divided by 131101: PREDIV2 input clock divided by 141110: PREDIV2 input clock divided by 151111: PREDIV2 input clock divided by 16

Bits 3:0 PREDIV1[3:0]: PREDIV1 division factorSet and cleared by software to select PREDIV1 division factor. These bits can be written only when PLL is disabled.Note: Bit(0) is the same as bit(17) in the RCC_CFGR register, so modifying bit(17) in the RCC_CFGR register changes Bit(0) accordingly.0000: PREDIV1 input clock not divided0001: PREDIV1 input clock divided by 20010: PREDIV1 input clock divided by 30011: PREDIV1 input clock divided by 40100: PREDIV1 input clock divided by 50101: PREDIV1 input clock divided by 60110: PREDIV1 input clock divided by 70111: PREDIV1 input clock divided by 81000: PREDIV1 input clock divided by 91001: PREDIV1 input clock divided by 101010: PREDIV1 input clock divided by 111011: PREDIV1 input clock divided by 121100: PREDIV1 input clock divided by 131101: PREDIV1 input clock divided by 141110: PREDIV1 input clock divided by 151111: PREDIV1 input clock divided by 16

Each of the general-purpose I/O ports has two 32-bit configuration registers (GPIOx_CRL, GPIOx_CRH), two 32-bit data registers (GPIOx_IDR, GPIOx_ODR), a 32-bit set/reset register (GPIOx_BSRR), a 16-bit reset register (GPIOx_BRR) and a 32-bit locking register (GPIOx_LCKR).

Subject to the specific hardware characteristics of each I/O port listed in the datasheet, each port bit of the General Purpose IO (GPIO) Ports, can be individually configured by software in several modes:

Each I/O port bit is freely programmable, however the I/O port registers have to be accessed as 32-bit words (half-word or byte accesses are not allowed). The purpose of the GPIOx_BSRR and GPIOx_BRR registers is to allow atomic read/modify accesses to any of the GPIO registers. This way, there is no risk that an IRQ occurs between the read and the modify access.

When configured as output, the value written to the Output Data register (GPIOx_ODR) is output on the I/O pin. It is possible to use the output driver in Push-Pull mode or Open-Drain mode (only the N-MOS is activated when outputting 0).

There is no need for the software to disable interrupts when programming the GPIOx_ODR at bit level: it is possible to modify only one or several bits in a single atomic APB2 write access. This is achieved by programming to ‘1’ the Bit Set/Reset Register (GPIOx_BSRR, 

Note:It is also possible to emulate the AFI input pin by software by programming the GPIO controller. In this case, the port should be configured in Alternate Function Output mode. And obviously, the corresponding port should not be driven externally as it will be driven by the software using the GPIO controller.

To optimize the number of peripheral I/O functions for different device packages, it is possible to remap some alternate functions to some other pins. This is achieved by software, by programming the corresponding registers (refer to AFIO registers. In that case, the alternate functions are no longer mapped to their original assignations.

The locking mechanism allows the IO configuration to be frozen. When the LOCK sequence has been applied on a port bit, it is no longer possible to modify the value of the port bit until the next reset.

This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit it is no longer possible to modify the value of the port bit until the next reset.

To optimize the number of peripherals available for the 64-pin or the 100-pin or the 144-pin package, it is possible to remap some alternate functions to some other pins. This is achieved by software, by programming the AF remap and debug I/O configuration register (AFIO_MAPR). In this case, the alternate functions are no longer mapped to their original assignations. 

The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general-purpose I/O PC14 and PC15, respectively, when the LSE oscillator is off. The LSE has priority over the GP IOs function.

Note:The PC14/PC15 GPIO functionality is lost when the 1.8 V domain is powered off (by entering standby mode) or when the backup domain is supplied by VBAT (VDD no more supplied). In this case the IOs are set in analog mode.

Bit 16 LCKK[16]: Lock keyThis bit can be read anytime. It can only be modified using the Lock Key Writing Sequence. 0: Port configuration lock key not active1: Port configuration lock key active. GPIOx_LCKR register is locked until the next reset.

LOCK key writing sequence:Write 1Write 0Write 1Read 0Read 1 (this read is optional but confirms that the lock is active)Note: During the LOCK Key Writing sequence, the value of LCK[15:0] must not change.Any error in the lock sequence will abort the lock.

The CAN signals can be mapped on Port A, Port B or Port D as shown in Table 34. For port D, remapping is not possible in devices delivered in 36-, 48- and 64-pin packages.

To optimize the number of free GPIOs during debugging, this mapping can be configured in different ways by programming the SWJ_CFG[1:0] bits in the AF remap and debug I/O configuration register (AFIO_MAPR). Refer to Table 37.

Timer 4 channels 1 to 4 can be remapped from Port B to Port D. Other timer remapping possibilities are listed in Table 44 to Table 46. Refer to AF remap and debug I/O configuration register (AFIO_MAPR).

Bits 6:4 PORT[2:0]: Port selectionSet and cleared by software. Select the port used to output the Cortex® EVENTOUT signal.Note: The EVENTOUT signal output capability is not extended to ports PF and PG.000: PA selected001: PB selected010: PC selected011: PD selected100: PE selected

Bits 26:24 SWJ_CFG[2:0]: Serial wire JTAG configurationThese bits are write-only (when read, the value is undefined). They are used to configure the SWJ and trace alternate function I/Os. The SWJ (Serial Wire JTAG) supports JTAG or SWD access to the Cortex® debug port. The default state after reset is SWJ ON without trace. This allows JTAG or SW mode to be enabled by sending a specific sequence on the JTMS / JTCK pin.000: Full SWJ (JTAG-DP + SW-DP): Reset State001: Full SWJ (JTAG-DP + SW-DP) but without NJTRST010: JTAG-DP Disabled and SW-DP Enabled100: JTAG-DP Disabled and SW-DP DisabledOther combinations: no effect

Bits 20 ADC2_ETRGREG_REMAP: ADC 2 external trigger regular conversion remappingSet and cleared by software. This bit controls the trigger input connected to ADC2 external trigger regular conversion. When this bit is reset, the ADC2 external trigger regular conversion is connected to EXTI11. When this bit is set, the ADC2 external event regular conversion is connected to TIM8_TRGO.

Bits 19 ADC2_ETRGINJ_REMAP: ADC 2 external trigger injected conversion remappingSet and cleared by software. This bit controls the trigger input connected to ADC2 external trigger injected conversion. When this bit is reset, the ADC2 external trigger injected conversion is connected to EXTI15. When this bit is set, the ADC2 external event injected conversion is connected to TIM8_Channel4.

Bits 18 ADC1_ETRGREG_REMAP: ADC 1 external trigger regular conversion remappingSet and cleared by software. This bit controls the trigger input connected to ADC1External trigger regular conversion. When reset the ADC1 External trigger regular conversion is connected to EXTI11. When set the ADC1 External Event regular conversion is connected to TIM8 TRGO.

Bits 17 ADC1_ETRGINJ_REMAP: ADC 1 External trigger injected conversion remappingSet and cleared by software. This bit controls the trigger input connected to ADC1External trigger injected conversion. When reset the ADC1 External trigger injected conversion is connected to EXTI15. When set the ADC1 External Event injected conversion is connected to TIM8 Channel4.

Bits 16 TIM5CH4_IREMAP: TIM5 channel4 internal remapSet and cleared by software. This bit controls the TIM5_CH4 internal mapping. When reset the timer TIM5_CH4 is connected to PA3. When set the LSI internal clock is connected to TIM5_CH4 input for calibration purpose.Note: This bit is available only in high density value line devices.

Bit 15 PD01_REMAP: Port D0/Port D1 mapping on OSC_IN/OSC_OUTThis bit is set and cleared by software. It controls the mapping of PD0 and PD1 GPIO functionality. When the HSE oscillator is not used (application running on internal 8 MHz RC) PD0 and PD1 can be mapped on OSC_IN and OSC_OUT. This is available only on 36-, 48- and 64-pin packages (PD0 and PD1 are available on 100-pin and 144-pin packages, no need for remapping).0: No remapping of PD0 and PD11: PD0 remapped on OSC_IN, PD1 remapped on OSC_OUT,

Bits 14:13 CAN_REMAP[1:0]: CAN alternate function remappingThese bits are set and cleared by software. They control the mapping of alternate functions CAN_RX and CAN_TX in devices with a single CAN interface.00: CAN_RX mapped to PA11, CAN_TX mapped to PA1201: Not used10: CAN_RX mapped to PB8, CAN_TX mapped to PB9 (not available on 36-pin package)11: CAN_RX mapped to PD0, CAN_TX mapped to PD1

Bit 30 PTP_PPS_REMAP: Ethernet PTP PPS remappingThis bit is set and cleared by software. It enables the Ethernet MAC PPS_PTS to be output on the PB5 pin.0: PTP_PPS not output on PB5 pin.1: PTP_PPS is output on PB5 pin.Note: This bit is available only in connectivity line devices and is reserved otherwise.

Bit 29 TIM2ITR1_IREMAP: TIM2 internal trigger 1 remappingThis bit is set and cleared by software. It controls the TIM2_ITR1 internal mapping.0: Connect TIM2_ITR1 internally to the Ethernet PTP output for calibration purposes.1: Connect USB OTG SOF (Start of Frame) output to TIM2_ITR1 for calibration purposes.Note: This bit is available only in connectivity line devices and is reserved otherwise.

Bits 26:24 SWJ_CFG[2:0]: Serial wire JTAG configurationThese bits are write-only (when read, the value is undefined). They are used to configure the SWJ and trace alternate function I/Os. The SWJ (Serial Wire JTAG) supports JTAG or SWD access to the Cortex® debug port. The default state after reset is SWJ ON without trace. This allows JTAG or SW mode to be enabled by sending a specific sequence on the JTMS / JTCK pin.000: Full SWJ (JTAG-DP + SW-DP): Reset State001: Full SWJ (JTAG-DP + SW-DP) but without NJTRST010: JTAG-DP Disabled and SW-DP Enabled100: JTAG-DP Disabled and SW-DP DisabledOther combinations: no effect

Bit 23 MII_RMII_SEL: MII or RMII selectionThis bit is set and cleared by software. It configures the Ethernet MAC internally for use with an external MII or RMII PHY.0: Configure Ethernet MAC for connection with an MII PHY 1: Configure Ethernet MAC for connection with an RMII PHYNote: This bit is available only in connectivity line devices and is reserved otherwise.

Bits 16 TIM5CH4_IREMAP: TIM5 channel4 internal remapSet and cleared by software. This bit controls the TIM5_CH4 internal mapping. When reset the timer TIM5_CH4 is connected to PA3. When set the LSI internal clock is connected to TIM5_CH4 input for calibration purpose.

Bit 15 PD01_REMAP: Port D0/Port D1 mapping on OSC_IN/OSC_OUTThis bit is set and cleared by software. It controls the mapping of PD0 and PD1 GPIO functionality. When the HSE oscillator is not used (application running on internal 8 MHz RC) PD0 and PD1 can be mapped on OSC_IN and OSC_OUT. This is available only on 36-, 48- and 64-pin packages (PD0 and PD1 are available on 100-pin and 144-pin packages, no need for remapping).0: No remapping of PD0 and PD11: PD0 remapped on OSC_IN, PD1 remapped on OSC_OUT,

Bits 14:13 CAN1_REMAP[1:0]: CAN1 alternate function remappingThese bits are set and cleared by software. They control the mapping of alternate functions CAN1_RX and CAN1_TX.00: CAN1_RX mapped to PA11, CAN1_TX mapped to PA1201: Not used10: CAN1_RX mapped to PB8, CAN1_TX mapped to PB9 (not available on 36-pin package)11: CAN1_RX mapped to PD0, CAN1_TX mapped to PD1

Bits 15:0  EXTIx[3:0]: EXTI x configuration (x= 4 to 7)These bits are written by software to select the source input for EXTIx external interrupt.0000: PA[x] pin0001: PB[x] pin0010: PC[x] pin0011: PD[x] pin0100: PE[x] pin0101: PF[x] pin0110: PG[x] pin

Bits 15:0  EXTIx[3:0]: EXTI x configuration (x= 8 to 11)These bits are written by software to select the source input for EXTIx external interrupt.0000: PA[x] pin0001: PB[x] pin0010: PC[x] pin0011: PD[x] pin0100: PE[x] pin0101: PF[x] pin0110: PG[x] pin

Bits 15:0  EXTIx[3:0]: EXTI x configuration (x= 12 to 15)These bits are written by software to select the source input for EXTIx external interrupt.0000: PA[x] pin0001: PB[x] pin0010: PC[x] pin0011: PD[x] pin0100: PE[x] pin0101: PF[x] pin0110: PG[x] pin

Bit 10 FSMC_NADV: NADV connect/disconnectThis bit is set and cleared by software. It controls the use of the optional FSMC_NADV signal.0: The NADV signal is connected to the output (default)1: The NADV signal is not connected. The I/O pin can be used by another peripheral.

All interrupts including the core exceptions are managed by the NVIC. For more information on exceptions and NVIC programming, refer to STM32F10xxx Cortex®-M3 programming manual (see Related documents on page 1).

The external interrupt/event controller consists of up to 20 edge detectors in connectivity line devices, or 19 edge detectors in other devices for generating event/interrupt requests. Each input line can be independently configured to select the type (event or interrupt) and the corresponding trigger event (rising or falling or both). Each line can also masked independently. A pending register maintains the status line of the interrupt requests 


• enabling an interrupt in the peripheral control register but not in the NVIC, and enabling the SEVONPEND bit in the Cortex®-M3 System Control register. When the MCU resumes from WFE, the peripheral interrupt pending bit and the peripheral NVIC IRQ channel pending bit (in the NVIC interrupt clear pending register) have to be cleared.


• or configuring an external or internal EXTI line in event mode. When the CPU resumes from WFE, it is not necessary to clear the peripheral interrupt pending bit or the NVIC IRQ channel pending bit as the pending bit corresponding to the event line is not set.

To generate the interrupt, the interrupt line should be configured and enabled. This is done by programming the two trigger registers with the desired edge detection and by enabling the interrupt request by writing a ‘1’ to the corresponding bit in the interrupt mask register. When the selected edge occurs on the external interrupt line, an interrupt request is generated. The pending bit corresponding to the interrupt line is also set. This request is reset by writing a ‘1’ in the pending register.

To generate the event, the event line should be configured and enabled. This is done by programming the two trigger registers with the desired edge detection and by enabling the event request by writing a ‘1’ to the corresponding bit in the event mask register. When the selected edge occurs on the event line, an event pulse is generated. The pending bit corresponding to the event line is not set


• Configure the enable and mask bits that control the NVIC IRQ channel mapped to the External Interrupt Controller (EXTI) so that an interrupt coming from one of the 20 lines can be correctly acknowledged.

Bits 19:0 MRx: Interrupt Mask on line x0: Interrupt request from Line x is masked1: Interrupt request from Line x is not maskedNote: Bit 19 is used in connectivity line devices only and is reserved otherwise.

Bits 19:0 MRx: Event mask on line x0: Event request from Line x is masked1: Event request from Line x is not maskedNote: Bit 19 is used in connectivity line devices only and is reserved otherwise.

Note:The external wakeup lines are edge triggered, no glitches must be generated on these lines.If a rising edge on external interrupt line occurs during writing of EXTI_RTSR register, the pending bit will not be set.

Note:The external wakeup lines are edge triggered, no glitches must be generated on these lines.If a falling edge on external interrupt line occurs during writing of EXTI_FTSR register, the pending bit will not be set.

Bits 19:0 TRx: Rising trigger event configuration bit of line x0: Rising trigger disabled (for Event and Interrupt) for input line1: Rising trigger enabled (for Event and Interrupt) for input line.Note: Bit 19 is used in connectivity line devices only and is reserved otherwise.

Bits 19:0 TRx: Falling trigger event configuration bit of line x0: Falling trigger disabled (for Event and Interrupt) for input line1: Falling trigger enabled (for Event and Interrupt) for input line.Note: Bit 19 used in connectivity line devices and is reserved otherwise.

Bits 19:0 SWIERx: Software interrupt on line xIf the interrupt is enabled on this line in the EXTI_IMR, writing a '1' to this bit when it is set to '0' sets the corresponding pending bit in EXTI_PR resulting in an interrupt request generation. This bit is cleared by clearing the corresponding bit of EXTI_PR (by writing a 1 into the bit).Note: Bit 19 used in connectivity line devices and is reserved otherwise.

Bits 19:0 PRx: Pending bit 0: No trigger request occurred1: selected trigger request occurredThis bit is set when the selected edge event arrives on the external interrupt line. This bit is cleared by writing a ‘1’ into the bit. Note: Bit 19 is used in connectivity line devices only and is reserved otherwise.

The 12-bit ADC is a successive approximation analog-to-digital converter. It has up to 18 multiplexed channels allowing it measure signals from sixteen external and two internal sources. A/D conversion of the various channels can be performed in single, continuous, scan or discontinuous mode. The result of the ADC is stored in a left-aligned or right-aligned 16-bit data register.

The ADC input clock is generated from the PCLK2 clock divided by a prescaler and it must not exceed 14 MHz, refer to Figure 8 for low-, medium-, high- and XL-density devices, and to Figure 11 for connectivity line devices.

The ADC can be powered-on by setting the ADON bit in the ADC_CR2 register. When the ADON bit is set for the first time, it wakes up the ADC from Power Down mode.

The conversion can be stopped, and the ADC put in power down mode by resetting the ADON bit. In this mode the ADC consumes almost no power (only a few µA). 

The ADCCLK clock provided by the Clock Controller is synchronous with the PCLK2 (APB2 clock). The RCC controller has a dedicated programmable prescaler for the ADC clock, refer to Low-, medium-, high- and XL-density reset and clock control (RCC) for more details.

There are 16 multiplexed channels. It is possible to organize the conversions in two groups: regular and injected. A group consists of a sequence of conversions which can be done on any channel and in any order. For instance, it is possible to do the conversion in the following order: Ch3, Ch8, Ch2, Ch2, Ch0, Ch2, Ch2, Ch15.


• The regular group is composed of up to 16 conversions. The regular channels and their order in the conversion sequence must be selected in the ADC_SQRx registers. The total number of conversions in the regular group must be written in the L[3:0] bits in the ADC_SQR1 register.


• The injected group is composed of up to 4 conversions. The injected channels and their order in the conversion sequence must be selected in the ADC_JSQR register. The total number of conversions in the injected group must be written in the L[1:0] bits in the ADC_JSQR register.

If the ADC_SQRx or ADC_JSQR registers are modified during a conversion, the current conversion is reset and a new start pulse is sent to the ADC to convert the new chosen group.

The Temperature sensor is connected to channel ADCx_IN16 and the internal reference voltage VREFINT is connected to ADCx_IN17. These two internal channels can be selected and converted as injected or regular channels.

In Single conversion mode the ADC does one conversion. This mode is started either by setting the ADON bit in the ADC_CR2 register (for a regular channel only) or by external trigger (for a regular or injected channel), while the CONT bit is 0.

In continuous conversion mode ADC starts another conversion as soon as it finishes one. This mode is started either by external trigger or by setting the ADON bit in the ADC_CR2 register, while the CONT bit is 1.

As shown in Figure 23, the ADC needs a stabilization time of tSTAB before it starts converting accurately. After the start of ADC conversion and after 14 clock cycles, the EOC flag is set and the 16-bit ADC Data register contains the result of the conversion. 

The AWD analog watchdog status bit is set if the analog voltage converted by the ADC is below a low threshold or above a high threshold. These thresholds are programmed in the 12 least significant bits of the ADC_HTR and ADC_LTR 16-bit registers. An interrupt can be enabled by using the AWDIE bit in the ADC_CR1 register.

Scan mode can be selected by setting the SCAN bit in the ADC_CR1 register. Once this bit is set, ADC scans all the channels selected in the ADC_SQRx registers (for regular channels) or in the ADC_JSQR (for injected channels). A single conversion is performed for each channel of the group. After each end of conversion the next channel of the group is converted automatically. If the CONT bit is set, conversion does not stop at the last selected group channel but continues again from the first selected group channel.

When using scan mode, DMA bit must be set and the direct memory access controller is used to transfer the converted data of regular group channels to SRAM after each update of the ADC_DR register.

Note:When using triggered injection, the interval between trigger events must be longer than the injection sequence. For instance, if the sequence length is 28 ADC clock cycles (that is two conversions with a 1.5 clock-period sampling time), the minimum interval between triggers must be 29 ADC clock cycles.

If the JAUTO bit is set, then the injected group channels are automatically converted after the regular group channels. This can be used to convert a sequence of up to 20 conversions programmed in the ADC_SQRx and ADC_JSQR registers.

For ADC clock prescalers ranging from 4 to 8, a delay of 1 ADC clock period is automatically inserted when switching from regular to injected sequence (respectively injected to regular). When the ADC clock prescaler is set to 2, the delay is 2 ADC clock periods.

This mode is enabled by setting the DISCEN bit in the ADC_CR1 register. It can be used to convert a short sequence of n conversions (n <=8) which is a part of the sequence of conversions selected in the ADC_SQRx registers. The value of n is specified by writing to the DISCNUM[2:0] bits in the ADC_CR1 register.

When an external trigger occurs, it starts the next n conversions selected in the ADC_SQRx registers until all the conversions in the sequence are done. The total sequence length is defined by the L[3:0] bits in the ADC_SQR1 register.

conversionsecond trigger: sequence converted 3, 6, 7. An EOC event is generated at each conversionthird trigger: sequence converted 9, 10. An EOC event is generated at each conversionfourth trigger: sequence converted 0, 1, 2. An EOC event is generated at each conversion

This mode is enabled by setting the JDISCEN bit in the ADC_CR1 register. It can be used to convert the sequence selected in the ADC_JSQR register, channel by channel, after an external trigger event.

When an external trigger occurs, it starts the next channel conversions selected in the ADC_JSQR registers until all the conversions in the sequence are done. The total sequence length is defined by the JL[1:0] bits in the ADC_JSQR register.

n = 1, channels to be converted = 1, 2, 3first trigger: channel 1 converted second trigger: channel 2 converted third trigger: channel 3 converted and EOC and JEOC events generatedfourth trigger: channel 1

The ADC has an built-in self calibration mode. Calibration significantly reduces accuracy errors due to internal capacitor bank variations. During calibration, an error-correction code (digital word) is calculated for each capacitor, and during all subsequent conversions, the error contribution of each capacitor is removed using this code.

Calibration is started by setting the CAL bit in the ADC_CR2 register. Once calibration is over, the CAL bit is reset by hardware and normal conversion can be performed. It is recommended to calibrate the ADC once at power-on. The calibration codes are stored in the ADC_DR as soon as the calibration phase ends.

The injected group channels converted data value is decreased by the user-defined offset written in the ADC_JOFRx registers so the result can be a negative value. The SEXT bit is the extended sign value.

ADC samples the input voltage for a number of ADC_CLK cycles which can be modified us-ing the SMP[2:0] bits in the ADC_SMPR1 and ADC_SMPR2 registers. Each channel can be sampled with a different sample time.

Conversion can be triggered by an external event (e.g. timer capture, EXTI line). If the EXT-TRIG control bit is set then external events are able to trigger a conversion. The EXT-SEL[2:0] and JEXTSEL[2:0] control bits allow the application to select decide which out of 8possible events can trigger conversion for the regular and injected groups.

Since converted regular channels value are stored in a unique data register, it is necessary to use DMA for conversion of more than one regular channel. This avoids the loss of data already stored in the ADC_DR register.

Only the end of conversion of a regular channel generates a DMA request, which allows the transfer of its converted data from the ADC_DR register to the destination location selected by the user.

In dual ADC mode the start of conversion is triggered alternately or simultaneously by the ADC1 master to the ADC2 slave, depending on the mode selected by the DUALMOD[2:0] bits in the ADC1_CR1 register.

Note:In dual mode, when configuring conversion to be triggered by an external event, the user must set the trigger for the master only and set a software trigger for the slave to prevent spurious triggers to start unwanted slave conversion. However, external triggers must be enabled on both master and slave ADCs.

Note:In dual ADC mode, to read the slave converted data on the master data register, the DMA bit must be enabled even if it is not used to transfer converted regular channel data.

This mode converts an injected channel group. The source of external trigger comes from the injected group mux of ADC1 (selected by the JEXTSEL[2:0] bits in the ADC1_CR2 register). A simultaneous trigger is provided to ADC2. 

This mode is performed on a regular channel group. The source of the external trigger comes from the regular group mux of ADC1 (selected by the EXTSEL[2:0] bits in the ADC1_CR2 register). A simultaneous trigger is provided to the ADC2. 


• A 32-bit DMA transfer request is generated (if DMA bit is set) which transfers to SRAM the ADC1_DR 32-bit register containing the ADC2 converted data in the upper halfword and the ADC1 converted data in the lower halfword.

This mode can be started only on a regular channel group (usually one channel). The source of external trigger comes from the regular channel mux of ADC1. After an external trigger occurs:

After an EOC interrupt is generated by ADC1 (if enabled through the EOCIE bit) a 32-bit DMA transfer request is generated (if the DMA bit is set) which transfers to SRAM the ADC1_DR 32-bit register containing the ADC2 converted data in the upper halfword and the ADC1 converted data in the lower halfword.

This mode can be started only on a regular channel group (only one channel). The source of external trigger comes from regular channel mux of ADC1. After external trigger occurs: 

After an EOC interrupt is generated by ADC1 (if enabled through the EOCIE bit) a 32-bit DMA transfer request is generated (if the DMA bit is set) which transfers to SRAM the ADC1_DR 32-bit register containing the ADC2 converted data in the upper halfword and the ADC1 converted data in the lower halfword.

It is possible to interrupt regular group simultaneous conversion to start alternate trigger conversion of an injected group. Figure 36 shows the behavior of an alternate trigger interrupting a regular simultaneous conversion.

The injected alternate conversion is immediately started after the injected event arrives. If regular conversion is already running, in order to ensure synchronization after the injected conversion, the regular conversion of both (master/slave) ADCs is stopped and resumed synchronously at the end of the injected conversion.

If a trigger occurs during an injected conversion that has interrupted a regular conversion, it will be ignored. Figure 37 shows the behavior in this case (the second trigger is ignored).

It is possible to interrupt an interleaved conversion with an injected event. In this case the interleaved conversion is interrupted and the injected conversion starts, at the end of the injected sequence the interleaved conversion is resumed. Figure 38 shows the behavior using an example.

Note:When the ADC clock prescaler is set to 4, the interleaved mode does not recover with evenly spaced sampling periods: the sampling interval is 8 ADC clock periods followed by 6 ADC clock periods, instead of 7 clock periods followed by 7 clock periods.

The temperature sensor is internally connected to the ADCx_IN16 input channel which is used to convert the sensor output voltage into a digital value. The recommended sampling time for the temperature sensor is 17.1 µs.

The temperature sensor output voltage changes linearly with temperature. The offset of this line varies from chip to chip due to process variation (up to 45 °C from one chip to another). 

The internal temperature sensor is more suited to applications that detect temperature variations instead of absolute temperatures. If accurate temperature readings are needed, an external temperature sensor part should be used.

Note:The sensor has a startup time after waking from power down mode before it can output VSENSE at the correct level. The ADC also has a startup time after power-on, so to minimize the delay, the ADON and TSVREFE bits should be set at the same time.

An interrupt can be produced on end of conversion for regular and injected groups and when the analog watchdog status bit is set. Separate interrupt enable bits are available for flexibility.

Bit 4 STRT: Regular channel Start flag This bit is set by hardware when regular channel conversion starts. It is cleared by software.0: No regular channel conversion started1: Regular channel conversion has started

Bit 3 JSTRT: Injected channel Start flagThis bit is set by hardware when injected channel group conversion starts. It is cleared by software.0: No injected group conversion started1: Injected group conversion has started

Bit 2 JEOC: Injected channel end of conversionThis bit is set by hardware at the end of all injected group channel conversion. It is cleared by software. 0: Conversion is not complete 1: Conversion complete

Bit 1 EOC: End of conversionThis bit is set by hardware at the end of a group channel conversion (regular or injected). It is cleared by software or by reading the ADC_DR. 0: Conversion is not complete 1: Conversion complete

Bit 0 AWD: Analog watchdog flag This bit is set by hardware when the converted voltage crosses the values programmed in the ADC_LTR and ADC_HTR registers. It is cleared by software.0: No Analog watchdog event occurred1: Analog watchdog event occurred

Bits 19:16 DUALMOD[3:0]: Dual mode selectionThese bits are written by software to select the operating mode.0000: Independent mode. 0001: Combined regular simultaneous + injected simultaneous mode 0010: Combined regular simultaneous + alternate trigger mode0011: Combined injected simultaneous + fast interleaved mode 0100: Combined injected simultaneous + slow Interleaved mode 0101: Injected simultaneous mode only0110: Regular simultaneous mode only0111: Fast interleaved mode only1000: Slow interleaved mode only1001: Alternate trigger mode onlyNote: These bits are reserved in ADC2 and ADC3.In dual mode, a change of channel configuration generates a restart that can produce a loss of synchronization. It is recommended to disable dual mode before any configuration change.

Bit 12 JDISCEN: Discontinuous mode on injected channelsThis bit set and cleared by software to enable/disable discontinuous mode on injected group channels0: Discontinuous mode on injected channels disabled1: Discontinuous mode on injected channels enabled

Bit 11 DISCEN: Discontinuous mode on regular channelsThis bit set and cleared by software to enable/disable Discontinuous mode on regular channels.0: Discontinuous mode on regular channels disabled1: Discontinuous mode on regular channels enabled

Bit 10 JAUTO: Automatic Injected Group conversion This bit set and cleared by software to enable/disable automatic injected group conversion after regular group conversion.0: Automatic injected group conversion disabled 1: Automatic injected group conversion enabled

Bit 9 AWDSGL: Enable the watchdog on a single channel in scan modeThis bit set and cleared by software to enable/disable the analog watchdog on the channel identified by the AWDCH[4:0] bits.0: Analog watchdog enabled on all channels1: Analog watchdog enabled on a single channel 

Bit 8 SCAN: Scan mode This bit is set and cleared by software to enable/disable Scan mode. In Scan mode, the inputs selected through the ADC_SQRx or ADC_JSQRx registers are converted. 0: Scan mode disabled1: Scan mode enabledNote: An EOC or JEOC interrupt is generated only on the end of conversion of the last channel if the corresponding EOCIE or JEOCIE bit is set

Bit 7 JEOCIE: Interrupt enable for injected channelsThis bit is set and cleared by software to enable/disable the end of conversion interrupt for injected channels. 0: JEOC interrupt disabled1: JEOC interrupt enabled. An interrupt is generated when the JEOC bit is set.

Bit 6 AWDIE: Analog watchdog interrupt enable This bit is set and cleared by software to enable/disable the analog watchdog interrupt. 0: Analog watchdog interrupt disabled 1: Analog watchdog interrupt enabled

Bit 5 EOCIE: Interrupt enable for EOC This bit is set and cleared by software to enable/disable the End of Conversion interrupt. 0: EOC interrupt disabled1: EOC interrupt enabled. An interrupt is generated when the EOC bit is set.

Bit 23 TSVREFE: Temperature sensor and VREFINT enableThis bit is set and cleared by software to enable/disable the temperature sensor and VREFINT channel. In devices with dual ADCs this bit is present only in ADC1.0: Temperature sensor and VREFINT channel disabled1: Temperature sensor and VREFINT channel enabled

Bit 22 SWSTART: Start conversion of regular channelsThis bit is set by software to start conversion and cleared by hardware as soon as conversion starts. It starts a conversion of a group of regular channels if SWSTART is selected as trigger event by the EXTSEL[2:0] bits. 0: Reset state1: Starts conversion of regular channels 

Bit 21 JSWSTART: Start conversion of injected channelsThis bit is set by software and cleared by software or by hardware as soon as the conversion starts. It starts a conversion of a group of injected channels (if JSWSTART is selected as trigger event by the JEXTSEL[2:0] bits. 0: Reset state1: Starts conversion of injected channels

Bit 20 EXTTRIG: External trigger conversion mode for regular channelsThis bit is set and cleared by software to enable/disable the external trigger used to start conversion of a regular channel group.0: Conversion on external event disabled1: Conversion on external event enabled

Bits 19:17 EXTSEL[2:0]: External event select for regular groupThese bits select the external event used to trigger the start of conversion of a regular group:For ADC1 and ADC2, the assigned triggers are:000: Timer 1 CC1 event001: Timer 1 CC2 event010: Timer 1 CC3 event011: Timer 2 CC2 event100: Timer 3 TRGO event101: Timer 4 CC4 event110: EXTI line 11/TIM8_TRGO event (TIM8_TRGO is available only in high-density and XL-density devices)111: SWSTART

For ADC3, the assigned triggers are:000: Timer 3 CC1 event001: Timer 2 CC3 event010: Timer 1 CC3 event011: Timer 8 CC1 event100: Timer 8 TRGO event101: Timer 5 CC1 event110: Timer 5 CC3 event111: SWSTART

Bit 15 JEXTTRIG: External trigger conversion mode for injected channelsThis bit is set and cleared by software to enable/disable the external trigger used to start conversion of an injected channel group.0: Conversion on external event disabled1: Conversion on external event enabled

Bits 14:12 JEXTSEL[2:0]: External event select for injected groupThese bits select the external event used to trigger the start of conversion of an injected group:For ADC1 and ADC2 the assigned triggers are:000: Timer 1 TRGO event001: Timer 1 CC4 event010: Timer 2 TRGO event011: Timer 2 CC1 event100: Timer 3 CC4 event101: Timer 4 TRGO event110: EXTI line15/TIM8_CC4 event (TIM8_CC4 is available only in high-density and XL-density devices)111: JSWSTART

For ADC3 the assigned triggers are:000: Timer 1 TRGO event001: Timer 1 CC4 event010: Timer 4 CC3 event011: Timer 8 CC2 event100: Timer 8 CC4 event101: Timer 5 TRGO event110: Timer 5 CC4 event111: JSWSTART

Bit 8  DMA: Direct memory access modeThis bit is set and cleared by software. Refer to the DMA controller chapter for more details.0: DMA mode disabled1: DMA mode enabledOnly ADC1 and ADC3 can generate a DMA request.

Bit 3 RSTCAL: Reset calibrationThis bit is set by software and cleared by hardware. It is cleared after the calibration registers are initialized.0: Calibration register initialized. 1: Initialize calibration register.Note: If RSTCAL is set when conversion is ongoing, additional cycles are required to clear the calibration registers.

Bit 1 CONT: Continuous conversionThis bit is set and cleared by software. If set conversion takes place continuously till this bit is reset. 0: Single conversion mode 1: Continuous conversion mode 

Bit 0 ADON: A/D converter ON / OFFThis bit is set and cleared by software. If this bit holds a value of zero and a 1 is written to it then it wakes up the ADC from Power Down state.Conversion starts when this bit holds a value of 1 and a 1 is written to it. The application should allow a delay of tSTAB between power up and start of conversion. Refer to Figure 23.0: Disable ADC conversion/calibration and go to power down mode.1: Enable ADC and to start conversionNote: If any other bit in this register apart from ADON is changed at the same time, then conversion is not triggered. This is to prevent triggering an erroneous conversion.

Bits 11:0 JOFFSETx[11:0]: Data offset for injected channel x These bits are written by software to define the offset to be subtracted from the raw converted data when converting injected channels. The conversion result can be read from in the ADC_JDRx registers. 

Note:The software can write to these registers when an ADC conversion is ongoing. The programmed value will be effective when the next conversion is complete. Writing to this register is performed with a write delay that can create uncertainty on the effective time at which the new value is programmed.

Note:The software can write to these registers when an ADC conversion is ongoing. The programmed value will be effective when the next conversion is complete. Writing to this register is performed with a write delay that can create uncertainty on the effective time at which the new value is programmed.

Bits 21:20 JL[1:0]: Injected sequence lengthThese bits are written by software to define the total number of conversions in the injected channel conversion sequence.00: 1 conversion01: 2 conversions10: 3 conversions11: 4 conversions

Note: Unlike a regular conversion sequence, if JL[1:0] length is less than four, the channels are converted in a sequence starting from (4-JL). Example: ADC_JSQR[21:0] = 10 00011 00011 00111 00010 means that a scan conversion will convert the following channel sequence: 7, 3, 3. (not 2, 7, 3) 

Bits 15:0 JDATA[15:0]: Injected data These bits are read only. They contain the conversion result from injected channel x. The data is left or right-aligned as shown in Figure 27 and Figure 28.

Bits 31:16 ADC2DATA[15:0]: ADC2 dataIn ADC1: In dual mode, these bits contain the regular data of ADC2. Refer to Section 11.9: Dual ADC mode.In ADC2 and ADC3: these bits are not used.

Bits 15:0 DATA[15:0]: Regular dataThese bits are read only. They contain the conversion result from the regular channels. The data is left or right-aligned as shown in Figure 27 and Figure 28.

The DAC module is a 12-bit, voltage output digital-to-analog converter. The DAC can be configured in 8- or 12-bit mode and may be used in conjunction with the DMA controller. In 12-bit mode, the data could be left- or right-aligned. The DAC has two output channels, each with its own converter. In dual DAC channel mode, conversions could be done independently or simultaneously when both channels are grouped together for synchronous update operation. An input reference pin VREF+ (shared with ADC) is available for better resolution.

Note:Once DAC channelx is enabled, the corresponding GPIO pin (PA4 or PA5) is automatically connected to the analog converter output (DAC_OUTx). To avoid parasitic consumption, the PA4 or PA5 pin should first be configured to analog (AIN).

The DAC integrates two output buffers that can be used to reduce the output impedance, and to drive external loads directly without having to add an external operational amplifier. Each DAC channel output buffer can be enabled and disabled using the corresponding BOFFx bit in the DAC_CR register.

Depending on the loaded DAC_DHRyyyx register, the data written by the user will be shifted and stored into the DHRx (Data Holding Registerx, that are internal non-memory-mapped registers). The DHRx register will then be loaded into the DORx register either automatically, by software trigger or by an external event trigger.

–8-bit right alignment: data for DAC channel1 to be loaded into DAC_DHR8RD [7:0] bits (stored into DHR1[11:4] bits) and data for DAC channel2 to be loaded into DAC_DHR8RD [15:8] bits (stored into DHR2[11:4] bits)

–12-bit left alignment: data for DAC channel1 to be loaded into DAC_DHR12LD [15:4] bits (stored into DHR1[11:0] bits) and data for DAC channel2 to be loaded into DAC_DHR12LD [31:20] bits (stored into DHR2[11:0] bits) 

–12-bit right alignment: data for DAC channel1 to be loaded into DAC_DHR12RD [11:0] bits (stored into DHR1[11:0] bits) and data for DAC channel2 to be loaded into DAC_DHR12RD [27:16] bits (stored into DHR2[11:0] bits)

Depending on the loaded DAC_DHRyyyD register, the data written by the user will be shifted and stored into the DHR1 and DHR2 (Data Holding Registers, that are internal non-memory-mapped registers). The DHR1 and DHR2 registers will then be loaded into the DOR1 and DOR2 registers, respectively, either automatically, by software trigger or by an external event trigger.

Data stored into the DAC_DHRx register are automatically transferred to the DAC_DORx register after one APB1 clock cycle, if no hardware trigger is selected (TENx bit in DAC_CR register is reset). However, when a hardware trigger is selected (TENx bit in DAC_CR register is set) and a trigger occurs, the transfer is performed three APB1 clock cycles later.

When DAC_DORx is loaded with the DAC_DHRx contents, the analog output voltage becomes available after a time of tSETTLING that depends on the power supply voltage and the analog output load.

If the TENx control bit is set, conversion can then be triggered by an external event (timer counter, external interrupt line). The TSELx[2:0] control bits determine which one, out of 8 possible events, will trigger conversion, as shown in Table 74.

Each time a DAC interface detects a rising edge on the selected timer TRGO output, or on the selected external interrupt line 9, the last data stored into the DAC_DHRx register is transferred into the DAC_DORx register. The DAC_DORx register is updated three APB1 cycles after the trigger occurs.

If the software trigger is selected, the conversion starts once the SWTRIG bit is set. SWTRIG is reset by hardware once the DAC_DORx register has been loaded with the DAC_DHRx register contents.

A DAC DMA request is generated when an external trigger (but not a software trigger) occurs while the DMAENx bit is set. The value of the DAC_DHRx register is then transferred to the DAC_DORx register.In dual mode, if both DMAENx bits are set, two DMA requests are generated. If only one DMA request is needed, you should set only the corresponding DMAENx bit. In this way, the application can manage both DAC channels in dual mode by using one DMA request and a unique DMA channel.

The DAC DMA request is not queued so that if a second external trigger arrives before the acknowledgement of the last request, then the new request will not be serviced and no error is reported

In order to generate a variable-amplitude pseudonoise, a Linear Feedback Shift Register is available. The DAC noise generation is selected by setting WAVEx[1:0] to “01”. The preloaded value in the LFSR is 0xAAA. This register is updated, three APB1 clock cycles after each trigger event, following a specific calculation algorithm.

The LFSR value, that may be masked partially or totally by means of the MAMPx[3:0] bits in the DAC_CR register, is added up to the DAC_DHRx contents without overflow and this value is then stored into the DAC_DORx register.

It is possible to add a small-amplitude triangular waveform on a DC or slowly varying signal. DAC triangle-wave generation is selected by setting WAVEx[1:0] to “10”. The amplitude is configured through the MAMPx[3:0] bits in the DAC_CR register. An internal triangle counter is incremented three APB1 clock cycles after each trigger event. The value of this counter is then added to the DAC_DHRx register without overflow and the sum is stored into the DAC_DORx register. The triangle counter is incremented while it is less than the maximum amplitude defined by the MAMPx[3:0] bits. Once the configured amplitude is reached, the counter is decremented down to 0, then incremented again and so on.

To efficiently use the bus bandwidth in applications that require the two DAC channels at the same time, three dual registers are implemented: DHR8RD, DHR12RD and DHR12LD. A unique register access is then required to drive both DAC channels at the same time.

When a DAC channel1 trigger arrives, the LFSR1 counter, with the same mask, is added to the DHR1 register and the sum is transferred into DAC_DOR1 (three APB1 clock cycles later). Then the LFSR1 counter is updated.

When a DAC channel2 trigger arrives, the LFSR2 counter, with the same mask, is added to the DHR2 register and the sum is transferred into DAC_DOR2 (three APB1 clock cycles later). Then the LFSR2 counter is updated.

When a DAC channel1 trigger arrives, the LFSR1 counter, with the mask configured by MAMP1[3:0], is added to the DHR1 register and the sum is transferred into DAC_DOR1 (three APB1 clock cycles later). Then the LFSR1 counter is updated.

When a DAC channel2 trigger arrives, the LFSR2 counter, with the mask configured by MAMP2[3:0], is added to the DHR2 register and the sum is transferred into DAC_DOR2 (three APB1 clock cycles later). Then the LFSR2 counter is updated.

When a DAC channel2 trigger arrives, the DAC channel2 triangle counter, with the same triangle amplitude, is added to the DHR2 register and the sum is transferred into DAC_DOR2 (three APB1 clock cycles later). The DAC channel2 triangle counter is then updated.

When a DAC channel1 trigger arrives, the DAC channel1 triangle counter, with a triangle amplitude configured by MAMP1[3:0], is added to the DHR1 register and the sum is transferred into DAC_DOR1 (three APB1 clock cycles later). The DAC channel1 triangle counter is then updated.

When a DAC channel2 trigger arrives, the DAC channel2 triangle counter, with a triangle amplitude configured by MAMP2[3:0], is added to the DHR2 register part and the sum is transferred into DAC_DOR2 (three APB1 clock cycles later). The DAC channel2 triangle counter is then updated.

When a trigger arrives, the LFSR1 counter, with the same mask, is added to the DHR1 register and the sum is transferred into DAC_DOR1 (three APB1 clock cycles later). The LFSR1 counter is then updated. At the same time, the LFSR2 counter, with the same mask, is added to the DHR2 register and the sum is transferred into DAC_DOR2 (three APB1 clock cycles later). The LFSR2 counter is then updated.

When a trigger arrives, the LFSR1 counter, with the mask configured by MAMP1[3:0], is added to the DHR1 register and the sum is transferred into DAC_DOR1 (three APB1 clock cycles later). The LFSR1 counter is then updated.At the same time, the LFSR2 counter, with the mask configured by MAMP2[3:0], is added to the DHR2 register and the sum is transferred into DAC_DOR2 (three APB1 clock cycles later). The LFSR2 counter is then updated.

When a trigger arrives, the DAC channel1 triangle counter, with the same triangle amplitude, is added to the DHR1 register and the sum is transferred into DAC_DOR1 (three APB1 clock cycles later). The DAC channel1 triangle counter is then updated.At the same time, the DAC channel2 triangle counter, with the same triangle amplitude, is 

When a trigger arrives, the DAC channel1 triangle counter, with a triangle amplitude configured by MAMP1[3:0], is added to the DHR1 register and the sum is transferred into DAC_DOR1 (three APB1 clock cycles later). Then the DAC channel1 triangle counter is updated.At the same time, the DAC channel2 triangle counter, with a triangle amplitude configured by MAMP2[3:0], is added to the DHR2 register and the sum is transferred into DAC_DOR2 (three APB1 clock cycles later). Then the DAC channel2 triangle counter is updated.

Bit 27:24 MAMP2[3:0]: DAC channel2 mask/amplitude selectorThese bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode.0000: Unmask bit0 of LFSR/ Triangle Amplitude equal to 10001: Unmask bits[1:0] of LFSR/ Triangle Amplitude equal to 30010: Unmask bits[2:0] of LFSR/ Triangle Amplitude equal to 70011: Unmask bits[3:0] of LFSR/ Triangle Amplitude equal to 150100: Unmask bits[4:0] of LFSR/ Triangle Amplitude equal to 310101: Unmask bits[5:0] of LFSR/ Triangle Amplitude equal to 630110: Unmask bits[6:0] of LFSR/ Triangle Amplitude equal to 1270111: Unmask bits[7:0] of LFSR/ Triangle Amplitude equal to 2551000: Unmask bits[8:0] of LFSR/ Triangle Amplitude equal to 5111001: Unmask bits[9:0] of LFSR/ Triangle Amplitude equal to 10231010: Unmask bits[10:0] of LFSR/ Triangle Amplitude equal to 2047≥ 1011: Unmask bits[11:0] of LFSR/ Triangle Amplitude equal to 4095

Bit 23:22 WAVE2[1:0]: DAC channel2 noise/triangle wave generation enableThese bits are set/reset by software.00: wave generation disabled 01: Noise wave generation enabled 1x: Triangle wave generation enabledNote: only used if bit TEN2 = 1 (DAC channel2 trigger enabled)

Bits 21:19 TSEL2[2:0]: DAC channel2 trigger selectionThese bits select the external event used to trigger DAC channel2000: Timer 6 TRGO event001: Timer 3 TRGO event in connectivity line devices, Timer 8 TRGO in high-density and XL-density devices010: Timer 7 TRGO event011: Timer 5 TRGO event100: Timer 2 TRGO event101: Timer 4 TRGO event110: External line9 111: Software trigger Note: only used if bit TEN2 = 1 (DAC channel2 trigger enabled)

Bit 18 TEN2: DAC channel2 trigger enableThis bit set and cleared by software to enable/disable DAC channel2 trigger 0: DAC channel2 trigger disabled and data written into DAC_DHRx register is transferred one APB1 clock cycle later to the DAC_DOR2 register.1: DAC channel2 trigger enabled and data transfer from DAC_DHRx register is transferred three APB1 clock cycles later to the DAC_DOR2 register.Note: When software trigger is selected, it takes only one APB1 clock cycle for DAC_DHRx to DAC_DOR2 register transfer.

Bits 11:8 MAMP1[3:0]: DAC channel1 mask/amplitude selectorThese bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode.0000: Unmask bit0 of LFSR/ Triangle Amplitude equal to 10001: Unmask bits[1:0] of LFSR/ Triangle Amplitude equal to 30010: Unmask bits[2:0] of LFSR/ Triangle Amplitude equal to 70011: Unmask bits[3:0] of LFSR/ Triangle Amplitude equal to 150100: Unmask bits[4:0] of LFSR/ Triangle Amplitude equal to 310101: Unmask bits[5:0] of LFSR/ Triangle Amplitude equal to 630110: Unmask bits[6:0] of LFSR/ Triangle Amplitude equal to 1270111: Unmask bits[7:0] of LFSR/ Triangle Amplitude equal to 2551000: Unmask bits[8:0] of LFSR/ Triangle Amplitude equal to 5111001: Unmask bits[9:0] of LFSR/ Triangle Amplitude equal to 10231010: Unmask bits[10:0] of LFSR/ Triangle Amplitude equal to 2047≥ 1011: Unmask bits[11:0] of LFSR/ Triangle Amplitude equal to 4095

Bits 7:6 WAVE1[1:0]: DAC channel1 noise/triangle wave generation enableThese bits are set/reset by software.00: wave generation disabled 01: Noise wave generation enabled 1x: Triangle wave generation enabledNote: only used if bit TEN1 = 1 (DAC channel1 trigger enabled)

Bits 5:3 TSEL1[2:0]: DAC channel1 trigger selectionThese bits select the external event used to trigger DAC channel1000: Timer 6 TRGO event001: Timer 3 TRGO event in connectivity line devices, Timer 8 TRGO in high-density and XL-density devices010: Timer 7 TRGO event011: Timer 5 TRGO event100: Timer 2 TRGO event101: Timer 4 TRGO event110: External line9 111: Software trigger Note: only used if bit TEN1 = 1 (DAC channel1 trigger enabled)

Bit 2 TEN1: DAC channel1 trigger enableThis bit set and cleared by software to enable/disable DAC channel1 trigger 0: DAC channel1 trigger disabled and data written into DAC_DHRx register is transferred one APB1 clock cycle later to the DAC_DOR1 register.1: DAC channel1 trigger enabled and data transfer from DAC_DHRx register is transferred three APB1 clock cycles later to the DAC_DOR1 register.Note: When software trigger is selected, it takes only one APB1 clock cycle for DAC_DHRx to DAC_DOR1 register transfer.

Bit 1 SWTRIG2: DAC channel2 software triggerThis bit is set and cleared by software to enable/disable the software trigger.0: Software trigger disabled1: Software trigger enabledNote: This bit is reset by hardware (one APB1 clock cycle later) once the DAC_DHR2 register value is loaded to the DAC_DOR2 register.

Bit 0 SWTRIG1: DAC channel1 software triggerThis bit is set and cleared by software to enable/disable the software trigger.0: Software trigger disabled1: Software trigger enabledNote: This bit is reset by hardware (one APB1 clock cycle later) once the DAC_DHR1 register value is loaded to the DAC_DOR1 register.

Direct memory access (DMA) is used in order to provide high-speed data transfer between peripherals and memory as well as memory to memory. Data can be quickly moved by DMA without any CPU actions. This keeps CPU resources free for other operations.

The two DMA controllers have 12 channels in total (7 for DMA1 and 5 for DMA2), each dedicated to managing memory access requests from one or more peripherals. It has an arbiter for handling the priority between DMA requests.


• Priorities between requests from channels of one DMA are software programmable (4 levels consisting of very high, high, medium, low) or hardware in case of equality (request 1 has priority over request 2, etc.)

The DMA controller performs direct memory transfer by sharing the system bus with the Cortex®-M3 core. The DMA request may stop the CPU access to the system bus for some bus cycles, when the CPU and DMA are targeting the same destination (memory or peripheral). The bus matrix implements round-robin scheduling, thus ensuring at least half of the system bus bandwidth (both to memory and peripheral) for the CPU.

After an event, the peripheral sends a request signal to the DMA Controller. The DMA controller serves the request depending on the channel priorities. As soon as the DMA Controller accesses the peripheral, an Acknowledge is sent to the peripheral by the DMA Controller. The peripheral releases its request as soon as it gets the Acknowledge from the DMA Controller. Once the request is deasserted by the peripheral, the DMA Controller release the Acknowledge. If there are more requests, the peripheral can initiate the next transaction.


• The loading of data from the peripheral data register or a location in memory addressed through an internal current peripheral/memory address register. The start address used for the first transfer is the base peripheral/memory address programmed in the DMA_CPARx or DMA_CMARx register


• The storage of the data loaded to the peripheral data register or a location in memory addressed through an internal current peripheral/memory address register. The start address used for the first transfer is the base peripheral/memory address programmed in the DMA_CPARx or DMA_CMARx register


• Hardware: if 2 requests have the same software priority level, the channel with the lowest number will get priority versus the channel with the highest number. For example, channel 2 gets priority over channel 4.

Each channel can handle DMA transfer between a peripheral register located at a fixed address and a memory address. The amount of data to be transferred (up to 65535) is programmable. The register which contains the amount of data items to be transferred is decremented after each transaction. 

Peripheral and memory pointers can optionally be automatically post-incremented after each transaction depending on the PINC and MINC bits in the DMA_CCRx register. If incremented mode is enabled, the address of the next transfer will be the address of the previous one incremented by 1, 2 or 4 depending on the chosen data size. The first transfer address is the one programmed in the DMA_CPARx/DMA_CMARx registers. During transfer operations, these registers keep the initially programmed value. The current 

If the channel is configured in noncircular mode, no DMA request is served after the last transfer (that is once the number of data items to be transferred has reached zero). In order to reload a new number of data items to be transferred into the DMA_CNDTRx register, the DMA channel must be disabled.

In circular mode, after the last transfer, the DMA_CNDTRx register is automatically reloaded with the initially programmed value. The current internal address registers are reloaded with the base address values from the DMA_CPARx/DMA_CMARx registers.

Once half of the bytes are transferred, the half-transfer flag (HTIF) is set and an interrupt is generated if the Half-Transfer Interrupt Enable bit (HTIE) is set. At the end of the transfer, the Transfer Complete Flag (TCIF) is set and an interrupt is generated if the Transfer Complete Interrupt Enable bit (TCIE) is set. 

Circular mode is available to handle circular buffers and continuous data flows (e.g. ADC scan mode). This feature can be enabled using the CIRC bit in the DMA_CCRx register. When circular mode is activated, the number of data to be transferred is automatically reloaded with the initial value programmed during the channel configuration phase, and the DMA requests continue to be served.

If the MEM2MEM bit in the DMA_CCRx register is set, then the channel initiates transfers as soon as it is enabled by software by setting the Enable bit (EN) in the DMA_CCRx 

When the DMA initiates an AHB byte or halfword write operation, the data are duplicated on the unused lanes of the HWDATA[31:0] bus. So when the used AHB slave peripheral does not support byte or halfword write operations (when HSIZE is not used by the peripheral) 

Assuming that the AHB/APB bridge is an AHB 32-bit slave peripheral that does not take the HSIZE data into account, it will transform any AHB byte or halfword operation into a 32-bit APB operation in the following manner:


• an AHB byte write operation of the data “0xB0” to 0x0 (or to 0x1, 0x2 or 0x3) will be converted to an APB word write operation of the data “0xB0B0B0B0” to 0x0

For instance, to write the APB backup registers (16-bit registers aligned to a 32-bit address boundary), the memory source size (MSIZE) must be configured to “16-bit” and the peripheral destination size (PSIZE) to “32-bit”.

A DMA transfer error can be generated by reading from or writing to a reserved address space. When a DMA transfer error occurs during a DMA read or a write access, the faulty channel is automatically disabled through a hardware clear of its EN bit in the corresponding Channel configuration register (DMA_CCRx). The channel's transfer error interrupt flag (TEIF) in the DMA_IFR register is set and an interrupt is generated if the transfer error interrupt enable bit (TEIE) in the DMA_CCRx register is set.

Note:In high-density and XL-density devices, DMA2 Channel4 and DMA2 Channel5 interrupts are mapped onto the same interrupt vector. In connectivity line devices, DMA2 Channel4 and DMA2 Channel5 interrupts have separate interrupt vectors. All other DMA1 and DMA2 Channel interrupts have their own interrupt vector.

The 7 requests from the peripherals (TIMx[1,2,3,4], ADC1, SPI1, SPI/I2S2, I2Cx[1,2] and USARTx[1,2,3]) are simply logically ORed before entering the DMA1, this means that only one request must be enabled at a time. Refer to Figure 50. 

The five requests from the peripherals (TIMx[5,6,7,8], ADC3, SPI/I2S3, UART4, DAC_Channel[1,2] and SDIO) are simply logically ORed before entering the DMA2, this means that only one request must be enabled at a time. Refer to Figure 51. 

Bits 15:0 NDT[15:0]: Number of data to transferNumber of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer.Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode.If this register is zero, no transaction can be served whether the channel is enabled or not.

Bits 31:0 PA[31:0]: Peripheral addressBase address of the peripheral data register from/to which the data will be read/written.When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address.When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.

Bits 31:0 MA[31:0]: Memory addressBase address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address.When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.

It may be used for a variety of purposes, including measuring the pulse lengths of input signals (input capture) or generating output waveforms (output compare, PWM, complementary PWM with dead-time insertion).

The main block of the programmable advanced-control timer is a 16-bit counter with its related auto-reload register. The counter can count up, down or both up and down. The counter clock can be divided by a prescaler. 

The auto-reload register is preloaded. Writing to or reading from the auto-reload register accesses the preload register. The content of the preload register are transferred into the shadow register permanently or at each update event (UEV), depending on the auto-reload preload enable bit (ARPE) in TIMx_CR1 register. The update event is sent when the counter reaches the overflow (or underflow when downcounting) and if the UDIS bit equals 0 in the TIMx_CR1 register. It can also be generated by software. The generation of the update event is described in detailed for each configuration.

The counter is clocked by the prescaler output CK_CNT, which is enabled only when the counter enable bit (CEN) in TIMx_CR1 register is set (refer also to the slave mode controller description to get more details on counter enabling). 

The prescaler can divide the counter clock frequency by any factor between 1 and 65536. It is based on a 16-bit counter controlled through a 16-bit register (in the TIMx_PSC register). It can be changed on the fly as this control register is buffered. The new prescaler ratio is taken into account at the next update event.

If the repetition counter is used, the update event (UEV) is generated after upcounting is repeated for the number of times programmed in the repetition counter register plus one (TIMx_RCR+1). Else the update event is generated at each counter overflow.

The UEV event can be disabled by software by setting the UDIS bit in the TIMx_CR1 register. This is to avoid updating the shadow registers while writing new values in the preload registers. Then no update event occurs until the UDIS bit has been written to 0. However, the counter restarts from 0, as well as the counter of the prescaler (but the prescale rate does not change). In addition, if the URS bit (update request selection) in TIMx_CR1 register is set, setting the UG bit generates an update event UEV but without setting the UIF flag (thus no interrupt or DMA request is sent). This is to avoid generating both update and capture interrupts when clearing the counter on the capture event.

If the repetition counter is used, the update event (UEV) is generated after downcounting is repeated for the number of times programmed in the repetition counter register plus one (TIMx_RCR+1). Else the update event is generated at each counter underflow.

The UEV update event can be disabled by software by setting the UDIS bit in TIMx_CR1 register. This is to avoid updating the shadow registers while writing new values in the preload registers. Then no update event occurs until UDIS bit has been written to 0. However, the counter restarts from the current auto-reload value, whereas the counter of the prescaler restarts from 0 (but the prescale rate doesn’t change). 

In addition, if the URS bit (update request selection) in TIMx_CR1 register is set, setting the UG bit generates an update event UEV but without setting the UIF flag (thus no interrupt or DMA request is sent). This is to avoid generating both update and capture interrupts when clearing the counter on the capture event.


• The auto-reload active register is updated with the preload value (content of the TIMx_ARR register). Note that the auto-reload is updated before the counter is reloaded, so that the next period is the expected one

In center-aligned mode, the counter counts from 0 to the auto-reload value (content of the TIMx_ARR register) – 1, generates a counter overflow event, then counts from the auto-reload value down to 1 and generates a counter underflow event. Then it restarts counting from 0.

Center-aligned mode is active when the CMS bits in TIMx_CR1 register are not equal to '00'. The Output compare interrupt flag of channels configured in output is set when: the counter counts down (Center aligned mode 1, CMS = "01"), the counter counts up (Center aligned mode 2, CMS = "10") the counter counts up and down (Center aligned mode 3, CMS = "11").

The update event can be generated at each counter overflow and at each counter underflow or by setting the UG bit in the TIMx_EGR register (by software or by using the slave mode controller) also generates an update event. In this case, the counter restarts counting from 0, as well as the counter of the prescaler.

The UEV update event can be disabled by software by setting the UDIS bit in the TIMx_CR1 register. This is to avoid updating the shadow registers while writing new values in the preload registers. Then no update event occurs until UDIS bit has been written to 0. However, the counter continues counting up and down, based on the current auto-reload value. 

In addition, if the URS bit (update request selection) in TIMx_CR1 register is set, setting the UG bit generates an UEV update event but without setting the UIF flag (thus no interrupt or DMA request is sent). This is to avoid generating both update and capture interrupts when clearing the counter on the capture event.


• The auto-reload active register is updated with the preload value (content of the TIMx_ARR register). Note that if the update source is a counter overflow, the auto-reload is updated before the counter is reloaded, so that the next period is the expected one (the counter is loaded with the new value).

This means that data are transferred from the preload registers to the shadow registers (TIMx_ARR auto-reload register, TIMx_PSC prescaler register, but also TIMx_CCRx capture/compare registers in compare mode) every N+1 counter overflows or underflows, where N is the value in the TIMx_RCR repetition counter register.


• At each counter overflow and at each counter underflow in center-aligned mode. Although this limits the maximum number of repetition to 128 PWM cycles, it makes it possible to update the duty cycle twice per PWM period. When refreshing compare registers only once per PWM period in center-aligned mode, maximum resolution is 2xTck, due to the symmetry of the pattern.

The repetition counter is an auto-reload type; the repetition rate is maintained as defined by the TIMx_RCR register value (refer to Figure 72). When the update event is generated by software (by setting the UG bit in TIMx_EGR register) or by hardware through the slave mode controller, it occurs immediately whatever the value of the repetition counter is and the repetition counter is reloaded with the content of the TIMx_RCR register.

In center-aligned mode, for odd values of RCR, the update event occurs either on the overflow or on the underflow depending on when the RCR register was written and when the counter was started. If the RCR was written before starting the counter, the UEV occurs on the overflow. If the RCR was written after starting the counter, the UEV occurs on the underflow. For example for RCR = 3, the UEV is generated on each 4th overflow or underflow event depending on when RCR was written.


• Internal trigger inputs (ITRx): using one timer as prescaler for another timer, for example, the user can configure Timer 1 to act as a prescaler for Timer 2. Refer to Using one timer as prescaler for another timer for more details.

If the slave mode controller is disabled (SMS=000), then the CEN, DIR (in the TIMx_CR1 register) and UG bits (in the TIMx_EGR register) are actual control bits and can be changed only by software (except UG which remains cleared automatically). As soon as the CEN bit is written to 1, the prescaler is clocked by the internal clock CK_INT.

Each Capture/Compare channel is built around a capture/compare register (including a shadow register), a input stage for capture (with digital filter, multiplexing and prescaler) and an output stage (with comparator and output control).

The input stage samples the corresponding TIx input to generate a filtered signal TIxF. Then, an edge detector with polarity selection generates a signal (TIxFPx) which can be used as trigger input by the slave mode controller or as the capture command. It is prescaled before the capture register (ICxPS).

In Input capture mode, the Capture/Compare Registers (TIMx_CCRx) are used to latch the value of the counter after a transition detected by the corresponding ICx signal. When a capture occurs, the corresponding CCXIF flag (TIMx_SR register) is set and an interrupt or a DMA request can be sent if they are enabled. If a capture occurs while the CCxIF flag was already high, then the over-capture flag CCxOF (TIMx_SR register) is set. CCxIF can be cleared by software by writing it to ‘0’ or by reading the captured data stored in the TIMx_CCRx register. CCxOF is cleared when written to ‘0’.


• Select the active input: TIMx_CCR1 must be linked to the TI1 input, so write the CC1S bits to 01 in the TIMx_CCMR1 register. As soon as CC1S becomes different from 00, the channel is configured in input and the TIMx_CCR1 register becomes read-only.


• Program the needed input filter duration with respect to the signal connected to the timer (by programming ICxF bits in the TIMx_CCMRx register if the input is a TIx input). Let’s imagine that, when toggling, the input signal is not stable during at must five internal clock cycles. We must program a filter duration longer than these five clock cycles. We can validate a transition on TI1 when 8 consecutive samples with the new level have been detected (sampled at fDTS frequency). Then write IC1F bits to 0011 in the TIMx_CCMR1 register.


• Program the input prescaler. In our example, we wish the capture to be performed at each valid transition, so the prescaler is disabled (write IC1PS bits to ‘00’ in the TIMx_CCMR1 register).

In order to handle the overcapture, it is recommended to read the data before the overcapture flag. This is to avoid missing an overcapture which could happen after reading the flag and before reading the data.

For example, user can measure the period (in TIMx_CCR1 register) and the duty cycle (in TIMx_CCR2 register) of the PWM applied on TI1 using the following procedure (depending on CK_INT frequency and prescaler value):

In output mode (CCxS bits = 00 in the TIMx_CCMRx register), each output compare signal (OCxREF and then OCx/OCxN) can be forced to active or inactive level directly by software, independently of any comparison between the output compare register and the counter.

To force an output compare signal (OCXREF/OCx) to its active level, the user just needs to write 101 in the OCxM bits in the corresponding TIMx_CCMRx register. Thus OCXREF is forced high (OCxREF is always active high) and OCx get opposite value to CCxP polarity bit.

Anyway, the comparison between the TIMx_CCRx shadow register and the counter is still performed and allows the flag to be set. Interrupt and DMA requests can be sent accordingly. This is described in the output compare mode section below.


• Assigns the corresponding output pin to a programmable value defined by the output compare mode (OCxM bits in the TIMx_CCMRx register) and the output polarity (CCxP bit in the TIMx_CCER register). The output pin can keep its level (OCXM=000), be set active (OCxM=001), be set inactive (OCxM=010) or can toggle (OCxM=011) on match.

In output compare mode, the update event UEV has no effect on OCxREF and OCx output. The timing resolution is one count of the counter. Output compare mode can also be used to output a single pulse (in One Pulse mode).

The TIMx_CCRx register can be updated at any time by software to control the output waveform, provided that the preload register is not enabled (OCxPE=’0’, else TIMx_CCRx shadow register is updated only at the next update event UEV). An example is given in Figure 83.

Pulse Width Modulation mode allows generating a signal with a frequency determined by the value of the TIMx_ARR register and a duty cycle determined by the value of the TIMx_CCRx register.

The PWM mode can be selected independently on each channel (one PWM per OCx output) by writing ‘110’ (PWM mode 1) or ‘111’ (PWM mode 2) in the OCxM bits in the TIMx_CCMRx register. The corresponding preload register must be enabled by setting the OCxPE bit in the TIMx_CCMRx register, and eventually the auto-reload preload register (in upcounting or center-aligned modes) by setting the ARPE bit in the TIMx_CR1 register.

As the preload registers are transferred to the shadow registers only when an update event occurs, before starting the counter, the user must initialize all the registers by setting the UG bit in the TIMx_EGR register.

OCx polarity is software programmable using the CCxP bit in the TIMx_CCER register. It can be programmed as active high or active low. OCx output is enabled by a combination of the CCxE, CCxNE, MOE, OSSI and OSSR bits (TIMx_CCER and TIMx_BDTR registers). Refer to the TIMx_CCER register description for more details.

In the following example, we consider PWM mode 1. The reference PWM signal OCxREF is high as long as TIMx_CNT < TIMx_CCRx else it becomes low. If the compare value in TIMx_CCRx is greater than the auto-reload value (in TIMx_ARR) then OCxREF is held at ‘1’. If the compare value is 0 then OCxRef is held at ‘0’. Figure 84 shows some edge-aligned PWM waveforms in an example where TIMx_ARR=8.

In PWM mode 1, the reference signal OCxRef is low as long as TIMx_CNT > TIMx_CCRx else it becomes high. If the compare value in TIMx_CCRx is greater than the auto-reload value in TIMx_ARR, then OCxREF is held at ‘1’. 0% PWM is not possible in this mode.

Center-aligned mode is active when the CMS bits in TIMx_CR1 register are different from ‘00’ (all the remaining configurations having the same effect on the OCxRef/OCx signals). The compare flag is set when the counter counts up, when it counts down or both when it counts up and down depending on the CMS bits configuration. The direction bit (DIR) in the TIMx_CR1 register is updated by hardware and must not be changed by software. Refer to Center-aligned mode (up/down counting).


• When starting in center-aligned mode, the current up-down configuration is used. It means that the counter counts up or down depending on the value written in the DIR bit in the TIMx_CR1 register. Moreover, the DIR and CMS bits must not be changed at the same time by the software.

–The direction is not updated if the user writes a value in the counter greater than the auto-reload value (TIMx_CNT>TIMx_ARR). For example, if the counter was counting up, it will continue to count up.


• The safest way to use center-aligned mode is to generate an update by software (setting the UG bit in the TIMx_EGR register) just before starting the counter and not to write the counter while it is running.

User can select the polarity of the outputs (main output OCx or complementary OCxN) independently for each output. This is done by writing to the CCxP and CCxNP bits in the TIMx_CCER register.

The complementary signals OCx and OCxN are activated by a combination of several control bits: the CCxE and CCxNE bits in the TIMx_CCER register and the MOE, OISx, OISxN, OSSI and OSSR bits in the TIMx_BDTR and TIMx_CR2 registers. Refer to Table 83 for more details. In particular, the dead-time is activated when switching to the IDLE state (MOE falling down to 0).

Dead-time insertion is enabled by setting both CCxE and CCxNE bits, and the MOE bit if the break circuit is present. DTG[7:0] bits of the TIMx_BDTR register are used to control the dead-time generation for all channels. From a reference waveform OCxREF, it generates 2 outputs OCx and OCxN. If OCx and OCxN are active high:

In output mode (forced, output compare or PWM), OCxREF can be re-directed to the OCx output or to OCxN output by configuring the CCxE and CCxNE bits in the TIMx_CCER register.

This allows the user to send a specific waveform (such as PWM or static active level) on one output while the complementary remains at its inactive level. Other possibilities are to have both outputs at inactive level or both outputs active and complementary with dead-time.

Note:When only OCxN is enabled (CCxE=0, CCxNE=1), it is not complemented and becomes active as soon as OCxREF is high. For example, if CCxNP=0 then OCxN=OCxRef. On the other hand, when both OCx and OCxN are enabled (CCxE=CCxNE=1) OCx becomes active when OCxREF is high whereas OCxN is complemented and becomes active when OCxREF is low.

When using the break function, the output enable signals and inactive levels are modified according to additional control bits (MOE, OSSI and OSSR bits in the TIMx_BDTR register, OISx and OISxN bits in the TIMx_CR2 register). In any case, the OCx and OCxN outputs cannot be set both to active level at a given time. Refer to Table 83 for more details.

When exiting from reset, the break circuit is disabled and the MOE bit is low. User can enable the break function by setting the BKE bit in the TIMx_BDTR register. The break input polarity can be selected by configuring the BKP bit in the same register. BKE and BKP can be modified at the same time. When the BKE and BKP bits are written, a delay of 1 APB clock cycle is applied before the writing is effective. Consequently, it is necessary to wait 1 APB clock period to correctly read back the bit after the write operation.

Because MOE falling edge can be asynchronous, a resynchronization circuit has been inserted between the actual signal (acting on the outputs) and the synchronous control bit (accessed in the TIMx_BDTR register). It results in some delays between the asynchronous and the synchronous signals. In particular, if MOE is written to 1 whereas it was low, a delay (dummy instruction) must be inserted before reading it correctly. This is because the user writes an asynchronous signal, but reads a synchronous signal.


• The MOE bit is cleared asynchronously, putting the outputs in inactive state, idle state or in reset state (selected by the OSSI bit). This feature functions even if the MCU oscillator is off.


• Each output channel is driven with the level programmed in the OISx bit in the TIMx_CR2 register as soon as MOE=0. If OSSI=0 then the timer releases the enable output else the enable output remains high.

–The outputs are first put in reset state inactive state (depending on the polarity). This is done asynchronously so that it works even if no clock is provided to the timer. 

–If the timer clock is still present, then the dead-time generator is reactivated in order to drive the outputs with the level programmed in the OISx and OISxN bits after a dead-time. Even in this case, OCx and OCxN cannot be driven to their active level together. Note that because of the resynchronization on MOE, the dead-time duration is a bit longer than usual (around 2 ck_tim clock cycles).


• The break status flag (BIF bit in the TIMx_SR register) is set. An interrupt can be generated if the BIE bit in the TIMx_DIER register is set. A DMA request can be sent if the BDE bit in the TIMx_DIER register is set.


• If the AOE bit in the TIMx_BDTR register is set, the MOE bit is automatically set again at the next update event UEV. This can be used to perform a regulation, for instance. Else, MOE remains low until it is written to ‘1’ again. In this case, it can be used for security and the break input can be connected to an alarm from power drivers, thermal sensors or any security components.

Note:The break inputs is acting on level. Thus, the MOE cannot be set while the break input is active (neither automatically nor by software). In the meantime, the status flag BIF cannot be cleared.

The OCxREF signal for a given channel can be driven Low by applying a High level to the ETRF input (OCxCE enable bit of the corresponding TIMx_CCMRx register set to ‘1’). The OCxREF signal remains Low until the next update event, UEV, occurs. 

Figure 90 shows the behavior of the OCxREF signal when the ETRF Input becomes High, for both values of the enable bit OCxCE. In this example, the timer TIMx is programmed in PWM mode.

When complementary outputs are used on a channel, preload bits are available on the OCxM, CCxE and CCxNE bits. The preload bits are transferred to the shadow bits at the COM commutation event. The user can thus program in advance the configuration for the next step and change the configuration of all the channels at the same time. COM can be generated by software by setting the COM bit in the TIMx_EGR register or by hardware (on TRGI rising edge).

A flag is set when the COM event occurs (COMIF bit in the TIMx_SR register), which can generate an interrupt (if the COMIE bit is set in the TIMx_DIER register) or a DMA request (if the COMDE bit is set in the TIMx_DIER register).

One-pulse mode (OPM) is a particular case of the previous modes. It allows the counter to be started in response to a stimulus and to generate a pulse with a programmable length after a programmable delay.

Starting the counter can be controlled through the slave mode controller. Generating the waveform can be done in output compare mode or PWM mode. Select One-pulse mode by setting the OPM bit in the TIMx_CR1 register. This makes the counter stop automatically at the next update event UEV.

A pulse can be correctly generated only if the compare value is different from the counter initial value. Before starting (when the timer is waiting for the trigger), the configuration must be:

For example the user may want to generate a positive pulse on OC1 with a length of tPULSE and after a delay of tDELAY as soon as a positive edge is detected on the TI2 input pin.


• Let us say the user wants to build a waveform with a transition from ‘0’ to ‘1’ when a compare match occurs and a transition from ‘1’ to ‘0’ when the counter reaches the 

auto-reload value. To do this, enable PWM mode 2 by writing OC1M=111 in the TIMx_CCMR1 register. The user can optionally enable the preload registers by writing OC1PE=’1’ in the TIMx_CCMR1 register and ARPE in the TIMx_CR1 register. In this case the compare value must be written in the TIMx_CCR1 register, the auto-reload value in the TIMx_ARR register, generate an update by setting the UG bit and wait for external trigger event on TI2. CC1P is written to ‘0’ in this example.

The user only wants one pulse (Single mode), so '1’ must be written in the OPM bit in the TIMx_CR1 register to stop the counter at the next update event (when the counter rolls over from the auto-reload value back to 0). When OPM bit in the TIMx_CR1 register is set to '0', so the Repetitive Mode is selected.

In One-pulse mode, the edge detection on TIx input set the CEN bit which enables the counter. Then the comparison between the counter and the compare value makes the output toggle. But several clock cycles are needed for these operations and it limits the minimum delay tDELAY min we can get.

If the user wants to output a waveform with the minimum delay, the OCxFE bit in the TIMx_CCMRx register must be set. Then OCxRef (and OCx) are forced in response to the stimulus, without taking in account the comparison. Its new level is the same as if a compare match had occurred. OCxFE acts only if the channel is configured in PWM1 or PWM2 mode.

To select Encoder Interface mode write SMS=‘001’ in the TIMx_SMCR register if the counter is counting on TI2 edges only, SMS=’010’ if it is counting on TI1 edges only and SMS=’011’ if it is counting on both TI1 and TI2 edges.

The two inputs TI1 and TI2 are used to interface to an incremental encoder. Refer to Table 81. The counter is clocked by each valid transition on TI1FP1 or TI2FP2 (TI1 and TI2 after input filter and polarity selection, TI1FP1=TI1 if not filtered and not inverted, TI2FP2=TI2 if not filtered and not inverted) assuming that it is enabled (CEN bit in TIMx_CR1 register written to ‘1’). The sequence of transitions of the two inputs is evaluated and generates count pulses as well as the direction signal. Depending on the sequence the counter counts up or down, the DIR bit in the TIMx_CR1 register is modified by hardware accordingly. The DIR bit is calculated at each transition on any input (TI1 or TI2), whatever the counter is counting on TI1 only, TI2 only or both TI1 and TI2.

Encoder interface mode acts simply as an external clock with direction selection. This means that the counter just counts continuously between 0 and the auto-reload value in the TIMx_ARR register (0 to ARR or ARR down to 0 depending on the direction). So user must configure TIMx_ARR before starting. in the same way, the capture, compare, prescaler, repetition counter, trigger output features continue to work as normal. Encoder mode and External clock mode 2 are not compatible and must not be selected together. 

In this mode, the counter is modified automatically following the speed and the direction of the incremental encoder and its content, therefore, always represents the encoder’s position. The count direction correspond to the rotation direction of the connected sensor. 

An external incremental encoder can be connected directly to the MCU without external interface logic. However, comparators are normally be used to convert the encoder’s differential outputs to digital signals. This greatly increases noise immunity. The third encoder output which indicate the mechanical zero position, may be connected to an external interrupt input and trigger a counter reset.

Figure 93 gives an example of counter operation, showing count signal generation and direction control. It also shows how input jitter is compensated where both edges are selected. This might occur if the sensor is positioned near to one of the switching points. For this example we assume that the configuration is the following:

The timer, when configured in Encoder Interface mode provides information on the sensor’s current position.The user can obtain dynamic information (speed, acceleration, deceleration) by measuring the period between two encoder events using a second timer configured in capture mode. The output of the encoder which indicates the mechanical zero can be used for this purpose. Depending on the time between two events, the counter can also be read at regular times. This can be done by latching the counter value into a third input capture register if available (then the capture signal must be periodic and can be generated by another timer). when available, it is also possible to read its value through a DMA request generated by a real-time clock.

The TI1S bit in the TIMx_CR2 register, allows the input filter of channel 1 to be connected to the output of a XOR gate, combining the three input pins TIMx_CH1, TIMx_CH2 and TIMx_CH3.

This is done using the advanced-control timers (TIM1 or TIM8) to generate PWM signals to drive the motor and another timer TIMx (TIM2, TIM3, TIM4 or TIM5) referred to as “interfacing timer” in Figure 95. The “interfacing timer” captures the 3 timer input pins (TIMx_CH1, TIMx_CH2, and TIMx_CH3) connected through a XOR to the TI1 input channel (selected by setting the TI1S bit in the TIMx_CR2 register).

The slave mode controller is configured in reset mode; the slave input is TI1F_ED. Thus, each time one of the 3 inputs toggles, the counter restarts counting from 0. This creates a time base triggered by any change on the Hall inputs.

On the “interfacing timer”, capture/compare channel 1 is configured in capture mode, capture signal is TRC (see Figure 78). The captured value, which corresponds to the time elapsed between 2 changes on the inputs, gives information about motor speed.

The “interfacing timer” can be used in output mode to generate a pulse which changes the configuration of the channels of the advanced-control timer (TIM1 or TIM8) (by triggering a COM event). The TIM1 timer is used to generate PWM signals to drive the motor. To do this, the interfacing timer channel must be programmed so that a positive pulse is generated after a programmed delay (in output compare or PWM mode). This pulse is sent to the advanced-control timer (TIM1 or TIM8) through the TRGO output.

Example: the user wants to change the PWM configuration of the advanced-control timer TIM1 after a programmed delay each time a change occurs on the Hall inputs connected to one of the TIMx timers.


• Program the time base: write the TIMx_ARR to the max value (the counter must be cleared by the TI1 change. Set the prescaler to get a maximum counter period longer than the time between 2 changes on the sensors,

In the advanced-control timer TIM1, the right ITR input must be selected as trigger input, the timer is programmed to generate PWM signals, the capture/compare control signals are preloaded (CCPC=1 in the TIMx_CR2 register) and the COM event is controlled by the trigger input (CCUS=1 in the TIMx_CR2 register). The PWM control bits (CCxE, OCxM) are written after a COM event for the next step (this can be done in an interrupt subroutine generated by the rising edge of OC2REF).

The counter and its prescaler can be reinitialized in response to an event on a trigger input. Moreover, if the URS bit from the TIMx_CR1 register is low, an update event UEV is generated. Then all the preloaded registers (TIMx_ARR, TIMx_CCRx) are updated.


• Configure the channel 1 to detect rising edges on TI1. Configure the input filter duration (in this example, we don’t need any filter, so we keep IC1F=0000). The capture prescaler is not used for triggering, so there’s no need to configure it. The CC1S bits select the input capture source only, CC1S = 01 in the TIMx_CCMR1 register. Write CC1P=0 in TIMx_CCER register to validate the polarity (and detect rising edges only).

The counter starts counting on the internal clock, then behaves normally until TI1 rising edge. When TI1 rises, the counter is cleared and restarts from 0. In the meantime, the trigger flag is set (TIF bit in the TIMx_SR register) and an interrupt request, or a DMA request can be sent if enabled (depending on the TIE and TDE bits in TIMx_DIER register).

The following figure shows this behavior when the auto-reload register TIMx_ARR=0x36. The delay between the rising edge on TI1 and the actual reset of the counter is due to the resynchronization circuit on TI1 input.


• Configure the channel 1 to detect low levels on TI1. Configure the input filter duration (in this example, we don’t need any filter, so we keep IC1F=0000). The capture prescaler is not used for triggering, so the user does not need to configure it. The CC1S bits select the input capture source only, CC1S=01 in TIMx_CCMR1 register. Write CC1P=1 in TIMx_CCER register to validate the polarity (and detect low level only).

The counter starts counting on the internal clock as long as TI1 is low and stops as soon as TI1 becomes high. The TIF flag in the TIMx_SR register is set both when the counter starts or stops.


• Configure the channel 2 to detect rising edges on TI2. Configure the input filter duration (in this example, we don’t need any filter, so we keep IC2F=0000). The capture prescaler is not used for triggering, so there’s no need to configure it. The CC2S bits are configured to select the input capture source only, CC2S=01 in TIMx_CCMR1 register. Write CC2P=1 in TIMx_CCER register to validate the polarity (and detect low level only).

The external clock mode 2 can be used in addition to another slave mode (except external clock mode 1 and encoder mode). In this case, the ETR signal is used as external clock input, and another input can be selected as trigger input (in reset mode, gated mode or trigger mode). It is recommended not to select ETR as TRGI through the TS bits of TIMx_SMCR register.

Note:The clock of the slave timer must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.

For safety purposes, when the counter is stopped (DBG_TIMx_STOP = 1 in DBGMCU_APBx_FZ register), the outputs are disabled (as if the MOE bit was reset). The outputs can either be forced to an inactive state (OSSI bit = 1), or have their control taken over by the GPIO controller (OSSI bit = 0) to force them to Hi-Z.

Bits 9:8 CKD[1:0]: Clock divisionThis bit-field indicates the division ratio between the timer clock (CK_INT) frequency and the dead-time and sampling clock (tDTS)used by the dead-time generators and the digital filters (ETR, TIx),00: tDTS=tCK_INT01: tDTS=2*tCK_INT10: tDTS=4*tCK_INT11: Reserved, do not program this value

Bits 6:5 CMS[1:0]: Center-aligned mode selection00: Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).01: Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting down.10: Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting up.11: Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set both when the counter is counting up or down.Note: It is not allowed to switch from edge-aligned mode to center-aligned mode as long as the counter is enabled (CEN=1)

Bit 2 URS: Update request sourceThis bit is set and cleared by software to select the UEV event sources.0: Any of the following events generate an update interrupt or DMA request if enabled. These events can be: –Counter overflow/underflow–Setting the UG bit–Update generation through the slave mode controller1: Only counter overflow/underflow generates an update interrupt or DMA request if enabled.

Bit 1 UDIS: Update disableThis bit is set and cleared by software to enable/disable UEV event generation.0: UEV enabled. The Update (UEV) event is generated by one of the following events:–Counter overflow/underflow–Setting the UG bit–Update generation through the slave mode controllerBuffered registers are then loaded with their preload values.1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.

Bit 0 CEN: Counter enable0: Counter disabled1: Counter enabledNote: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.

Bit 9 OIS1N: Output Idle state 1 (OC1N output)0: OC1N=0 after a dead-time when MOE=01: OC1N=1 after a dead-time when MOE=0Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).

Bit 8 OIS1: Output Idle state 1 (OC1 output)0: OC1=0 (after a dead-time if OC1N is implemented) when MOE=01: OC1=1 (after a dead-time if OC1N is implemented) when MOE=0Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).

Bits 6:4 MMS[2:0]: Master mode selectionThese bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:000: Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.001: Enable - the Counter Enable signal CNT_EN is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enable. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register).010: Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.011: Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO).100: Compare - OC1REF signal is used as trigger output (TRGO)101: Compare - OC2REF signal is used as trigger output (TRGO)110: Compare - OC3REF signal is used as trigger output (TRGO)111: Compare - OC4REF signal is used as trigger output (TRGO)Note: The clock of the slave timer and ADC must be enabled prior to receiving events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.

Bit 2 CCUS: Capture/compare control update selection0: When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit only1: When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit or when an rising edge occurs on TRGINote: This bit acts only on channels that have a complementary output.

Bit 0 CCPC: Capture/compare preloaded control0: CCxE, CCxNE and OCxM bits are not preloaded1: CCxE, CCxNE and OCxM bits are preloaded, after having been written, they are updated only when a commutation event (COM) occurs (COMG bit set or rising edge detected on TRGI, depending on the CCUS bit).Note: This bit acts only on channels that have a complementary output.

Bit 15 ETP: External trigger polarityThis bit selects whether ETR or ETR is used for trigger operations0: ETR is non-inverted, active at high level or rising edge.1: ETR is inverted, active at low level or falling edge.

Bit 14 ECE: External clock enableThis bit enables External clock mode 2.0: External clock mode 2 disabled1: External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.Note: 1: Setting the ECE bit has the same effect as selecting external clock mode 1 with TRGI connected to ETRF (SMS=111 and TS=111).2: It is possible to simultaneously use external clock mode 2 with the following slave modes: reset mode, gated mode and trigger mode. Nevertheless, TRGI must not be connected to ETRF in this case (TS bits must not be 111).3: If external clock mode 1 and external clock mode 2 are enabled at the same time, the external clock input is ETRF.

Bits 13:12 ETPS[1:0]: External trigger prescalerExternal trigger signal ETRP frequency must be at most 1/4 of TIMxCLK frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks.00: Prescaler OFF01: ETRP frequency divided by 210: ETRP frequency divided by 411: ETRP frequency divided by 8

Bit 7 MSM: Master/slave mode0: No action1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.

Bits 6:4 TS[2:0]: Trigger selectionThis bit-field selects the trigger input to be used to synchronize the counter.000: Internal Trigger 0 (ITR0) 001: Internal Trigger 1 (ITR1)010: Internal Trigger 2 (ITR2)011: Internal Trigger 3 (ITR3)100: TI1 Edge Detector (TI1F_ED)101: Filtered Timer Input 1 (TI1FP1)110: Filtered Timer Input 2 (TI2FP2)111: External Trigger input (ETRF)See Table 82 for more details on ITRx meaning for each Timer.Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.

Bits 2:0 SMS: Slave mode selectionWhen external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description.000: Slave mode disabled - if CEN = ‘1’ then the prescaler is clocked directly by the internal clock.001: Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level.010: Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level.011: Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.100: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.101: Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.110: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.111: External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.Note: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=’100’). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal.The clock of the slave timer must be enabled prior to receiving events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.

Bit 9 CC1OF: Capture/Compare 1 overcapture flagThis flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to ‘0’.0: No overcapture has been detected.1: The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set

Bit 7 BIF: Break interrupt flagThis flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active.0: No break event occurred.1: An active level has been detected on the break input.

Bit 6 TIF: Trigger interrupt flagThis flag is set by hardware on trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode, both edges in case gated mode is selected). It is cleared by software.0: No trigger event occurred.1: Trigger interrupt pending.

Bit 5 COMIF: COM interrupt flagThis flag is set by hardware on COM event (when Capture/compare Control bits - CCxE, CCxNE, OCxM - have been updated). It is cleared by software.0: No COM event occurred.1: COM interrupt pending.

Bit 1 CC1IF: Capture/Compare 1 interrupt flagIf channel CC1 is configured as output:This flag is set by hardware when the counter matches the compare value, with some exception in center-aligned mode (refer to the CMS bits in the TIMx_CR1 register description). It is cleared by software.0: No match.1: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the contents of TIMx_CCR1 are greater than the contents of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in upcounting and up/down-counting modes) or underflow (in downcounting mode)If channel CC1 is configured as input:This bit is set by hardware on a capture. It is cleared by software or by reading the TIMx_CCR1 register.0: No input capture occurred1: The counter value has been captured in TIMx_CCR1 register (An edge has been detected on IC1 which matches the selected polarity)

Bit 7 BG: Break generationThis bit is set by software in order to generate an event, it is automatically cleared by hardware.0: No action1: A break event is generated. MOE bit is cleared and BIF flag is set. Related interrupt or DMA transfer can occur if enabled.

Bit 6 TG: Trigger generationThis bit is set by software in order to generate an event, it is automatically cleared by hardware.0: No action1: The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.

Bit 5 COMG: Capture/Compare control update generationThis bit can be set by software, it is automatically cleared by hardware0: No action1: When CCPC bit is set, it allows to update CCxE, CCxNE and OCxM bitsNote: This bit acts only on channels having a complementary output.

Bit 1 CC1G: Capture/Compare 1 generationThis bit is set by software in order to generate an event, it is automatically cleared by hardware.0: No action1: A capture/compare event is generated on channel 1:If channel CC1 is configured as output:CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.If channel CC1 is configured as input:The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.

Bit 0 UG: Update generationThis bit can be set by software, it is automatically cleared by hardware.0: No action1: Reinitialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (TIMx_ARR) if DIR=1 (downcounting).

The channels can be used in input (capture mode) or in output (compare mode). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function in input and in output mode. For a given bit, OCxx describes its function when the channel is configured in output, ICxx describes its function when the channel is configured in input. So the user must take care that the same bit can have a different meaning for the input stage and for the output stage.

Bits 9:8 CC2S[1:0]: Capture/Compare 2 selectionThis bit-field defines the direction of the channel (input/output) as well as the used input. 00: CC2 channel is configured as output01: CC2 channel is configured as input, IC2 is mapped on TI210: CC2 channel is configured as input, IC2 is mapped on TI111: CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through the TS bit (TIMx_SMCR register)Note: CC2S bits are writable only when the channel is OFF (CC2E = ‘0’ in TIMx_CCER).

Bit 7 OC1CE: Output Compare 1 clear enableOC1CE: Output Compare 1 Clear Enable0: OC1Ref is not affected by the ETRF Input1: OC1Ref is cleared as soon as a High level is detected on ETRF input

Bits 6:4 OC1M: Output Compare 1 modeThese bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.000: Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).001: Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).010: Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).011: Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.100: Force inactive level - OC1REF is forced low.101: Force active level - OC1REF is forced high.110: PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT<TIMx_CCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF=‘0’) as long as TIMx_CNT>TIMx_CCR1 else active (OC1REF=’1’).111: PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT<TIMx_CCR1 else active. In downcounting, channel 1 is active as long as TIMx_CNT>TIMx_CCR1 else inactive.Note: 1: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=’00’ (the channel is configured in output).2: In PWM mode 1 or 2, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from “frozen” mode to “PWM” mode.

Bit 3 OC1PE: Output Compare 1 preload enable0: Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately.1: Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.Note: 1: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=’00’ (the channel is configured in output).2: The PWM mode can be used without validating the preload register only in one pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed.

Bit 2 OC1FE: Output Compare 1 fast enableThis bit is used to accelerate the effect of an event on the trigger in input on the CC output.0: CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.1: An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is set to the compare level independently from the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OCFE acts only if the channel is configured in PWM1 or PWM2 mode.

Bits 1:0 CC1S: Capture/Compare 1 selectionThis bit-field defines the direction of the channel (input/output) as well as the used input. 00: CC1 channel is configured as output01: CC1 channel is configured as input, IC1 is mapped on TI110: CC1 channel is configured as input, IC1 is mapped on TI211: CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)Note: CC1S bits are writable only when the channel is OFF (CC1E = ‘0’ in TIMx_CCER).

Bits 9:8 CC2S: Capture/Compare 2 selectionThis bit-field defines the direction of the channel (input/output) as well as the used input. 00: CC2 channel is configured as output01: CC2 channel is configured as input, IC2 is mapped on TI210: CC2 channel is configured as input, IC2 is mapped on TI111: CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)Note: CC2S bits are writable only when the channel is OFF (CC2E = ‘0’ in TIMx_CCER).

Bits 3:2 IC1PSC: Input capture 1 prescalerThis bit-field defines the ratio of the prescaler acting on CC1 input (IC1).The prescaler is reset as soon as CC1E=’0’ (TIMx_CCER register).00: no prescaler, capture is done each time an edge is detected on the capture input01: capture is done once every 2 events10: capture is done once every 4 events11: capture is done once every 8 events

Bits 1:0 CC1S: Capture/Compare 1 SelectionThis bit-field defines the direction of the channel (input/output) as well as the used input. 00: CC1 channel is configured as output01: CC1 channel is configured as input, IC1 is mapped on TI110: CC1 channel is configured as input, IC1 is mapped on TI211: CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)Note: CC1S bits are writable only when the channel is OFF (CC1E = ‘0’ in TIMx_CCER).

Bits 9:8 CC4S: Capture/Compare 4 selectionThis bit-field defines the direction of the channel (input/output) as well as the used input. 00: CC4 channel is configured as output01: CC4 channel is configured as input, IC4 is mapped on TI410: CC4 channel is configured as input, IC4 is mapped on TI311: CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)Note: CC4S bits are writable only when the channel is OFF (CC4E = ‘0’ in TIMx_CCER).

Bits 1:0 CC3S: Capture/Compare 3 selectionThis bit-field defines the direction of the channel (input/output) as well as the used input. 00: CC3 channel is configured as output01: CC3 channel is configured as input, IC3 is mapped on TI310: CC3 channel is configured as input, IC3 is mapped on TI411: CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)Note: CC3S bits are writable only when the channel is OFF (CC3E = ‘0’ in TIMx_CCER).

Bits 9:8 CC4S: Capture/Compare 4 selectionThis bit-field defines the direction of the channel (input/output) as well as the used input. 00: CC4 channel is configured as output01: CC4 channel is configured as input, IC4 is mapped on TI410: CC4 channel is configured as input, IC4 is mapped on TI311: CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)Note: CC4S bits are writable only when the channel is OFF (CC4E = ‘0’ in TIMx_CCER).

Bits 1:0 CC3S: Capture/compare 3 selectionThis bit-field defines the direction of the channel (input/output) as well as the used input. 00: CC3 channel is configured as output01: CC3 channel is configured as input, IC3 is mapped on TI310: CC3 channel is configured as input, IC3 is mapped on TI411: CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)Note: CC3S bits are writable only when the channel is OFF (CC3E = ‘0’ in TIMx_CCER).

Bit 3 CC1NP: Capture/Compare 1 complementary output polarity0: OC1N active high.1: OC1N active low.Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=”00” (the channel is configured in output).

Bit 1 CC1P: Capture/Compare 1 output polarityCC1 channel configured as output:0: OC1 active high1: OC1 active lowCC1 channel configured as input:This bit selects whether IC1 or IC1 is used for trigger or capture operations.0: non-inverted: capture is done on a rising edge of IC1. When used as external trigger, IC1 is non-inverted.1: inverted: capture is done on a falling edge of IC1. When used as external trigger, IC1 is inverted.Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).

Bit 0 CC1E: Capture/Compare 1 output enableCC1 channel configured as output:0: Off - OC1 is not active. OC1 level is then function of MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits.1: On - OC1 signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits.CC1 channel configured as input:This bit determines if a capture of the counter value can actually be done into the input capture/compare register 1 (TIMx_CCR1) or not.0: Capture disabled.1: Capture enabled.

00Output Disabled (not driven by the timer)Asynchronously: OCx=CCxP, OCx_EN=0, OCxN=CCxNP, OCxN_EN=0Then if the clock is present: OCx=OISx and OCxN=OISxN after a dead-time, assuming that OISx and OISxN do not correspond to OCX and OCxN both in active state.

101Off-State (output enabled with inactive state)Asynchronously: OCx=CCxP, OCx_EN=1, OCxN=CCxNP, OCxN_EN=1Then if the clock is present: OCx=OISx and OCxN=OISxN after a dead-time, assuming that OISx and OISxN do not correspond to OCX and OCxN both in active state

Bits 15:0 PSC[15:0]: Prescaler valueThe counter clock frequency (CK_CNT) is equal to fCK_PSC / (PSC[15:0] + 1).PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in “reset mode”).

Bits 7:0 REP[7:0]: Repetition counter valueThese bits allow the user to set-up the update rate of the compare registers (i.e. periodic transfers from preload to active registers) when preload registers are enable, as well as the update interrupt generation rate, if this interrupt is enable.Each time the REP_CNT related downcounter reaches zero, an update event is generated and it restarts counting from REP value. As REP_CNT is reloaded with REP value only at the repetition update event U_RC, any write to the TIMx_RCR register is not taken in account until the next repetition update event.It means in PWM mode (REP+1) corresponds to:–the number of PWM periods in edge-aligned mode–the number of half PWM period in center-aligned mode.

Bits 15:0 CCR1[15:0]: Capture/Compare 1 valueIf channel CC1 is configured as output:CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC1 output.If channel CC1 is configured as input:CCR1 is the counter value transferred by the last input capture 1 event (IC1). The TIMx_CCR1 register is read-only and cannot be programmed.

Bits 15:0 CCR2[15:0]: Capture/Compare 2 valueIf channel CC2 is configured as output:CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value).It is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on OC2 output.If channel CC2 is configured as input:CCR2 is the counter value transferred by the last input capture 2 event (IC2). The TIMx_CCR2 register is read-only and cannot be programmed.

Bits 15:0 CCR3[15:0]: Capture/Compare valueIf channel CC3 is configured as output:CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value).It is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on OC3 output.If channel CC3 is configured as input:CCR3 is the counter value transferred by the last input capture 3 event (IC3). The TIMx_CCR3 register is read-only and cannot be programmed.

Note:As the bits AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] can be write-locked depending on the LOCK configuration, it can be necessary to configure all of them during the first write access to the TIMx_BDTR register.

Bits 15:0 CCR4[15:0]: Capture/Compare valueIf channel CC4 is configured as output:CCR4 is the value to be loaded in the actual capture/compare 4 register (preload value).It is loaded permanently if the preload feature is not selected in the TIMx_CCMR4 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs.The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on OC4 output.If channel CC4 is configured as input:CCR4 is the counter value transferred by the last input capture 4 event (IC4). The TIMx_CCR3 register is read-only and cannot be programmed.

Bit 14 AOE: Automatic output enable0: MOE can be set only by software1: MOE can be set by software or automatically at the next update event (if the break input is not be active)Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).

Bit 13 BKP: Break polarity0: Break input BRK is active low1: Break input BRK is active highNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.

Bit 12 BKE: Break enable0: Break inputs (BRK and CSS clock failure event) disabled1; Break inputs (BRK and CSS clock failure event) enabledNote: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.

Bits 9:8 LOCK[1:0]: Lock configurationThese bits offer a write protection against software errors.00: LOCK OFF - No bit is write protected.01: LOCK Level 1 = DTG bits in TIMx_BDTR register, OISx and OISxN bits in TIMx_CR2 register and BKE/BKP/AOE bits in TIMx_BDTR register can no longer be written.10: LOCK Level 2 = LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in TIMx_CCER register, as long as the related channel is configured in output through the CCxS bits) as well as OSSR and OSSI bits can no longer be written.11: LOCK Level 3 = LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in TIMx_CCMRx registers, as long as the related channel is configured in output through the CCxS bits) can no longer be written.Note: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset.

Bits 7:0 DTG[7:0]: Dead-time generator setupThis bit-field defines the duration of the dead-time inserted between the complementary outputs. DT correspond to this duration.DTG[7:5]=0xx => DT=DTG[7:0]x tdtg with tdtg=tDTS.DTG[7:5]=10x => DT=(64+DTG[5:0])xtdtg with Tdtg=2xtDTS.DTG[7:5]=110 => DT=(32+DTG[4:0])xtdtg with Tdtg=8xtDTS.DTG[7:5]=111 => DT=(32+DTG[4:0])xtdtg with Tdtg=16xtDTS.Example if TDTS=125ns (8MHz), dead-time possible values are:0 to 15875 ns by 125 ns steps,16 us to 31750 ns by 250 ns steps,32 us to 63us by 1 us steps,64 us to 126 us by 2 us stepsNote: This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).

In this example the timer DMA burst feature is used to update the contents of the CCRx registers (x = 2, 3, 4) with the DMA transferring half words into the CCRx registers. 

Note:This example is for the case where every CCRx register to be updated once. If every CCRx register is to be updated twice for example, the number of data to transfer should be 6. Let's take the example of a buffer in the RAM containing data1, data2, data3, data4, data5 and data6. The data is transferred to the CCRx registers as follows: on the first update DMA request, data1 is transferred to CCR2, data2 is transferred to CCR3, data3 is transferred to CCR4 and on the second update DMA request, data4 is transferred to CCR2, data5 is transferred to CCR3 and data6 is transferred to CCR4. 

Bits 31:0 DMAB[31:0]: DMA register for burst accessesA read or write operation to the DMAR register accesses the register located at the address(TIMx_CR1 address) + (DBA + DMA index) x 4 where TIMx_CR1 address is the address of the control register 1, DBA is the DMA base address configured in TIMx_DCR register, DMA index is automatically controlled by the DMA transfer, and ranges from 0 to DBL (DBL configured in TIMx_DCR).

The main block of the programmable timer is a 16-bit counter with its related auto-reload register. The counter can count up, down or both up and down. The counter clock can be divided by a prescaler. 

The auto-reload register is preloaded. Writing to or reading from the auto-reload register accesses the preload register. The content of the preload register are transferred into the shadow register permanently or at each update event (UEV), depending on the auto-reload preload enable bit (ARPE) in TIMx_CR1 register. The update event is sent when the counter reaches the overflow (or underflow when downcounting) and if the UDIS bit equals 0 in the TIMx_CR1 register. It can also be generated by software. The generation of the update event is described in detail for each configuration.

The counter is clocked by the prescaler output CK_CNT, which is enabled only when the counter enable bit (CEN) in TIMx_CR1 register is set (refer also to the slave mode controller description to get more details on counter enabling).

The prescaler can divide the counter clock frequency by any factor between 1 and 65536. It is based on a 16-bit counter controlled through a 16-bit register (in the TIMx_PSC register). It can be changed on the fly as this control register is buffered. The new prescaler ratio is taken into account at the next update event.

The UEV event can be disabled by software by setting the UDIS bit in TIMx_CR1 register. This is to avoid updating the shadow registers while writing new values in the preload registers. Then no update event occurs until the UDIS bit has been written to 0. However, the counter restarts from 0, as well as the counter of the prescaler (but the prescale rate 

does not change). In addition, if the URS bit (update request selection) in TIMx_CR1 register is set, setting the UG bit generates an update event UEV but without setting the UIF flag (thus no interrupt or DMA request is sent). This is to avoid generating both update and capture interrupts when clearing the counter on the capture event.

The UEV update event can be disabled by software by setting the UDIS bit in TIMx_CR1 register. This is to avoid updating the shadow registers while writing new values in the 

preload registers. Then no update event occurs until UDIS bit has been written to 0. However, the counter restarts from the current auto-reload value, whereas the counter of the prescaler restarts from 0 (but the prescale rate doesn’t change). 

In addition, if the URS bit (update request selection) in TIMx_CR1 register is set, setting the UG bit generates an update event UEV but without setting the UIF flag (thus no interrupt or DMA request is sent). This is to avoid generating both update and capture interrupts when clearing the counter on the capture event.


• The auto-reload active register is updated with the preload value (content of the TIMx_ARR register). Note that the auto-reload is updated before the counter is reloaded, so that the next period is the expected one.

In center-aligned mode, the counter counts from 0 to the auto-reload value (content of the TIMx_ARR register) – 1, generates a counter overflow event, then counts from the auto-reload value down to 1 and generates a counter underflow event. Then it restarts counting from 0.

Center-aligned mode is active when the CMS bits in TIMx_CR1 register are not equal to '00'. The Output compare interrupt flag of channels configured in output is set when: the counter counts down (Center aligned mode 1, CMS = "01"), the counter counts up (Center aligned mode 2, CMS = "10") the counter counts up and down (Center aligned mode 3, CMS = "11").

The update event can be generated at each counter overflow and at each counter underflow or by setting the UG bit in the TIMx_EGR register (by software or by using the slave mode controller) also generates an update event. In this case, the counter restarts counting from 0, as well as the counter of the prescaler.

The UEV update event can be disabled by software by setting the UDIS bit in TIMx_CR1 register. This is to avoid updating the shadow registers while writing new values in the preload registers. Then no update event occurs until the UDIS bit has been written to 0. However, the counter continues counting up and down, based on the current auto-reload value. 

In addition, if the URS bit (update request selection) in TIMx_CR1 register is set, setting the UG bit generates an update event UEV but without setting the UIF flag (thus no interrupt or DMA request is sent). This is to avoid generating both update and capture interrupt when clearing the counter on the capture event.


• The auto-reload active register is updated with the preload value (content of the TIMx_ARR register). Note that if the update source is a counter overflow, the auto-reload is updated before the counter is reloaded, so that the next period is the expected one (the counter is loaded with the new value).


• Internal trigger inputs (ITRx): using one timer as prescaler for another timer, for example, Timer1 can be configured to act as a prescaler for Timer 2. Refer to Using one timer as prescaler for another timer for more details.

If the slave mode controller is disabled (SMS=000 in the TIMx_SMCR register), then the CEN, DIR (in the TIMx_CR1 register) and UG bits (in the TIMx_EGR register) are actual control bits and can be changed only by software (except UG which remains cleared automatically). As soon as the CEN bit is written to 1, the prescaler is clocked by the internal clock CK_INT.

Each Capture/Compare channel (see Figure 125) is built around a capture/compare register (including a shadow register), an input stage for capture (with digital filter, multiplexing and prescaler) and an output stage (with comparator and output control).

The input stage samples the corresponding TIx input to generate a filtered signal TIxF. Then, an edge detector with polarity selection generates a signal (TIxFPx) which can be used as trigger input by the slave mode controller or as the capture command. It is prescaled before the capture register (ICxPS).

In Input capture mode, the Capture/Compare Registers (TIMx_CCRx) are used to latch the value of the counter after a transition detected by the corresponding ICx signal. When a capture occurs, the corresponding CCXIF flag (TIMx_SR register) is set and an interrupt or a DMA request can be sent if they are enabled. If a capture occurs while the CCxIF flag was already high, then the over-capture flag CCxOF (TIMx_SR register) is set. CCxIF can be cleared by software by writing it to 0 or by reading the captured data stored in the TIMx_CCRx register. CCxOF is cleared when written to 0.


• Select the active input: TIMx_CCR1 must be linked to the TI1 input, so write the CC1S bits to 01 in the TIMx_CCMR1 register. As soon as CC1S becomes different from 00, the channel is configured in input and the TIMx_CCR1 register becomes read-only.


• Program the needed input filter duration with respect to the signal connected to the timer (by programming the ICxF bits in the TIMx_CCMRx register if the input is one of the TIx inputs). Let’s imagine that, when toggling, the input signal is not stable during at must five internal clock cycles. We must program a filter duration longer than these five clock cycles. We can validate a transition on TI1 when eight consecutive samples with the new level have been detected (sampled at fDTS frequency). Then write IC1F bits to 0011 in the TIMx_CCMR1 register.


• Program the input prescaler. In our example, we wish the capture to be performed at each valid transition, so the prescaler is disabled (write IC1PS bits to 00 in the TIMx_CCMR1 register).

In order to handle the overcapture, it is recommended to read the data before the overcapture flag. This is to avoid missing an overcapture which could happen after reading the flag and before reading the data.

For example, the user can measure the period (in TIMx_CCR1 register) and the duty cycle (in TIMx_CCR2 register) of the PWM applied on TI1 using the following procedure (depending on CK_INT frequency and prescaler value):

In output mode (CCxS bits = 00 in the TIMx_CCMRx register), each output compare signal (OCxREF and then OCx) can be forced to active or inactive level directly by software, independently of any comparison between the output compare register and the counter.

To force an output compare signal (ocxref/OCx) to its active level, the user just needs to write 101 in the OCxM bits in the corresponding TIMx_CCMRx register. Thus ocxref is forced high (OCxREF is always active high) and OCx get opposite value to CCxP polarity bit.

Anyway, the comparison between the TIMx_CCRx shadow register and the counter is still performed and allows the flag to be set. Interrupt and DMA requests can be sent accordingly. This is described in the Output Compare Mode section.


• Assigns the corresponding output pin to a programmable value defined by the output compare mode (OCxM bits in the TIMx_CCMRx register) and the output polarity (CCxP bit in the TIMx_CCER register). The output pin can keep its level (OCXM=000), be set active (OCxM=001), be set inactive (OCxM=010) or can toggle (OCxM=011) on match.

In output compare mode, the update event UEV has no effect on ocxref and OCx output. The timing resolution is one count of the counter. Output compare mode can also be used to output a single pulse (in One-pulse mode).

The TIMx_CCRx register can be updated at any time by software to control the output waveform, provided that the preload register is not enabled (OCxPE=0, else TIMx_CCRx shadow register is updated only at the next update event UEV). An example is given in Figure 129.

Pulse width modulation mode allows generating a signal with a frequency determined by the value of the TIMx_ARR register and a duty cycle determined by the value of the TIMx_CCRx register.

The PWM mode can be selected independently on each channel (one PWM per OCx output) by writing 110 (PWM mode 1) or ‘111 (PWM mode 2) in the OCxM bits in the TIMx_CCMRx register. The user must enable the corresponding preload register by setting the OCxPE bit in the TIMx_CCMRx register, and eventually the auto-reload preload register by setting the ARPE bit in the TIMx_CR1 register.

As the preload registers are transferred to the shadow registers only when an update event occurs, before starting the counter, the user has to initialize all the registers by setting the UG bit in the TIMx_EGR register.

OCx polarity is software programmable using the CCxP bit in the TIMx_CCER register. It can be programmed as active high or active low. OCx output is enabled by the CCxE bit in the TIMx_CCER register. Refer to the TIMx_CCERx register description for more details.

In PWM mode (1 or 2), TIMx_CNT and TIMx_CCRx are always compared to determine whether TIMx_CCRx≤TIMx_CNT or TIMx_CNT≤TIMx_CCRx (depending on the direction of the counter). However, to comply with the ETRF (OCREF can be cleared by an external event through the ETR signal until the next PWM period), the OCREF signal is asserted only:

In the following example, we consider PWM mode 1. The reference PWM signal OCxREF is high as long as TIMx_CNT <TIMx_CCRx else it becomes low. If the compare value in TIMx_CCRx is greater than the auto-reload value (in TIMx_ARR) then OCxREF is held at ‘1. If the compare value is 0 then OCxREF is held at ‘0. Figure 130 shows some edge-aligned PWM waveforms in an example where TIMx_ARR=8.

In PWM mode 1, the reference signal ocxref is low as long as TIMx_CNT>TIMx_CCRx else it becomes high. If the compare value in TIMx_CCRx is greater than the auto-reload value in TIMx_ARR, then ocxref is held at ‘1. 0% PWM is not possible in this mode.

Center-aligned mode is active when the CMS bits in TIMx_CR1 register are different from ‘00 (all the remaining configurations having the same effect on the ocxref/OCx signals). The compare flag is set when the counter counts up, when it counts down or both when it counts 

up and down depending on the CMS bits configuration. The direction bit (DIR) in the TIMx_CR1 register is updated by hardware and must not be changed by software. Refer to Center-aligned mode (up/down counting).

–The direction is not updated if the user writes a value in the counter that is greater than the auto-reload value (TIMx_CNT>TIMx_ARR). For example, if the counter was counting up, it continues to count up.


• The safest way to use center-aligned mode is to generate an update by software (setting the UG bit in the TIMx_EGR register) just before starting the counter and not to write the counter while it is running.

One-pulse mode (OPM) is a particular case of the previous modes. It allows the counter to be started in response to a stimulus and to generate a pulse with a programmable length after a programmable delay.

Starting the counter can be controlled through the slave mode controller. Generating the waveform can be done in output compare mode or PWM mode. Select One-pulse mode by setting the OPM bit in the TIMx_CR1 register. This makes the counter stop automatically at the next update event UEV.

A pulse can be correctly generated only if the compare value is different from the counter initial value. Before starting (when the timer is waiting for the trigger), the configuration must be:

For example the user may want to generate a positive pulse on OC1 with a length of tPULSE and after a delay of tDELAY as soon as a positive edge is detected on the TI2 input pin.


• Let us say user wants to build a waveform with a transition from ‘0 to ‘1 when a compare match occurs and a transition from ‘1 to ‘0 when the counter reaches the auto-reload value. To do this enable PWM mode 2 by writing OC1M=111 in the TIMx_CCMR1 register. The user can optionally enable the preload registers by writing OC1PE=1 in the TIMx_CCMR1 register and ARPE in the TIMx_CR1 register. In this case write the compare value in the TIMx_CCR1 register, the auto-reload value in the TIMx_ARR register, generate an update by setting the UG bit and wait for external trigger event on TI2. CC1P is written to ‘0 in this example.

User only wants one pulse (Single mode), so write '1 in the OPM bit in the TIMx_CR1 register to stop the counter at the next update event (when the counter rolls over from the auto-reload value back to 0). When OPM bit in the TIMx_CR1 register is set to '0', so the Repetitive Mode is selected.

In One-pulse mode, the edge detection on TIx input set the CEN bit which enables the counter. Then the comparison between the counter and the compare value makes the output toggle. But several clock cycles are needed for these operations and it limits the minimum delay tDELAY min we can get.

To output a waveform with the minimum delay, the user can set the OCxFE bit in the TIMx_CCMRx register. Then OCxRef (and OCx) is forced in response to the stimulus, without taking in account the comparison. Its new level is the same as if a compare match had occurred. OCxFE acts only if the channel is configured in PWM1 or PWM2 mode.

The OCxREF signal for a given channel can be driven Low by applying a High level to the ETRF input (OCxCE enable bit of the corresponding TIMx_CCMRx register set to '1'). The OCxREF signal remains Low until the next update event, UEV, occurs. 

Figure 133 shows the behavior of the OCxREF signal when the ETRF input becomes high, for both values of the OCxCE enable bit. In this example, the timer TIMx is programmed in PWM mode.

To select Encoder Interface mode write SMS=‘001 in the TIMx_SMCR register if the counter is counting on TI2 edges only, SMS=010 if it is counting on TI1 edges only and SMS=011 if it is counting on both TI1 and TI2 edges.

The two inputs TI1 and TI2 are used to interface to an incremental encoder. Refer to Table 85. The counter is clocked by each valid transition on TI1FP1 or TI2FP2 (TI1 and TI2 after input filter and polarity selection, TI1FP1=TI1 if not filtered and not inverted, TI2FP2=TI2 if not filtered and not inverted) assuming that it is enabled (CEN bit in TIMx_CR1 register written to ‘1). The sequence of transitions of the two inputs is evaluated and generates count pulses as well as the direction signal. Depending on the sequence the counter counts up or down, the DIR bit in the TIMx_CR1 register is modified by hardware accordingly. The DIR bit is calculated at each transition on any input (TI1 or TI2), whatever the counter is counting on TI1 only, TI2 only or both TI1 and TI2.

Encoder interface mode acts simply as an external clock with direction selection. This means that the counter just counts continuously between 0 and the auto-reload value in the TIMx_ARR register (0 to ARR or ARR down to 0 depending on the direction). So the user must configure TIMx_ARR before starting. In the same way, the capture, compare, prescaler, trigger output features continue to work as normal. 

In this mode, the counter is modified automatically following the speed and the direction of the incremental encoder and its content, therefore, always represents the encoder’s position. The count direction correspond to the rotation direction of the connected sensor. The table summarizes the possible combinations, assuming TI1 and TI2 don’t switch at the same time.

An external incremental encoder can be connected directly to the MCU without external interface logic. However, comparators are normally be used to convert the encoder’s differential outputs to digital signals. This greatly increases noise immunity. The third encoder output which indicate the mechanical zero position, may be connected to an external interrupt input and trigger a counter reset.

Figure 134 gives an example of counter operation, showing count signal generation and direction control. It also shows how input jitter is compensated where both edges are selected. This might occur if the sensor is positioned near to one of the switching points. For this example we assume that the configuration is the following:

The timer, when configured in Encoder Interface mode provides information on the sensor’s current position. The user can obtain dynamic information (speed, acceleration, deceleration) by measuring the period between two encoder events using a second timer configured in capture mode. The output of the encoder which indicates the mechanical zero can be used for this purpose. Depending on the time between two events, the counter can also be read at regular times. The user can do this by latching the counter value into a third input capture register if available (then the capture signal must be periodic and can be generated by another timer). when available, it is also possible to read its value through a DMA request generated by a Real-Time clock.

The TI1S bit in the TIM1_CR2 register, allows the input filter of channel 1 to be connected to the output of a XOR gate, combining the three input pins TIMx_CH1 to TIMx_CH3.

The counter and its prescaler can be reinitialized in response to an event on a trigger input. Moreover, if the URS bit from the TIMx_CR1 register is low, an update event UEV is generated. Then all the preloaded registers (TIMx_ARR, TIMx_CCRx) are updated.


• Configure the channel 1 to detect rising edges on TI1. Configure the input filter duration (in this example, we don’t need any filter, so we keep IC1F=0000). The capture prescaler is not used for triggering, so the user does not need to configure it. The CC1S bits select the input capture source only, CC1S = 01 in the TIMx_CCMR1 register. Write CC1P=0 in TIMx_CCER register to validate the polarity (and detect rising edges only).

The counter starts counting on the internal clock, then behaves normally until TI1 rising edge. When TI1 rises, the counter is cleared and restarts from 0. In the meantime, the trigger flag is set (TIF bit in the TIMx_SR register) and an interrupt request, or a DMA request can be sent if enabled (depending on the TIE and TDE bits in TIMx_DIER register).

Figure 136 shows this behavior when the auto-reload register TIMx_ARR=0x36. The delay between the rising edge on TI1 and the actual reset of the counter is due to the resynchronization circuit on TI1 input.


• Configure the channel 1 to detect low levels on TI1. Configure the input filter duration (in this example, we don’t need any filter, so we keep IC1F=0000). The capture prescaler is not used for triggering, so the user does not need to configure it. The CC1S bits select the input capture source only, CC1S=01 in TIMx_CCMR1 register. Write CC1P=1 in TIMx_CCER register to validate the polarity (and detect low level only).

The counter starts counting on the internal clock as long as TI1 is low and stops as soon as TI1 becomes high. The TIF flag in the TIMx_SR register is set both when the counter starts or stops.


• Configure the channel 2 to detect rising edges on TI2. Configure the input filter duration (in this example, we don’t need any filter, so we keep IC2F=0000). The capture prescaler is not used for triggering, so the user does not need to configure it. CC2S bits are selecting the input capture source only, CC2S=01 in TIMx_CCMR1 register. Write CC2P=1 in TIMx_CCER register to validate the polarity (and detect low level only).

The external clock mode 2 can be used in addition to another slave mode (except external clock mode 1 and encoder mode). In this case, the ETR signal is used as external clock input, and another input can be selected as trigger input when operating in reset mode, gated mode or trigger mode. It is recommended not to select ETR as TRGI through the TS bits of TIMx_SMCR register.

The TIMx timers are linked together internally for timer synchronization or chaining. When one Timer is configured in Master Mode, it can reset, start, stop or clock the counter of another Timer configured in Slave Mode.

Note:The clock of the slave timer must be enabled prior to receiving events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.


• Configure Timer 1 in master mode so that it outputs a periodic trigger signal on each update event UEV. If you write MMS=010 in the TIM1_CR2 register, a rising edge is output on TRGO1 each time an update event is generated.


• To connect the TRGO1 output of Timer 1 to Timer 2, Timer 2 must be configured in slave mode using ITR0 as internal trigger. You select this through the TS bits in the TIM2_SMCR register (writing TS=000).


• Then you put the slave mode controller in external clock mode 1 (write SMS=111 in the TIM2_SMCR register). This causes Timer 2 to be clocked by the rising edge of the periodic Timer 1 trigger signal (which correspond to the timer 1 counter overflow).

In this example, we control the enable of Timer 2 with the output compare 1 of Timer 1. Refer to Figure 140 for connections. Timer 2 counts on the divided internal clock only when OC1REF of Timer 1 is high. Both counter clock frequencies are divided by 3 by the prescaler compared to CK_INT (fCK_CNT = fCK_INT/3).

In the example in Figure 141, the Timer 2 counter and prescaler are not initialized before being started. So they start counting from their current value. It is possible to start from a given value by resetting both timers before starting Timer 1. You can then write any value 

In the next example, we synchronize Timer 1 and Timer 2. Timer 1 is the master and starts from 0. Timer 2 is the slave and starts from 0xE7. The prescaler ratio is the same for both timers. Timer 2 stops when Timer 1 is disabled by writing ‘0 to the CEN bit in the TIM1_CR1 register:

In this example, we set the enable of Timer 2 with the update event of Timer 1. Refer to Figure 140 for connections. Timer 2 starts counting from its current value (which can be nonzero) on the divided internal clock as soon as the update event is generated by Timer 1. When Timer 2 receives the trigger signal its CEN bit is automatically set and the counter counts until we write ‘0 to the CEN bit in the TIM2_CR1 register. Both counter clock frequencies are divided by 3 by the prescaler compared to CK_INT (fCK_CNT = fCK_INT/3).

As in the previous example, the user can initialize both counters before starting counting. Figure 144 shows the behavior with the same configuration as in Figure 143 but in trigger mode instead of gated mode (SMS=110 in the TIM2_SMCR register).

In this example, we set the enable of timer 1 when its TI1 input rises, and the enable of Timer 2 with the enable of Timer 1. Refer to Figure 140 for connections. To ensure the counters are aligned, Timer 1 must be configured in Master/Slave mode (slave with respect to TI1, master with respect to Timer 2):

Note:In this example both timers are initialized before starting (by setting their respective UG bits). Both counters starts from 0, but you can easily insert an offset between them by writing any of the counter registers (TIMx_CNT). You can see that the master/slave mode insert a delay between CNT_EN and CK_PSC on timer 1.

The 32-bit peripheral registers have to be written by words (32 bits). All other peripheral registers have to be written by half-words (16 bits) or words (32 bits). Read accesses can be done by bytes (8 bits), half-words (16 bits) or words (32 bits). 

Bits 9:8 CKD: Clock divisionThis bit-field indicates the division ratio between the timer clock (CK_INT) frequency and sampling clock used by the digital filters (ETR, TIx),00: tDTS = tCK_INT01: tDTS = 2 × tCK_INT10: tDTS = 4 × tCK_INT11: Reserved

Bits 6:5 CMS: Center-aligned mode selection00: Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).01: Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting down.10: Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set only when the counter is counting up.11: Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set both when the counter is counting up or down.Note: It is not allowed to switch from edge-aligned mode to center-aligned mode as long as the counter is enabled (CEN=1)

Bit 2 URS: Update request sourceThis bit is set and cleared by software to select the UEV event sources.0: Any of the following events generate an update interrupt or DMA request if enabled. These events can be: –Counter overflow/underflow–Setting the UG bit–Update generation through the slave mode controller1: Only counter overflow/underflow generates an update interrupt or DMA request if enabled.

Bit 1 UDIS: Update disableThis bit is set and cleared by software to enable/disable UEV event generation.0: UEV enabled. The Update (UEV) event is generated by one of the following events:–Counter overflow/underflow–Setting the UG bit–Update generation through the slave mode controllerBuffered registers are then loaded with their preload values.1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.

Bit 0 CEN: Counter enable0: Counter disabled1: Counter enabledNote: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. CEN is cleared automatically in one-pulse mode, when an update event occurs.

Bits 6:4 MMS[2:0]: Master mode selectionThese bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:000: Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.001: Enable - the Counter enable signal, CNT_EN, is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register).010: Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.011: Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO)100: Compare - OC1REF signal is used as trigger output (TRGO)101: Compare - OC2REF signal is used as trigger output (TRGO)110: Compare - OC3REF signal is used as trigger output (TRGO)111: Compare - OC4REF signal is used as trigger output (TRGO)Note: The clock of the slave timer and ADC must be enabled prior to receiving events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.

Bit 15 ETP: External trigger polarityThis bit selects whether ETR or ETR is used for trigger operations0: ETR is non-inverted, active at high level or rising edge1: ETR is inverted, active at low level or falling edge

Bit 14 ECE: External clock enableThis bit enables External clock mode 2.0: External clock mode 2 disabled1: External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.1: Setting the ECE bit has the same effect as selecting external clock mode 1 with TRGI connected to ETRF (SMS=111 and TS=111).2: It is possible to simultaneously use external clock mode 2 with the following slave modes: reset mode, gated mode and trigger mode. Nevertheless, TRGI must not be connected to ETRF in this case (TS bits must not be 111).3: If external clock mode 1 and external clock mode 2 are enabled at the same time, the external clock input is ETRF.

Bits 13:12 ETPS: External trigger prescalerExternal trigger signal ETRP frequency must be at most 1/4 of CK_INT frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks.00: Prescaler OFF01: ETRP frequency divided by 210: ETRP frequency divided by 411: ETRP frequency divided by 8

Bit 7 MSM: Master/Slave mode0: No action1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.

Bits 6:4 TS: Trigger selectionThis bit-field selects the trigger input to be used to synchronize the counter.000: Internal Trigger 0 (ITR0). 001: Internal Trigger 1 (ITR1). 010: Internal Trigger 2 (ITR2). 011: Internal Trigger 3 (ITR3). 100: TI1 Edge Detector (TI1F_ED)101: Filtered Timer Input 1 (TI1FP1)110: Filtered Timer Input 2 (TI2FP2)111: External Trigger input (ETRF)See Table 86: TIMx Internal trigger connection for more details on ITRx meaning for each Timer.Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.

Bits 2:0 SMS: Slave mode selectionWhen external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description.000: Slave mode disabled - if CEN = ‘1 then the prescaler is clocked directly by the internal clock.001: Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level.010: Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level.011: Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.100: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.101: Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.110: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.111: External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.Note: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=100). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal.The clock of the slave timer must be enabled prior to receiving events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.

Bit 9 CC1OF: Capture/Compare 1 overcapture flagThis flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to ‘0’.0: No overcapture has been detected.1: The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set

Bit 6 TIF: Trigger interrupt flagThis flag is set by hardware on trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode, both edges in case gated mode is selected). It is cleared by software.0: No trigger event occurred.1: Trigger interrupt pending.

Bit 1 CC1IF: Capture/compare 1 interrupt flagIf channel CC1 is configured as output:This flag is set by hardware when the counter matches the compare value, with some exception in center-aligned mode (refer to the CMS bits in the TIMx_CR1 register description). It is cleared by software.0: No match.1: The content of the counter TIMx_CNT has matched the content of the TIMx_CCR1 register.If channel CC1 is configured as input:This bit is set by hardware on a capture. It is cleared by software or by reading the TIMx_CCR1 register.0: No input capture occurred.1: The counter value has been captured in TIMx_CCR1 register (An edge has been detected on IC1 which matches the selected polarity).

Bit 0 UIF: Update interrupt flag– This bit is set by hardware on an update event. It is cleared by software.0: No update occurred.1: Update interrupt pending. This bit is set by hardware when the registers are updated:– At overflow or underflow and if the UDIS=0 in the TIMx_CR1 register.– When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.– When CNT is reinitialized by a trigger event (refer to the synchro control register description), if URS=0 and UDIS=0 in the TIMx_CR1 register.

Bit 6 TG: Trigger generationThis bit is set by software in order to generate an event, it is automatically cleared by hardware.0: No action1: The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.

Bit 1 CC1G: Capture/compare 1 generationThis bit is set by software in order to generate an event, it is automatically cleared by hardware.0: No action1: A capture/compare event is generated on channel 1:If channel CC1 is configured as output:CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.If channel CC1 is configured as input:The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.

Bit 0 UG: Update generationThis bit can be set by software, it is automatically cleared by hardware.0: No action1: Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (TIMx_ARR) if DIR=1 (downcounting).

The channels can be used in input (capture mode) or in output (compare mode). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function in input and in output mode. For a given bit, OCxx describes its function when the channel is configured in output, ICxx describes its function when the channel is configured in input. Take care that the same bit can have a different meaning for the input stage and for the output stage.

Bits 9:8 CC2S[1:0]: Capture/Compare 2 selectionThis bit-field defines the direction of the channel (input/output) as well as the used input. 00: CC2 channel is configured as output01: CC2 channel is configured as input, IC2 is mapped on TI210: CC2 channel is configured as input, IC2 is mapped on TI111: CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through the TS bit (TIMx_SMCR register)Note: CC2S bits are writable only when the channel is OFF (CC2E = 0 in TIMx_CCER).

Bit 7 OC1CE: Output compare 1 clear enableOC1CE: Output Compare 1 Clear Enable0: OC1Ref is not affected by the ETRF input1: OC1Ref is cleared as soon as a High level is detected on ETRF input

Bits 6:4 OC1M: Output compare 1 modeThese bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.000: Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).001: Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).010: Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).011: Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.100: Force inactive level - OC1REF is forced low.101: Force active level - OC1REF is forced high.110: PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT<TIMx_CCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF=‘0) as long as TIMx_CNT>TIMx_CCR1 else active (OC1REF=1).111: PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT<TIMx_CCR1 else active. In downcounting, channel 1 is active as long as TIMx_CNT>TIMx_CCR1 else inactive.Note: In PWM mode 1 or 2, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from “frozen” mode to “PWM” mode.

Bit 3 OC1PE: Output compare 1 preload enable0: Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately.1: Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.Note: 1: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=00 (the channel is configured in output).2: The PWM mode can be used without validating the preload register only in one-pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed.

Bit 2 OC1FE: Output compare 1 fast enableThis bit is used to accelerate the effect of an event on the trigger in input on the CC output.0: CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.1: An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is set to the compare level independently from the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OCFE acts only if the channel is configured in PWM1 or PWM2 mode.

Bits 1:0 CC1S: Capture/Compare 1 selectionThis bit-field defines the direction of the channel (input/output) as well as the used input. 00: CC1 channel is configured as output.01: CC1 channel is configured as input, IC1 is mapped on TI1.10: CC1 channel is configured as input, IC1 is mapped on TI2.11: CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).

Bits 9:8 CC2S: Capture/compare 2 selectionThis bit-field defines the direction of the channel (input/output) as well as the used input. 00: CC2 channel is configured as output.01: CC2 channel is configured as input, IC2 is mapped on TI2.10: CC2 channel is configured as input, IC2 is mapped on TI1.11: CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)Note: CC2S bits are writable only when the channel is OFF (CC2E = 0 in TIMx_CCER).

Bits 3:2 IC1PSC: Input capture 1 prescalerThis bit-field defines the ratio of the prescaler acting on CC1 input (IC1).The prescaler is reset as soon as CC1E=0 (TIMx_CCER register).00: no prescaler, capture is done each time an edge is detected on the capture input01: capture is done once every 2 events10: capture is done once every 4 events11: capture is done once every 8 events

Bits 1:0 CC1S: Capture/Compare 1 selectionThis bit-field defines the direction of the channel (input/output) as well as the used input. 00: CC1 channel is configured as output01: CC1 channel is configured as input, IC1 is mapped on TI110: CC1 channel is configured as input, IC1 is mapped on TI211: CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).

Bits 9:8 CC4S: Capture/Compare 4 selectionThis bit-field defines the direction of the channel (input/output) as well as the used input. 00: CC4 channel is configured as output01: CC4 channel is configured as input, IC4 is mapped on TI410: CC4 channel is configured as input, IC4 is mapped on TI311: CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)Note: CC4S bits are writable only when the channel is OFF (CC4E = 0 in TIMx_CCER).

Bits 1:0 CC3S: Capture/Compare 3 selectionThis bit-field defines the direction of the channel (input/output) as well as the used input. 00: CC3 channel is configured as output01: CC3 channel is configured as input, IC3 is mapped on TI310: CC3 channel is configured as input, IC3 is mapped on TI411: CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)Note: CC3S bits are writable only when the channel is OFF (CC3E = 0 in TIMx_CCER).

Bits 9:8 CC4S: Capture/Compare 4 selectionThis bit-field defines the direction of the channel (input/output) as well as the used input. 00: CC4 channel is configured as output01: CC4 channel is configured as input, IC4 is mapped on TI410: CC4 channel is configured as input, IC4 is mapped on TI311: CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)Note: CC4S bits are writable only when the channel is OFF (CC4E = 0 in TIMx_CCER).

Bits 1:0 CC3S: Capture/Compare 3 selectionThis bit-field defines the direction of the channel (input/output) as well as the used input. 00: CC3 channel is configured as output01: CC3 channel is configured as input, IC3 is mapped on TI310: CC3 channel is configured as input, IC3 is mapped on TI411: CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)Note: CC3S bits are writable only when the channel is OFF (CC3E = 0 in TIMx_CCER).

Bit 1 CC1P: Capture/Compare 1 output polarityCC1 channel configured as output:0: OC1 active high.1: OC1 active low.CC1 channel configured as input:This bit selects whether IC1 or IC1 is used for trigger or capture operations.0: non-inverted: capture is done on a rising edge of IC1. When used as external trigger, IC1 is non-inverted.1: inverted: capture is done on a falling edge of IC1. When used as external trigger, IC1 is inverted.

Bit 0 CC1E: Capture/Compare 1 output enableCC1 channel configured as output:0: Off - OC1 is not active. 1: On - OC1 signal is output on the corresponding output pin. CC1 channel configured as input:This bit determines if a capture of the counter value can actually be done into the input capture/compare register 1 (TIMx_CCR1) or not.0: Capture disabled.1: Capture enabled.

Bits 15:0 PSC[15:0]: Prescaler valueThe counter clock frequency CK_CNT is equal to fCK_PSC / (PSC[15:0] + 1).PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in “reset mode”).

Bits 15:0 CCR1[15:0]: Capture/Compare 1 valueIf channel CC1 is configured as output:CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC1 output.

Bits 15:0 CCR2[15:0]: Capture/Compare 2 valueIf channel CC2 is configured as output:CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value).It is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on OC2 output.If channel CC2 is configured as input:CCR2 is the counter value transferred by the last input capture 2 event (IC2). The TIMx_CCR2 register is read-only and cannot be programmed.

Bits 15:0 CCR3[15:0]: Capture/Compare valueIf channel CC3 is configured as output:CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value).It is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC3 output.If channel CC3 is configured as input:CCR3 is the counter value transferred by the last input capture 3 event (IC3). The TIMx_CCR3 register is read-only and cannot be programmed.

In this example the timer DMA burst feature is used to update the contents of the CCRx registers (x = 2, 3, 4) with the DMA transferring half words into the CCRx registers. 

Note:This example is for the case where every CCRx register to be updated once. If every CCRx register is to be updated twice for example, the number of data to transfer should be 6. Let's take the example of a buffer in the RAM containing data1, data2, data3, data4, data5 and data6. The data is transferred to the CCRx registers as follows: on the first update DMA request, data1 is transferred to CCR2, data2 is transferred to CCR3, data3 is transferred to CCR4 and on the second update DMA request, data4 is transferred to CCR2, data5 is transferred to CCR3 and data6 is transferred to CCR4. 

Bits 15:0 DMAB[15:0]: DMA register for burst accessesA read or write operation to the DMAR register accesses the register located at the address(TIMx_CR1 address) + (DBA + DMA index) x 4 where TIMx_CR1 address is the address of the control register 1, DBA is the DMA base address configured in TIMx_DCR register, DMA index is automatically controlled by the DMA transfer, and ranges from 0 to DBL (DBL configured in TIMx_DCR).

The auto-reload register is preloaded. Writing to or reading from the auto-reload register accesses the preload register. The content of the preload register are transferred into the shadow register permanently or at each update event (UEV), depending on the auto-reload preload enable bit (ARPE) in TIMx_CR1 register. The update event is sent when the counter reaches the overflow and if the UDIS bit equals 0 in the TIMx_CR1 register. It can also be generated by software. The generation of the update event is described in details for each configuration.

The counter is clocked by the prescaler output CK_CNT, which is enabled only when the counter enable bit (CEN) in TIMx_CR1 register is set (refer also to the slave mode controller description to get more details on counter enabling). 

The prescaler can divide the counter clock frequency by any factor between 1 and 65536. It is based on a 16-bit counter controlled through a 16-bit register (in the TIMx_PSC register). It can be changed on the fly as this control register is buffered. The new prescaler ratio is taken into account at the next update event.

The UEV event can be disabled by software by setting the UDIS bit in the TIMx_CR1 register. This is to avoid updating the shadow registers while writing new values in the preload registers. Then no update event occurs until the UDIS bit has been written to 0. However, the counter restarts from 0, as well as the counter of the prescaler (but the prescale rate does not change). In addition, if the URS bit (update request selection) in TIMx_CR1 register is set, setting the UG bit generates an update event UEV but without setting the UIF flag (thus no interrupt is sent). This is to avoid generating both update and capture interrupts when clearing the counter on the capture event.

For TIM9 and TIM12, the internal clock source is selected when the slave mode controller is disabled (SMS=’000’). The CEN bit in the TIMx_CR1 register and the UG bit in the TIMx_EGR register are then used as control bits and can be changed only by software (except for UG which remains cleared). As soon as the CEN bit is programmed to 1, the prescaler is clocked by the internal clock CK_INT. 

Each Capture/Compare channel is built around a capture/compare register (including a shadow register), a input stage for capture (with digital filter, multiplexing and prescaler) and an output stage (with comparator and output control).

The input stage samples the corresponding TIx input to generate a filtered signal TIxF. Then, an edge detector with polarity selection generates a signal (TIxFPx) which can be used as trigger input by the slave mode controller or as the capture command. It is prescaled before the capture register (ICxPS).

In Input capture mode, the Capture/Compare Registers (TIMx_CCRx) are used to latch the value of the counter after a transition detected by the corresponding ICx signal. When a capture occurs, the corresponding CCXIF flag (TIMx_SR register) is set and an interrupt or a DMA request can be sent if they are enabled. If a capture occurs while the CCxIF flag was already high, then the over-capture flag CCxOF (TIMx_SR register) is set. CCxIF can be 

In order to handle the overcapture, it is recommended to read the data before the overcapture flag. This is to avoid missing an overcapture which could happen after reading the flag and before reading the data.

For example, the user can measure the period (in TIMx_CCR1 register) and the duty cycle (in TIMx_CCR2 register) of the PWM applied on TI1 using the following procedure (depending on CK_INT frequency and prescaler value):

In output mode (CCxS bits = ‘00’ in the TIMx_CCMRx register), each output compare signal (OCxREF and then OCx) can be forced to active or inactive level directly by software, independently of any comparison between the output compare register and the counter.

To force an output compare signal (OCXREF/OCx) to its active level, the user just needs to write ‘101’ in the OCxM bits in the corresponding TIMx_CCMRx register. Thus OCXREF is forced high (OCxREF is always active high) and OCx get opposite value to CCxP polarity bit.

Anyway, the comparison between the TIMx_CCRx shadow register and the counter is still performed and allows the flag to be set. Interrupt requests can be sent accordingly. This is described in the output compare mode section below.

In output compare mode, the update event UEV has no effect on OCxREF and OCx output. The timing resolution is one count of the counter. Output compare mode can also be used to output a single pulse (in One-pulse mode).

The TIMx_CCRx register can be updated at any time by software to control the output waveform, provided that the preload register is not enabled (OCxPE=’0’, else TIMx_CCRx shadow register is updated only at the next update event UEV). An example is given in Figure 163.

Pulse Width Modulation mode allows the user to generate a signal with a frequency determined by the value of the TIMx_ARR register and a duty cycle determined by the value of the TIMx_CCRx register.

The PWM mode can be selected independently on each channel (one PWM per OCx output) by writing ‘110’ (PWM mode 1) or ‘111’ (PWM mode 2) in the OCxM bits in the TIMx_CCMRx register. Enable the corresponding preload register by setting the OCxPE bit in the TIMx_CCMRx register, and eventually the auto-reload preload register by setting the ARPE bit in the TIMx_CR1 register.

As the preload registers are transferred to the shadow registers only when an update event occurs, before starting the counter, the user has to initialize all the registers by setting the UG bit in the TIMx_EGR register.

The OCx polarity is software programmable using the CCxP bit in the TIMx_CCER register. It can be programmed as active high or active low. The OCx output is enabled by the CCxE bit in the TIMx_CCER register. Refer to the TIMx_CCERx register description for more details.

In the following example, we consider PWM mode 1. The reference PWM signal OCxREF is high as long as TIMx_CNT < TIMx_CCRx else it becomes low. If the compare value in 

TIMx_CCRx is greater than the auto-reload value (in TIMx_ARR) then OCxREF is held at ‘1’. If the compare value is 0 then OCxRef is held at ‘0’. Figure 164 shows some edge-aligned PWM waveforms in an example where TIMx_ARR=8.

One-pulse mode (OPM) is a particular case of the previous modes. It allows the counter to be started in response to a stimulus and to generate a pulse with a programmable length after a programmable delay.

Starting the counter can be controlled through the slave mode controller. Generating the waveform can be done in output compare mode or PWM mode. Select One-pulse mode by setting the OPM bit in the TIMx_CR1 register. This makes the counter stop automatically at the next update event UEV.

A pulse can be correctly generated only if the compare value is different from the counter initial value. Before starting (when the timer is waiting for the trigger), the configuration must be as follows:

For example the user may want to generate a positive pulse on OC1 with a length of tPULSE and after a delay of tDELAY as soon as a positive edge is detected on the TI2 input pin.


• Let us say the user wants to build a waveform with a transition from ‘0’ to ‘1’ when a compare match occurs and a transition from ‘1’ to ‘0’ when the counter reaches the auto-reload value. To do this enable PWM mode 2 by writing OC1M=’111’ in the TIMx_CCMR1 register. The user can optionally enable the preload registers by writing OC1PE=’1’ in the TIMx_CCMR1 register and ARPE in the TIMx_CR1 register. In this case the user has to write the compare value in the TIMx_CCR1 register, the auto-reload value in the TIMx_ARR register, generate an update by setting the UG bit and wait for external trigger event on TI2. CC1P is written to ‘0’ in this example.

The user only wants one pulse (Single mode), so write '1 in the OPM bit in the TIMx_CR1 register to stop the counter at the next update event (when the counter rolls over from the auto-reload value back to 0). When OPM bit in the TIMx_CR1 register is set to '0', so the Repetitive Mode is selected.

In One-pulse mode, the edge detection on TIx input set the CEN bit which enables the counter. Then the comparison between the counter and the compare value makes the output toggle. But several clock cycles are needed for these operations and it limits the minimum delay tDELAY min we can get.

If the user wants to output a waveform with the minimum delay, set the OCxFE bit in the TIMx_CCMRx register. Then OCxRef (and OCx) are forced in response to the stimulus, without taking in account the comparison. Its new level is the same as if a compare match had occurred. OCxFE acts only if the channel is configured in PWM1 or PWM2 mode.

The counter and its prescaler can be reinitialized in response to an event on a trigger input. Moreover, if the URS bit from the TIMx_CR1 register is low, an update event UEV is generated. Then all the preloaded registers (TIMx_ARR, TIMx_CCRx) are updated.

The counter starts counting on the internal clock, then behaves normally until TI1 rising edge. When TI1 rises, the counter is cleared and restarts from 0. In the meantime, the trigger flag is set (TIF bit in the TIMx_SR register) and an interrupt request can be sent if enabled (depending on the TIE bit in TIMx_DIER register).

The following figure shows this behavior when the auto-reload register TIMx_ARR=0x36. The delay between the rising edge on TI1 and the actual reset of the counter is due to the resynchronization circuit on TI1 input.

The counter starts counting on the internal clock as long as TI1 is low and stops as soon as TI1 becomes high. The TIF flag in the TIMx_SR register is set both when the counter starts or stops.

Note:The clock of the slave timer must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.

The peripheral registers have to be written by half-words (16 bits) or words (32 bits). Read accesses can be done by bytes (8 bits), half-words (16 bits) or words (32 bits). 

Bits 9:8 CKD: Clock divisionThis bit-field indicates the division ratio between the timer clock (CK_INT) frequency and sampling clock used by the digital filters (TIx),00: tDTS = tCK_INT01: tDTS = 2 × tCK_INT10: tDTS = 4 × tCK_INT11: Reserved

Bit 2 URS: Update request sourceThis bit is set and cleared by software to select the UEV event sources.0: Any of the following events generates an update interrupt if enabled:–Counter overflow–Setting the UG bit1: Only counter overflow generates an update interrupt if enabled.

Bit 1 UDIS: Update disableThis bit is set and cleared by software to enable/disable update event (UEV) generation.0: UEV enabled. An UEV is generated by one of the following events:–Counter overflow–Setting the UG bitBuffered registers are then loaded with their preload values.1: UEV disabled. No UEV is generated, shadow registers keep their value (ARR, PSC, CCRx). The counter and the prescaler are reinitialized if the UG bit is set.

Bits 6:4 TS: Trigger selectionThis bit field selects the trigger input to be used to synchronize the counter.000: Internal Trigger 0 (ITR0)001: Internal Trigger 1 (ITR1)010: Internal Trigger 2 (ITR2)011: Internal Trigger 3 (ITR3)100: TI1 Edge Detector (TI1F_ED)101: Filtered Timer Input 1 (TI1FP1)110: Filtered Timer Input 2 (TI2FP2)111: Reserved.See Table 89 for more details on the meaning of ITRx for each timer.Note: These bits must be changed only when they are not used (e.g. when SMS=’000’) to avoid wrong edge detections at the transition.

Bits 2:0 SMS: Slave mode selectionWhen external signals are selected, the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input control register and Control register descriptions.000: Slave mode disabled - if CEN = 1 then the prescaler is clocked directly by the internal clock001: Reserved010: Reserved011: Reserved100: Reset mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers101: Gated mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Counter starts and stops are both controlled110: Trigger mode - The counter starts on a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled111: External clock mode 1 - Rising edges of the selected trigger (TRGI) clock the counterNote: The Gated mode must not be used if TI1F_ED is selected as the trigger input (TS=’100’). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the Gated mode checks the level of the trigger signal.Note: The clock of the slave timer must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.

Bit 9 CC1OF: Capture/Compare 1 overcapture flagThis flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to ‘0’.0: No overcapture has been detected.1: The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set

Bit 6 TIF: Trigger interrupt flagThis flag is set by hardware on trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode. It is set when the counter starts or stops when gated mode is selected. It is cleared by software.0: No trigger event occurred.1: Trigger interrupt pending.

Bit 1 CC1IF: Capture/compare 1 interrupt flagIf channel CC1 is configured as output:This flag is set by hardware when the counter matches the compare value. It is cleared by software.0: No match.1: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the contents of TIMx_CCR1 are greater than the contents of TIMx_ARR, the CC1IF bit goes high on the counter overflow.If channel CC1 is configured as input:This bit is set by hardware on a capture. It is cleared by software or by reading the TIMx_CCR1 register.0: No input capture occurred.1: The counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1 which matches the selected polarity).

Bit 0 UIF: Update interrupt flagThis bit is set by hardware on an update event. It is cleared by software.0: No update occurred.1: Update interrupt pending. This bit is set by hardware when the registers are updated:– At overflow and if UDIS=’0’ in the TIMx_CR1 register.– When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=’0’ and UDIS=’0’ in the TIMx_CR1 register.– When CNT is reinitialized by a trigger event (refer to the synchro control register description), if URS=’0’ and UDIS=’0’ in the TIMx_CR1 register.

Bit 6 TG: Trigger generationThis bit is set by software in order to generate an event, it is automatically cleared by hardware.0: No action1: The TIF flag is set in the TIMx_SR register. Related interrupt can occur if enabled

Bit 1 CC1G: Capture/compare 1 generationThis bit is set by software to generate an event, it is automatically cleared by hardware.0: No action1: A capture/compare event is generated on channel 1:If channel CC1 is configured as output:the CC1IF flag is set, the corresponding interrupt is sent if enabled.If channel CC1 is configured as input:The current counter value is captured in the TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.

Bit 0 UG: Update generationThis bit can be set by software, it is automatically cleared by hardware.0: No action1: Re-initializes the counter and generates an update of the registers. The prescaler counter is also cleared and the prescaler ratio is not affected. The counter is cleared.

The channels can be used in input (capture mode) or in output (compare mode). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits in this register have different functions in input and output modes. For a given bit, OCxx describes its function when the channel is configured in output mode, ICxx describes its function when the channel is configured in input mode. Take care that the same bit can have different meanings for the input stage and the output stage.

Bits 9:8 CC2S[1:0]: Capture/Compare 2 selectionThis bitfield defines the direction of the channel (input/output) as well as the used input. 00: CC2 channel is configured as output01: CC2 channel is configured as input, IC2 is mapped on TI210: CC2 channel is configured as input, IC2 is mapped on TI111: CC2 channel is configured as input, IC2 is mapped on TRC. This mode works only if an internal trigger input is selected through the TS bit (TIMx_SMCR registerNote: The CC2S bits are writable only when the channel is OFF (CC2E = 0 in TIMx_CCER).

Bit 7 OC1CE: Output compare 1 clear enableOC1CE: Output Compare 1 Clear Enable0: OC1Ref is not affected by the ETRF input1: OC1Ref is cleared as soon as a High level is detected on ETRF input

Bits 6:4 OC1M: Output compare 1 modeThese bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas the active levels of OC1 and OC1N depend on the CC1P and CC1NP bits, respectively.000: Frozen - The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.(this mode is used to generate a timing base).001: Set channel 1 to active level on match. The OC1REF signal is forced high when the TIMx_CNT counter matches the capture/compare register 1 (TIMx_CCR1).010: Set channel 1 to inactive level on match. The OC1REF signal is forced low when the TIMx_CNT counter matches the capture/compare register 1 (TIMx_CCR1).011: Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1100: Force inactive level - OC1REF is forced low101: Force active level - OC1REF is forced high110: PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT<TIMx_CCR1 else it is inactive. In downcounting, channel 1 is inactive (OC1REF=‘0) as long as TIMx_CNT>TIMx_CCR1, else it is active (OC1REF=’1’)111: PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT<TIMx_CCR1 else it is active. In downcounting, channel 1 is active as long as TIMx_CNT>TIMx_CCR1 else it is inactive.Note: In PWM mode 1 or 2, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from “frozen” mode to “PWM” mode.

Bit 3 OC1PE: Output compare 1 preload enable0: Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken into account immediately1: Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded into the active register at each update eventNote: The PWM mode can be used without validating the preload register only in one-pulse mode (OPM bit set in the TIMx_CR1 register). Else the behavior is not guaranteed.

Bit 2 OC1FE: Output compare 1 fast enableThis bit is used to accelerate the effect of an event on the trigger in input on the CC output.0: CC1 behaves normally depending on the counter and CCR1 values even when the trigger is ON. The minimum delay to activate the CC1 output when an edge occurs on the trigger input is 5 clock cycles1: An active edge on the trigger input acts like a compare match on the CC1 output. Then, OC is set to the compare level independently of the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OC1FE acts only if the channel is configured in PWM1 or PWM2 mode.

Bits 1:0 CC1S: Capture/Compare 1 selectionThis bitfield defines the direction of the channel (input/output) as well as the used input. 00: CC1 channel is configured as output01: CC1 channel is configured as input, IC1 is mapped on TI110: CC1 channel is configured as input, IC1 is mapped on TI211: CC1 channel is configured as input, IC1 is mapped on TRC. This mode works only if an internal trigger input is selected through the TS bit (TIMx_SMCR register)Note: The CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).

Bits 9:8 CC2S: Capture/compare 2 selectionThis bitfield defines the direction of the channel (input/output) as well as the used input. 00: CC2 channel is configured as output01: CC2 channel is configured as input, IC2 is mapped on TI210: CC2 channel is configured as input, IC2 is mapped on TI111: CC2 channel is configured as input, IC2 is mapped on TRC. This mode works only if an internal trigger input is selected through the TS bit (TIMx_SMCR register)Note: The CC2S bits are writable only when the channel is OFF (CC2E = 0 in TIMx_CCER).

Bits 3:2 IC1PSC: Input capture 1 prescalerThis bitfield defines the ratio of the prescaler acting on the CC1 input (IC1).The prescaler is reset as soon as CC1E=’0’ (TIMx_CCER register).00: no prescaler, capture is done each time an edge is detected on the capture input01: capture is done once every 2 events10: capture is done once every 4 events11: capture is done once every 8 events

Bits 1:0 CC1S: Capture/Compare 1 selectionThis bitfield defines the direction of the channel (input/output) as well as the used input. 00: CC1 channel is configured as output01: CC1 channel is configured as input, IC1 is mapped on TI110: CC1 channel is configured as input, IC1 is mapped on TI211: CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)Note: The CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).

Bit 3 CC1NP: Capture/Compare 1 complementary output PolarityCC1 channel configured as output: CC1NP must be kept clearedCC1 channel configured as input: CC1NP is used in conjunction with CC1P to define TI1FP1/TI2FP1 polarity (refer to CC1P description).

Bit 1 CC1P: Capture/Compare 1 output Polarity.CC1 channel configured as output:0: OC1 active high.1: OC1 active low.CC1 channel configured as input:CC1NP/CC1P bits select TI1FP1 and TI2FP1 polarity for trigger or capture operations.00: noninverted/rising edgeCircuit is sensitive to TIxFP1 rising edge (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger in gated mode, encoder mode).01: inverted/falling edgeCircuit is sensitive to TIxFP1 falling edge (capture, trigger in reset, external clock or trigger mode), TIxFP1 is inverted (trigger in gated mode, encoder mode).10: reserved, do not use this configuration.Note: 11: noninverted/both edgesCircuit is sensitive to both TIxFP1 rising and falling edges (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger in gated mode). This configuration must not be used for encoder mode.

Bit 0 CC1E: Capture/Compare 1 output enable.CC1 channel configured as output:0: Off - OC1 is not active. 1: On - OC1 signal is output on the corresponding output pin. CC1 channel configured as input:This bit determines if a capture of the counter value can actually be done into the input capture/compare register 1 (TIMx_CCR1) or not.0: Capture disabled.1: Capture enabled.

Bits 15:0 PSC[15:0]: Prescaler valueThe counter clock frequency CK_CNT is equal to fCK_PSC / (PSC[15:0] + 1).PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in “reset mode”).

Bits 15:0 CCR1[15:0]: Capture/Compare 1 valueIf channel CC1 is configured as output:CCR1 is the value to be loaded into the actual capture/compare 1 register (preload value).It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (OC1PE bit). Else the preload value is copied into the active capture/compare 1 register when an update event occurs.The active capture/compare register contains the value to be compared to the TIMx_CNT counter and signaled on the OC1 output.If channel CC1is configured as input:CCR1 is the counter value transferred by the last input capture 1 event (IC1). The TIMx_CCR1 register is read-only and cannot be programmed.

Bits 15:0 CCR2[15:0]: Capture/Compare 2 valueIf channel CC2 is configured as output:CCR2 is the value to be loaded into the actual capture/compare 2 register (preload value).It is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (OC2PE bit). Else the preload value is copied into the active capture/compare 2 register when an update event occurs.The active capture/compare register contains the value to be compared to the TIMx_CNT counter and signalled on the OC2 output.If channel CC2 is configured as input:CCR2 is the counter value transferred by the last input capture 2 event (IC2). The TIMx_CCR2 register is read-only and cannot be programmed.

The peripheral registers have to be written by half-words (16 bits) or words (32 bits). Read accesses can be done by bytes (8 bits), half-words (16 bits) or words (32 bits). 

Bits 9:8 CKD: Clock divisionThis bit-field indicates the division ratio between the timer clock (CK_INT) frequency and sampling clock used by the digital filters (TIx),00: tDTS = tCK_INT01: tDTS = 2 × tCK_INT10: tDTS = 4 × tCK_INT11: Reserved

Bit 2 URS: Update request sourceThis bit is set and cleared by software to select the update interrupt (UEV) sources.0: Any of the following events generate an UEV if enabled: –Counter overflow–Setting the UG bit1: Only counter overflow generates an UEV if enabled.

Bit 1 UDIS: Update disableThis bit is set and cleared by software to enable/disable update interrupt (UEV) event generation.0: UEV enabled. An UEV is generated by one of the following events:–Counter overflow–Setting the UG bit. Buffered registers are then loaded with their preload values.1: UEV disabled. No UEV is generated, shadow registers keep their value (ARR, PSC, CCRx). The counter and the prescaler are reinitialized if the UG bit is set.

Bit 9 CC1OF: Capture/Compare 1 overcapture flagThis flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to ‘0’.0: No overcapture has been detected.1: The counter value has been captured in TIMx_CCR1 register while CC1IF flag was already set

Bit 1 CC1IF: Capture/compare 1 interrupt flagIf channel CC1 is configured as output:This flag is set by hardware when the counter matches the compare value. It is cleared by software.0: No match.1: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the contents of TIMx_CCR1 are greater than the contents of TIMx_ARR, the CC1IF bit goes high on the counter overflow.If channel CC1 is configured as input:This bit is set by hardware on a capture. It is cleared by software or by reading the TIMx_CCR1 register.0: No input capture occurred.1: The counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1 which matches the selected polarity).

The channels can be used in input (capture mode) or in output (compare mode). The direction of a channel is defined by configuring the corresponding CCxS bits. All the other bits of this register have a different function in input and in output mode. For a given bit, OCxx describes its function when the channel is configured in output, ICxx describes its function when the channel is configured in input. So take care that the same bit can have a different meaning for the input stage and for the output stage.

Bit 0 UIF: Update interrupt flagThis bit is set by hardware on an update event. It is cleared by software.0: No update occurred.1: Update interrupt pending. This bit is set by hardware when the registers are updated:–At overflow and if UDIS=’0’ in the TIMx_CR1 register.–When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=’0’ and UDIS=’0’ in the TIMx_CR1 register.

Bit 1 CC1G: Capture/compare 1 generationThis bit is set by software in order to generate an event, it is automatically cleared by hardware.0: No action1: A capture/compare event is generated on channel 1:If channel CC1 is configured as output:CC1IF flag is set, Corresponding interrupt or is sent if enabled.If channel CC1 is configured as input:The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.

Bit 0 UG: Update generationThis bit can be set by software, it is automatically cleared by hardware.0: No action1: Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared. 

Bits 6:4 OC1M: Output compare 1 modeThese bits define the behavior of the output reference signal OC1REF from which OC1 is derived. OC1REF is active high whereas OC1 active level depends on CC1P bit. 000: Frozen. The comparison between the output compare register TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs. 001: Set channel 1 to active level on match. OC1REF signal is forced high when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1). 010: Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1). 011: Toggle - OC1REF toggles when TIMx_CNT = TIMx_CCR1. 100: Force inactive level - OC1REF is forced low. 101: Force active level - OC1REF is forced high.110: PWM mode 1 - Channel 1 is active as long as TIMx_CNT < TIMx_CCR1 else inactive.111: PWM mode 2 - Channel 1 is inactive as long as TIMx_CNT < TIMx_CCR1 else active.Note: In PWM mode 1 or 2, the OCREF level changes when the result of the comparison changes or when the output compare mode switches from frozen to PWM mode. 

Bit 3 OC1PE: Output compare 1 preload enable0: Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the new value is taken in account immediately. 1: Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload register. TIMx_CCR1 preload value is loaded in the active register at each update event.Note: The PWM mode can be used without validating the preload register only in one pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed. 

Bit 2 OC1FE: Output compare 1 fast enableThis bit is used to accelerate the effect of an event on the trigger in input on the CC output.0: CC1 behaves normally depending on counter and CCR1 values even when the trigger is ON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is 5 clock cycles.1: An active edge on the trigger input acts like a compare match on CC1 output. OC is then set to the compare level independently of the result of the comparison. Delay to sample the trigger input and to activate CC1 output is reduced to 3 clock cycles. OC1FE acts only if the channel is configured in PWM1 or PWM2 mode.

Bits 1:0 CC1S: Capture/Compare 1 selectionThis bit-field defines the direction of the channel (input/output) as well as the used input. 00: CC1 channel is configured as output.01: CC1 channel is configured as input, IC1 is mapped on TI1.10: CC1 channel is configured as input, IC1 is mapped on TI211: CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).

Bits 3:2 IC1PSC: Input capture 1 prescalerThis bit-field defines the ratio of the prescaler acting on CC1 input (IC1).The prescaler is reset as soon as CC1E=’0’ (TIMx_CCER register).00: no prescaler, capture is done each time an edge is detected on the capture input01: capture is done once every 2 events10: capture is done once every 4 events11: capture is done once every 8 events

Bits 1:0 CC1S: Capture/Compare 1 selectionThis bit-field defines the direction of the channel (input/output) as well as the used input. 00: CC1 channel is configured as output01: CC1 channel is configured as input, IC1 is mapped on TI110: CC1 channel is configured as input, IC1 is mapped on TI211: CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (TIMx_SMCR register)Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).

Bit 3 CC1NP: Capture/Compare 1 complementary output Polarity. CC1 channel configured as output: CC1NP must be kept cleared. CC1 channel configured as input: CC1NP bit is used in conjunction with CC1P to define TI1FP1 polarity (refer to CC1P description).

Bit 1 CC1P: Capture/Compare 1 output Polarity.CC1 channel configured as output:0: OC1 active high1: OC1 active lowCC1 channel configured as input:The CC1P bit selects TI1FP1 and TI2FP1 polarity for trigger or capture operations.00: noninverted/rising edgeCircuit is sensitive to TI1FP1 rising edge (capture mode), TI1FP1 is not inverted. 01: inverted/falling edgeCircuit is sensitive to TI1FP1 falling edge (capture mode), TI1FP1 is inverted.10: reserved, do not use this configuration. 11: noninverted/both edgesCircuit is sensitive to both TI1FP1 rising and falling edges (capture mode), TI1FP1 is not inverted. 

Bit 0 CC1E: Capture/Compare 1 output enable.CC1 channel configured as output:0: Off - OC1 is not active1: On - OC1 signal is output on the corresponding output pinCC1 channel configured as input:This bit determines if a capture of the counter value can actually be done into the input capture/compare register 1 (TIMx_CCR1) or not.0: Capture disabled1: Capture enabled

Bits 15:0 PSC[15:0]: Prescaler valueThe counter clock frequency CK_CNT is equal to fCK_PSC / (PSC[15:0] + 1).PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in “reset mode”).

Bits 15:0 CCR1[15:0]: Capture/Compare 1 valueIf channel CC1 is configured as output:CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC1 output.

They may be used as generic timers for time-base generation but they are also specifically used to drive the digital-to-analog converter (DAC). In fact, the timers are internally connected to the DAC and are able to drive it through their trigger outputs.

The auto-reload register is preloaded. The preload register is accessed each time an attempt is made to write or read the auto-reload register. The contents of the preload register are transferred into the shadow register permanently or at each update event UEV, depending on the auto-reload preload enable bit (ARPE) in the TIMx_CR1 register. The update event is sent when the counter reaches the overflow value and if the UDIS bit equals 0 in the TIMx_CR1 register. It can also be generated by software. The generation of the update event is described in detail for each configuration.

The prescaler can divide the counter clock frequency by any factor between 1 and 65536. It is based on a 16-bit counter controlled through a 16-bit register (in the TIMx_PSC register). It can be changed on the fly as the TIMx_PSC control register is buffered. The new prescaler ratio is taken into account at the next update event.

The UEV event can be disabled by software by setting the UDIS bit in the TIMx_CR1 register. This avoids updating the shadow registers while writing new values into the preload registers. In this way, no update event occurs until the UDIS bit has been written to 0, however, the counter and the prescaler counter both restart from 0 (but the prescale rate does not change). In addition, if the URS (update request selection) bit in the TIMx_CR1 register is set, setting the UG bit generates an update event UEV, but the UIF flag is not set (so no interrupt or DMA request is sent). 

The CEN (in the TIMx_CR1 register) and UG bits (in the TIMx_EGR register) are actual control bits and can be changed only by software (except for UG that remains cleared automatically). As soon as the CEN bit is written to 1, the prescaler is clocked by the internal clock CK_INT.

The peripheral registers have to be written by half-words (16 bits) or words (32 bits). Read accesses can be done by bytes (8 bits), half-words (16 bits) or words (32 bits). 

Bit 2 URS: Update request sourceThis bit is set and cleared by software to select the UEV event sources.0: Any of the following events generates an update interrupt or DMA request if enabled. These events can be: –Counter overflow/underflow–Setting the UG bit–Update generation through the slave mode controller1: Only counter overflow/underflow generates an update interrupt or DMA request if enabled.

Bit 1 UDIS: Update disableThis bit is set and cleared by software to enable/disable UEV event generation.0: UEV enabled. The Update (UEV) event is generated by one of the following events:–Counter overflow/underflow–Setting the UG bit–Update generation through the slave mode controllerBuffered registers are then loaded with their preload values.1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.

Bit 0 CEN: Counter enable0: Counter disabled1: Counter enabledNote: Gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. CEN is cleared automatically in one-pulse mode, when an update event occurs.

Bits 6:4 MMS[2:0]: Master mode selectionThese bits are used to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:000: Reset - the UG bit from the TIMx_EGR register is used as a trigger output (TRGO). If reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.001: Enable - the Counter enable signal, CNT_EN, is used as a trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in the TIMx_SMCR register).010: Update - The update event is selected as a trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.Note: The clock of the slave timer and ADC must be enabled prior to receiving events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.

Bit 0 UIF: Update interrupt flagThis bit is set by hardware on an update event. It is cleared by software.0: No update occurred.1: Update interrupt pending. This bit is set by hardware when the registers are updated:– At overflow or underflow and if UDIS = 0 in the TIMx_CR1 register.– When CNT is reinitialized by software using the UG bit in the TIMx_EGR register, if URS = 0 and UDIS = 0 in the TIMx_CR1 register.

Bit 0 UG: Update generationThis bit can be set by software, it is automatically cleared by hardware.0: No action.1: Re-initializes the timer counter and generates an update of the registers. Note that the prescaler counter is cleared too (but the prescaler ratio is not affected).

Bits 15:0 PSC[15:0]: Prescaler valueThe counter clock frequency CK_CNT is equal to fCK_PSC / (PSC[15:0] + 1).PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in “reset mode”).

The real-time clock is an independent timer. The RTC provides a set of continuously running counters which can be used, with suitable software, to provide a clock-calendar function. The counter values can be written to set the current time/date of the system.

After reset, access to the Backup registers and RTC is disabled and the Backup domain (BKP) is protected against possible parasitic write access. To enable access to the Backup registers and the RTC, proceed as follows:

The RTC consists of two main units (see Figure 179). The first one (APB1 Interface) is used to interface with the APB1 bus. This unit also contains a set of 16-bit registers accessible from the APB1 bus in read or write mode (for more information refer to Section 18.4: RTC registers). The APB1 interface is clocked by the APB1 bus clock in order to interface with the APB1 bus.

The other unit (RTC Core) consists of a chain of programmable counters made of two main blocks. The first block is the RTC prescaler block, which generates the RTC time base TR_CLK that can be programmed to have a period of up to 1 second. It includes a 20-bit programmable divider (RTC Prescaler). Every TR_CLK period, the RTC generates an interrupt (Second Interrupt) if it is enabled in the RTC_CR register. The second block is a 32-bit programmable counter that can be initialized to the current system time. The system time is incremented at the TR_CLK rate and compared with a programmable date (stored in the RTC_ALR register) in order to generate an alarm interrupt, if enabled in the RTC_CR control register.

Software accesses the RTC prescaler, counter and alarm values through the APB1 interface but the associated readable registers are internally updated at each rising edge of the RTC clock resynchronized by the RTC APB1 clock. This is also true for the RTC flags.

This means that the first read to the RTC APB1 registers may be corrupted (generally read as 0) if the APB1 interface has previously been disabled and the read occurs immediately after the APB1 interface is enabled but before the first internal update of the registers. This can occur if:

Consequently when reading the RTC registers, after having disabled the RTC APB1 interface, the software must first wait for the RSF bit (Register Synchronized Flag) in the RTC_CRL register to be set by hardware. 

In addition, writing to any RTC register is only enabled if the previous write operation is finished. To enable the software to detect this situation, the RTOFF status bit is provided in the RTC_CR register to indicate that an update of the registers is in progress. A new value can be written to the RTC registers only when the RTOFF status bit value is ’1’.

The RTC_Alarm and RTC Alarm flag (ALRF) (see Figure 180) are asserted on the last RTC Core clock cycle before the counter reaches the RTC Alarm value stored in the Alarm register increased by one (RTC_ALR + 1). The write operation in the RTC Alarm and RTC Second flag must be synchronized by using one of the following sequences:

Bit 5 RTOFF: RTC operation OFFWith this bit the RTC reports the status of the last write operation performed on its registers, indicating if it has been completed or not. If its value is ‘0’ then it is not possible to write to any of the RTC registers. This bit is read only.0: Last write operation on RTC registers is still ongoing.1: Last write operation on RTC registers terminated.

Bit 4 CNF: Configuration flagThis bit must be set by software to enter in configuration mode so as to allow new values to be written in the RTC_CNT, RTC_ALR or RTC_PRL registers. The write operation is only executed when the CNF bit is reset by software after has been set.0: Exit configuration mode (start update of RTC registers).1: Enter configuration mode.

Bit 3 RSF: Registers synchronized flagThis bit is set by hardware at each time the RTC_CNT and RTC_DIV registers are updated and cleared by software. Before any read operation after an APB1 reset or an APB1 clock stop, this bit must be cleared by software, and the user application must wait until it is set to be sure that the RTC_CNT, RTC_ALR or RTC_PRL registers are synchronized.0: Registers not yet synchronized.1: Registers synchronized.

Bit 2 OWF: Overflow flagThis bit is set by hardware when the 32-bit programmable counter overflows. An interrupt is generated if OWIE=1 in the RTC_CRH register. It can be cleared only by software. Writing ‘1’ has no effect.0: Overflow not detected1: 32-bit programmable counter overflow occurred.

Bit 1 ALRF: Alarm flagThis bit is set by hardware when the 32-bit programmable counter reaches the threshold set in the RTC_ALR register. An interrupt is generated if ALRIE=1 in the RTC_CRH register. It can be cleared only by software. Writing ‘1’ has no effect.0: Alarm not detected1: Alarm detected

Bit 0 SECF: Second flagThis bit is set by hardware when the 32-bit programmable prescaler overflows, thus incrementing the RTC counter. Hence this flag provides a periodic signal with a period corresponding to the resolution programmed for the RTC counter (usually one second). An interrupt is generated if SECIE=1 in the RTC_CRH register. It can be cleared only by software. Writing ‘1’ has no effect. 0: Second flag condition not met.1: Second flag condition met.

If ALRF = 1 and ALRIE = 1, the RTC global interrupt is enabled. If EXTI Line 17 is also enabled through the EXTI Controller, both the RTC global interrupt and the RTC Alarm interrupt are enabled.

If ALRF = 1, the RTC Alarm interrupt is enabled if EXTI Line 17 is enabled through the EXTI Controller in interrupt mode. When the EXTI Line 17 is enabled in event mode, a pulse is generated on this line (no RTC Alarm interrupt generation).

The Prescaler Load registers keep the period counting value of the RTC prescaler. They are write-protected by the RTOFF bit in the RTC_CR register, and a write operation is allowed if the RTOFF value is ‘1’.

During each period of TR_CLK, the counter inside the RTC prescaler is reloaded with the value stored in the RTC_PRL register. To get an accurate time measurement it is possible to read the current value of the prescaler counter, stored in the RTC_DIV register, without stopping it. This register is read-only and it is reloaded by hardware after any change in the RTC_PRL or RTC_CNT registers.

The RTC core has one 32-bit programmable counter, accessed through two 16-bit registers; the count rate is based on the TR_CLK time reference, generated by the prescaler. RTC_CNT registers keep the counting value of this counter. They are write-protected by bit RTOFF in the RTC_CR register, and a write operation is allowed if the RTOFF value is ‘1’. A write operation on the upper (RTC_CNTH) or lower (RTC_CNTL) registers directly loads the corresponding programmable counter and reloads the RTC Prescaler. When reading, the current value in the counter (system date) is returned. 

When the programmable counter reaches the 32-bit value stored in the RTC_ALR register, an alarm is triggered and the RTC_alarmIT interrupt request is generated. This register is write-protected by the RTOFF bit in the RTC_CR register, and a write operation is allowed if the RTOFF value is ‘1’.

The devices have two embedded watchdog peripherals which offer a combination of high safety level, timing accuracy and flexibility of use. Both watchdog peripherals (Independent and Window) serve to detect and resolve malfunctions due to software failure, and to trigger system reset or an interrupt (window watchdog only) when the counter reaches a given timeout value.

The independent watchdog (IWDG) is clocked by its own dedicated low-speed clock (LSI) and thus stays active even if the main clock fails. The window watchdog (WWDG) clock is prescaled from the APB1 clock and has a configurable time-window that can be programmed to detect abnormally late or early application behavior.

The IWDG is best suited to applications which require the watchdog to run as a totally independent process outside the main application, but have lower timing accuracy constraints. The WWDG is best suited to applications which require the watchdog to react within an accurate timing window. For further information on the window watchdog, refer to Section 20 on page 500.

When the independent watchdog is started by writing the value 0xCCCC in the Key register (IWDG_KR), the counter starts counting down from the reset value of 0xFFF. When it reaches the end of count value (0x000) a reset signal is generated (IWDG reset).

If the “Hardware watchdog” feature is enabled through the device option bits, the watchdog is automatically enabled at power-on, and will generate a reset unless the Key register is written by the software before the counter reaches end of count.

Write access to the IWDG_PR and IWDG_RLR registers is protected. To modify them, first write the code 0x5555 in the IWDG_KR register. A write access to this register with a different value will break the sequence and register access will be protected again. This implies that it is the case of the reload operation (writing 0xAAAA).

Note:If several reload values or prescaler values are used by application, it is mandatory to wait until RVU bit is reset before changing the reload value and to wait until PVU bit is reset before changing the prescaler value. However, after updating the prescaler and/or the reload value it is not necessary to wait until RVU or PVU is reset before continuing code execution (even in case of low-power mode entry, the write operation is taken into account and will complete)

Bit 1 RVU: Watchdog counter reload value update This bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 kHz cycles).Reload value can be updated only when RVU bit is reset.

Bit 0 PVU: Watchdog prescaler value updateThis bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the VDD voltage domain (takes up to 5 RC 40 kHz cycles).Prescaler value can be updated only when PVU bit is reset.

The window watchdog is used to detect the occurrence of a software fault, usually generated by external interference or by unforeseen logical conditions, which causes the application program to abandon its normal sequence. The watchdog circuit generates an MCU reset on expiry of a programmed time period, unless the program refreshes the contents of the downcounter before the T6 bit becomes cleared. An MCU reset is also generated if the 7-bit downcounter value (in the control register) is refreshed before the downcounter has reached the window register value. This implies that the counter must be refreshed in a limited window.

If the watchdog is activated (the WDGA bit is set in the WWDG_CR register) and when the 7-bit downcounter (T[6:0] bits) rolls over from 0x40 to 0x3F (T6 becomes cleared), it initiates a reset. If the software reloads the counter while the counter is greater than the value stored in the window register, then a reset is generated.

The application program must write in the WWDG_CR register at regular intervals during normal operation to prevent an MCU reset. This operation must occur only when the counter value is lower than the window register value. The value to be stored in the WWDG_CR register must be between 0xFF and 0xC0.

The T[5:0] bits contain the number of increments which represents the time delay before the watchdog produces a reset. The timing varies between a minimum and a maximum value due to the unknown status of the prescaler when writing to the WWDG_CR register (see Figure 184). The Configuration register (WWDG_CFR) contains the high limit of the window: To prevent a reset, the downcounter must be reloaded when its value is lower than the window register value and greater than 0x3F. Figure 184 describes the window watchdog process.

The Early Wakeup Interrupt (EWI) can be used if specific safety operations or data logging must be performed before the actual reset is generated. The EWI interrupt is enabled by setting the EWI bit in the WWDG_CFR register. When the downcounter reaches the value 0x40, an EWI interrupt is generated and the corresponding interrupt service routine (ISR) can be used to trigger specific actions (such as communications or data logging), before resetting the device. 

In some applications, the EWI interrupt can be used to manage a software system check and/or system recovery/graceful degradation, without generating a WWDG reset. In this case, the corresponding interrupt service routine (ISR) should reload the WWDG counter to avoid the WWDG reset, then trigger the required actions. 

Bit 7 WDGA: Activation bit This bit is set by software and only cleared by hardware after a reset. When WDGA = 1, the watchdog can generate a reset.0: Watchdog disabled1: Watchdog enabled

Bits 6:0 T[6:0]: 7-bit counter (MSB to LSB)These bits contain the value of the watchdog counter. It is decremented every (4096 x 2WDGTB[1:0]) PCLK1 cycles. A reset is produced when it rolls over from 0x40 to 0x3F (T6 becomes cleared).

Bits 8:7 WDGTB[1:0]: Timer baseThe time base of the prescaler can be modified as follows:00: CK Counter Clock (PCLK1 div 4096) div 101: CK Counter Clock (PCLK1 div 4096) div 210: CK Counter Clock (PCLK1 div 4096) div 411: CK Counter Clock (PCLK1 div 4096) div 8

Bit 0 EWIF: Early wakeup interrupt flagThis bit is set by hardware when the counter has reached the value 0x40. It must be cleared by software by writing ‘0’. A write of ‘1’ has no effect. This bit is also set if the interrupt is not enabled. 

All external memories share the addresses, data and control signals with the controller. Each external device is accessed by means of a unique chip select. The FSMC performs only one access at a time to an external device.


• A Write FIFO, 2-word long , each word is 32 bits wide, only stores data and not the address. Therefore, this FIFO only buffers AHB write burst transactions. This makes it possible to write to slow memories and free the AHB quickly for other operations. Only one burst at a time is buffered: if a new AHB burst or single transaction occurs while an operation is in progress, the FIFO is drained. The FSMC will insert wait states until the current memory access is complete.

The FSMC registers that define the external device type and associated characteristics are usually set at boot time and do not change until the next reset or power-up. However, it is possible to change the settings at any time.

AHB transactions are translated into the external device protocol. In particular, if the selected external memory is 16 or 8 bits wide, 32-bit wide transactions on the AHB are split into consecutive 16- or 8-bit accesses. The Chip Select is kept low or toggles between the consecutive accesses when performing 32-bit aligned or 32-bit unaligned accesses respectively.

–Asynchronous accesses to devices that do not have the byte select feature (NOR and NAND Flash 16-bit).This situation occurs when a byte access is requested to a 16-bit wide Flash memory. Clearly, the device cannot be accessed in byte mode (only 16-bit words can be read from/written to the Flash memory) therefore:

HADDR[25:0] contain the external memory address. Since HADDR is a byte address whereas the memory is addressed in words, the address actually issued to the memory varies according to the memory data width, as shown in the following table.


• To specify the NAND Flash address that must be read or written: the software must write the address value to any memory location in the address section. Since an address can be 4 or 5 bytes long (depending on the actual memory size), several consecutive writes to the address section are needed to specify the full address.

For synchronous accesses, the FSMC issues the clock (CLK) to the selected external device only during the read/write transactions. This clock is a submultiple of the HCLK clock. The size of each bank is fixed and equal to 64 Mbytes.

Table 108 below displays an example of the supported devices, access modes and transactions when the memory data bus is 16-bit for NOR, PSRAM and SRAM. Transactions not allowed (or not supported) by the FSMC in this example appear in gray.


• The FSMC always samples the data before de-asserting the NOE signals. This guarantees that the memory data-hold timing constraint is met (chip enable high to data transition, usually 0 ns min.)


• If the extended mode is enabled (EXTMOD bit is set in the FSMC_BCRx register), up to four extended modes (A, B, C and D) are available. It is possible to mix A, B, C and D modes for read and write operations. For example, read operation can be performed in mode A and write in mode B.

The one HCLK cycle at the end of the write transaction helps guarantee the address and data hold time after the NWE rising edge. Due to the presence of this one HCLK cycle, the DATAST value must be greater than zero (DATAST > 0).

If the asynchronous memory asserts a WAIT signal to indicate that it is not yet ready to accept or to provide data, the ASYNCWAIT bit has to be set in FSMC_BCRx register.

If the WAIT signal is active (high or low depending on the WAITPOL bit), the second access phase (Data setup phase) programmed by the DATAST bits, is extended until WAIT becomes inactive. Unlike the data setup phase, the first access phases (Address setup and Address hold phases), programmed by the ADDSET[3:0] and ADDHLD bits, are not WAIT sensitive and so they are not prolonged.

Figure 200 and Figure 201 show the number of HCLK clock cycles that are added to the memory access after WAIT is released by the asynchronous memory (independently of the above cases).

NOR Flash memories specify a minimum time from NADV assertion to CLK high. To meet this constraint, the FSMC does not issue the clock to the memory during the first internal clock cycle of the synchronous access (before NADV assertion). This guarantees that the rising edge of the memory clock occurs in the middle of the NADV low pulse.

The data latency is the number of cycles to wait before sampling the data. The DATLAT value must be consistent with the latency value specified in the NOR Flash configuration register. The FSMC does not include the clock cycle when NADV is low in the data latency count.

Caution:Some NOR Flash memories include the NADV Low cycle in the data latency count, so the exact relation between the NOR Flash latency and the FMSC DATLAT parameter can be either of:

Some recent memories assert NWAIT during the latency phase. In such cases DATLAT can be set to its minimum value. As a result, the FSMC samples the data and waits long enough to evaluate if the data are valid. Thus the FSMC detects when the memory exits latency and real data are taken.

Other memories do not assert NWAIT during latency. In this case the latency must be set correctly for both the FSMC and the memory, otherwise invalid data are mistaken for good data, or valid data are lost in the initial phase of the memory access.

When the selected bank is configured in burst mode for synchronous accesses, if for example an AHB single-burst transaction is requested on 16-bit memories, the FSMC performs a burst transaction of length 1 (if the AHB transfer is 16-bit), or length 2 (if the AHB transfer is 32-bit) and de-assert the chip select signal when the last data is strobed.

Clearly, such a transfer is not the most efficient in terms of cycles (compared to an asynchronous read). Nevertheless, a random asynchronous access would first require to re-program the memory access mode, which would altogether last longer.

Cellular RAM 1.5 does not allow burst access to cross the page boundary. The FSMC controller allows to split automatically the burst access when the memory page size is reached by configuring the CPSIZE bits in the FSMC_BCR1 register following the memory page size.

If NWAIT is sensed active (low level when WAITPOL = 0, high level when WAITPOL = 1), wait states are inserted until NWAIT is sensed inactive (high level when WAITPOL = 0, low level when WAITPOL = 1).

During wait-state insertion via the NWAIT signal, the controller continues to send clock pulses to the memory, keeping the chip select and output enable signals valid, and does not consider the data valid.

Bit 19 CBURSTRW: Write burst enable.For Cellular RAM (PSRAM) memories, this bit enables the synchronous burst protocol during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FSMC_BCRx register.0: Write operations are always performed in asynchronous mode1: Write operations are performed in synchronous mode.

Bits 18: 16 CPSIZE[2:0]: CRAM page size.These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FSMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size).000: No burst split when crossing page boundary (default after reset)001: 128 bytes010: 256 bytes011: 512 bytes100: 1024 bytesOthers: reserved.

Bit 15 ASYNCWAIT: Wait signal during asynchronous transfersThis bit enables/disables the FSMC to use the wait signal even during an asynchronous protocol.0: NWAIT signal is not taken into account when running an asynchronous protocol (default after reset)1: NWAIT signal is taken into account when running an asynchronous protocol

Bit 14 EXTMOD: Extended mode enable.This bit enables the FSMC to program the write timings for non-multiplexed asynchronous accesses inside the FSMC_BWTR register, thus resulting in different timings for read and write operations.0: values inside FSMC_BWTR register are not taken into account (default after reset)1: values inside FSMC_BWTR register are taken into accountNote: When the extended mode is disabled, the FSMC can operate in Mode1 or Mode2 as follows:–Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP [0:1]=0x0 or 0x01)–Mode 2 is the default mode when the NOR memory type is selected (MTYP [0:1]= 0x10).

Bit 13 WAITEN: Wait enable bit.This bit enables/disables wait-state insertion via the NWAIT signal when accessing the Flash memory in synchronous mode.0: NWAIT signal is disabled (its level not taken into account, no wait state inserted after the programmed Flash latency period)1: NWAIT signal is enabled (its level is taken into account after the programmed Flash latency period to insert wait states if asserted) (default after reset)

Bit 12 WREN: Write enable bit.This bit indicates whether write operations are enabled/disabled in the bank by the FSMC:0: Write operations are disabled in the bank by the FSMC, an AHB error is reported,1: Write operations are enabled for the bank by the FSMC (default after reset).

Bit 11 WAITCFG: Wait timing configuration.The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the Flash memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:0: NWAIT signal is active one data cycle before wait state (default after reset),1: NWAIT signal is active during wait state (not used for PRAM).

Bit 10 WRAPMOD: Wrapped burst mode support.Defines whether the controller will or not split an AHB burst wrap access into two linear accesses. Valid only when accessing memories in burst mode0: Direct wrapped burst is not enabled (default after reset),1: Direct wrapped burst is enabled.Note: This bit has no effect as the CPU and DMA cannot generate wrapping burst transfers.

Bit 9 WAITPOL: Wait signal polarity bit.Defines the polarity of the wait signal from memory. Valid only when accessing the memory in burst mode:0: NWAIT active low (default after reset),1: NWAIT active high.

Bit 8 BURSTEN: Burst enable bit.This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in burst mode:0: Burst mode disabled (default after reset). Read accesses are performed in asynchronous mode. 1: Burst mode enable. Read accesses are performed in synchronous mode. 

Bits 5:4 MWID[1:0]: Memory databus width.Defines the external memory device width, valid for all type of memories.00: 8 bits,01: 16 bits (default after reset),10: reserved, do not use,11: reserved, do not use.

Bit 1 MUXEN: Address/data multiplexing enable bit.When this bit is set, the address and data values are multiplexed on the databus, valid only with NOR and PSRAM memories:0: Address/Data nonmultiplexed1: Address/Data multiplexed on databus (default after reset)

Bit 0 MBKEN: Memory bank enable bit.Enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AHB bus.0: Corresponding memory bank is disabled1: Corresponding memory bank is enabled

FSMC_BTRx bits are written by software to add a delay at the end of a read /write transaction. This delay allows matching the minimum time between consecutive transactions (tEHEL from NEx high to FSMC_NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ).

This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FSMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FSMC_BWTRx registers).

Bits 29:28 ACCMOD[1:0]: Access modeSpecifies the asynchronous access modes as shown in the timing diagrams. These bits are taken into account only when the EXTMOD bit in the FSMC_BCRx register is 1.00: access mode A01: access mode B10: access mode C11: access mode D

Bits 27:24 DATLAT[3:0]: Data latency for synchronous NOR Flash memory (see note below bit description table)For synchronous NOR Flash memory with burst mode enabled, defines the number of memory clock cycles (+2) to issue to the memory before reading/writing the first data. This timing parameter is not expressed in HCLK periods, but in FSMC_CLK periods. In case of PSRAM (CRAM), this field must be set to 0. In asynchronous NOR Flash or SRAM or PSRAM , this value is don't care.0000: Data latency of 2 CLK clock cycles for first burst access1111: Data latency of 17 CLK clock cycles for first burst access (default value after reset)

Bits 23:20 CLKDIV[3:0]: Clock divide ratio (for FSMC_CLK signal)Defines the period of FSMC_CLK clock output signal, expressed in number of HCLK cycles:0000: Reserved0001: FSMC_CLK period = 2 × HCLK periods0010: FSMC_CLK period = 3 × HCLK periods1111: FSMC_CLK period = 16 × HCLK periods (default value after reset) In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is don’t care.

Note:PSRAMs (CRAMs) have a variable latency due to internal refresh. Therefore these memories issue the NWAIT signal during the whole latency phase to prolong the latency as needed.With PSRAMs (CRAMs) the DATLAT field must be set to 0, so that the FSMC exits its latency phase soon and starts sampling NWAIT from memory, then starts to read or write when the memory is ready.This method can be used also with the latest generation of synchronous Flash memories that issue the NWAIT signal, unlike older Flash memories (check the datasheet of the specific Flash memory being used).

This register contains the control information of each memory bank, used for SRAMs, PSRAMs and NOR Flash memories. This register is active for write asynchronous access only when the EXTMOD bit is set in the FSMC_BCRx register.

Bits 29:28 ACCMOD[2:0]: Access mode.Specifies the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FSMC_BCRx register is 1.00: access mode A01: access mode B10: access mode C11: access mode D

Caution:When using a PC Card or a CompactFlash in I/O mode, the NIOS16 input pin must remain at ground level during the whole operation, otherwise the FSMC may not operate properly. This means that the NIOS16 input pin must not be connected to the card, but directly to ground (only 16-bit accesses are allowed).

CDIPC Card presence detection. Active high. If an access is performed to the PC Card banks while CD is low, an AHB error is generated. Refer to Section 21.3: AHB interface

Each timing configuration register contains three parameters used to define number of HCLK cycles for the three phases of any PC Card/CompactFlash or NAND Flash access, plus one parameter that defines the timing for starting driving the databus in the case of a write. Figure 205 shows the timing parameter definitions for common memory accesses, knowing that Attribute and I/O (only for PC Card) memory space access timings are similar.

The command latch enable (CLE) and address latch enable (ALE) signals of the NAND Flash device are driven by some address signals of the FSMC controller. This means that to send a command or an address to the NAND Flash memory, the CPU has to perform a write to a certain address in its memory space.

When this functionality is needed, it can be guaranteed by programming the MEMHOLD value to meet the tWB timing. However CPU read accesses to the NAND Flash memory has a hold delay of (MEMHOLD + 2) x HCLK cycles, while CPU write accesses have a hold delay of (MEMHOLD) x HCLK cycles. 

To overcome this timing constraint, the attribute memory space can be used by programming its timing register with an ATTHOLD value that meets the tWB timing, and leaving the MEMHOLD value at its minimum. Then, the CPU must use the common memory space for all NAND Flash read and write accesses, except when writing the last address byte to the NAND Flash device, where the CPU must write to the attribute memory space.

The FSMC PC-Card controller includes two error correction code computation hardware blocks, one per memory bank. They are used to reduce the host CPU workload when processing the error correction code by software in the system.

The error correction code (ECC) algorithm implemented in the FSMC can perform 1-bit error correction and 2-bit error detection per 256, 512, 1 024, 2 048, 4 096 or 8 192 bytes read from or written to NAND Flash memory. It is based on the Hamming coding algorithm and consists in calculating the row and column parity.


• When access to NAND Flash occurs at any other address, the ECC logic is idle, and does not perform any operation. Thus, write operations for defining commands or addresses to NAND Flash are not taken into account for ECC computation.

Once the desired number of bytes has been read from/written to the NAND Flash by the host CPU, the FSMC_ECCR2/3 registers must be read in order to retrieve the computed value. Once read, they should be cleared by resetting the ECCEN bit to zero. To compute a new data block, the ECCEN bit must be set to one in the FSMC_PCR2/3 registers.

The nCE2 and nCE1 pins (FSMC_NCE4_2 and FSMC_NCE4_1 respectively) select the card and indicate whether a byte or a word operation is being performed: nCE2 accesses the odd byte on D15-8 and nCE1 accesses the even byte on D7-0 if A0=0 or the odd byte on D7-0 if A0=1. The full word is accessed on D15-0 if both nCE2 and nCE1 are low.

The I/O Space is selected by asserting low nIORD for read accesses or nIOWR for write accesses [instead of nOE/nWE for memory Space], combined with nCE2/nCE1. Note that nREG must also be asserted low during accesses to I/O Space.

Note that 8-bit accesses at odd addresses are not supported and will not lead to the low assertion of nCE2. A 32-bit AHB request is translated into two 16-bit memory accesses.

 Note that a 16-bit AHB access will be converted into a single 8-bit memory transfer: nCE1 will be asserted low, nCE2 will be asserted high and only the even Byte on D7-D0 will be valid. Instead a 32-bit AHB access will be converted into two 8-bit memory 

This register contains information about FIFO status and interrupt. The FSMC has a FIFO that is used when writing to memories to store up to16 words of data from the AHB.This is used to quickly write to the AHB and free it for transactions to peripherals other than the FSMC, while the FSMC is draining its FIFO into the memory. This register has one of its bits that indicates the status of the FIFO, for ECC purposes.The ECC is calculated while the data are written to the memory, so in order to read the correct ECC the software must wait until the FIFO is empty.

Bits 5:4 PWID[1:0]: Databus width.Defines the external memory device width.00: 8 bits01: 16 bits (default after reset). This value is mandatory for PC Cards.10: reserved, do not use11: reserved, do not use

Bit 2 PBKEN: PC Card/NAND Flash memory bank enable bit.Enables the memory bank. Accessing a disabled memory bank causes an ERROR on AHB bus 0: Corresponding memory bank is disabled (default after reset)1: Corresponding memory bank is enabled

Bit 1 PWAITEN: Wait feature enable bit.Enables the Wait feature for the PC Card/NAND Flash memory bank:0: disabled1: enabledNote: For a PC Card, when the wait feature is enabled, the MEMWAITx/ATTWAITx/IOWAITx bits must be programmed to a value as follows:xxWAITx ≥ 4 + max_wait_assertion_time/HCLKWhere max_wait_assertion_time is the maximum time taken by NWAIT to go low once nOE/nWE or nIORD/nIOWR is low.

Bits 31:24 MEMHIZx[7:0]: Common memory x databus HiZ timeDefines the number of HCLK (+1 only for NAND) clock cycles during which the databus is kept in HiZ after the start of a PC Card/NAND Flash write access to common memory space on socket x. Only valid for write transaction:

Bits 23:16 MEMHOLDx[7:0]: Common memory x hold timeFor NAND Flash read accesses to the common memory space, these bits define the number of (HCLK+2) clock cycles during which the address is held after the command is deasserted (NWE, NOE).For NAND Flash write accesses to the common memory space, these bits define the number of HCLK clock cycles during which the data are held after the command is deasserted (NWE, NOE).0000 0000: Reserved0000 0001: 1 HCLK cycle for write accesses, 3 HCLK cycles for read accesses1111 1110: 254 HCLK cycle for write accesses, 256 HCLK cycles for read accesses1111 1111: Reserved

Bits 15:8 MEMWAITx[7:0]: Common memory x wait timeDefines the minimum number of HCLK (+1) clock cycles to assert the command (NWE, NOE), for PC Card/NAND Flash read or write access to common memory space on socket x. The duration for command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of HCLK:0000 0000: Reserved0000 0001: 2 HCLK cycles (+ wait cycle introduced by deasserting NWAIT)1111 1110: 255 HCLK cycles (+ wait cycle introduced by deasserting NWAIT)1111 1111: Reserved.

Bits 7:0 MEMSETx[7:0]: Common memory x setup timeDefines the number of HCLK (+1 for PC Card, +2 for NAND) clock cycles to set up the address before the command assertion (NWE, NOE), for PC Card/NAND Flash read or write access to common memory space on socket x:0000 0000: 1 HCLK cycle1111 1110: 255 HCLK cycles1111 1111: Reserved 

Bits 31:24 ATTHIZ[7:0]: Attribute memory x databus HiZ timeDefines the number of HCLK clock cycles during which the databus is kept in HiZ after the start of a PC CARD/NAND Flash write access to attribute memory space on socket x. Only valid for write transaction:0000 0000: 0 HCLK cycle1111 1110: 255 HCLK cycles1111 1111: Reserved.

Bits 23:16 ATTHOLD[7:0]: Attribute memory x hold timeFor PC Card/NAND Flash read accesses to attribute memory space on socket x, these bits define the number of HCLK clock cycles (HCLK +2) clock cycles during which the address is held after the command is deasserted (NWE, NOE).For PC Card/NAND Flash write accesses to attribute memory space on socket x, these bits define the number of HCLK clock cycles during which the data are held after the command is deasserted (NWE, NOE).0000 0000: reserved0000 0001: 1 HCLK cycle for write access, 3 HCLK cycles for read accesses1111 1110: 254 HCLK cycle for write access, 256 HCLK cycles for read accesses1111 1111: Reserved

Bits 15:8 ATTWAIT[7:0]: Attribute memory x wait timeDefines the minimum number of HCLK (+1) clock cycles to assert the command (NWE, NOE), for PC Card/NAND Flash read or write access to attribute memory space on socket x. The duration for command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of HCLK:0000 0000: Reserved0000 0001: 2 HCLK cycles (+ wait cycle introduced by deassertion of NWAIT)1111 1111: 255 HCLK cycles (+ wait cycle introduced by deasserting NWAIT)1111 1111: Reserved.

Bits 7:0 ATTSET[7:0]: Attribute memory x setup timeDefines the number of HCLK (+1) clock cycles to set up address before the command assertion (NWE, NOE), for PC CARD/NAND Flash read or write access to attribute memory space on socket x:0000 0000: 1 HCLK cycle1111 1110: 255 HCLK cycles1111 1111: Reserved. 

Bits 31:24 IOHIZ[7:0]: I/O x databus HiZ timeDefines the number of HCLK clock cycles during which the databus is kept in HiZ after the start of a PC Card write access to I/O space on socket x. Only valid for write transaction:0000 0000: 0 HCLK cycle1111 1111: 255 HCLK cycles (default value after reset)

Bits 23:16 IOHOLD[7:0]: I/O x hold timeDefines the number of HCLK clock cycles to hold address (and data for write access) after the command deassertion (NWE, NOE), for PC Card read or write access to I/O space on socket x:0000 0000: reserved0000 0001: 1 HCLK cycle1111 1111: 255 HCLK cycles (default value after reset)

Bits 15:8 IOWAIT[7:0]: I/O x wait timeDefines the minimum number of HCLK (+1) clock cycles to assert the command (SMNWE, SMNOE), for PC Card read or write access to I/O space on socket x. The duration for command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of HCLK:0000 0000: reserved, do not use this value0000 0001: 2 HCLK cycles (+ wait cycle introduced by deassertion of NWAIT)1111 1111: 256 HCLK cycles (+ wait cycle introduced by the Card deasserting NWAIT) (default value after reset)

Bits 7:0 IOSET[7:0]: I/O x setup timeDefines the number of HCLK (+1) clock cycles to set up the address before the command assertion (NWE, NOE), for PC Card read or write access to I/O space on socket x:0000 0000: 1 HCLK cycle1111 1111: 256 HCLK cycles (default value after reset)

The basic transaction on the MultiMediaCard/SD/SD I/O bus is the command/response transaction. These types of bus transaction transfer their information directly within the command or response structure. In addition, some operations have a data token.

Data transfers to/from SD/SDIO memory cards are done in data blocks. Data transfers to/from MMC are done data blocks or streams. Data transfers to/from the CE-ATA Devices are done in data blocks.

If a MultiMediaCard is connected to the bus, SDIO_D0, SDIO_D[3:0] or SDIO_D[7:0] can be used for data transfer. MMC V3.31 or previous, supports only 1 bit of data so only SDIO_D0 can be used.

If an SD or SD I/O card is connected to the bus, data transfer can be configured by the host to use SDIO_D0 or SDIO_D[3:0]. All data lines are operating in push-pull mode.

The SDIO adapter is a multimedia/secure digital memory card bus master that provides an interface to a multimedia card stack or to a secure digital memory card. It consists of five subunits:

The adapter register block contains all system registers. This block also generates the signals that clear the static flags in the multimedia card. The clear signals are generated when 1 is written into the corresponding bit location in the SDIO Clear register.


• if the power saving mode is enabled and the card bus is in the Idle state (eight clock periods after both the command and data path subunits enter the Idle phase)

–When the command register is written to and the enable bit is set, command transfer starts. When the command has been sent, the command path state machine (CPSM) sets the status flags and enters the Idle state if a response is not required. If a response is required, it waits for the response (see Figure 216). When the response is received, the received CRC code and the internally generated code are compared, and the appropriate status flags are set.

When the Wait state is entered, the command timer starts running. If the timeout is reached before the CPSM moves to the Receive state, the timeout flag is set and the Idle state is entered.

If the interrupt bit is set in the command register, the timer is disabled and the CPSM waits for an interrupt request from one of the cards. If a pending bit is set in the command register, the CPSM enters the Pend state, and waits for a CmdPend signal from the data path subunit. When CmdPend is detected, the CPSM moves to the Send state. This enables the data counter to trigger the stop command transmission.

Note:The CPSM remains in the Idle state for at least eight SDIO_CK periods to meet the NCC and NRC timing constraints. NCC is the minimum delay between two host commands, and NRC is the minimum delay between the host command and the card response.

–Command: a command is a token that starts an operation. Command are sent from the host either to a single card (addressed command) or to all connected cards (broadcast command are available for MMC V3.31 or previous). Commands are transferred serially on the CMD line. All commands have a fixed length of 48 bits. The general format for a command token for MultiMediaCards, SD-Memory cards and SDIO-Cards is shown in Table 138. CE-ATA commands are an extension of MMC commands V4.2, and so have the same format.

The command path operates in a half-duplex mode, so that commands and responses can either be sent or received. If the CPSM is not in the Send state, the SDIO_CMD output is in the Hi-Z state, as shown in Figure 217. Data on SDIO_CMD are synchronous with the rising edge of SDIO_CK. Table 138 shows the command format.

–Response: a response is a token that is sent from an addressed card (or synchronously from all connected cards for MMC V3.31 or previous), to the host as an answer to a previously received command. Responses are transferred serially on the CMD line.

The CRC generator calculates the CRC checksum for all bits before the CRC code. This includes the start bit, transmitter bit, command index, and command argument (or card status). The CRC checksum is calculated for the first 120 bits of CID or CSD for the long response format. Note that the start bit, transmitter bit and the six reserved bits are not used in the CRC calculation.

The card databus width can be programmed using the clock control register. If the 4-bit wide bus mode is enabled, data is transferred at four bits per clock cycle over all four data signals (SDIO_D[3:0]). If the 8-bit wide bus mode is enabled, data is transferred at eight bits per clock cycle over all eight data signals (SDIO_D[7:0]). If the wide bus mode is not enabled, only one bit per clock cycle is transferred over SDIO_D0.


• Send: the DPSM moves to the Wait_S state. If there is data in the transmit FIFO, the DPSM moves to the Send state, and the data path subunit starts sending data to a card.


• Receive: the DPSM moves to the Wait_R state and waits for a start bit. When it receives a start bit, the DPSM moves to the Receive state, and the data path subunit starts receiving data from a card.


• Idle: the data path is inactive, and the SDIO_D[7:0] outputs are in Hi-Z. When the data control register is written and the enable bit is set, the DPSM loads the data counter with a new value and, depending on the data direction bit, moves to either the Wait_S or the Wait_R state.


• Wait_R: if the data counter equals zero, the DPSM moves to the Idle state when the receive FIFO is empty. If the data counter is not zero, the DPSM waits for a start bit on SDIO_D. The DPSM moves to the Receive state if it receives a start bit before a timeout, and loads the data block counter. If it reaches a timeout before it detects a start bit, or a start bit error occurs, it moves to the Idle state and sets the timeout status flag.


• Receive: serial data received from a card is packed in bytes and written to the data FIFO. Depending on the transfer mode bit in the data control register, the data transfer mode can be either block or stream:

–In block mode, when the data block counter reaches zero, the DPSM waits until it receives the CRC code. If the received code matches the internally generated CRC code, the DPSM moves to the Wait_R state. If not, the CRC fail status flag is set and the DPSM moves to the Idle state.

–In stream mode, the DPSM receives data while the data counter is not zero. When the counter is zero, the remaining data in the shift register is written to the data FIFO, and the DPSM moves to the Wait_R state.


• Wait_S: the DPSM moves to the Idle state if the data counter is zero. If not, it waits until the data FIFO empty flag is deasserted, and moves to the Send state.

Note:The DPSM remains in the Wait_S state for at least two clock periods to meet the NWR timing requirements, where NWR is the number of clock cycles between the reception of the card response and the start of the data transfer from the host.

–When receiving data, the timeout occurs if the end of the data is not true, and if the DPSM stays in the Wait_R state for longer than the programmed timeout period.


• Data: data can be transferred from the card to the host or vice versa. Data is transferred via the data lines. They are stored in a FIFO of 32 words, each word is 32 bits wide.

The FIFO contains a 32-bit wide, 32-word deep data buffer, and transmit and receive logic. Because the data FIFO operates in the AHB clock domain (HCLK/2), all signals from the subunits in the SDIO clock domain (SDIOCLK) are resynchronized.

Depending on the TXACT and RXACT flags, the FIFO can be disabled, transmit enabled, or receive enabled. TXACT and RXACT are driven by the data path subunit and are mutually exclusive:

The transmit FIFO is accessible via 32 sequential addresses. The transmit FIFO contains a data output register that holds the data word pointed to by the read pointer. When the data path subunit has loaded its shift register, it increments the read pointer and drives new data out.

When the data path subunit receives a word of data, it drives the data on the write databus. The write pointer is incremented after the write operation completes. On the read side, the contents of the FIFO word pointed to by the current value of the read pointer is driven onto the read databus. If the receive FIFO is disabled, all status flags are deasserted, and the read and write pointers are reset. The data path subunit asserts RXACT when it receives data. Table 144 lists the receive FIFO status flags. The receive FIFO is accessible via 32 sequential addresses.

The interrupt logic generates an interrupt request signal that is asserted when at least one of the selected status flags is high. A mask register is provided to allow selection of the conditions that will generate an interrupt. A status flag generates the interrupt request if a corresponding mask flag is set.

In the example shown, the transfer is from the SDIO host controller to an MMC (512 bytes using CMD24 (WRITE_BLOCK). The SDIO FIFO is filled by data stored in a memory using the DMA controller.

c) Program the SDIO command register: CmdIndex with 24 (WRITE_BLOCK); WaitResp with ‘1’ (SDIO card host waits for a response); CPSMEN with ‘1’ (SDIO card host enabled to send a command). Other fields are at their reset value.

d) Wait for SDIO_STA[6] = CMDREND interrupt, then program the SDIO data control register: DTEN with ‘1’ (SDIO card host enabled to send data); DTDIR with ‘0’ (from controller to card); DTMODE with ‘0’ (block data transfer); DMAEN with ‘1’ (DMA enabled); DBLOCKSIZE with 0x9 (512 bytes). Other fields are don’t care.

While in card identification mode the host resets all cards, validates the operation voltage range, identifies cards and sets a relative card address (RCA) for each card on the bus. All data communications in the card identification mode use the command line (CMD) only.

The GO_IDLE_STATE command (CMD0) is the software reset command and it puts the MultiMediaCard and SD memory in the Idle state. The IO_RW_DIRECT command (CMD52) resets the SD I/O card. After power-up or CMD0, all cards output bus drivers are in the high-impedance state and the cards are initialized with a default relative card address (RCA=0x0001) and with a default driver stage register setting (lowest speed, highest driving current capability).

All cards can communicate with the SDIO card host using any operating voltage within the specification range. The supported minimum and maximum VDD values are defined in the operation conditions register (OCR) on the card.

Cards that store the card identification number (CID) and card specific data (CSD) in the payload memory are able to communicate this information only under data-transfer VDD conditions. When the SDIO card host module and the card have incompatible VDD ranges, the card is not able to complete the identification cycle and cannot send CSD data. For this purpose, the special commands, SEND_OP_COND (CMD1), SD_APP_OP_COND (ACMD41 for SD Memory), and IO_SEND_OP_COND (CMD5 for SD I/O), are designed to provide a mechanism to identify and reject cards that do not match the VDD range desired by the SDIO card host. The SDIO card host sends the required VDD voltage window as the operand of these commands. Cards that cannot perform data transfer in the specified range disconnect from the bus and go to the inactive state.

By using these commands without including the voltage range as the operand, the SDIO card host can query each card and determine the common voltage range before placing out-of-range cards in the inactive state. This query is used when the SDIO card host is able to select a common voltage range or when the user requires notification that cards are not usable.

The card identification process differs for MultiMediaCards and SD cards. For MultiMediaCard cards, the identification process starts at clock rate Fod. The SDIO_CMD line output drivers are open-drain and allow parallel card operation during this process. The registration process is accomplished as follows:

For the SD card, the identification process starts at clock rate Fod, and the SDIO_CMD line output drives are push-pull drivers instead of open-drain. The registration process is accomplished as follows:

During block write (CMD24 - 27) one or more blocks of data are transferred from the host to the card with a CRC appended to the end of each block by the host. A card supporting block write is always able to accept a block of data defined by WRITE_BL_LEN. If the CRC fails, the card indicates the failure on the SDIO_D line and the transferred data are discarded and not written, and all further transmitted blocks (in multiple block write mode) are ignored.

If the host uses partial blocks whose accumulated length is not block aligned and, block misalignment is not allowed (CSD parameter WRITE_BLK_MISALIGN is not set), the card will detect the block misalignment error before the beginning of the first misaligned block. (ADDRESS_ERROR error bit is set in the status register). The write operation will also be aborted if the host tries to write over a write-protected area. In this case, however, the card will set the WP_VIOLATION bit.

Programming of the CID and CSD registers does not require a previous block length setting. The transferred data is also CRC protected. If a part of the CSD or CID register is stored in ROM, then this unchangeable part must match the corresponding part of the receive buffer. If this match fails, then the card reports an error and does not change any register contents. Some cards may require long and unpredictable times to write a block of data. After receiving a block of data and completing the CRC check, the card begins writing and holds the SDIO_D line low if its write buffer is full and unable to accept new data from a new WRITE_BLOCK command. The host may poll the status of the card with a SEND_STATUS command (CMD13) at any time, and the card will respond with its status. The READY_FOR_DATA status bit indicates whether the card can accept new data or whether the write process is still in progress. The host may deselect the card by issuing CMD7 (to 

select a different card), which will place the card in the Disconnect state and release the SDIO_D line(s) without interrupting the write operation. When reselecting the card, it will reactivate busy indication by pulling SDIO_D to low if programming is still in progress and the write buffer is unavailable.

In Block read mode the basic unit of data transfer is a block whose maximum size is defined in the CSD (READ_BL_LEN). If READ_BL_PARTIAL is set, smaller blocks whose start and end addresses are entirely contained within one physical block (as defined by READ_BL_LEN) may also be transmitted. A CRC is appended to the end of each block, ensuring data transfer integrity. CMD17 (READ_SINGLE_BLOCK) initiates a block read and after completing the transfer, the card returns to the Transfer state.

If the card detects an error (for example, out of range, address misalignment or internal error) during a multiple block read operation (both types) it stops the data transmission and remains in the data state. The host must than abort the operation by sending the stop transmission command. The read error is reported in the response to the stop transmission command.

If the host sends a stop transmission command after the card transmits the last block of a multiple block operation with a predefined number of blocks, it is responded to as an illegal command, since the card is no longer in the data state. If the host uses partial blocks whose accumulated length is not block-aligned and block misalignment is not allowed, the card detects a block misalignment error condition at the beginning of the first misaligned block (ADDRESS_ERROR error bit is set in the status register).

WRITE_DAT_UNTIL_STOP (CMD20) starts the data transfer from the SDIO card host to the card, beginning at the specified address and continuing until the SDIO card host issues a stop command. When partial blocks are allowed (CSD parameter WRITE_BL_PARTIAL is set), the data stream can start and stop at any address within the card address space, otherwise it can only start and stop at block boundaries. Because the amount of data to be transferred is not determined in advance, a CRC cannot be used. When the end of the memory range is reached while sending data and no stop command is sent by the SD card host, any additional transferred data are discarded.

If the host attempts to use a higher frequency, the card may not be able to process the data and stop programming, set the OVERRUN error bit in the status register, and while ignoring all further data transfer, wait (in the receive data state) for a stop command. The write operation is also aborted if the host tries to write over a write-protected area. In this case, however, the card sets the WP_VIOLATION bit.

This command instructs the card to send its data, starting at a specified address, until the SDIO card host sends STOP_TRANSMISSION (CMD12). The stop command has an execution delay due to the serial command transmission and the data transfer stops after the end bit of the stop command. When the end of the memory range is reached while sending data and no stop command is sent by the SDIO card host, any subsequent data sent are considered undefined.

If the host attempts to use a higher frequency, the card is not able to sustain data transfer. If this happens, the card sets the UNDERRUN error bit in the status register, aborts the transmission and waits in the data state for a stop command.

The erasable unit of the MultiMediaCard is the erase group. The erase group is measured in write blocks, which are the basic writable units of the card. The size of the erase group is a card-specific parameter and defined in the CSD.

First the host defines the start address of the range using the ERASE_GROUP_START (CMD35) command, next it defines the last address of the range using the ERASE_GROUP_END (CMD36) command and, finally, it starts the erase process by issuing the ERASE (CMD38) command. The address field in the erase commands is an Erase Group address in byte units. The card ignores all LSBs below the Erase Group size, effectively rounding the address down to the Erase Group boundary.

If an out-of-sequence (neither of the erase commands, except SEND_STATUS) command received, the card sets the ERASE_RESET status bit in the status register, resets the erase sequence and executes the last command.

The card indicates that an erase is in progress by holding SDIO_D low. The actual erase time may be quite long, and the host may issue CMD7 to deselect the card.

Wide bus (4-bit bus width) operation mode is selected or deselected using SET_BUS_WIDTH (ACMD6). The default bus width after power-up or GO_IDLE_STATE (CMD0) is 1 bit. SET_BUS_WIDTH (ACMD6) is only valid in a transfer state, which means that the bus width can be changed only after a card is selected by SELECT/DESELECT_CARD (CMD7).

Card data can be protected against write and erase. By setting the permanent or temporary write-protect bits in the CSD, the entire card can be permanently write-protected by the manufacturer or content provider. For cards that support write protection of groups of sectors by setting the WP_GRP_ENABLE bit in the CSD, portions of the data can be protected, and the write protection can be changed by the application. The write protection is in units of WP_GRP_SIZE sectors as specified in the CSD. The SET_WRITE_PROT and CLR_WRITE_PROT commands control the protection of the addressed group. The SEND_WRITE_PROT command is similar to a single block read command. The card sends a data block containing 32 write protection bits (representing 32 write protect groups starting at the specified address) followed by 16 CRC bits. The address field in the write protect commands is a group address in byte units.

A mechanical sliding tab on the side of the card allows the user to set or clear the write protection on a card. When the sliding tab is positioned with the window open, the card is write-protected, and when the window is closed, the card contents can be changed. A matched switch on the socket side indicates to the SDIO card host module that the card is write-protected. The SDIO card host module is responsible for protecting the card. The position of the write protect switch is unknown to the internal circuitry of the card.

The password protection feature enables the SDIO card host module to lock and unlock a card with a password. The password is stored in the 128-bit PWD register and its size is set in the 8-bit PWD_LEN register. These registers are nonvolatile so that a power cycle does not erase them. Locked cards respond to and execute certain commands. This means that the SDIO card host module is allowed to reset, initialize, select, and query for status, however it is not allowed to access data on the card. When the password is set (as indicated by a nonzero value of PWD_LEN), the card is locked automatically after power-up. As with the CSD and CID register write commands, the lock/unlock commands are available in the transfer state only. In this state, the command does not include an address argument and the card must be selected before using it. The card lock/unlock commands have the structure and bus transaction types of a regular single-block write command. The transferred data block includes all of the required information for the command (the password setting mode, the PWD itself, and card lock/unlock). The command data block size is defined by the SDIO card host module before it sends the card lock/unlock command, and has the structure shown in Table 158.

The password length field (PWD_LEN) indicates whether a password is currently set. When this field is nonzero, there is a password set and the card locks itself after power-up. It is possible to lock the card immediately in the current power session by setting the LOCK_UNLOCK bit (while setting the password) or sending an additional command for card locking.

It is possible to set the password and to lock the card in the same sequence. In this case, the SDIO card host module performs all the required steps for setting the password (see Setting the password), however it is necessary to set the LOCK_UNLOCK bit in Step 3 when the new password command is sent.

When the password is previously set (PWD_LEN is not 0), the card is locked automatically after power on reset. An attempt to lock a locked card or to lock a card that does not have a password fails and the LOCK_UNLOCK_FAILED error bit is set in the card status register.

If the user has forgotten the password (PWD content), it is possible to access the card after clearing all the data on the card. This forced erase operation erases all card data and all password data.

The response format R1 contains a 32-bit field named card status. This field is intended to transmit the card status information (which may be stored in a local status register) to the host. If not specified otherwise, the status entries are always related to the previously issued command.

The command address argument was out of the allowed range for this card.A multiple block or stream read/write operation is (although started in a valid address) attempting to read or write beyond the card capacity.

The commands address argument (in accordance with the currently set block length) positions the first data block misaligned to the card physical blocks.A multiple block read/write operation (although started with a valid address/block-length combination) is attempting to read or write a data block which is not aligned with the physical blocks of the card. 

Either the argument of a SET_BLOCKLEN command exceeds the maximum value allowed for the card, or the previously defined block length is illegal for the current command (e.g. the host issues a write command, the current block length is smaller than the maximum allowed value for the card and it is not allowed to write partial blocks) 

Can be either of the following errors:– The CID register has already been written and cannot be overwritten– The read-only section of the CSD does not match the card contents– An attempt to reverse the copy (set as original) or permanent WP (unprotected) bits was made

The SD status contains status bits that are related to the SD memory card proprietary features and may be used for future application-specific usage. The size of the SD Status is one data block of 512 bits. The contents of this register are transmitted to the SDIO card host if ACMD13 is sent (CMD55 followed with CMD13). ACMD13 can be sent to a card in transfer state only (card is selected).

The state of the card when receiving the command. If the command execution causes a state change, it will be visible to the host in the response on the next command. The four bits are interpreted as a binary number between 0 and 15. 

In the future, the 8 LSBs will be used to define different variations of an SD memory card (each bit will define different SD types). The 8 MSBs will be used to define SD Cards that do not comply with current SD physical layer specification.

This 8-bit field indicates Pm (performance move) and the value can be set by 1 [MB/sec] steps. If the card does not move used RUs (recording units), Pm should be considered as infinity. Setting the field to FFh means infinity.

The maximum AU size, which depends on the card capacity, is defined in Table 150. The card can be set to any AU size between RU size and maximum AU size.

This 16-bit field indicates NERASE. When NERASE numbers of AUs are erased, the timeout value is specified by ERASE_TIMEOUT (Refer to ERASE_TIMEOUT). The host should determine the proper number of AUs to be erased in one operation so that the host can show the progress of the erase operation. If this field is set to 0, the erase timeout calculation is not supported.

To allow the SD I/O card to interrupt the MultiMediaCard/SD module, an interrupt function is available on a pin on the SD interface. Pin 8, used as SDIO_D1 when operating in the 4-bit SD mode, signals the cards interrupt to the MultiMediaCard/SD module. The use of the interrupt is optional for each card or function within a card. The SD I/O interrupt is level-sensitive, which means that the interrupt line must be held active (low) until it is either recognized and acted upon by the MultiMediaCard/SD module or deasserted due to the end of the interrupt period. After the MultiMediaCard/SD module has serviced the interrupt, the interrupt status bit is cleared via an I/O write to the appropriate bit in the SD I/O card’s internal registers. The interrupt output of all SD I/O cards is active low and the application must provide pull-up resistors externally on all data lines (SDIO_D[3:0]). The MultiMediaCard/SD module samples the level of pin 8 (SDIO_D/IRQ) into the interrupt detector only during the interrupt period. At all other times, the MultiMediaCard/SD module ignores this value.

The interrupt period is applicable for both memory and I/O operations. The definition of the interrupt period for operations with single blocks is different from the definition for multiple-block data transfers.

Within a multifunction SD I/O or a card with both I/O and memory functions, there are multiple devices (I/O and memory) that share access to the MMC/SD bus. To share access to the MMC/SD module among multiple devices, SD I/O and combo cards optionally implement the concept of suspend/resume. When a card supports suspend/resume, the MMC/SD module can temporarily halt a data transfer operation to one function or memory (suspend) to free the bus for a higher-priority transfer to a different function or memory. After this higher-priority transfer is complete, the original transfer is resumed (restarted) where it left off. Support of suspend/resume is optional on a per-card basis. To perform the suspend/resume operation on the MMC/SD bus, the MMC/SD module performs the following steps:

The optional ReadWait (RW) operation is defined only for the SD 1-bit and 4-bit modes. The ReadWait operation allows the MMC/SD module to signal a card that it is reading multiple registers (IO_RW_EXTENDED, CMD53) to temporarily stall the data transfer while allowing the MMC/SD module to send commands to any function within the SD I/O device. To determine when a card supports the ReadWait protocol, the MMC/SD module must test capability bits in the internal card registers. The timing for ReadWait is based on the interrupt period.

The SD card host module system is designed to provide a standard interface for a variety of applications types. In this environment, there is a need for specific customer/application features. To implement these features, two types of generic commands are defined in the standard: application-specific commands (ACMD) and general commands (GEN_CMD).

When the card receives the APP_CMD (CMD55) command, the card expects the next command to be an application-specific command. ACMDs have the same structure as regular MultiMediaCard commands and can have the same CMD number. The card recognizes it as ACMD because it appears after APP_CMD (CMD55). When the command immediately following the APP_CMD (CMD55) is not a defined application-specific command, the standard command is used. For example, when the card has a definition for SD_STATUS (ACMD13), and receives CMD13 immediately following APP_CMD (CMD55), this is interpreted as SD_STATUS (ACMD13). However, when the card receives CMD7 immediately following APP_CMD (CMD55) and the card does not have a definition for ACMD7, this is interpreted as the standard (SELECT/DESELECT_CARD) CMD7.

The bus transaction for a GEN_CMD is the same as the single-block read or write commands (WRITE_BLOCK, CMD24 or READ_SINGLE_BLOCK,CMD17). In this case, the argument denotes the direction of the data transfer rather than the address, and the data block has vendor-specific format and meaning.

Programming of the card identification register. This command must be issued only once per card. The card contains hardware to prevent this operation after the first programming. Normally this command is reserved for manufacturer.

Used to write and read 8-bit (register) data fields. The command addresses a card and a register and provides the data for writing if the write flag is set. The R4 response contains data read from the addressed register. This command accesses application-dependent registers that are not defined in the MultiMediaCard standard.

Used either to transfer a data block to the card or to get a data block from the card for general purpose/application-specific commands. The size of the data block shall be set by the SET_BLOCK_LEN command.

All responses are sent via the MCCMD command line SDIO_CMD. The response transmission always starts with the left bit of the bit string corresponding to the response code word. The code length depends on the response type.

A response always starts with a start bit (always 0), followed by the bit indicating the direction of transmission (card = 0). A value denoted by x in the tables below indicates a variable entry. All responses, except for the R3 response type, are protected by a CRC. Every command code word is terminated by the end bit (always 1).

Code length = 48 bits. The 45:40 bits indicate the index of the command to be responded to, this value being interpreted as a binary-coded number (between 0 and 63). The status of the card is coded in 32 bits.

It is identical to R1 with an optional busy signal transmitted on the data line. The card may become busy after receiving these commands based on its state prior to the command reception.

Code length: 48 bits. The contents of the OCR register are sent as a response to CMD1. The level coding is as follows: restricted voltage windows = low, card busy = low.

Once an SD I/O card has received a CMD5, the I/O portion of that card is enabled to respond normally to all further commands. This I/O enable of the function within the I/O card will remain set until a reset, power cycle or CMD52 with write to I/O reset is received by the card. Note that an SD memory-only card may respond to a CMD5. The proper response for a memory-only card would be Present memory = 1 and Number of I/O functions = 0. A memory-only card built to meet the SD Memory Card specification version 1.0 would detect the CMD5 as an illegal command and not respond. The I/O aware host will send CMD5. If the card responds with response R4, the host determines the card’s configuration based on the data contained within the R4 response.

It is possible to start the readwait interval before the first block is received: when the data path is enabled (SDIO_DCTRL[0] bit set), the SDIO-specific operation is enabled (SDIO_DCTRL[11] bit set), read wait starts (SDI0_DCTRL[10] =0 and SDI_DCTRL[8] =1) and data direction is from card to SDIO (SDIO_DCTRL[1] = 1), the DPSM directly moves from Idle to Readwait. In Readwait the DPSM drives SDIO_D2 to 0 after 2 SDIO_CK clock cycles. In this state, when you set the RWSTOP bit (SDIO_DCTRL[9]), the DPSM remains in Wait for two more SDIO_CK clock cycles to drive SDIO_D2 to 1 for one clock cycle (in accordance with SDIO specification). The DPSM then starts waiting again until it receives data from the card. The DPSM will not start a readwait interval while receiving a block even if read wait start is set: the readwait interval will start after the CRC is received. The 

While sending data to the card, the SDIO can suspend the write operation. the SDIO_CMD[11] bit is set and indicates to the CPSM that the current command is a suspend command. The CPSM analyzes the response and when the ACK is received from the card (suspend accepted), it acknowledges the DPSM that goes Idle after receiving the CRC token of the current block.

The write operation can be suspended by software, just by disabling the DPSM (SDIO_DCTRL[0] =0) when the ACK of the suspend command is received from the card. The DPSM enters then the Idle state.

To suspend a read: the DPSM waits in the Wait_r state as the function to be suspended sends a complete packet just before stopping the data transaction. The application continues reading RxFIFO until the FIF0 is empty, and the DPSM goes Idle automatically.

Command completion signal disable is sent 8 bit cycles after the reception of a short response if the ‘enable CMD completion’ bit, SDIO_CMD[12], is not set and the ‘not interrupt Enable’ bit, SDIO_CMD[13], is set.

The CPSM enters the Pend state, loading the command shift register with the disable sequence “00001” and, the command counter with 43. Eight cycles after, a trigger moves the CPSM to the Send state. When the command counter reaches 48, the CPSM becomes Idle as no response is awaited.

When ‘0’ is received on the CMD line, the CPSM enters the Idle state. No new command can be sent for 7 bit cycles. Then, for the last 5 cycles (out of the 7) the CMD line is driven to ‘1’ in push-pull mode.

If the command completion disable signal has not been sent and CMD61 needs to be aborted, the command state machine must be disabled. It then becomes Idle, and the CMD12 command can be sent. No command completion disable signal is sent during the operation.

The behavior is to stop SDIO_CK and freeze SDIO state machines. The data transfer is stalled while the FIFO is unable to transmit or receive data. Only state machines clocked by SDIOCLK are frozen, the AHB interface is still alive. The FIFO can thus be filled or emptied even if flow control is activated.

[1:0] PWRCTRL: Power supply control bits.These bits are used to define the current functional state of the card clock:00: Power-off: the clock to card is stopped.01: Reserved10: Reserved power-up11: Power-on: the card is clocked.

At least seven HCLK clock periods are needed between two write accesses to this register. SDIO_CK can also be stopped during the read wait interval for SD I/O cards: in this case the SDIO_CLKCR register does not control SDIO_CK.

Bit 10 BYPASS: Clock divider bypass enable bit0: Disable bypass: SDIOCLK is divided according to the CLKDIV value before driving the SDIO_CK output signal.1: Enable bypass: SDIOCLK directly drives the SDIO_CK output signal.

Bit 9 PWRSAV: Power saving configuration bitFor power saving, the SDIO_CK clock output can be disabled when the bus is idle by setting PWRSAV:0: SDIO_CK clock is always enabled1: SDIO_CK is only enabled when the bus is active

Bits 31:0 CMDARG: Command argumentCommand argument sent to a card as part of a command message. If a command contains an argument, it must be loaded into this register before writing a command to the command register.

The SDIO_CMD register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM).

Bit 9 WAITPEND: CPSM Waits for ends of data transfer (CmdPend internal signal).If this bit is set, the CPSM waits for the end of data transfer before it starts sending a command.

Bits 7:6 WAITRESP: Wait for response bitsThey are used to configure whether the CPSM is to wait for a response, and if yes, which kind of response.00: No response, expect CMDSENT flag01: Short response, expect CMDREND or CCRCFAIL flag10: No response, expect CMDSENT flag11: Long response, expect CMDREND or CCRCFAIL flag

The SDIO_RESPCMD register contains the command index field of the last command response received. If the command response transmission does not contain the command index field (long or OCR response), the RESPCMD field is unknown, although it must contain 111111b (the value of the reserved field from the response).

A counter loads the value from the SDIO_DTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_R or Busy state. If the timer reaches 0 while the DPSM is in either of these states, the timeout status flag is set.

Note:For a block data transfer, the value in the data length register must be a multiple of the block size (see SDIO_DCTRL). A data transfer must be written to the data timer register and the data length register before being written to the data control register.

Bits 7:4 DBLOCKSIZE: Data block sizeDefine the data block length when the block data transfer mode is selected:0000: (0 decimal) lock length = 20 = 1 byte0001: (1 decimal) lock length = 21 = 2 bytes0010: (2 decimal) lock length = 22 = 4 bytes0011: (3 decimal) lock length = 23 = 8 bytes0100: (4 decimal) lock length = 24 = 16 bytes0101: (5 decimal) lock length = 25 = 32 bytes0110: (6 decimal) lock length = 26 = 64 bytes0111: (7 decimal) lock length = 27 = 128 bytes1000: (8 decimal) lock length = 28 = 256 bytes1001: (9 decimal) lock length = 29 = 512 bytes1010: (10 decimal) lock length = 210 = 1024 bytes1011: (11 decimal) lock length = 211 = 2048 bytes1100: (12 decimal) lock length = 212 = 4096 bytes1101: (13 decimal) lock length = 213 = 8192 bytes1110: (14 decimal) lock length = 214 = 16384 bytes1111: (15 decimal) reserved

The SDIO_DCOUNT register loads the value from the data length register (see SDIO_DLEN) when the DPSM moves from the Idle state to the Wait_R or Wait_S state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the Idle state and the data status end flag, DATAEND, is set.

Bit 2 DTMODE: Data transfer mode selection 1: Stream or SDIO multibyte data transfer.0: Block data transfer1: Stream or SDIO multibyte data transfer on STM32F10xxx XL-density devices.Stream data transfer on STM32F10xxx high-density devices.

[0] DTEN: Data transfer enabled bitData transfer starts if 1b is written to the DTEN bit. Depending on the direction bit, DTDIR, the DPSM moves to the Wait_S, Wait_R state or Readwait if RW Start is set immediately at the beginning of the transfer. It is not necessary to clear the enable bit after the end of a data transfer but the SDIO_DCTRL must be updated to enable a new data transfer


• Dynamic flags (bits [21:11]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and deasserted as data while written to the FIFO)

Bit 23 CEATAENDIE: CE-ATA command completion signal received interrupt enableSet and cleared by software to enable/disable the interrupt generated when receiving the CE-ATA command completion signal.0: CE-ATA command completion signal received interrupt disabled1: CE-ATA command completion signal received interrupt enabled

Bit 22 SDIOITIE: SDIO mode interrupt received interrupt enableSet and cleared by software to enable/disable the interrupt generated when receiving the SDIO mode interrupt.0: SDIO Mode Interrupt Received interrupt disabled1: SDIO Mode Interrupt Received interrupt enabled

Bit 21 RXDAVLIE: Data available in Rx FIFO interrupt enableSet and cleared by software to enable/disable the interrupt generated by the presence of data available in Rx FIFO.0: Data available in Rx FIFO interrupt disabled1: Data available in Rx FIFO interrupt enabled

Bit 20 TXDAVLIE: Data available in Tx FIFO interrupt enableSet and cleared by software to enable/disable the interrupt generated by the presence of data available in Tx FIFO.0: Data available in Tx FIFO interrupt disabled1: Data available in Tx FIFO interrupt enabled

Bit 15 RXFIFOHFIE: Rx FIFO half full interrupt enableSet and cleared by software to enable/disable interrupt caused by Rx FIFO half full.0: Rx FIFO half full interrupt disabled1: Rx FIFO half full interrupt enabled

Bit 14 TXFIFOHEIE: Tx FIFO half empty interrupt enableSet and cleared by software to enable/disable interrupt caused by Tx FIFO half empty.0: Tx FIFO half empty interrupt disabled1: Tx FIFO half empty interrupt enabled

Bit 13 RXACTIE: Data receive acting interrupt enableSet and cleared by software to enable/disable interrupt caused by data being received (data receive acting).0: Data receive acting interrupt disabled1: Data receive acting interrupt enabled

Bit 12 TXACTIE: Data transmit acting interrupt enableSet and cleared by software to enable/disable interrupt caused by data being transferred (data transmit acting).0: Data transmit acting interrupt disabled1: Data transmit acting interrupt enabled

The SDIO_FIFOCNT register contains the remaining number of words to be written to or read from the FIFO. The FIFO counter loads the value from the data length register (see SDIO_DLEN) when the data transfer enable bit, DTEN, is set in the data control register (SDIO_DCTRL register) and the DPSM is at the Idle state. If the data length is not word-aligned (multiple of 4), the remaining 1 to 3 bytes are regarded as a word.

Bit 5 RXOVERRIE: Rx FIFO overrun error interrupt enableSet and cleared by software to enable/disable interrupt caused by Rx FIFO overrun error.0: Rx FIFO overrun error interrupt disabled1: Rx FIFO overrun error interrupt enabled

Bit 4 TXUNDERRIE: Tx FIFO underrun error interrupt enableSet and cleared by software to enable/disable interrupt caused by Tx FIFO underrun error.0: Tx FIFO underrun error interrupt disabled1: Tx FIFO underrun error interrupt enabled

The receive and transmit FIFOs can be read or written as 32-bit wide registers. The FIFOs contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO.

In low, medium, high and XL-density devices, the USB and CAN share a dedicated 512-byte SRAM memory for data transmission and reception, and so they cannot be used concurrently (the shared RAM is accessed through CAN and USB exclusively). The USB and CAN can be used in the same application but not at the same time.

The USB peripheral provides an USB compliant connection between the host PC and the function implemented by the microcontroller. Data transfer between the host PC and the system memory occurs through a dedicated packet buffer memory accessed directly by the USB peripheral. The size of this dedicated buffer memory must be according to the number of endpoints used and the maximum packet size. This dedicated memory is sized to 512 bytes and up to 16 mono-directional or 8 bidirectional endpoints can be used.The USB peripheral interfaces with the USB host, detecting token packets, handling data transmission/reception, and processing handshake packets as required by the USB standard. Transaction formatting is performed by the hardware, including CRC generation and checking.

Each endpoint is associated with a buffer description block indicating where the endpoint related memory area is located, how large it is or how many bytes must be transmitted. When a token for a valid function/endpoint pair is recognized by the USB peripheral, the related data transfer (if required and if the endpoint is configured) takes place. The data buffered by the USB peripheral is loaded in an internal 16 bit register and memory access to the dedicated buffer is performed. When all the data has been transferred, if needed, the proper handshake packet over the USB is generated or expected according to the direction of the transfer. 

Special support is offered to Isochronous transfers and high throughput bulk transfers, implementing a double buffer usage, which allows to always have an available buffer for the USB peripheral while the microcontroller uses the other one.

The unit can be placed in low-power mode (SUSPEND mode), by writing in the control register, whenever required. At this time, all static power dissipation is avoided, and the USB clock can be slowed down or stopped. The detection of activity at the USB inputs, while in low-power mode, wakes the device up asynchronously. A special interrupt source can be connected directly to a wakeup line to allow the system to immediately restart the normal clock generation and/or support direct clock start/stop.


• Serial Interface Engine (SIE): The functions of this block include: synchronization pattern recognition, bit-stuffing, CRC generation and checking, PID verification/generation, and handshake evaluation. It must interface with the USB transceivers and uses the virtual buffers provided by the packet buffer interface for local data storage,. This unit also generates signals according to USB peripheral events, such as Start of Frame (SOF), USB_Reset, Data errors etc. and to Endpoint related events like end of transmission or correct reception of a packet; these signals are then used to generate interrupts.


• Packet Buffer Interface: This block manages the local memory implementing a set of buffers in a flexible way, both for transmission and reception. It can choose the proper buffer according to requests coming from the SIE and locate them in the memory addresses pointed by the Endpoint registers. It increments the address after each exchanged word until the end of packet, keeping track of the number of exchanged bytes and preventing the buffer to overrun the maximum capacity.


• Endpoint-Related Registers: Each endpoint has an associated register containing the endpoint type and its current status. For mono-directional/single-buffer endpoints, a single register can be used to implement two distinct endpoints. The number of registers is 8, allowing up to 16 mono-directional/single-buffer or up to 7 double-buffer 


• Interrupt Registers: These contain the Interrupt masks and a record of the events. They can be used to inquire an interrupt reason, the interrupt status or to clear the status of a pending interrupt.


• Packet Memory: This is the local memory that physically contains the Packet Buffers. It can be used by the Packet Buffer interface, which creates the data structure and can be accessed directly by the application software. The size of the Packet Memory is 512 bytes, structured as 256 words by 16 bits.


• Arbiter: This block accepts memory requests coming from the APB1 bus and from the USB interface. It resolves the conflicts by giving priority to APB1 accesses, while always reserving half of the memory bandwidth to complete all USB transfers. This time-duplex scheme implements a virtual dual-port SRAM that allows memory access, while an USB transaction is happening. Multiword APB1 transfers of any length are also allowed by this scheme.

This part describes the main tasks required of the application software in order to obtain USB compliant behavior. The actions related to the most general USB events are taken into account and paragraphs are dedicated to the special cases of double-buffered endpoints 

Upon system and power-on reset, the first operation the application software should perform is to provide all required clock signals to the USB peripheral and subsequently de-assert its reset signal so to be able to access its registers. The whole initialization sequence is hereafter described.

After that, the analog part of the device related to the USB transceiver must be switched on using the PDWN bit in CNTR register, which requires a special handling. This bit is intended to switch on the internal voltage references that supply the port transceiver. This circuit has a defined startup time (tSTARTUP specified in the datasheet) during which the behavior of the USB transceiver is not defined. It is thus necessary to wait this time, after setting the PDWN bit in the CNTR register, before removing the reset condition on the USB part (by clearing the FRES bit in the CNTR register). Clearing the ISTR register then removes any spurious pending interrupt before any other macrocell operation is enabled.

When this event occurs, the USB peripheral is put in the same conditions it is left by the system reset after the initialization described in the previous paragraph: communication is disabled in all endpoint registers (the USB peripheral will not respond to any packet). As a response to the USB reset event, the USB function must be enabled, having as USB address 0, implementing only the default control endpoint (endpoint address is 0 too). This is accomplished by setting the Enable Function (EF) bit of the USB_DADDR register and initializing the EP0R register and its related packet buffers accordingly. During USB enumeration process, the host assigns a unique address to this device, which must be written in the ADD[6:0] bits of the USB_DADDR register, and configures any other necessary endpoint.

When a RESET interrupt is received, the application software is responsible to enable again the default endpoint of USB function 0 within 10mS from the end of reset sequence which triggered the interrupt.

Each bidirectional endpoint may receive or transmit data from/to the host. The received data is stored in a dedicated memory buffer reserved for that endpoint, while another memory buffer contains the data to be transmitted by the endpoint. Access to this memory is performed by the packet buffer interface block, which delivers a memory access request and waits for its acknowledgement. Since the packet buffer memory has to be accessed by the microcontroller also, an arbitration logic takes care of the access conflicts, using half 

APB1 cycle for microcontroller access and the remaining half for the USB peripheral access. In this way, both the agents can operate as if the packet memory is a dual-port SRAM, without being aware of any conflict even when the microcontroller is performing back-to-back accesses. The USB peripheral logic uses a dedicated clock. The frequency of this dedicated clock is fixed by the requirements of the USB standard at 48 MHz, and this can be different from the clock used for the interface to the APB1 bus. Different clock configurations are possible where the APB1 clock frequency can be higher or lower than the USB peripheral one.

Each packet buffer is used either during reception or transmission starting from the bottom. The USB peripheral will never change the contents of memory locations adjacent to the allocated memory buffers; if a packet bigger than the allocated buffer length is received (buffer overrun condition) the data will be copied to the memory only up to the last available location.

The first step to initialize an endpoint is to write appropriate values to the ADDRn_TX/ADDRn_RX registers so that the USB peripheral finds the data to be transmitted already available and the data to be received can be buffered. The EP_TYPE bits in the USB_EPnR register must be set according to the endpoint type, eventually using the EP_KIND bit to enable any special required feature. On the transmit side, the endpoint must be enabled using the STAT_TX bits in the USB_EPnR register and COUNTn_TX must be initialized. For reception, STAT_RX bits must be set to enable reception and COUNTn_RX must be written with the allocated buffer size using the BL_SIZE and NUM_BLOCK fields. Unidirectional endpoints, except Isochronous and double-buffered bulk endpoints, need to initialize only bits and registers related to the supported direction. Once 

the transmission and/or reception are enabled, register USB_EPnR and locations ADDRn_TX/ADDRn_RX, COUNTn_TX/COUNTn_RX (respectively), should not be modified by the application software, as the hardware can change their value on the fly. When the data transfer operation is completed, notified by a CTR interrupt event, they can be accessed again to re-enable a new operation.

When receiving an IN token packet, if the received address matches a configured and valid endpoint one, the USB peripheral accesses the contents of ADDRn_TX and COUNTn_TX locations inside buffer descriptor table entry related to the addressed endpoint. The content of these locations is stored in its internal 16 bit registers ADDR and COUNT (not accessible by software). The packet memory is accessed again to read the first word to be transmitted (refer to Structure and usage of packet buffers) and starts sending a DATA0 or DATA1 PID according to USB_EPnR bit DTOG_TX. When the PID is completed, the first byte from the word, read from buffer memory, is loaded into the output shift register to be transmitted on the USB bus. After the last data byte is transmitted, the computed CRC is sent. If the addressed endpoint is not valid, a NAK or STALL handshake packet is sent instead of the data packet, according to STAT_TX bits in the USB_EPnR register.

The ADDR internal register is used as a pointer to the current buffer memory location while COUNT is used to count the number of remaining bytes to be transmitted. Each word read from the packet buffer memory is transmitted over the USB bus starting from the least significant byte. Transmission buffer memory is read starting from the address pointed by ADDRn_TX for COUNTn_TX/2 words. If a transmitted packet is composed of an odd number of bytes, only the lower half of the last word accessed will be used.

On receiving the ACK receipt by the host, the USB_EPnR register is updated in the following way: DTOG_TX bit is toggled, the endpoint is made invalid by setting STAT_TX=10 (NAK) and bit CTR_TX is set. The application software must first identify the endpoint, which is requesting microcontroller attention by examining the EP_ID and DIR bits in the USB_ISTR register. Servicing of the CTR_TX event starts clearing the interrupt bit; the application software then prepares another buffer full of data to be sent, updates the COUNTn_TX table location with the number of byte to be transmitted during the next transfer, and finally sets STAT_TX to ‘11 (VALID) to re-enable transmissions. While the STAT_TX bits are equal to ‘10 (NAK), any IN request addressed to that endpoint is NAKed, indicating a flow control condition: the USB host will retry the transaction until it succeeds. It is mandatory to execute the sequence of operations in the above mentioned order to avoid losing the notification of a second IN transaction addressed to the same endpoint immediately following the one which triggered the CTR interrupt.

These two tokens are handled by the USB peripheral more or less in the same way; the differences in the handling of SETUP packets are detailed in the following paragraph about control transfers. When receiving an OUT/SETUP PID, if the address matches a valid endpoint, the USB peripheral accesses the contents of the ADDRn_RX and COUNTn_RX locations inside the buffer descriptor table entry related to the addressed endpoint. The content of the ADDRn_RX is stored directly in its internal register ADDR. While COUNT is now reset and the values of BL_SIZE and NUM_BLOCK bit fields, which are read within COUNTn_RX content are used to initialize BUF_COUNT, an internal 16 bit counter, which is used to check the buffer overrun condition (all these internal registers are not accessible by software). Data bytes subsequently received by the USB peripheral are packed in words (the first byte received is stored as least significant byte) and then transferred to the packet 

buffer starting from the address contained in the internal ADDR register while BUF_COUNT is decremented and COUNT is incremented at each byte transfer. When the end of DATA packet is detected, the correctness of the received CRC is tested and only if no errors occurred during the reception, an ACK handshake packet is sent back to the transmitting host. 

In case of wrong CRC or other kinds of errors (bit-stuff violations, frame errors, etc.), data bytes are still copied in the packet memory buffer, at least until the error detection point, but ACK packet is not sent and the ERR bit in USB_ISTR register is set. However, there is usually no software action required in this case: the USB peripheral recovers from reception errors and remains ready for the next transaction to come. If the addressed endpoint is not valid, a NAK or STALL handshake packet is sent instead of the ACK, according to bits STAT_RX in the USB_EPnR register and no data is written in the reception memory buffers.

Reception memory buffer locations are written starting from the address contained in the ADDRn_RX for a number of bytes corresponding to the received data packet length, CRC included (i.e. data payload length + 2), or up to the last allocated memory location, as defined by BL_SIZE and NUM_BLOCK, whichever comes first. In this way, the USB peripheral never writes beyond the end of the allocated reception memory buffer area. If the length of the data packet payload (actual number of bytes used by the application) is greater than the allocated buffer, the USB peripheral detects a buffer overrun condition. in this case, a STALL handshake is sent instead of the usual ACK to notify the problem to the host, no interrupt is generated and the transaction is considered failed.

When the transaction is completed correctly, by sending the ACK handshake packet, the internal COUNT register is copied back in the COUNTn_RX location inside the buffer description table entry, leaving unaffected BL_SIZE and NUM_BLOCK fields, which normally do not require to be re-written, and the USB_EPnR register is updated in the following way: DTOG_RX bit is toggled, the endpoint is made invalid by setting STAT_RX = ‘10 (NAK) and bit CTR_RX is set. If the transaction has failed due to errors or buffer overrun condition, none of the previously listed actions take place. The application software must first identify the endpoint, which is requesting microcontroller attention by examining the EP_ID and DIR bits in the USB_ISTR register. The CTR_RX event is serviced by first determining the transaction type (SETUP bit in the USB_EPnR register); the application software must clear the interrupt flag bit and get the number of received bytes reading the COUNTn_RX location inside the buffer description table entry related to the endpoint being processed. After the received data is processed, the application software should set the STAT_RX bits to ‘11 (Valid) in the USB_EPnR, enabling further transactions. While the STAT_RX bits are equal to ‘10 (NAK), any OUT request addressed to that endpoint is NAKed, indicating a flow control condition: the USB host will retry the transaction until it succeeds. It is mandatory to execute the sequence of operations in the above mentioned order to avoid losing the notification of a second OUT transaction addressed to the same endpoint following immediately the one which triggered the CTR interrupt.

Control transfers are made of a SETUP transaction, followed by zero or more data stages, all of the same direction, followed by a status stage (a zero-byte transfer in the opposite direction). SETUP transactions are handled by control endpoints only and are very similar to OUT ones (data reception) except that the values of DTOG_TX and DTOG_RX bits of the addressed endpoint registers are set to 1 and 0 respectively, to initialize the control transfer, and both STAT_TX and STAT_RX are set to ‘10 (NAK) to let software decide if subsequent transactions must be IN or OUT depending on the SETUP contents. A control endpoint must check SETUP bit in the USB_EPnR register at each CTR_RX event to distinguish normal 

OUT transactions from SETUP ones. A USB device can determine the number and direction of data stages by interpreting the data transferred in the SETUP stage, and is required to STALL the transaction in the case of errors. To do so, at all data stages before the last, the unused direction should be set to STALL, so that, if the host reverses the transfer direction too soon, it gets a STALL as a status stage. 

While enabling the last data stage, the opposite direction should be set to NAK, so that, if the host reverses the transfer direction (to perform the status stage) immediately, it is kept waiting for the completion of the control operation. If the control operation completes successfully, the software will change NAK to VALID, otherwise to STALL. At the same time, if the status stage will be an OUT, the STATUS_OUT (EP_KIND in the USB_EPnR register) bit should be set, so that an error is generated if a status transaction is performed with not-zero data. When the status transaction is serviced, the application clears the STATUS_OUT bit and sets STAT_RX to VALID (to accept a new command) and STAT_TX to NAK (to delay a possible status stage immediately following the next setup).

Since the USB specification states that a SETUP packet cannot be answered with a handshake different from ACK, eventually aborting a previously issued command to start the new one, the USB logic doesn’t allow a control endpoint to answer with a NAK or STALL packet to a SETUP token received from the host. 

When the STAT_RX bits are set to ‘01 (STALL) or ‘10 (NAK) and a SETUP token is received, the USB accepts the data, performing the required data transfers and sends back an ACK handshake. If that endpoint has a previously issued CTR_RX request not yet acknowledged by the application (i.e. CTR_RX bit is still set from a previously completed reception), the USB discards the SETUP transaction and does not answer with any handshake packet regardless of its state, simulating a reception error and forcing the host to send the SETUP token again. This is done to avoid losing the notification of a SETUP transaction addressed to the same endpoint immediately following the transaction, which triggered the CTR_RX interrupt.

All different endpoint types defined by the USB standard represent different traffic models, and describe the typical requirements of different kind of data transfer operations. When large portions of data are to be transferred between the host PC and the USB function, the bulk endpoint type is the most suited model. This is because the host schedules bulk transactions so as to fill all the available bandwidth in the frame, maximizing the actual transfer rate as long as the USB function is ready to handle a bulk transaction addressed to it. If the USB function is still busy with the previous transaction when the next one arrives, it will answer with a NAK handshake and the host PC will issue the same transaction again until the USB function is ready to handle it, reducing the actual transfer rate due to the bandwidth occupied by re-transmissions. For this reason, a dedicated feature called ‘double-buffering’ can be used with bulk endpoints.

When ‘double-buffering’ is activated, data toggle sequencing is used to select, which buffer is to be used by the USB peripheral to perform the required data transfers, using both ‘transmission’ and ‘reception’ packet memory areas to manage buffer swapping on each successful transaction in order to always have a complete buffer to be used by the application, while the USB peripheral fills the other one. For example, during an OUT transaction directed to a ‘reception’ double-buffered bulk endpoint, while one buffer is being filled with new data coming from the USB host, the other one is available for the microcontroller software usage (the same would happen with a ‘transmission’ double-buffered bulk endpoint and an IN transaction).

Since the swapped buffer management requires the usage of all four buffer description table locations hosting the address pointer and the length of the allocated memory buffers, the USB_EPnR registers used to implement double-buffered bulk endpoints are forced to be used as unidirectional ones. Therefore, only one STAT bit pair must be set at a value different from ‘00 (Disabled): STAT_RX if the double-buffered bulk endpoint is enabled for reception, STAT_TX if the double-buffered bulk endpoint is enabled for transmission. In case it is required to have double-buffered bulk endpoints enabled both for reception and transmission, two USB_EPnR registers must be used.

To exploit the double-buffering feature and reach the highest possible transfer rate, the endpoint flow control structure, described in previous chapters, has to be modified, in order to switch the endpoint status to NAK only when a buffer conflict occurs between the USB peripheral and application software, instead of doing it at the end of each successful transaction. The memory buffer which is currently being used by the USB peripheral is defined by the DTOG bit related to the endpoint direction: DTOG_RX (bit 14 of USB_EPnR register) for ‘reception’ double-buffered bulk endpoints or DTOG_TX (bit 6 of USB_EPnR register) for ‘transmission’ double-buffered bulk endpoints. To implement the new flow control scheme, the USB peripheral should know which packet buffer is currently in use by the application software, so to be aware of any conflict. Since in the USB_EPnR register, there are two DTOG bits but only one is used by USB peripheral for data and buffer sequencing (due to the unidirectional constraint required by double-buffering feature) the other one can be used by the application software to show which buffer it is currently using. This new buffer flag is called SW_BUF. In the following table the correspondence between USB_EPnR register bits and DTOG/SW_BUF definition is explained, for the cases of ‘transmission’ and ‘reception’ double-buffered bulk endpoints.

The memory buffer which is currently being used by the USB peripheral is defined by DTOG buffer flag, while the buffer currently in use by application software is identified by SW_BUF buffer flag. The relationship between the buffer flag value and the used packet buffer is the same in both cases, and it is listed in the following table.

The application software is responsible for DTOG and SW_BUF bits initialization according to the first buffer to be used; this has to be done considering the special toggle-only property that these two bits have. The end of the first transaction occurring after having set DBL_BUF, triggers the special flow control of double-buffered bulk endpoints, which is used for all other transactions addressed to this endpoint until DBL_BUF remain set. At the end of each transaction the CTR_RX or CTR_TX bit of the addressed endpoint USB_EPnR register is set, depending on the enabled direction. At the same time, the affected DTOG bit in the USB_EPnR register is hardware toggled making the USB peripheral buffer swapping completely software independent. Unlike common transactions, and the first one after DBL_BUF setting, STAT bit pair is not affected by the transaction termination and its value remains ‘11 (Valid). However, as the token packet of a new transaction is received, the actual endpoint status will be masked as ‘10 (NAK) when a buffer conflict between the USB peripheral and the application software is detected (this condition is identified by DTOG and SW_BUF having the same value, see Table 170). The application software responds to the CTR event notification by clearing the interrupt flag and starting any required handling of the completed transaction. When the application packet buffer usage is over, the software toggles the SW_BUF bit, writing ‘1 to it, to notify the USB peripheral about the availability of that buffer. In this way, the number of NAK-ed transactions is limited only by the application elaboration time of a transaction data: if the elaboration time is shorter than the time required to complete a transaction on the USB bus, no re-transmissions due to flow control will take place and the actual transfer rate will be limited only by the host PC.

The application software can always override the special flow control implemented for double-buffered bulk endpoints, writing an explicit status different from ‘11 (Valid) into the STAT bit pair of the related USB_EPnR register. In this case, the USB peripheral will always use the programmed endpoint status, regardless of the buffer usage condition.

The USB standard supports full speed peripherals requiring a fixed and accurate data production/consume frequency, defining this kind of traffic as ‘Isochronous’. Typical examples of this data are: audio samples, compressed video streams, and in general any sort of sampled data having strict requirements for the accuracy of delivered frequency. When an endpoint is defined to be ‘isochronous’ during the enumeration phase, the host allocates in the frame the required bandwidth and delivers exactly one IN or OUT packet each frame, depending on endpoint direction. To limit the bandwidth requirements, no re-transmission of failed transactions is possible for Isochronous traffic; this leads to the fact that an isochronous transaction does not have a handshake phase and no ACK packet is expected or sent after the data packet. For the same reason, Isochronous transfers do not support data toggle sequencing and always use DATA0 PID to start any data packet.

The Isochronous behavior for an endpoint is selected by setting the EP_TYPE bits at ‘10 in its USB_EPnR register; since there is no handshake phase the only legal values for the STAT_RX/STAT_TX bit pairs are ‘00 (Disabled) and ‘11 (Valid), any other value will produce results not compliant to USB standard. Isochronous endpoints implement double-buffering to ease application software development, using both ‘transmission’ and ‘reception’ packet memory areas to manage buffer swapping on each successful transaction in order to have always a complete buffer to be used by the application, while the USB peripheral fills the other.

The memory buffer which is currently used by the USB peripheral is defined by the DTOG bit related to the endpoint direction (DTOG_RX for ‘reception’ isochronous endpoints, DTOG_TX for ‘transmission’ isochronous endpoints, both in the related USB_EPnR register) according to Table 171.

As it happens with double-buffered bulk endpoints, the USB_EPnR registers used to implement Isochronous endpoints are forced to be used as unidirectional ones. If it is required to have Isochronous endpoints enabled both for reception and transmission, two USB_EPnR registers must be used.

The application software is responsible for the DTOG bit initialization according to the first buffer to be used; this has to be done considering the special toggle-only property that these two bits have. At the end of each transaction, the CTR_RX or CTR_TX bit of the addressed endpoint USB_EPnR register is set, depending on the enabled direction. At the same time, the affected DTOG bit in the USB_EPnR register is hardware toggled making buffer swapping completely software independent. STAT bit pair is not affected by transaction completion; since no flow control is possible for Isochronous transfers due to the lack of handshake phase, the endpoint remains always ‘11 (Valid). CRC errors or buffer-overrun conditions occurring during Isochronous OUT transfers are anyway considered as correct transactions and they always trigger an CTR_RX event. However, CRC errors will anyway set the ERR bit in the USB_ISTR register to notify the software of the possible data corruption.

The USB standard defines a special peripheral state, called SUSPEND, in which the average current drawn from the USB bus must not be greater than 2.5 mA. This requirement is of fundamental importance for bus-powered devices, while self-powered devices are not required to comply to this strict power consumption constraint. In suspend mode, the host PC sends the notification to not send any traffic on the USB bus for more than 3mS: since a SOF packet must be sent every mS during normal operations, the USB peripheral detects the lack of 3 consecutive SOF packets as a suspend request from the host PC and set the SUSP bit to ‘1 in USB_ISTR register, causing an interrupt if enabled. Once the device is suspended, its normal operation can be restored by a so called RESUME sequence, which can be started from the host PC or directly from the peripheral itself, but it is always terminated by the host PC. The suspended USB peripheral must be anyway able to detect a RESET sequence, reacting to this event as a normal USB reset event.

A brief description of a typical suspend procedure is provided below, focused on the USB- related aspects of the application software routine responding to the SUSP notification of the USB peripheral:

When an USB event occurs while the device is in SUSPEND mode, the RESUME procedure must be invoked to restore nominal clocks and regain normal USB behavior. Particular care must be taken to insure that this process does not take more than 10mS when the wakening event is an USB reset sequence (See “Universal Serial Bus Specification” for more details). The start of a resume or reset sequence, while the USB peripheral is suspended, clears the LP_MODE bit in USB_CNTR register asynchronously. Even if this event can trigger an WKUP interrupt if enabled, the use of an interrupt response routine must be carefully evaluated because of the long latency due to system clock restart; to have the shorter latency before re-activating the nominal clock it is suggested to put the resume procedure just after the end of the suspend one, so its code is immediately executed as soon as the system clock restarts. To prevent ESD discharges or any other kind of noise from waking-up the system (the exit from suspend mode is an asynchronous event), a suitable analog filter on data line status is activated during suspend; the filter width is about 70ns. 

A device may require to exit from suspend mode as an answer to particular events not directly related to the USB protocol (e.g. a mouse movement wakes up the whole system). In this case, the resume sequence can be started by setting the RESUME bit in the USB_CNTR register to ‘1 and resetting it to 0 after an interval between 1 mS and 15 mS (this interval can be timed using ESOF interrupts, occurring with a 1mS period when the system clock is running at nominal frequency). Once the RESUME bit is clear, the resume sequence will be completed by the host PC and its end can be monitored again using the RXDP and RXDM bits in the USB_FNR register. 

All register addresses are expressed as offsets with respect to the USB peripheral registers base address 0x4000 5C00, except the buffer descriptor table locations, which starts at the address specified by the USB_BTABLE register. Due to the common limitation of APB1 bridges on word addressability, all register addresses are aligned to 32-bit word boundaries although they are 16-bit wide. The same address alignment is used to access packet buffer memory locations, which are located starting from 0x4000 6000.

Bit 14 PMAOVRM: Packet memory area over / underrun interrupt mask0: PMAOVR Interrupt disabled.1: PMAOVR Interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set.

Bit 11 SUSPM: Suspend mode interrupt mask0: Suspend Mode Request (SUSP) Interrupt disabled.1: SUSP Interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set.

Bit 8 ESOFM: Expected start of frame interrupt mask0: Expected Start of Frame (ESOF) Interrupt disabled.1: ESOF Interrupt enabled, an interrupt request is generated when the corresponding bit in the USB_ISTR register is set.

Bit 4 RESUME: Resume requestThe microcontroller can set this bit to send a Resume signal to the host. It must be activated, according to USB specifications, for no less than 1 mS and no more than 15 mS after which the Host PC is ready to drive the resume sequence up to its end.

Bit 3 FSUSP: Force suspendSoftware must set this bit when the SUSP interrupt is received, which is issued when no traffic is received by the USB peripheral for 3 mS.0: No effect.1: Enter suspend mode. Clocks and static power dissipation in the analog transceiver are left unaffected. If suspend power consumption is a requirement (bus-powered device), the application software should set the LP_MODE bit after FSUSP as explained below.

Bit 2 LP_MODE: Low-power mode This mode is used when the suspend-mode power constraints require that all static power dissipation is avoided, except the one required to supply the external pull-up resistor. This condition should be entered when the application is ready to stop all system clocks, or reduce their frequency in order to meet the power consumption requirements of the USB suspend condition. The USB activity during the suspend mode (WKUP event) asynchronously resets this bit (it can also be reset by software). 0: No Low-power mode.1: Enter Low-power mode.

Bit 1 PDWN: Power downThis bit is used to completely switch off all USB-related analog parts if it is required to completely disable the USB peripheral for any reason. When this bit is set, the USB peripheral is disconnected from the transceivers and it cannot be used.0: Exit Power Down.1: Enter Power down mode.

Bit 0 FRES: Force USB Reset0: Clear USB reset.1: Force a reset of the USB peripheral, exactly like a RESET signalling on the USB. The USB peripheral is held in RESET state until software clears this bit. A “USB-RESET” interrupt is generated, if enabled.

The upper part of this register contains single bits, each of them representing a specific event. These bits are set by the hardware when the related event occurs; if the corresponding bit in the USB_CNTR register is set, a generic interrupt request is generated. The interrupt routine, examining each bit, will perform all necessary actions, and finally it will clear the serviced bits. If any of them is not cleared, the interrupt is considered to be still pending, and the interrupt line will be kept high again. If several bits are set simultaneously, only a single interrupt will be generated.

Endpoint transaction completion can be handled in a different way to reduce interrupt response latency. The CTR bit is set by the hardware as soon as an endpoint successfully completes a transaction, generating a generic interrupt request if the corresponding bit in USB_CNTR is set. An endpoint dedicated interrupt condition is activated independently from the CTRM bit in the USB_CNTR register. Both interrupt conditions remain active until software clears the pending bit in the corresponding USB_EPnR register (the CTR bit is actually a read only bit). For endpoint-related interrupts, the software can use the Direction of Transaction (DIR) and EP_ID read-only bits to identify, which endpoint made the last interrupt request and called the corresponding interrupt service routine.

The user can choose the relative priority of simultaneously pending USB_ISTR events by specifying the order in which software checks USB_ISTR bits in an interrupt service routine. Only the bits related to events, which are serviced, are cleared. At the end of the service routine, another interrupt will be requested, to service the remaining conditions.

To avoid spurious clearing of some bits, it is recommended to clear them with a load instruction where all bits which must not be altered are written with 1, and all bits to be cleared are written with ‘0 (these bits can only be cleared by software). Read-modify-write cycles should be avoided because between the read and the write operations another bit could be set by the hardware and the next write will clear it before the microprocessor has the time to serve the event.

Bit 15 CTR: Correct transferThis bit is set by the hardware to indicate that an endpoint has successfully completed a transaction; using DIR and EP_ID bits software can determine which endpoint requested the interrupt. This bit is read-only.

Bit 14 PMAOVR: Packet memory area over / underrunThis bit is set if the microcontroller has not been able to respond in time to an USB memory request. The USB peripheral handles this event in the following way: During reception an ACK handshake packet is not sent, during transmission a bit-stuff error is forced on the transmitted stream; in both cases the host will retry the transaction. The PMAOVR interrupt should never occur during normal operations. Since the failed transaction is retried by the host, the application software has the chance to speed-up device operations during this interrupt handling, to be ready for the next transaction retry; however this does not happen during Isochronous transfers (no isochronous transaction is anyway retried) leading to a loss of data in this case. This bit is read/write but only ‘0 can be written and writing ‘1 has no effect.

Bit 12 WKUP: WakeupThis bit is set to 1 by the hardware when, during suspend mode, activity is detected that wakes up the USB peripheral. This event asynchronously clears the LP_MODE bit in the CTLR register and activates the USB_WAKEUP line, which can be used to notify the rest of the device (e.g. wakeup unit) about the start of the resume process. This bit is read/write but only ‘0 can be written and writing ‘1 has no effect.

Bit 11 SUSP: Suspend mode requestThis bit is set by the hardware when no traffic has been received for 3mS, indicating a suspend mode request from the USB bus. The suspend condition check is enabled immediately after any USB reset and it is disabled by the hardware when the suspend mode is active (FSUSP=1) until the end of resume sequence. This bit is read/write but only ‘0 can be written and writing ‘1 has no effect.

Bit 10 RESET: USB reset requestSet when the USB peripheral detects an active USB RESET signal at its inputs. The USB peripheral, in response to a RESET, just resets its internal protocol state machine, generating an interrupt if RESETM enable bit in the USB_CNTR register is set. Reception and transmission are disabled until the RESET bit is cleared. All configuration registers do not reset: the microcontroller must explicitly clear these registers (this is to ensure that the RESET interrupt can be safely delivered, and any transaction immediately followed by a RESET can be completed). The function address and endpoint registers are reset by an USB reset event. This bit is read/write but only ‘0 can be written and writing ‘1 has no effect.

Bit 9 SOF: Start of frameThis bit signals the beginning of a new USB frame and it is set when a SOF packet arrives through the USB bus. The interrupt service routine may monitor the SOF events to have a 1 mS synchronization event to the USB host and to safely read the USB_FNR register which is updated at the SOF packet reception (this could be useful for isochronous applications). This bit is read/write but only ‘0 can be written and writing ‘1 has no effect.

Bit 8 ESOF: Expected start of frameThis bit is set by the hardware when an SOF packet is expected but not received. The host sends an SOF packet each mS, but if the hub does not receive it properly, the Suspend Timer issues this interrupt. If three consecutive ESOF interrupts are generated (i.e. three SOF packets are lost) without any traffic occurring in between, a SUSP interrupt is generated. This bit is set even when the missing SOF packets occur while the Suspend Timer is not yet locked. This bit is read/write but only ‘0 can be written and writing ‘1 has no effect.

Bit 4 DIR: Direction of transactionThis bit is written by the hardware according to the direction of the successful transaction, which generated the interrupt request.If DIR bit=0, CTR_TX bit is set in the USB_EPnR register related to the interrupting endpoint. The interrupting transaction is of IN type (data transmitted by the USB peripheral to the host PC).If DIR bit=1, CTR_RX bit or both CTR_TX/CTR_RX are set in the USB_EPnR register related to the interrupting endpoint. The interrupting transaction is of OUT type (data received by the USB peripheral from the host PC) or two pending transactions are waiting to be processed.This information can be used by the application software to access the USB_EPnR bits related to the triggering transaction since it represents the direction having the interrupt pending. This bit is read-only.

Bits 3:0 EP_ID[3:0]: Endpoint IdentifierThese bits are written by the hardware according to the endpoint number, which generated the interrupt request. If several endpoint transactions are pending, the hardware writes the endpoint identifier related to the endpoint having the highest priority defined in the following way: Two endpoint sets are defined, in order of priority: Isochronous and double-buffered bulk endpoints are considered first and then the other endpoints are examined. If more than one endpoint from the same set is requesting an interrupt, the EP_ID bits in USB_ISTR register are assigned according to the lowest requesting endpoint register, EP0R having the highest priority followed by EP1R and so on. The application software can assign a register to each endpoint according to this priority scheme, so as to order the concurring endpoint requests in a suitable way. These bits are read only.

Bit 15 RXDP: Receive data + line status This bit can be used to observe the status of received data plus upstream port data line. It can be used during end-of-suspend routines to help determining the wakeup event.

Bit 14 RXDM: Receive data - line statusThis bit can be used to observe the status of received data minus upstream port data line. It can be used during end-of-suspend routines to help determining the wakeup event.

Bit 13 LCK: LockedThis bit is set by the hardware when at least two consecutive SOF packets have been received after the end of an USB reset condition or after the end of an USB resume sequence. Once locked, the frame timer remains in this state until an USB reset or USB suspend event occurs.

Bits 12:11 LSOF[1:0]: Lost SOFThese bits are written by the hardware when an ESOF interrupt is generated, counting the number of consecutive SOF packets lost. At the reception of an SOF packet, these bits are cleared.

Bits 10:0 FN[10:0]: Frame numberThis bit field contains the 11-bits frame number contained in the last received SOF packet. The frame number is incremented for every frame sent by the host and it is useful for Isochronous transfers. This bit field is updated on the generation of an SOF interrupt.

Bit 7 EF: Enable functionThis bit is set by the software to enable the USB device. The address of this device is contained in the following ADD[6:0] bits. If this bit is at ‘0 no transactions are handled, irrespective of the settings of USB_EPnR registers.

Bits 6:0 ADD[6:0]: Device addressThese bits contain the USB function address assigned by the host PC during the enumeration process. Both this field and the Endpoint Address (EA) field in the associated USB_EPnR register must match with the information contained in a USB token in order to handle a transaction to the required endpoint.

Bits 15:3 BTABLE[15:3]: Buffer tableThese bits contain the start address of the buffer allocation table inside the dedicated packet memory. This table describes each endpoint buffer location and size and it must be aligned to an 8 byte boundary (the 3 least significant bits are always ‘0). At the beginning of every transaction addressed to this device, the USP peripheral reads the element of this table related to the addressed endpoint, to get its buffer start location and the buffer size (refer to Structure and usage of packet buffers).

The number of these registers varies according to the number of endpoints that the USB peripheral is designed to handle. The USB peripheral supports up to 8 bidirectional endpoints. Each USB device must support a control endpoint whose address (EA bits) must be set to 0. The USB peripheral behaves in an undefined way if multiple endpoints are enabled having the same endpoint number value. For each endpoint, an USB_EPnR register is available to store the endpoint specific information.

They are also reset when an USB reset is received from the USB bus or forced through bit FRES in the CTLR register, except the CTR_RX and CTR_TX bits, which are kept unchanged to avoid missing a correct packet notification immediately followed by an USB reset event. Each endpoint has its USB_EPnR register where n is the endpoint identifier.

Read-modify-write cycles on these registers should be avoided because between the read and the write operations some bits could be set by the hardware and the next write would modify them before the CPU has the time to detect the change. For this purpose, all bits affected by this problem have an ‘invariant’ value that must be used whenever their modification is not required. It is recommended to modify these registers with a load instruction where all the bits, which can be modified only by the hardware, are written with their ‘invariant’ value.

         Bit 15 CTR_RX: Correct Transfer for receptionThis bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below. A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches. This bit is read/write but only ‘0 can be written, writing 1 has no effect.

Bit 11 SETUP: Setup transaction completedThis bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (CTR_RX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while CTR_RX bit is at 1; its state changes when CTR_RX is at 0. This bit is read-only.

Bit 7 CTR_TX: Correct Transfer for transmissionThis bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. A transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches. This bit is read/write but only ‘0 can be written.

Bits 3:0 EA[3:0]: Endpoint addressSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.

Although the buffer descriptor table is located inside the packet buffer memory, its entries can be considered as additional registers used to configure the location and size of the packet buffers used to exchange data between the USB macro cell and the STM32F10xxx. Due to the common APB bridge limitation on word addressability, all packet memory locations are accessed by the APB using 32-bit aligned addresses, instead of the actual memory location addresses utilized by the USB peripheral for the USB_BTABLE register and buffer description table locations.

In the following pages two location addresses are reported: the one to be used by application software while accessing the packet memory, and the local one relative to USB Peripheral access. To obtain the correct STM32F10xxx memory address value to be used in the application software while accessing the packet memory, the actual memory location address must be multiplied by two. The first packet memory location is located at 0x4000 6000. The buffer descriptor table entry associated with the USB_EPnR registers is described below.

Bits 15:1 ADDRn_TX[15:1]: Transmission buffer addressThese bits point to the starting address of the packet buffer containing data to be transmitted by the endpoint associated with the USB_EPnR register at the next IN token addressed to it.

Bits 9:0 COUNTn_TX[9:0]: Transmission byte countThese bits contain the number of bytes to be transmitted by the endpoint associated with the USB_EPnR register at the next IN token addressed to it.

Bits 15:1 ADDRn_RX[15:1]: Reception buffer addressThese bits point to the starting address of the packet buffer, which will contain the data received by the endpoint associated with the USB_EPnR register at the next OUT/SETUP token addressed to it.

This table location is used to store two different values, both required during packet reception. The most significant bits contains the definition of allocated buffer size, to allow buffer overflow detection, while the least significant part of this location is written back by the USB peripheral at the end of reception to give the actual number of received bytes. Due to the restrictions on the number of available bits, buffer size is represented using the number of allocated memory blocks, where block size can be selected to choose the trade-off between fine-granularity/small-buffer and coarse-granularity/large-buffer. The size of allocated buffer is a part of the endpoint descriptor and it is normally defined during the enumeration process according to its maxPacketSize parameter value (See “Universal Serial Bus Specification”).

Bit 15 BL_SIZE: BLock sizeThis bit selects the size of memory block used to define the allocated buffer area.– If BL_SIZE=0, the memory block is 2 byte large, which is the minimum block allowed in a word-wide memory. With this block size the allocated buffer size ranges from 2 to 62 bytes.– If BL_SIZE=1, the memory block is 32 byte large, which allows to reach the maximum packet length defined by USB specifications. With this block size the allocated buffer size ranges from 32 to 1024 bytes, which is the longest packet size allowed by USB standard specifications.

Bits 14:10 NUM_BLOCK[4:0]: Number of blocksThese bits define the number of memory blocks allocated to this packet buffer. The actual amount of allocated memory depends on the BL_SIZE value as illustrated in Table 177.

The Basic Extended CAN peripheral, named bxCAN, interfaces the CAN network. It supports the CAN protocols version 2.0A and B. It has been designed to manage a high number of incoming messages efficiently with a minimum CPU load. It also meets the priority requirements for transmit messages. 

Note:In low, medium-, high- and XL-density devices the USB and CAN share a dedicated 512-byte SRAM memory for data transmission and reception, and so they cannot be used concurrently (the shared SRAM is accessed through CAN and USB exclusively). The USB and CAN can be used in the same application but not at the same time.

In today’s CAN applications, the number of nodes in a network is increasing and often several networks are linked together via gateways. Typically the number of messages in the system (and thus to be handled by each node) has significantly increased. In addition to the application messages, Network Management and Diagnostic messages have been introduced. 

The bxCAN provides 28 scalable/configurable identifier filter banks for selecting the incoming messages the software needs and discarding the others. In other devices there are 14 scalable/configurable identifier filter banks. 

bxCAN has three main operating modes: initialization, normal and Sleep. After a hardware reset, bxCAN is in Sleep mode to reduce power consumption and an internal pull-up is active on CANTX. The software requests bxCAN to enter initialization or Sleep mode by setting the INRQ or SLEEP bits in the CAN_MCR register. Once the mode has been entered, bxCAN confirms it by setting the INAK or SLAK bits in the CAN_MSR register and the internal pull-up is disabled. When neither INAK nor SLAK are set, bxCAN is in normal 

mode. Before entering normal mode bxCAN always has to synchronize on the CAN bus. To synchronize, bxCAN waits until the CAN bus is idle, this means 11 consecutive recessive bits have been monitored on CANRX.

The software initialization can be done while the hardware is in Initialization mode. To enter this mode the software sets the INRQ bit in the CAN_MCR register and waits until the hardware has confirmed the request by setting the INAK bit in the CAN_MSR register.

To initialize the registers associated with the CAN filter banks (mode, scale, FIFO assignment, activation and filter values), software has to set the FINIT bit (CAN_FMR). Filter initialization also can be done outside the initialization mode. 

The request to enter Normal mode is issued by clearing the INRQ bit in the CAN_MCR register. The bxCAN enters Normal mode and is ready to take part in bus activities when it has synchronized with the data transfer on the CAN bus. This is done by waiting for the occurrence of a sequence of 11 consecutive recessive bits (Bus Idle state). The switch to Normal mode is confirmed by the hardware by clearing the INAK bit in the CAN_MSR register.

The initialization of the filter values is independent from Initialization Mode but must be done while the filter is not active (corresponding FACTx bit cleared). The filter scale and mode configuration must be configured before entering Normal Mode.

To reduce power consumption, bxCAN has a low-power mode called Sleep mode. This mode is entered on software request by setting the SLEEP bit in the CAN_MCR register. In this mode, the bxCAN clock is stopped, however software can still access the bxCAN mailboxes. 

On CAN bus activity detection, hardware automatically performs the wakeup sequence by clearing the SLEEP bit if the AWUM bit in the CAN_MCR register is set. If the AWUM bit is cleared, software has to clear the SLEEP bit when a wakeup interrupt occurs, in order to exit from Sleep mode.

Note:If the wakeup interrupt is enabled (WKUIE bit set in CAN_IER register) a wakeup interrupt will be generated on detection of CAN bus activity, even if the bxCAN automatically performs the wakeup sequence.

After the SLEEP bit has been cleared, Sleep mode is exited once bxCAN has synchronized with the CAN bus, refer to Figure 224. The Sleep mode is exited once the SLAK bit has been cleared by hardware.

Test mode can be selected by the SILM and LBKM bits in the CAN_BTR register. These bits must be configured while bxCAN is in Initialization mode. Once test mode has been selected, the INRQ bit in the CAN_MCR register must be reset to enter Normal mode.

In Silent mode, the bxCAN is able to receive valid data frames and valid remote frames, but it sends only recessive bits on the CAN bus and it cannot start a transmission. If the bxCAN has to send a dominant bit (ACK bit, overload flag, active error flag), the bit is rerouted internally so that the CAN Core monitors this dominant bit, although the CAN bus may 

The bxCAN can be set in Loop Back Mode by setting the LBKM bit in the CAN_BTR register. In Loop Back Mode, the bxCAN treats its own transmitted messages as received messages and stores them (if they pass acceptance filtering) in a Receive mailbox. 

This mode is provided for self-test functions. To be independent of external events, the CAN Core ignores acknowledge errors (no dominant bit sampled in the acknowledge slot of a data / remote frame) in Loop Back Mode. In this mode, the bxCAN performs an internal feedback from its Tx output to its Rx input. The actual value of the CANRX input pin is disregarded by the bxCAN. The transmitted messages can be monitored on the CANTX pin.

It is also possible to combine Loop Back mode and Silent mode by setting the LBKM and SILM bits in the CAN_BTR register. This mode can be used for a “Hot Selftest”, meaning the bxCAN can be tested like in Loop Back mode but without affecting a running CAN system connected to the CANTX and CANRX pins. In this mode, the CANRX pin is disconnected from the bxCAN and the CANTX pin is held recessive. 

In order to transmit a message, the application must select one empty transmit mailbox, set up the identifier, the data length code (DLC) and the data before requesting the transmission by setting the corresponding TXRQ bit in the CAN_TIxR register. Once the mailbox has left empty state, the software no longer has write access to the mailbox registers. Immediately after the TXRQ bit has been set, the mailbox enters pending state and waits to become the highest priority mailbox, see Transmit Priority. As soon as the mailbox has the highest priority it will be scheduled for transmission. The transmission of the message of the scheduled mailbox will start (enter transmit state) when the CAN bus becomes idle. Once the mailbox has been successfully transmitted, it will become empty again. The hardware indicates a successful transmission by setting the RQCP and TXOK bits in the CAN_TSR register. 

If the transmission fails, the cause is indicated by the ALST bit in the CAN_TSR register in case of an Arbitration Lost, and/or the TERR bit, in case of transmission error detection.

A transmission request can be aborted by the user setting the ABRQ bit in the CAN_TSR register. In pending or scheduled state, the mailbox is aborted immediately. An abort request while the mailbox is in transmit state can have two results. If the mailbox is transmitted successfully the mailbox becomes empty with the TXOK bit set in the CAN_TSR register. If the transmission fails, the mailbox becomes scheduled, the transmission is aborted and becomes empty with TXOK cleared. In all cases the mailbox will become empty again at least at the end of the current transmission.

This mode has been implemented in order to fulfil the requirement of the Time Triggered Communication option of the CAN standard. To configure the hardware in this mode the NART bit in the CAN_MCR register must be set.

In this mode, each transmission is started only once. If the first attempt fails, due to an arbitration loss or an error, the hardware will not automatically restart the message transmission.

At the end of the first transmission attempt, the hardware considers the request as completed and sets the RQCP bit in the CAN_TSR register. The result of the transmission is indicated in the CAN_TSR register by the TXOK, ALST and TERR bits.

By identifierWhen more than one transmit mailbox is pending, the transmission order is given by the identifier of the message stored in the mailbox. The message with the lowest identifier value has the highest priority according to the arbitration of the CAN protocol. If the identifier values are equal, the lower mailbox number will be scheduled first.

By transmit request order The transmit mailboxes can be configured as a transmit FIFO by setting the TXFP bit in the CAN_MCR register. In this mode the priority order is given by the transmit request order. This mode is very useful for segmented transmission.

For the reception of CAN messages, three mailboxes organized as a FIFO are provided. In order to save CPU load, simplify the software and guarantee data consistency, the FIFO is managed completely by hardware. The application accesses the messages stored in the FIFO through the FIFO output mailbox.

Starting from the empty state, the first valid message received is stored in the FIFO which becomes pending_1. The hardware signals the event setting the FMP[1:0] bits in the CAN_RFR register to the value 01b. The message is available in the FIFO output mailbox. The software reads out the mailbox content and releases it by setting the RFOM bit in the CAN_RFR register. The FIFO becomes empty again. If a new valid message has been received in the meantime, the FIFO stays in pending_1 state and the new message is available in the output mailbox. 

If the application does not release the mailbox, the next valid message will be stored in the FIFO which enters pending_2 state (FMP[1:0] = 10b). The storage process is repeated for the next valid message putting the FIFO into pending_3 state (FMP[1:0] = 11b). At this point, the software must release the output mailbox by setting the RFOM bit, so that a mailbox is free to store the next valid message. Otherwise the next valid message received will cause a loss of message.

Once the FIFO is in pending_3 state (i.e. the three mailboxes are full) the next valid message reception will lead to an overrun and a message will be lost. The hardware 


• If the FIFO lock function is disabled (RFLM bit in the CAN_MCR register cleared) the last message stored in the FIFO will be overwritten by the new incoming message. In this case the latest messages will be always available to the application.


• If the FIFO lock function is enabled (RFLM bit in the CAN_MCR register set) the most recent message will be discarded and the software will have the three oldest messages in the FIFO available.

When the FIFO becomes full (i.e. a third message is stored) the FULL bit in the CAN_RFR register is set and an interrupt is generated if the FFIE bit in the CAN_IER register is set.

In the CAN protocol the identifier of a message is not associated with the address of a node but related to the content of the message. Consequently a transmitter broadcasts its message to all receivers. On message reception a receiver node decides - depending on the identifier value - whether the software needs the message or not. If the message is needed, it is copied into the SRAM. If not, the message must be discarded without intervention by the software.

To fulfill this requirement, the bxCAN Controller provides 28 configurable and scalable filter banks (27-0) to the application. In other devices the bxCAN Controller provides 14 configurable and scalable filter banks (13-0) to the application in order to receive only the messages the software needs. This hardware filtering saves CPU resources which would be otherwise needed to perform filtering by software. Each filter bank x consists of two 32-bit registers, CAN_FxR0 and CAN_FxR1. 

In identifier list mode, the mask registers are used as identifier registers. Thus instead of defining an identifier and a mask, two identifiers are specified, doubling the number of single 

The filter banks are configured by means of the corresponding CAN_FMR register. To configure a filter bank it must be deactivated by clearing the FACT bit in the CAN_FAR register. The filter scale is configured by means of the corresponding FSCx bit in the CAN_FS1R register, refer to Figure 230. The identifier list or identifier mask mode for the corresponding Mask/Identifier registers is configured by means of the FBMx bits in the CAN_FMR register.

Once a message has been received in the FIFO it is available to the application. Typically, application data is copied into SRAM locations. To copy the data to the right location the application has to identify the data by means of the identifier. To avoid this, and to ease the access to the SRAM locations, the CAN controller provides a Filter Match Index.

The index value of the filter number does not take into account the activation state of the filter banks. In addition, two independent numbering schemes are used, one for each FIFO. Refer to Figure 231 for an example.

Depending on the filter combination it may occur that an identifier passes successfully through several filters. In this case the filter match value stored in the receive mailbox is chosen according to the following priority rules:

The example above shows the filtering principle of the bxCAN. On reception of a message, the identifier is compared first with the filters configured in identifier list mode. If there is a match, the message is stored in the associated FIFO and the index of the matching filter is stored in the Filter Match Index. As shown in the example, the identifier matches with Identifier #2 thus the message content and FMI 2 is stored in the FIFO. 

The interface between the software and the hardware for the CAN messages is implemented by means of mailboxes. A mailbox contains all information related to a message; identifier, data, control, status and time stamp information.

When a message has been received, it is available to the software in the FIFO output mailbox. Once the software has handled the message (e.g. read it) the software must release the FIFO output mailbox by means of the RFOM bit in the CAN_RFR register to make the next incoming message available. The filter match index is stored in the MFMI field of the CAN_RDTxR register. The 16-bit time stamp value is stored in the TIME[15:0] field of CAN_RDTxR.

The error management as described in the CAN protocol is handled entirely by hardware using a Transmit Error Counter (TEC value, in CAN_ESR register) and a Receive Error Counter (REC value, in the CAN_ESR register), which get incremented or decremented according to the error condition. For detailed information about TEC and REC management, refer to the CAN standard. 

Both of them may be read by software to determine the stability of the network. Furthermore, the CAN hardware provides detailed information on the current error status in CAN_ESR register. By means of the CAN_IER register (ERRIE bit, etc.), the software can configure the interrupt generation on error detection in a very flexible way.

The Bus-Off state is reached when TEC is greater than 255, this state is indicated by BOFF bit in CAN_ESR register. In Bus-Off state, the bxCAN is no longer able to transmit and receive messages. 

Depending on the ABOM bit in the CAN_MCR register bxCAN will recover from Bus-Off (become error active again) either automatically or on software request. But in both cases the bxCAN has to wait at least for the recovery sequence specified in the CAN standard (128 occurrences of 11 consecutive recessive bits monitored on CANRX).


• Bit segment 1 (BS1): defines the location of the sample point. It includes the PROP_SEG and PHASE_SEG1 of the CAN standard. Its duration is programmable between 1 and 16 time quanta but may be automatically lengthened to compensate for positive phase drifts due to differences in the frequency of the various nodes of the network.


• Bit segment 2 (BS2): defines the location of the transmit point. It represents the PHASE_SEG2 of the CAN standard. Its duration is programmable between 1 and 8 time quanta but may also be automatically shortened to compensate for negative phase drifts.

Erroneous access to certain configuration registers can cause the hardware to temporarily disturb the whole CAN network. Therefore the CAN_BTR register can be modified by software only while the CAN hardware is in initialization mode.

Although the transmission of incorrect data will not cause problems at the CAN network level, it can severely disturb the application. A transmit mailbox can be only modified by software while it is in empty state, refer to Figure 228.

The filter values can be modified either deactivating the associated filter banks or by setting the FINIT bit. Moreover, the modification of the filter configuration (scale, mode and FIFO assignment) in CAN_FMxR, CAN_FSxR and CAN_FFAR registers can only be done when the filter initialization mode is set (FINIT=1) in the CAN_FMR register.

Bit 15 RESET: bxCAN software master reset0: Normal operation.1: Force a master reset of the bxCAN -> Sleep mode activated after reset (FMP bits and CAN_MCR register are initialized to the reset values). This bit is automatically reset to 0.

Bit 5 AWUM: Automatic wakeup modeThis bit controls the behavior of the CAN hardware on message reception during Sleep mode. 0: The Sleep mode is left on software request by clearing the SLEEP bit of the CAN_MCR register.1: The Sleep mode is left automatically by hardware on CAN message detection.The SLEEP bit of the CAN_MCR register and the SLAK bit of the CAN_MSR register are cleared by hardware.

Bit 4 NART: No automatic retransmission0: The CAN hardware will automatically retransmit the message until it has been successfully transmitted according to the CAN standard.1: A message will be transmitted only once, independently of the transmission result (successful, error or arbitration lost).

Bit 3 RFLM: Receive FIFO locked mode0: Receive FIFO not locked on overrun. Once a receive FIFO is full the next incoming message will overwrite the previous one.1: Receive FIFO locked against overrun. Once a receive FIFO is full the next incoming message will be discarded.

Bit 2 TXFP: Transmit FIFO priorityThis bit controls the transmission order when several mailboxes are pending at the same time.0: Priority driven by the identifier of the message1: Priority driven by the request order (chronologically)

Bit 1 SLEEP: Sleep mode requestThis bit is set by software to request the CAN hardware to enter the Sleep mode. Sleep mode will be entered as soon as the current CAN activity (transmission or reception of a CAN frame) has been completed.This bit is cleared by software to exit Sleep mode.This bit is cleared by hardware when the AWUM bit is set and a SOF bit is detected on the CAN Rx signal.This bit is set after reset - CAN starts in Sleep mode.

Bit 0 INRQ: Initialization requestThe software clears this bit to switch the hardware into normal mode. Once 11 consecutive recessive bits have been monitored on the Rx signal the CAN hardware is synchronized and ready for transmission and reception. Hardware signals this event by clearing the INAK bit in the CAN_MSR register.Software sets this bit to request the CAN hardware to enter initialization mode. Once software has set the INRQ bit, the CAN hardware waits until the current CAN activity (transmission or reception) is completed before entering the initialization mode. Hardware signals this event by setting the INAK bit in the CAN_MSR register.

Bit 4 SLAKI: Sleep acknowledge interruptWhen SLKIE=1, this bit is set by hardware to signal that the bxCAN has entered Sleep Mode. When set, this bit generates a status change interrupt if the SLKIE bit in the CAN_IER register is set.This bit is cleared by software or by hardware, when SLAK is cleared.Note: When SLKIE=0, no polling on SLAKI is possible. In this case the SLAK bit can be polled.

Bit 3 WKUI: Wakeup interruptThis bit is set by hardware to signal that a SOF bit has been detected while the CAN hardware was in Sleep mode. Setting this bit generates a status change interrupt if the WKUIE bit in the CAN_IER register is set.This bit is cleared by software.

Bit 2 ERRI: Error interruptThis bit is set by hardware when a bit of the CAN_ESR has been set on error detection and the corresponding interrupt in the CAN_IER is enabled. Setting this bit generates a status change interrupt if the ERRIE bit in the CAN_IER register is set.This bit is cleared by software.

Bit 1 SLAK: Sleep acknowledgeThis bit is set by hardware and indicates to the software that the CAN hardware is now in Sleep mode. This bit acknowledges the Sleep mode request from the software (set SLEEP bit in CAN_MCR register).This bit is cleared by hardware when the CAN hardware has left Sleep mode (to be synchronized on the CAN bus). To be synchronized the hardware has to monitor a sequence of 11 consecutive recessive bits on the CAN RX signal.Note: The process of leaving Sleep mode is triggered when the SLEEP bit in the CAN_MCR register is cleared. Refer to the AWUM bit of the CAN_MCR register description for detailed information for clearing SLEEP bit

Bit 0 INAK: Initialization acknowledgeThis bit is set by hardware and indicates to the software that the CAN hardware is now in initialization mode. This bit acknowledges the initialization request from the software (set INRQ bit in CAN_MCR register).This bit is cleared by hardware when the CAN hardware has left the initialization mode (to be synchronized on the CAN bus). To be synchronized the hardware has to monitor a sequence of 11 consecutive recessive bits on the CAN RX signal.

Bit 30 LOW1: Lowest priority flag for mailbox 1 This bit is set by hardware when more than one mailbox are pending for transmission and mailbox 1 has the lowest priority.

Bit 29 LOW0: Lowest priority flag for mailbox 0This bit is set by hardware when more than one mailbox are pending for transmission and mailbox 0 has the lowest priority.Note: The LOW[2:0] bits are set to zero when only one mailbox is pending.

Bits 25:24 CODE[1:0]: Mailbox codeIn case at least one transmit mailbox is free, the code value is equal to the number of the next transmit mailbox free.In case all transmit mailboxes are pending, the code value is equal to the number of the transmit mailbox with the lowest priority.

Bit 23 ABRQ2: Abort request for mailbox 2Set by software to abort the transmission request for the corresponding mailbox. Cleared by hardware when the mailbox becomes empty.Setting this bit has no effect when the mailbox is not pending for transmission.

Bit 17 TXOK2: Transmission OK of mailbox 2The hardware updates this bit after each transmission attempt.0: The previous transmission failed1: The previous transmission was successfulThis bit is set by hardware when the transmission request on mailbox 2 has been completed successfully. Refer to Figure 228.

Bit 16 RQCP2: Request completed mailbox2Set by hardware when the last request (transmit or abort) has been performed.Cleared by software writing a “1” or by hardware on transmission request (TXRQ2 set in CAN_TMID2R register).Clearing this bit clears all the status bits (TXOK2, ALST2 and TERR2) for Mailbox 2.

Bit 15 ABRQ1: Abort request for mailbox 1Set by software to abort the transmission request for the corresponding mailbox. Cleared by hardware when the mailbox becomes empty.Setting this bit has no effect when the mailbox is not pending for transmission.

Bit 9 TXOK1: Transmission OK of mailbox1The hardware updates this bit after each transmission attempt.0: The previous transmission failed1: The previous transmission was successfulThis bit is set by hardware when the transmission request on mailbox 1 has been completed successfully. Refer to Figure 228

Bit 8 RQCP1: Request completed mailbox1Set by hardware when the last request (transmit or abort) has been performed.Cleared by software writing a “1” or by hardware on transmission request (TXRQ1 set in CAN_TI1R register).Clearing this bit clears all the status bits (TXOK1, ALST1 and TERR1) for Mailbox 1.

Bit 7 ABRQ0: Abort request for mailbox0Set by software to abort the transmission request for the corresponding mailbox. Cleared by hardware when the mailbox becomes empty.Setting this bit has no effect when the mailbox is not pending for transmission.

Bit 1 TXOK0: Transmission OK of mailbox0The hardware updates this bit after each transmission attempt.0: The previous transmission failed1: The previous transmission was successfulThis bit is set by hardware when the transmission request on mailbox 1 has been completed successfully. Refer to Figure 228

Bit 0 RQCP0: Request completed mailbox0Set by hardware when the last request (transmit or abort) has been performed.Cleared by software writing a “1” or by hardware on transmission request (TXRQ0 set in CAN_TI0R register).Clearing this bit clears all the status bits (TXOK0, ALST0 and TERR0) for Mailbox 0.

Bit 5 RFOM0: Release FIFO 0 output mailboxSet by software to release the output mailbox of the FIFO. The output mailbox can only be released when at least one message is pending in the FIFO. Setting this bit when the FIFO is empty has no effect. If at least two messages are pending in the FIFO, the software has to release the output mailbox to access the next message.Cleared by hardware when the output mailbox has been released.

Bit 4 FOVR0: FIFO 0 overrun This bit is set by hardware when a new message has been received and passed the filter while the FIFO was full. This bit is cleared by software. 

Bits 1:0 FMP0[1:0]: FIFO 0 message pendingThese bits indicate how many messages are pending in the receive FIFO. FMP is increased each time the hardware stores a new message in to the FIFO. FMP is decreased each time the software releases the output mailbox by setting the RFOM0 bit.

Bit 5 RFOM1: Release FIFO 1 output mailboxSet by software to release the output mailbox of the FIFO. The output mailbox can only be released when at least one message is pending in the FIFO. Setting this bit when the FIFO is empty has no effect. If at least two messages are pending in the FIFO, the software has to release the output mailbox to access the next message.Cleared by hardware when the output mailbox has been released.

Bit 4 FOVR1: FIFO 1 overrun This bit is set by hardware when a new message has been received and passed the filter while the FIFO was full. This bit is cleared by software. 

Bits 1:0 FMP1[1:0]: FIFO 1 message pendingThese bits indicate how many messages are pending in the receive FIFO1. FMP1 is increased each time the hardware stores a new message in to the FIFO1. FMP is decreased each time the software releases the output mailbox by setting the RFOM1 bit.

Bit 15 ERRIE: Error interrupt enable0: No interrupt will be generated when an error condition is pending in the CAN_ESR.1: An interrupt will be generation when an error condition is pending in the CAN_ESR.

Bit 11 LECIE: Last error code interrupt enable0: ERRI bit will not be set when the error code in LEC[2:0] is set by hardware on error detection.1: ERRI bit will be set when the error code in LEC[2:0] is set by hardware on error detection.

Bits 31:24 REC[7:0]: Receive error counter The implementing part of the fault confinement mechanism of the CAN protocol. In case of an error during reception, this counter is incremented by 1 or by 8 depending on the error condition as defined by the CAN standard. After every successful reception the counter is decremented by 1 or reset to 120 if its value was higher than 128. When the counter value exceeds 127, the CAN controller enters the error passive state.

Bits 6:4 LEC[2:0]: Last error codeThis field is set by hardware and holds a code which indicates the error condition of the last error detected on the CAN bus. If a message has been transferred (reception or transmission) without error, this field will be cleared to ‘0’. The LEC[2:0] bits can be set to value 0b111 by software. They are updated by hardware to indicate the current communication status.000: No Error001: Stuff Error010: Form Error011: Acknowledgment Error100: Bit recessive Error101: Bit dominant Error110: CRC Error111: Set by software

Bits 25:24 SJW[1:0]: Resynchronization jump widthThese bits define the maximum number of time quanta the CAN hardware is allowed to lengthen or shorten a bit to perform the resynchronization.tRJW = tq x (SJW[1:0] + 1)

There are three TX Mailboxes and two RX Mailboxes , as shown in Figure 237. Each RX Mailbox allows access to a 3-level depth FIFO, the access being offered only to the oldest received message in the FIFO. Each mailbox consist of four registers.

Bit 8 TGT: Transmit global time This bit is active only when the hardware is in the Time Trigger Communication mode, TTCM bit of the CAN_MCR register is set.0: Time stamp TIME[15:0] is not sent. 1: Time stamp TIME[15:0] value is sent in the last two data bytes of the 8-byte message: TIME[7:0] in data byte 7 and TIME[15:8] in data byte 6, replacing the data written in CAN_TDHxR[31:16] register (DATA6[7:0] and DATA7[7:0]). DLC must be programmed as 8 in order these two bytes to be sent over the CAN bus. 

Bits 3:0 DLC[3:0]: Data length codeThis field defines the number of data bytes a data frame contains or a remote frame request.A message can contain from 0 to 8 data bytes, depending on the value in the DLC field.

Bits 31:24 DATA7[7:0]: Data byte 7 Data byte 7 of the message.Note: If TGT of this message and TTCM are active, DATA7 and DATA6 will be replaced by the TIME stamp value.

Bits 3:0 DLC[3:0]: Data length codeThis field defines the number of data bytes a data frame contains (0 to 8). It is 0 in the case of a remote frame request.

Bits 13:8 CAN2SB[5:0]: CAN2 start bankThese bits are set and cleared by software. They define the start bank for the CAN2 interface (Slave) in the range 0 to 27.Note: When CAN2SB[5:0] = 28d, all the filters to CAN1 can be used.When CAN2SB[5:0] is set to 0, no filters are assigned to CAN1. 

Bits 27:0 FBMx: Filter modeMode of the registers of Filter x. 0: Two 32-bit registers of filter bank x are in Identifier Mask mode.1: Two 32-bit registers of filter bank x are in Identifier List mode.Note: Bits 27:14 are available in connectivity line devices only and are reserved otherwise.

Bits 27:0 FSCx: Filter scale configurationThese bits define the scale configuration of Filters 13-0.0: Dual 16-bit scale configuration1: Single 32-bit scale configurationNote: Bits 27:14 are available in connectivity line devices only and are reserved otherwise.

Bits 27:0 FFAx: Filter FIFO assignment for filter xThe message passing through this filter will be stored in the specified FIFO.0: Filter assigned to FIFO 01: Filter assigned to FIFO 1Note: Bits 27:14 are available in connectivity line devices only and are reserved otherwise.

Bits 27:0 FACTx: Filter activeThe software sets this bit to activate Filter x. To modify the Filter x registers (CAN_FxR[0:7]), the FACTx bit must be cleared or the FINIT bit of the CAN_FMR register must be set.0: Filter x is not active1: Filter x is activeNote: Bits 27:14 are available in connectivity line devices only and are reserved otherwise.

Bits 31:0 FB[31:0]: Filter bits IdentifierEach bit of the register specifies the level of the corresponding bit of the expected identifier.0: Dominant bit is expected1: Recessive bit is expectedMaskEach bit of the register specifies whether the bit of the associated identifier register must match with the corresponding bit of the expected identifier or not.0: Don’t care, the bit is not used for the comparison1: Must match, the bit of the incoming identifier must have the same level has specified in the corresponding identifier register of the filter.

In high-density, XL-density and connectivity line devices, the SPI interface provides two main functions, supporting either the SPI protocol or the I2S audio protocol. By default, it is the SPI function that is selected. It is possible to switch the interface from SPI to I2S by software.In Cat.1 and Cat.2 devices, the I2S protocol is not available.

The serial peripheral interface (SPI) allows half/ full-duplex, synchronous, serial communication with external devices. The interface can be configured as the master and in this case it provides the communication clock (SCK) to the external slave device. The interface is also capable of operating in multimaster configuration.

The I2S is also a synchronous serial communication interface. It can address four different audio standards including the I2S Philips standard, the MSB- and LSB-justified standards, and the PCM standard. It can operate as a slave or a master device in full-duplex mode (using 4 pins) or in half-duplex mode (using 6 pins). Master clock can be provided by the interface to an external slave component when the I2S is configured as the communication master.

The communication is always initiated by the master. When the master device transmits data to a slave device via the MOSI pin, the slave device responds via the MISO pin. This implies full-duplex communication with both data out and data in synchronized with the same clock signal (which is provided by the master device via the SCK pin).

This configuration is used only when the device operates in master mode. The NSS signal is driven low when the master starts the communication and is kept low until the SPI is disabled. 

This configuration allows multimaster capability for devices operating in master mode. For devices set as slave, the NSS pin acts as a classical NSS input: the slave is selected when NSS is low and deselected when NSS high.

Four possible timing relationships may be chosen by software, using the CPOL and CPHA bits in the SPI_CR1 register. The CPOL (clock polarity) bit controls the steady state value of the clock when no data is being transferred. This bit affects both master and slave modes. If CPOL is reset, the SCK pin has a low-level idle state. If CPOL is set, the SCK pin has a high-level idle state.

If the CPHA (clock phase) bit is set, the second edge on the SCK pin (falling edge if the CPOL bit is reset, rising edge if the CPOL bit is set) is the MSBit capture strobe. Data are latched on the occurrence of the second clock transition. If the CPHA bit is reset, the first edge on the SCK pin (falling edge if CPOL bit is set, rising edge if CPOL bit is reset) is the MSBit capture strobe. Data are latched on the occurrence of the first clock transition.

Figure 240, shows an SPI transfer with the four combinations of the CPHA and CPOL bits. The diagram may be interpreted as a master or slave timing diagram where the SCK pin, the MISO pin, the MOSI pin are directly connected between the master and the slave device.

Each data frame is 8 or 16 bits long depending on the size of the data programmed using the DFF bit in the SPI_CR1 register. The selected data frame format is applicable for transmission and/or reception. 

In the slave configuration, the serial clock is received on the SCK pin from the master device. The value set in the BR[2:0] bits in the SPI_CR1 register, does not affect the data transfer rate.

Note:It is recommended to enable the SPI slave before the master sends the clock. If not, undesired data transmission might occur. The data register of the slave needs to be ready before the first edge of the communication clock or before the end of the ongoing communication. It is mandatory to have the polarity of the communication clock set to the steady state value before the slave and the master are enabled.

The transmit sequence begins when the slave device receives the clock signal and the most significant bit of the data on its MOSI pin. The remaining bits (the 7 bits in 8-bit data frame format, and the 15 bits in 16-bit data frame format) are loaded into the shift-register. The TXE flag in the SPI_SR register is set on the transfer of data from the Tx Buffer to the shift register and an interrupt is generated if the TXEIE bit in the SPI_CR2 register is set.

After the last sampling clock edge the RXNE bit is set, a copy of the data byte received in the shift register is moved to the Rx buffer. When the SPI_DR register is read, the SPI peripheral returns this buffered value.

The data byte is parallel-loaded into the shift register (from the internal bus) during the first bit transmission and then shifted out serially to the MOSI pin MSB first or LSB first depending on the LSBFIRST bit in the SPI_CR1 register. The TXE flag is set on the transfer of data from the Tx Buffer to the shift register and an interrupt is generated if the TXEIE bit in the SPI_CR2 register is set.

At the last sampling clock edge the RXNE bit is set, a copy of the data byte received in the shift register is moved to the Rx buffer. When the SPI_DR register is read, the SPI peripheral returns this buffered value.

A continuous transmit stream can be maintained if the next data to be transmitted is put in the Tx buffer once the transmission is started. Note that TXE flag should be ‘1 before any attempt to write the Tx buffer is made.

Note:When a master is communicating with SPI slaves which need to be de-selected between transmissions, the NSS pin must be configured as GPIO or another GPIO must be used and toggled by software. 

This mode is enabled by setting the BIDIMODE bit in the SPI_CR1 register. In this mode SCK is used for the clock and MOSI in master or MISO in slave mode is used for data communication. The transfer direction (Input/Output) is selected by the BIDIOE bit in the SPI_CR1 register. When this bit is 1, the data line is output otherwise it is input.


• Transmit-only mode is similar to full-duplex mode (BIDIMODE=0, RXONLY=0): the data are transmitted on the transmit pin (MOSI in master mode or MISO in slave mode) and the receive pin (MISO in master mode or MOSI in slave mode) can be used as a general-purpose IO. In this case, the application just needs to ignore the Rx buffer (if the data register is read, it does not contain the received value).


• In receive-only mode, the application can disable the SPI output function by setting the RXONLY bit in the SPI_CR1 register. In this case, it frees the transmit IO pin (MOSI in master mode or MISO in slave mode), so it can be used for other purposes.


• In master mode, the communication starts immediately and stops when the SPE bit is cleared and the current reception stops. There is no need to read the BSY flag in this mode. It is always set when an SPI communication is ongoing.


• In slave mode, the SPI continues to receive as long as the NSS is pulled down (or the SSI bit is cleared in NSS software mode) and the SCK is running.

–Only the receiver is activated and the received data on the MISO pin are shifted in serially to the 8-bit shift register and then parallel loaded into the SPI_DR register (Rx buffer).

–The sequence begins when the slave device receives the clock signal and the first bit of the data on its MOSI pin. The 7 remaining bits are loaded into the shift register.

–At the same time, the data are parallel loaded from the Tx buffer into the 8-bit shift register during the first bit transmission, and then shifted out serially to the MISO pin. The software must have written the data to be sent before the SPI master device initiates the transfer.

–The sequence begins when the slave device receives the clock signal and the first bit of the data on its MOSI pin. The 7 remaining bits are loaded into the shift register.

–The data are then parallel loaded from the Tx buffer into the 8-bit shift register during the first bit transmission and then shifted out serially to the MISO pin. The 

The TXE flag (Tx buffer empty) is set when the data are transferred from the Tx buffer to the shift register. It indicates that the internal Tx buffer is ready to be loaded with the next data. An interrupt can be generated if the TXEIE bit in the SPI_CR2 register is set. Clearing the TXE bit is performed by writing to the SPI_DR register.

Note:The software must ensure that the TXE flag is set to 1 before attempting to write to the Tx buffer. Otherwise, it overwrites the data previously written to the Tx buffer.

The RXNE flag (Rx buffer not empty) is set on the last sampling clock edge, when the data are transferred from the shift register to the Rx buffer. It indicates that data are ready to be read from the SPI_DR register. An interrupt can be generated if the RXNEIE bit in the SPI_CR2 register is set. Clearing the RXNE bit is performed by reading the SPI_DR register.

In this mode, the procedure can be reduced as described below and the BSY bit can be used to wait until the completion of the transmission (see Figure 243 and Figure 244).

Note:During discontinuous communications, there is a 2 APB clock period delay between the write operation to SPI_DR and the BSY bit setting. As a consequence, in transmit-only mode, it is mandatory to wait first until TXE is set and then until BSY is cleared after writing the last data.

In this mode, the procedure is similar to the procedure in Transmit-only mode except that the BIDIMODE and BIDIOE bits both have to be set in the SPI_CR2 register before enabling the SPI.

In this mode, the procedure is similar to the Receive-only mode procedure except that the BIDIMODE bit has to be set and the BIDIOE bit cleared in the SPI_CR2 register before enabling the SPI.

When transmitting data in master mode, if the software is fast enough to detect each rising edge of TXE (or TXE interrupt) and to immediately write to the SPI_DR register before the ongoing data transfer is complete, the communication is said to be continuous. In this case, there is no discontinuity in the generation of the SPI clock between each data item and the BSY bit is never cleared between each data transfer.

On the contrary, if the software is not fast enough, this can lead to some discontinuities in the communication. In this case, the BSY bit is cleared between each data transmission (see Figure 246).

In slave mode, the continuity of the communication is decided by the SPI master device. In any case, even if the communication is continuous, the BSY flag goes low between each transfer for a minimum duration of one SPI clock cycle (see Figure 244).

A CRC calculator has been implemented for communication reliability. Separate CRC calculators are implemented for transmitted data and received data. The CRC is calculated using a programmable polynomial serially on each bit. It is calculated on the sampling clock edge defined by the CPHA and CPOL bits in the SPI_CR1 register.

CRC calculation is enabled by setting the CRCEN bit in the SPI_CR1 register. This action resets the CRC registers (SPI_RXCRCR and SPI_TXCRCR). In full duplex or transmitter only mode, when the transfers are managed by the software (CPU mode), it is necessary to write the bit CRCNEXT immediately after the last data to be transferred is written to the SPI_DR. At the end of this last data transfer, the SPI_TXCRCR value is transmitted.

In receive only mode and when the transfers are managed by software (CPU mode), it is necessary to write the CRCNEXT bit after the second last data has been received. The CRC is received just after the last data reception and the CRC check is then performed.

If data are present in the TX buffer, the CRC value is transmitted only after the transmission of the data byte. During CRC transmission, the CRC calculator is switched off and the register value remains unchanged.

–In full duplex or transmitter-only mode, when the transfers are managed by software, when writing the last byte or half word to the Tx buffer, set the CRCNEXT bit in the SPI_CR1 register to indicate that the CRC will be transmitted after the transmission of the last byte.

–In receiver only mode, set the bit CRCNEXT just after the reception of the second to last data to prepare the SPI to enter in CRC Phase at the end of the reception of the last data. CRC calculation is frozen during the CRC transfer. 

Note:When the SPI is in slave mode, be careful to enable CRC calculation only when the clock is stable, that is, when the clock is in the steady state. If not, a wrong CRC calculation may be done. In fact, the CRC is sensitive to the SCK slave input clock as soon as CRCEN is set, and this, whatever the value of the SPE bit.

With high bitrate frequencies, be careful when transmitting the CRC. As the number of used CPU cycles has to be as low as possible in the CRC transfer phase, it is forbidden to call software functions in the CRC transmission sequence to avoid errors in the last data and CRC reception. In fact, CRCNEXT bit has to be written before the end of the transmission/reception of the last data.

When the SPI is configured in slave mode with the CRC feature enabled, CRC calculation takes place even if a high level is applied on the NSS pin. This may happen for example in case of a multislave environment where the communication master addresses slaves alternately.

Between a slave deselection (high level on NSS) and a new slave selection (low level on NSS), the CRC value should be cleared on both master and slave sides in order to resynchronize the master and slave for their respective CRC calculation.

When it is set, this flag indicates that the Tx buffer is empty and the next data to be transmitted can be loaded into the buffer. The TXE flag is cleared when writing to the SPI_DR register.

When BSY is set, it indicates that the SPI is busy communicating. There is one exception in master mode / bidirectional receive mode (MSTR=1 and BDM=1 and BDOE=0) where the BSY flag is kept low during reception.

The BSY flag is useful to detect the end of a transfer if the software wants to disable the SPI and enter Halt mode (or disable the peripheral clock). This avoids corrupting the last transfer. For this, the procedure described below must be strictly respected.

For some configurations, disabling the SPI and entering the Halt mode while a transfer is ongoing can cause the current transfer to be corrupted and/or the BSY flag might become unreliable.

To operate at its maximum speed, the SPI needs to be fed with the data for transmission and the data received on the Rx buffer should be read to avoid overrun. To facilitate the transfers, the SPI features a DMA capability implementing a simple request/acknowledge protocol.

A DMA access is requested when the enable bit in the SPI_CR2 register is enabled. Separate requests must be issued to the Tx and Rx buffers (see Figure 247 and Figure 248):

When the SPI is used only to transmit data, it is possible to enable only the SPI Tx DMA channel. In this case, the OVR flag is set because the data received are not read.

In transmission mode, when the DMA has written all the data to be transmitted (flag TCIF is set in the DMA_ISR register), the BSY flag can be monitored to ensure that the SPI communication is complete. This is required to avoid corrupting the last transmission before disabling the SPI or entering the Stop mode. The software must first wait until TXE=1 and then until BSY=0.

Note:During discontinuous communications, there is a 2 APB clock period delay between the write operation to SPI_DR and the BSY bit setting. As a consequence, it is mandatory to wait first until TXE=1 and then until BSY=0 after writing the last data.

When SPI communication is enabled with CRC communication and DMA mode, the transmission and reception of the CRC at the end of communication are automatic that is without using the bit CRCNEXT. After the CRC reception, the CRC must be read in the SPI_DR register to clear the RXNE flag.

Master mode fault occurs when the master device has its NSS pin pulled low (in NSS hardware mode) or SSI bit low (in NSS software mode), this automatically sets the MODF bit. Master mode fault affects the SPI peripheral in the following ways:

To avoid any multiple slave conflicts in a system comprising several MCUs, the NSS pin must be pulled high during the MODF bit clearing sequence. The SPE and MSTR bits can be restored to their original state after this clearing sequence.

In a slave device the MODF bit cannot be set. However, in a multimaster configuration, the device can be in slave mode with this MODF bit set. In this case, the MODF bit indicates that there might have been a multimaster conflict for system control. An interrupt routine can be used to recover cleanly from this state by performing a reset or returning to a default state.

An overrun condition occurs when the master device has sent data bytes and the slave device has not cleared the RXNE bit resulting from the previous data byte transmitted. When an overrun condition occurs:

In this case, the receiver buffer contents will not be updated with the newly received data from the master device. A read from the SPI_DR register returns this byte. All other subsequently transmitted bytes are lost.

This flag is used to verify the validity of the value received when the CRCEN bit in the SPI_CR1 register is set. The CRCERR flag in the SPI_SR register is set if the value received in the shift register does not match the receiver SPI_RXCRCR value.

The SPI could function as an audio I2S interface when the I2S capability is enabled (by setting the I2SMOD bit in the SPI_I2SCFGR register). This interface uses almost the same pins, flags and interrupts as the SPI.


• MCK: Master Clock (mapped separately) is used, when the I2S is configured in master mode (and when the MCKOE bit in the SPI_I2SPR register is set), to output this additional clock generated at a preconfigured frequency rate equal to 256 × FS, where FS is the audio sampling frequency.

The three-line bus has to handle only audio data generally time-multiplexed on two channels: the right channel and the left channel. However there is only one 16-bit register for the transmission and the reception. So, it is up to the software to write into the data register the adequate value corresponding to the considered channel side, or to read the data from the data register and to identify the corresponding channel by checking the CHSIDE bit in the SPI_SR register. Channel Left is always sent first followed by the channel right (CHSIDE has no meaning for the PCM protocol).

When using 16-bit data extended on 32-bit packet, the first 16 bits (MSB) are the significant bits, the 16-bit LSB is forced to 0 without any need for software action or DMA request (only one read/write operation).

The 24-bit and 32-bit data frames need two CPU read or write operations to/from the SPI_DR or two DMA operations if the DMA is preferred for the application. For 24-bit data frame specifically, the 8 nonsignificant bits are extended to 32 bits with 0-bits (by hardware).

Data are latched on the falling edge of CK (for the transmitter) and are read on the rising edge (for the receiver). The WS signal is also latched on the falling edge of CK.

When 16-bit data frame extended to 32-bit channel frame is selected during the I2S configuration phase, only one access to SPI_DR is required. The 16 remaining bits are forced by hardware to 0x0000 to extend the data to 32-bit format.

For transmission, each time an MSB is written to SPI_DR, the TXE flag is set and its interrupt, if allowed, is generated to load SPI_DR with the new value to send. This takes place even if 0x0000 have not yet been sent because it is done by hardware.

When 16-bit data frame extended to 32-bit channel frame is selected during the I2S configuration phase, Only one access to SPI_DR is required. The 16 remaining bits are forced by hardware to 0x0000 to extend the data to 32-bit format. In this case it corresponds to the half-word MSB.

In transmission mode, when TXE is asserted, the application has to write the data to be transmitted (in this case 0x76A3). The 0x000 field is transmitted first (extension on 32-bit). TXE is asserted again as soon as the effective data (0x76A3) is sent on SD.

Note:For both modes (master and slave) and for both synchronizations (short and long), the number of bits between two consecutive pieces of data (and so two synchronization signals) needs to be specified (DATLEN and CHLEN bits in the SPI_I2SCFGR register) even in slave mode.

The audio sampling frequency can be 96 kHz, 48 kHz, 44.1 kHz, 32 kHz, 22.05 kHz, 16 kHz, 11.025 kHz or 8 kHz (or any other value within this range). In order to reach the desired frequency, the linear divider needs to be programmed according to the formulas below:

The I2S can be configured in master mode for transmission and reception. This means that the serial clock is generated on the CK pin as well as the Word Select signal WS. Master clock (MCK) may be output or not, thanks to the MCKOE bit in the SPI_I2SPR register.

Assumedly, the first data written into the Tx buffer correspond to the channel Left data. When data are transferred from the Tx buffer to the shift register, TXE is set and data corresponding to the channel Right have to be written into the Tx buffer. The CHSIDE flag indicates which channel is to be transmitted. It has a meaning when the TXE flag is set because the CHSIDE flag is updated when TXE goes high.

A full frame has to be considered as a Left channel data transmission followed by a Right channel data transmission. It is not possible to have a partial frame where only the left channel is sent.

The data half-word is parallel loaded into the 16-bit shift register during the first bit transmission, and then shifted out, serially, to the MOSI/SD pin, MSB first. The TXE flag is set after each transfer from the Tx buffer to the shift register and an interrupt is generated if the TXEIE bit in the SPI_CR2 register is set.

Whatever the data or channel length, the audio data are received by 16-bit packets. This means that each time the Rx buffer is full, the RXNE flag is set and an interrupt is generated if the RXNEIE bit is set in SPI_CR2 register. Depending on the data and channel length configuration, the audio value received for a right or left channel may result from one or two receptions into the Rx buffer.

If data are received while the previously received data have not been read yet, an overrun is generated and the OVR flag is set. If the ERRIE bit is set in the SPI_CR2 register, an interrupt is generated to indicate the error.

To switch off the I2S, specific actions are required to ensure that the I2S completes the transfer cycle properly without initiating a new data transfer. The sequence depends on the configuration of the data and channel lengths, and on the audio protocol mode selected. In the case of:


• 16-bit data length extended on 32-bit channel length (DATLEN = 00 and CHLEN = 1) in MSB justified, I2S or PCM modes (I2SSTD = 00, I2SSTD = 01 or I2SSTD = 11, respectively)

In slave mode, the I2S can be configured in transmission or reception mode.The operating mode is following mainly the same rules as described for the I2S master configuration. In slave mode, there is no clock to be generated by the I2S interface. The clock and WS 

The transmission sequence begins when the external master device sends the clock and when the NSS_WS signal requests the transfer of data. The slave has to be enabled before the external master starts the communication. The I2S data register has to be loaded before the master initiates the communication.

For the I2S, MSB justified and LSB justified modes, the first data item to be written into the data register corresponds to the data for the left channel. When the communication starts, the data are transferred from the Tx buffer to the shift register. The TXE flag is then set in order to request the right channel data to be written into the I2S data register.

The CHSIDE flag indicates which channel is to be transmitted. Compared to the master transmission mode, in slave mode, CHSIDE is sensitive to the WS signal coming from the external master. This means that the slave needs to be ready to transmit the first data before the clock is generated by the master. WS assertion corresponds to left channel transmitted first.

The data half-word is parallel-loaded into the 16-bit shift register (from the internal bus) during the first bit transmission, and then shifted out serially to the MOSI/SD pin MSB first. The TXE flag is set after each transfer from the Tx buffer to the shift register and an interrupt is generated if the TXEIE bit in the SPI_CR2 register is set.

To secure a continuous audio data transmission, it is mandatory to write the SPI_DR register with the next data to transmit before the end of the current transmission. An underrun flag is set and an interrupt may be generated if the data are not written into the SPI_DR register before the first clock edge of the next data communication. This indicates to the software that the transferred data are wrong. If the ERRIE bit is set into the SPI_CR2 register, an interrupt is generated when the UDR flag in the SPI_SR register goes high. In this case, it is mandatory to switch off the I2S and to restart a data transfer starting from the left channel.

Whatever the data length or the channel length, the audio data are received by 16-bit packets. This means that each time the RX buffer is full, the RXNE flag in the SPI_SR register is set and an interrupt is generated if the RXNEIE bit is set in the SPI_CR2 register. Depending on the data length and channel length configuration, the audio value received for a right or left channel may result from one or two receptions into the RX buffer.

If data are received while the precedent received data have not yet been read, an overrun is generated and the OVR flag is set. If the bit ERRIE is set in the SPI_CR2 register, an interrupt is generated to indicate the error.

When BSY is set, it indicates that the I2S is busy communicating. There is one exception in master receive mode (I2SCFG = 11) where the BSY flag is kept low during reception.

The BSY flag is useful to detect the end of a transfer if the software needs to disable the I2S. This avoids corrupting the last transfer. For this, the procedure described below must be strictly respected.

When set, this flag indicates that the Tx buffer is empty and the next data to be transmitted can then be loaded into it. The TXE flag is reset when the Tx buffer already contains data to be transmitted. It is also reset when the I2S is disabled (I2SE bit is reset).

In transmission mode, this flag is refreshed when TXE goes high. It indicates the channel side to which the data to transfer on SD has to belong. In case of an underrun error event in slave transmission mode, this flag is not reliable and I2S needs to be switched off and switched on before resuming the communication.

In reception mode, this flag is refreshed when data are received into SPI_DR. It indicates from which channel side data have been received. Note that in case of error (like OVR) this flag becomes meaningless and the I2S should be reset by disabling and then enabling it (with configuration if it needs changing).

When the OVR or UDR flag in the SPI_SR is set and the ERRIE bit in SPI_CR2 is also set, an interrupt is generated. This interrupt can be cleared by reading the SPI_SR status register (once the interrupt source has been cleared).

In slave transmission mode this flag is set when the first clock for data transmission appears while the software has not yet loaded any value into SPI_DR. It is available when the I2SMOD bit in SPI_I2SCFGR is set. An interrupt may be generated if the ERRIE bit in SPI_CR2 is set.The UDR bit is cleared by a read operation on the SPI_SR register.

This flag is set when data are received and the previous data have not yet been read from SPI_DR. As a result, the incoming data are lost. An interrupt may be generated if the ERRIE bit is set in SPI_CR2.

In this case, the receive buffer contents are not updated with the newly received data from the transmitter device. A read operation to the SPI_DR register returns the previous correctly received data. All other subsequently transmitted half-words are lost.

DMA is working in exactly the same way as for the SPI mode. There is no difference on the I2S. Only the CRC feature is not available in I2S mode since there is no data transfer protection system.

Bit 14 BIDIOE: Output enable in bidirectional modeThis bit combined with the BIDImode bit selects the direction of transfer in bidirectional mode0: Output disabled (receive-only mode) 1: Output enabled (transmit-only mode)Note: This bit is not used in I2S mode.In master mode, the MOSI pin is used while the MISO pin is used in slave mode.

Bit 13 CRCEN: Hardware CRC calculation enable0: CRC calculation disabled1: CRC calculation enabledNote: This bit should be written only when SPI is disabled (SPE = ‘0’) for correct operation. It is not used in I2S mode.

Bit 12 CRCNEXT: CRC transfer next0: Data phase (no CRC phase) 1: Next transfer is CRC (CRC phase)Note: When the SPI is configured in full duplex or transmitter only modes, CRCNEXT must be written as soon as the last data is written to the SPI_DR register. When the SPI is configured in receiver only mode, CRCNEXT must be set after the second last data reception. This bit should be kept cleared when the transfers are managed by DMA.It is not used in I2S mode.

Bit 11 DFF: Data frame format0: 8-bit data frame format is selected for transmission/reception1: 16-bit data frame format is selected for transmission/receptionNote: This bit should be written only when SPI is disabled (SPE = ‘0’) for correct operation.It is not used in I2S mode.

Bit 10 RXONLY: Receive onlyThis bit combined with the BIDImode bit selects the direction of transfer in 2-line unidirectional mode. This bit is also useful in a multislave system in which this particular slave is not accessed, the output from the accessed slave is not corrupted.0: Full duplex (Transmit and receive)1: Output disabled (Receive-only mode)Note: This bit is not used in I2S mode

Bit 9 SSM: Software slave managementWhen the SSM bit is set, the NSS pin input is replaced with the value from the SSI bit.0: Software slave management disabled1: Software slave management enabledNote: This bit is not used in I2S mode

Bit 8 SSI: Internal slave selectThis bit has an effect only when the SSM bit is set. The value of this bit is forced onto the NSS pin and the IO value of the NSS pin is ignored.Note: This bit is not used in I2S mode

Bit1 CPOL: Clock polarity 0: CK to 0 when idle1: CK to 1 when idleNote: This bit should not be changed when communication is ongoing.It is not used in I2S mode

Bit 0 CPHA: Clock phase 0: The first clock transition is the first data capture edge1: The second clock transition is the first data capture edgeNote: This bit should not be changed when communication is ongoing.It is not used in I2S mode

Bit 5 ERRIE: Error interrupt enableThis bit controls the generation of an interrupt when an error condition occurs (CRCERR, OVR, MODF in SPI mode and UDR, OVR in I2S mode).0: Error interrupt is masked1: Error interrupt is enabled

Bit 2 SSOE: SS output enable0: SS output is disabled in master mode and the cell can work in multimaster configuration1: SS output is enabled in master mode and when the cell is enabled. The cell cannot work in a multimaster environment.Note: This bit is not used in I2S mode 

Bit 4 CRCERR: CRC error flag0: CRC value received matches the SPI_RXCRCR value1: CRC value received does not match the SPI_RXCRCR valueThis flag is set by hardware and cleared by software writing 0.Note: This bit is not used in I2S mode.

Bit 2 CHSIDE: Channel side0: Channel Left has to be transmitted or has been received1: Channel Right has to be transmitted or has been receivedNote: This bit is not used for SPI mode and is meaningless in PCM mode.

Bits 15:0 DR[15:0]: Data registerData received or to be transmitted.The data register is split into 2 buffers - one for writing (Transmit Buffer) and another one for reading (Receive buffer). A write to the data register will write into the Tx buffer and a read from the data register will return the value held in the Rx buffer.Note: These notes apply to SPI mode:Depending on the data frame format selection bit (DFF in SPI_CR1 register), the data sent or received is either 8-bit or 16-bit. This selection has to be made before enabling the SPI to ensure correct operation. For an 8-bit data frame, the buffers are 8-bit and only the LSB of the register (SPI_DR[7:0]) is used for transmission/reception. When in reception mode, the MSB of the register (SPI_DR[15:8]) is forced to 0.For a 16-bit data frame, the buffers are 16-bit and the entire register, SPI_DR[15:0] is used for transmission/reception.

Bits 15:0 CRCPOLY[15:0]: CRC polynomial registerThis register contains the polynomial for the CRC calculation.The CRC polynomial (0007h) is the reset value of this register. Another polynomial can be configured as required.Note: These bits are not used for the I2S mode.

Bits 15:0 RXCRC[15:0]: Rx CRC registerWhen CRC calculation is enabled, the RxCRC[15:0] bits contain the computed CRC value of the subsequently received bytes. This register is reset when the CRCEN bit in SPI_CR1 register is written to 1. The CRC is calculated serially using the polynomial programmed in the SPI_CRCPR register. Only the 8 LSB bits are considered when the data frame format is set to be 8-bit data (DFF bit of SPI_CR1 is cleared). CRC calculation is done based on any CRC8 standard.The entire 16-bits of this register are considered when a 16-bit data frame format is selected (DFF bit of the SPI_CR1 register is set). CRC calculation is done based on any CRC16 standard.Note: A read to this register when the BSY Flag is set could return an incorrect value.These bits are not used for I2S mode.

Bits 15:0 TXCRC[15:0]: Tx CRC registerWhen CRC calculation is enabled, the TxCRC[7:0] bits contain the computed CRC value of the subsequently transmitted bytes. This register is reset when the CRCEN bit of SPI_CR1 is written to 1. The CRC is calculated serially using the polynomial programmed in the SPI_CRCPR register.Only the 8 LSB bits are considered when the data frame format is set to be 8-bit data (DFF bit of SPI_CR1 is cleared). CRC calculation is done based on any CRC8 standard.The entire 16-bits of this register are considered when a 16-bit data frame format is selected (DFF bit of the SPI_CR1 register is set). CRC calculation is done based on any CRC16 standard.Note: A read to this register when the BSY flag is set could return an incorrect value.These bits are not used for I2S mode.

Bits 9:8 I2SCFG: I2S configuration mode00: Slave - transmit01: Slave - receive10: Master - transmit11: Master - receiveNote: This bit should be configured when the I2S is disabled.It is not used in SPI mode.

Bit 7 PCMSYNC: PCM frame synchronization0: Short frame synchronization1: Long frame synchronizationNote: This bit has a meaning only if I2SSTD = 11 (PCM standard is used)It is not used in SPI mode.

Bit 3 CKPOL: Steady state clock polarity0: I2S clock steady state is low level1: I2S clock steady state is high levelNote: For correct operation, this bit should be configured when the I2S is disabled.This bit is not used in SPI mode

Bits 2:1 DATLEN: Data length to be transferred00: 16-bit data length01: 24-bit data length10: 32-bit data length11: Not allowedNote: For correct operation, these bits should be configured when the I2S is disabled.This bit is not used in SPI mode.

Bit 0 CHLEN: Channel length (number of bits per audio channel)0: 16-bit wide1: 32-bit wideThe bit write operation has a meaning only if DATLEN = 00 otherwise the channel length is fixed to 32-bit by hardware whatever the value filled in. Not used in SPI mode.Note: For correct operation, this bit should be configured when the I2S is disabled.

Bit 9 MCKOE: Master clock output enable0: Master clock output is disabled1: Master clock output is enabledNote: This bit should be configured when the I2S is disabled. It is used only when the I2S is in master mode.This bit is not used in SPI mode.

I2C (inter-integrated circuit) bus Interface serves as an interface between the microcontroller and the serial I2C bus. It provides multimaster capability, and controls all I2C bus-specific sequencing, protocol, arbitration and timing. It supports the standard mode (Sm, up to 100 kHz) and Fm mode (Fm, up to 400 kHz).  

Note:Some of the above features may not be available in certain products. The user should refer to the product data sheet, to identify the specific features supported by the I2C interface implementation.

In addition to receiving and transmitting data, this interface converts it from serial to parallel format and vice versa. The interrupts are enabled or disabled by software. The interface is connected to the I2C bus by a data pin (SDA) and by a clock pin (SCL). It can be connected with a standard (up to 100 kHz) or fast (up to 400 kHz) I2C bus. 

By default, it operates in slave mode. The interface automatically switches from slave to master, after it generates a START condition and from master to slave, if an arbitration loss or a Stop generation occurs, allowing multimaster capability.

In Master mode, the I2C interface initiates a data transfer and generates the clock signal. A serial data transfer always begins with a start condition and ends with a stop condition. Both start and stop conditions are generated in master mode by software.

In Slave mode, the interface is capable of recognizing its own addresses (7 or 10-bit), and the General Call address. The General Call address detection may be enabled or disabled by software. 

Data and addresses are transferred as 8-bit bytes, MSB first. The first byte(s) following the start condition contain the address (one in 7-bit mode, two in 10-bit mode). The address is always transmitted in Master mode. 

As soon as a start condition is detected, the address is received from the SDA line and sent to the shift register. Then it is compared with the address of the interface (OAR1) and with OAR2 (if ENDUAL=1) or the General Call address (if ENGC = 1). 

In 10-bit mode, after receiving the address sequence the slave is always in Receiver mode. It will enter Transmitter mode on receiving a repeated Start condition followed by the header sequence with matching address bits and the least significant bit set (11110xx1).

If TxE is set and some data were not written in the I2C_DR register before the end of the next data transmission, the BTF bit is set and the interface waits until BTF is cleared by a read to I2C_SR1 followed by a write to the I2C_DR register, stretching SCL low.

Following the address reception and after clearing ADDR, the slave receives bytes from the SDA line into the DR register via the internal shift register. After each byte the interface generates in sequence:

If RxNE is set and the data in the DR register is not read before the end of the next data reception, the BTF bit is set and the interface waits until BTF is cleared by a read from I2C_SR1 followed by a read from the I2C_DR register, stretching SCL low (see Figure 272 Transfer sequencing).

In Master mode, the I2C interface initiates a data transfer and generates the clock signal. A serial data transfer always begins with a Start condition and ends with a Stop condition. 

The CCR bits are used to generate the high and low level of the SCL clock, starting from the generation of the rising and falling edge (respectively). As a slave may stretch the SCL line, the peripheral checks the SCL input from the bus at the end of the time programmed in TRISE bits after rising edge generation. 


• If the SCL line is low, it means that a slave is stretching the bus, and the high level counter stops until the SCL line is detected high. This allows to guarantee the minimum HIGH period of the SCL clock parameter. 

Indeed, the feedback loop from the SCL rising edge generation by the peripheral to the SCL rising edge detection by the peripheral takes time even if no slave stretches the clock. This loopback duration is linked to the SCL rising time (impacting SCL VIH input detection), plus delay due to the noise filter present on the SCL input path, plus delay due to internal SCL input synchronization with APB clock. The maximum time used by the feedback loop is programmed in the TRISE bits, so that the SCL frequency remains stable whatever the SCL rising time.

Then the master waits for a read of the SR1 register followed by a write in the DR register with the Slave address (see Figure 273 and Figure 274 Transfer sequencing EV5).

Then the master waits for a read of the SR1 register followed by a write in the DR register with the second address byte (see Figure 273 and Figure 274 Transfer sequencing). 

–To enter Receiver mode, a master sends the header (11110xx0) and then the slave address. Then it should send a repeated Start condition followed by the header (11110xx1), (where xx denotes the two most significant bits of the address).

If TxE is set and a data byte was not written in the DR register before the end of the last data transmission, BTF is set and the interface waits until BTF is cleared by a read from I2C_SR1 followed bya write to I2C_DR, stretching SCL low.

After the last byte is written to the DR register, the STOP bit is set by software to generate a Stop condition (see Figure 273 Transfer sequencing EV8_2). The interface automatically goes back to slave mode (MSL bit cleared).

Following the address transmission and after clearing ADDR, the I2C interface enters Master Receiver mode. In this mode the interface receives bytes from the SDA line into the DR register via the internal shift register. After each byte the interface generates in sequence:

If the RxNE bit is set and the data in the DR register is not read before the end of the last data reception, the BTF bit is set by hardware and the interface waits until BTF is cleared by a read in the SR1 register followed by a read in the DR register, stretching SCL low. 

The master sends a NACK for the last byte received from the slave. After receiving this NACK, the slave releases the control of the SCL and SDA lines. Then the master can send a Stop/Restart condition.

EV5: SB=1, cleared by reading SR1 register followed by writing DR register with Address.EV6: ADDR=1, cleared by reading SR1 register followed by reading SR2.EV8_1: TxE=1, shift register empty, data register empty, write Data1 in DR.EV8: TxE=1, shift register not empty, data register empty, cleared by writing DR register.EV8_2: TxE=1, BTF = 1, Program Stop request. TxE and BTF are cleared by hardware by the Stop conditionEV9: ADD10=1, cleared by reading SR1 register followed by writing DR register.

Notes: 1- The EV5, EV6, EV9, EV8_1 and EV8_2 events stretch SCL low until the end of the corresponding software sequence.           2- The EV8 software sequence must complete before the end of the current byte transfer. In case EV8 software sequence can not be managed before the current byte end of transfer, it is recommended to use BTF instead of TXE with the drawback of slowing the communication.

Method 2: This method is for the case when the I2C is used with interrupts that do not have the highest priority in the application or when the I2C is used with polling.

With this method, DataN_2 is not read, so that after DataN_1, the communication is stretched (both RxNE and BTF are set). Then, clear the ACK bit before reading DataN-2 in DR to ensure it is be cleared before the DataN Acknowledge pulse. After that, just after reading DataN_2, set the STOP/ START bit and read DataN_1. After RxNE is set, read DataN. This is illustrated below:


• BTF = 1 because both shift and data registers are full: DataN-2 in DR and DataN-1 in the shift register => SCL tied low: no other data will be received on the bus.

EV5: SB=1, cleared by reading SR1 register followed by writing the DR register.EV6: ADDR1, cleared by reading SR1 register followed by reading SR2. In 10-bit master receiver mode, this sequence should be followed by writing CR2 with START = 1.EV7: RxNE=1, cleared by reading DR registerEV7_2: BTF = 1, DataN-2 in DR and DataN-1 in shift register, program ACK = 0, Read DataN-2 in DR. Program STOP = 1, read DataN-1.

EV5: SB=1, cleared by reading SR1 register followed by writing the DR register.EV6: ADDR1, cleared by reading SR1 register followed by reading SR2. In 10-bit master receiver mode, this sequence should be followed by writing CR2 with START = 1.EV6_1: No associated flag event. The acknowledge disable should be done just after EV6, that is after ADDR is cleared.  


• In Master mode: the lines are not released and the state of the current transmission is not affected. It is up to the software to abort or not the current transmission


• the I2C Interface goes automatically back to slave mode (the MSL bit is cleared). When the I2C loses the arbitration, it is not able to acknowledge its slave address in the same transfer, but it can acknowledge it after a repeated Start from the winning master.

An overrun error can occur in slave mode when clock stretching is disabled and the I2C interface is receiving data. The interface has received a byte (RxNE=1) and the data in DR has not been read, before the next byte is received by the interface. In this case,

Underrun error can occur in slave mode when clock stretching is disabled and the I2C interface is transmitting data. The interface has not updated the DR with the next byte (TxE=1), before the clock comes for the next byte. In this case,


• The user should make sure that data received on the receiver side during an underrun error are discarded and that the next bytes are written within the clock low time specified in the I2C bus standard.

For the first byte to be transmitted, the DR must be written after ADDR is cleared and before the first SCL rising edge. If not possible, the receiver must discard the first data.

–Transmitter mode: If TxE=1 and BTF=1: the interface holds the clock line low before transmission to wait for the microcontroller to read SR1 and then write the byte in the Data Register (both buffer and shift register are empty).

–Receiver mode: If RxNE=1 and BTF=1: the interface holds the clock line low after reception to wait for the microcontroller to read SR1 and then read the byte in the Data Register (both buffer and shift register are full).

The System Management Bus (SMBus) is a two-wire interface through which various devices can communicate with each other and with the rest of the system. It is based on I2C principles of operation. SMBus provides a control bus for system and power management related tasks. A system may use SMBus to pass messages to and from devices instead of toggling individual control lines. 

The System Management Bus Specification refers to three types of devices. A slave is a device that is receiving or responding to a command. A master is a device that issues commands, generates the clocks, and terminates the transfer. A host is a specialized master that provides the main interface to the system's CPU. A host must be a master-slave and must support the SMBus host notify protocol. Only one host is allowed in a system.

With System Management Bus, a device can provide manufacturer information, tell the system what its model/part number is, save its state for a suspend event, report different types of errors, accept control parameters, and return its status. SMBus provides a control bus for system and power management related tasks. 

SMBus Alert is an optional signal with an interrupt line for devices that want to trade their ability to master for a pin. SMBA is a wired-AND signal just as the SCL and SDA signals are. SMBA is used in conjunction with the SMBus General Call Address. Messages invoked with the SMBus are two bytes long. 

A slave-only device can signal the host through SMBA that it wants to talk by setting ALERT bit in I2C_CR1 register. The host processes the interrupt and simultaneously accesses all SMBA devices through the Alert Response Address (known as ARA having a value 0001 100X). Only the device(s) which pulled SMBA low will acknowledge the Alert Response Address. This status is identified using SMBALERT Status flag in I2C_SR1 register. The host performs a modified Receive Byte operation. The 7 bit device address provided by the slave transmit device is placed in the 7 most significant bits of the byte. The eighth bit can be a zero or one.

If more than one device pulls SMBA low, the highest priority (lowest address) device will win communication rights via standard arbitration during the slave address transfer. After acknowledging the slave address the device must disengage its SMBA pull-down. If the host still sees SMBA low when the message transfer is complete, it knows to read the ARA again.A host which does not implement the SMBA signal may periodically access the ARA.

DMA requests (when enabled) are generated only for data transfer. DMA requests are generated by Data Register becoming empty in transmission and Data Register becoming full in reception. The DMA must be initialized and enabled before the I2C data transfer. The DMAEN bit must be set in the I2C_CR2 register before the ADDR event. In master mode or in slave mode when clock stretching is enabled, the DMAEN bit can also be set during the ADDR event, before clearing the ADDR flag. The DMA request must be served before the end of the current byte transfer. When the number of data transfers which has been programmed for the corresponding DMA stream is reached, the DMA controller sends an End of Transfer EOT signal to the I2C interface and generates a Transfer Complete interrupt if enabled: 


• Master receiver: when the number of bytes to be received is equal to or greater than two, the DMA controller sends a hardware signal, EOT_1, corresponding to the last but one data byte (number_of_bytes – 1). If, in the I2C_CR2 register, the LAST bit is set, I2C automatically sends a NACK after the next byte following EOT_1. The user can generate a Stop condition in the DMA Transfer Complete interrupt routine if enabled.

DMA mode can be enabled for transmission by setting the DMAEN bit in the I2C_CR2 register. Data will be loaded from a Memory area configured using the DMA peripheral (refer to the DMA specification) to the I2C_DR register whenever the TxE bit is set. To map a DMA stream x for I2C transmission (where x is the stream number), perform the following sequence:

When the number of data transfers which has been programmed in the DMA Controller registers is reached, the DMA controller sends an End of Transfer EOT/ EOT_1 signal to the I2C interface and the DMA generates an interrupt, if enabled, on the DMA stream interrupt vector.

DMA mode can be enabled for reception by setting the DMAEN bit in the I2C_CR2 register. Data will be loaded from the I2C_DR register to a Memory area configured using the DMA peripheral (refer to the DMA specification) whenever a data byte is received. To map a DMA stream x for I2C reception (where x is the stream number), perform the following sequence:

When the number of data transfers which has been programmed in the DMA Controller registers is reached, the DMA controller sends an End of Transfer EOT/ EOT_1 signal to the I2C interface and DMA generates an interrupt, if enabled, on the DMA stream interrupt vector. 

A PEC calculator has been implemented to improve the reliability of communication. The PEC is calculated by using the C(x) = x8 + x2 + x + 1 CRC-8 polynomial serially on each bit.

–In reception: set the PEC bit in the I2C_CR1 register after the RxNE event corresponding to the last byte so that the receiver sends a NACK if the next received byte is not equal to the internally calculated PEC. In case of Master-Receiver, a NACK must follow the PEC whatever the check result.The PEC must be set before the ACK pulse of the current byte reception.

–In reception: when the I2C interface receives an EOT_1 signal from the DMA controller, it will automatically consider the next byte as a PEC and will check it. A DMA request is generated after PEC reception.


• To allow intermediate PEC transfers, a control bit is available in the I2C_CR2 register (LAST bit) to determine if it is really the last DMA transfer or not. If it is the last DMA request for a master receiver, a NACK is automatically sent after the last received byte.

Bit 15 SWRST: Software resetWhen set, the I2C is under reset state. Before resetting this bit, make sure the I2C lines are released and the bus is free.0: I2C Peripheral not under reset1: I2C Peripheral under reset stateNote: This bit can be used to reinitialize the peripheral after an error or a locked state. As an example, if the BUSY bit is set and remains locked due to a glitch on the bus, the SWRST bit can be used to exit from this state.

Bit 13 ALERT: SMBus alertThis bit is set and cleared by software, and cleared by hardware when PE=0.0: Releases SMBA pin high. Alert Response Address Header followed by NACK.1: Drives SMBA pin low. Alert Response Address Header followed by ACK.

Bit 12 PEC: Packet error checkingThis bit is set and cleared by software, and cleared by hardware when PEC is transferred or by a START or Stop condition or when PE=0.0: No PEC transfer1: PEC transfer (in Tx or Rx mode)Note: PEC calculation is corrupted by an arbitration loss.

Bit 11 POS: Acknowledge/PEC Position (for data reception)This bit is set and cleared by software and cleared by hardware when PE=0.0: ACK bit controls the (N)ACK of the current byte being received in the shift register. The PEC bit indicates that current byte in shift register is a PEC.1: ACK bit controls the (N)ACK of the next byte which will be received in the shift register. The PEC bit indicates that the next byte in the shift register is a PECNote: The POS bit is used when the procedure for reception of 2 bytes (see Method 2: transfer sequence diagram for master receiver when N=2) is followed. It must be configured before data reception starts. In this case, to NACK the 2nd byte, the ACK bit must be cleared just after ADDR is cleared. To check the 2nd byte as PEC, the PEC bit must be set during the ADDR stretch event after configuring the POS bit. 

Bit 10 ACK: Acknowledge enableThis bit is set and cleared by software and cleared by hardware when PE=0.0: No acknowledge returned1: Acknowledge returned after a byte is received (matched address or data)

Bit 9 STOP: Stop generationThe bit is set and cleared by software, cleared by hardware when a Stop condition is detected, set by hardware when a timeout error is detected.In Master Mode:0: No Stop generation.1: Stop generation after the current byte transfer or after the current Start condition is sent.In Slave mode:0: No Stop generation.1: Release the SCL and SDA lines after the current byte transfer. 

Bit 8 START: Start generationThis bit is set and cleared by software and cleared by hardware when start is sent or PE=0.In Master Mode:0: No Start generation1: Repeated start generationIn Slave mode:0: No Start generation1: Start generation when the bus is free

Bit 7 NOSTRETCH: Clock stretching disable (Slave mode)This bit is used to disable clock stretching in slave mode when ADDR or BTF flag is set, until it is reset by software.0: Clock stretching enabled1: Clock stretching disabled

Note:When the STOP, START or PEC bit is set, the software must not perform any write access to I2C_CR1 before this bit is cleared by hardware. Otherwise there is a risk of setting a second STOP, START or PEC request.

Bit 0 PE: Peripheral enable0: Peripheral disable1: Peripheral enableNote: If this bit is reset while a communication is on going, the peripheral is disabled at the end of the current communication, when back to IDLE state. All bit resets due to PE=0 occur at the end of the communication.In master mode, this bit must not be reset before the end of the communication.

Bit 12 LAST: DMA last transfer0: Next DMA EOT is not the last transfer1: Next DMA EOT is the last transferNote: This bit is used in master receiver mode to permit the generation of a NACK on the last received data.

Bit 10 ITBUFEN: Buffer interrupt enable0: TxE = 1 or RxNE = 1 does not generate any interrupt.1: TxE = 1 or RxNE = 1 generates Event Interrupt (whatever the state of DMAEN)

Bit 9 ITEVTEN: Event interrupt enable0: Event interrupt disabled1: Event interrupt enabledThis interrupt is generated when:–SB = 1 (Master)–ADDR = 1 (Master/Slave)–ADD10= 1 (Master)–STOPF = 1 (Slave)–BTF = 1 with no TxE or RxNE event–TxE event to 1 if ITBUFEN = 1–RxNE event to 1if ITBUFEN = 1

Bits 7:0 DR[7:0] 8-bit data registerByte received or to be transmitted to the bus.– Transmitter mode: Byte transmission starts automatically when a byte is written in the DR register. A continuous transmit stream can be maintained if the next data to be transmitted is put in DR once the transmission is started (TxE=1)– Receiver mode: Received byte is copied into DR (RxNE=1). A continuous transmit stream can be maintained if DR is read before the next data byte is received (RxNE=1).Note: In slave mode, the address is not copied into DR.

Bit 14 TIMEOUT: Timeout or Tlow error 0: No timeout error1: SCL remained LOW for 25 ms (Timeout)orMaster cumulative clock low extend time more than 10 ms (Tlow:mext)orSlave cumulative clock low extend time more than 25 ms (Tlow:sext)– When set in slave mode: slave resets the communication and lines are released by hardware– When set in master mode: Stop condition sent by hardware– Cleared by software writing 0, or by hardware when PE=0.Note: This functionality is available only in SMBus mode.

Bit 12 PECERR: PEC Error in reception0: no PEC error: receiver returns ACK after PEC reception (if ACK=1)1: PEC error: receiver returns NACK after PEC reception (whatever ACK)Note: Cleared by software writing 0, or by hardware when PE=0.

Bit 11 OVR: Overrun/Underrun0: No overrun/underrun1: Overrun or underrun– Set by hardware in slave mode when NOSTRETCH=1 and:– In reception when a new byte is received (including ACK pulse) and the DR register has not been read yet. New received byte is lost.– In transmission when a new byte should be sent and the DR register has not been written yet. The same byte is sent twice.– Cleared by software writing 0, or by hardware when PE=0.Note: If the DR write occurs very close to SCL rising edge, the sent data is unspecified and a hold timing error occurs

Bit 9 ARLO: Arbitration lost (master mode) 0: No Arbitration Lost detected1: Arbitration Lost detectedSet by hardware when the interface loses the arbitration of the bus to another master– Cleared by software writing 0, or by hardware when PE=0.After an ARLO event the interface switches back automatically to Slave mode (MSL=0). Note: In SMBUS, the arbitration on the data in slave mode occurs only during the data phase, or the acknowledge transmission (not on the address acknowledge).

Bit 8 BERR: Bus error 0: No misplaced Start or Stop condition1: Misplaced Start or Stop condition– Set by hardware when the interface detects an SDA rising or falling edge while SCL is high, occurring in a non-valid position during a byte transfer.– Cleared by software writing 0, or by hardware when PE=0.

Bit 7 TxE: Data register empty (transmitters) 0: Data register not empty1: Data register empty– Set when DR is empty in transmission. TxE is not set during address phase.– Cleared by software writing to the DR register or by hardware after a start or a stop condition or when PE=0.TxE is not set if either a NACK is received, or if next byte to be transmitted is PEC (PEC=1)Note: TxE is not cleared by writing the first data being transmitted, or by writing data when BTF is set, as in both cases the data register is still empty.

Bit 6 RxNE: Data register not empty (receivers)0: Data register empty1: Data register not empty– Set when data register is not empty in receiver mode. RxNE is not set during address phase.– Cleared by software reading or writing the DR register or by hardware when PE=0.RxNE is not set in case of ARLO event.Note: RxNE is not cleared by reading data when BTF is set, as the data register is still full.

Bit 4 STOPF: Stop detection (slave mode) 0: No Stop condition detected1: Stop condition detected– Set by hardware when a Stop condition is detected on the bus by the slave after an acknowledge (if ACK=1). – Cleared by software reading the SR1 register followed by a write in the CR1 register, or by hardware when PE=0Note: The STOPF bit is not set after a NACK reception.It is recommended to perform the complete clearing sequence (READ SR1 then WRITE CR1) after the STOPF is set. Refer to Figure 272.

Bit 3 ADD10: 10-bit header sent (Master mode) 0: No ADD10 event occurred.1: Master has sent first address byte (header).– Set by hardware when the master has sent the first byte in 10-bit address mode. – Cleared by software reading the SR1 register followed by a write in the DR register of the second address byte, or by hardware when PE=0.Note: ADD10 bit is not set after a NACK reception

Bit 2 BTF: Byte transfer finished0: Data byte transfer not done1: Data byte transfer succeeded– Set by hardware when NOSTRETCH=0 and: – In reception when a new byte is received (including ACK pulse) and DR has not been read yet (RxNE=1).– In transmission when a new byte should be sent and DR has not been written yet (TxE=1). – Cleared by software reading SR1 followed by either a read or write in the DR register or by hardware after a start or a stop condition in transmission or when PE=0.Note: The BTF bit is not set after a NACK receptionThe BTF bit is not set if next byte to be transmitted is the PEC (TRA=1 in I2C_SR2 register and PEC=1 in I2C_CR1 register)

Note:Reading I2C_SR2 after reading I2C_SR1 clears the ADDR flag, even if the ADDR flag was set after reading I2C_SR1. Consequently, I2C_SR2 must be read only when ADDR is found set in I2C_SR1 or when the STOPF bit is cleared.

Bit 1 ADDR: Address sent (master mode)/matched (slave mode)This bit is cleared by software reading SR1 register followed reading SR2, or by hardware when PE=0.Address matched (Slave)0: Address mismatched or not received.1: Received address matched.– Set by hardware as soon as the received slave address matched with the OAR registers content or a general call or a SMBus Device Default Address or SMBus Host or SMBus Alert is recognized. (when enabled depending on configuration).Note: In slave mode, it is recommended to perform the complete clearing sequence (READ SR1 then READ SR2) after ADDR is set. Refer to Figure 272.Address sent (Master)0: No end of address transmission1: End of address transmission– For 10-bit addressing, the bit is set after the ACK of the 2nd byte.– For 7-bit addressing, the bit is set after the ACK of the byte.Note: ADDR is not set after a NACK reception

Bit 0 SB: Start bit (Master mode)0: No Start condition1: Start condition generated.– Set when a Start condition generated.– Cleared by software by reading the SR1 register followed by writing the DR register, or by hardware when PE=0

Bit 7 DUALF: Dual flag (Slave mode)0: Received address matched with OAR11: Received address matched with OAR2– Cleared by hardware after a Stop condition or repeated Start condition, or when PE=0.

Bit 6 SMBHOST: SMBus host header (Slave mode)0: No SMBus Host address1: SMBus Host address received when SMBTYPE=1 and ENARP=1.– Cleared by hardware after a Stop condition or repeated Start condition, or when PE=0.

Note:Reading I2C_SR2 after reading I2C_SR1 clears the ADDR flag, even if the ADDR flag was set after reading I2C_SR1. Consequently, I2C_SR2 must be read only when ADDR is found set in I2C_SR1 or when the STOPF bit is cleared.

Note:fPCLK1 must be at least 2 MHz to achieve Sm mode I²C frequencies. It must be at least 4 MHz to achieve Fm mode I²C frequencies. It must be a multiple of 10MHz to reach the 400 kHz maximum I²C Fm mode clock.

Bit 5 SMBDEFAULT: SMBus device default address (Slave mode) 0: No SMBus Device Default address1: SMBus Device Default address received when ENARP=1– Cleared by hardware after a Stop condition or repeated Start condition, or when PE=0.

Bit 4 GENCALL: General call address (Slave mode) 0: No General Call1: General Call Address received when ENGC=1– Cleared by hardware after a Stop condition or repeated Start condition, or when PE=0.

Bit 2 TRA: Transmitter/receiver0: Data bytes received1: Data bytes transmittedThis bit is set depending on the R/W bit of the address byte, at the end of total address phase.It is also cleared by hardware after detection of Stop condition (STOPF=1), repeated Start condition, loss of bus arbitration (ARLO=1), or when PE=0.

Bit 1 BUSY: Bus busy0: No communication on the bus1: Communication ongoing on the bus– Set by hardware on detection of SDA or SCL low – cleared by hardware on detection of a Stop condition. It indicates a communication in progress on the bus. This information is still updated when the interface is disabled (PE=0).

Bit 0 MSL: Master/slave0: Slave Mode1: Master Mode– Set by hardware as soon as the interface is in Master mode (SB=1). – Cleared by hardware after detecting a Stop condition on the bus or a loss of arbitration (ARLO=1), or by hardware when PE=0. 

Bits 11:0 CCR[11:0]: Clock control register in Fm/Sm mode (Master mode) Controls the SCL clock in master mode.Sm mode or SMBus:Thigh = CCR * TPCLK1Tlow = CCR * TPCLK1Fm mode:If DUTY = 0:Thigh = CCR * TPCLK1Tlow = 2 * CCR * TPCLK1If DUTY = 1: (to reach 400 kHz)Thigh = 9 * CCR * TPCLK1Tlow = 16 * CCR * TPCLK1For instance: in Sm mode, to generate a 100 kHz SCL frequency: If FREQR = 08, TPCLK1 = 125 ns so CCR must be programmed with 0x28(0x28 <=> 40d x 125 ns = 5000 ns.)Note: The minimum allowed value is 0x04, except in FAST DUTY mode where the minimum allowed value is 0x01thigh = tr(SCL) + tw(SCLH). See device datasheet for the definitions of parameters. tlow = tf(SCL) + tw(SCLL). See device datasheet for the definitions of parameters. I2C communication speed, fSCL ~ 1/(thigh + tlow). The real frequency may differ due to the analog noise filter input delay.The CCR register must be configured only when the I2C is disabled (PE = 0).

Bits 5:0 TRISE[5:0]: Maximum rise time in Fm/Sm mode (Master mode)These bits should provide the maximum duration of the SCL feedback loop in master mode. The purpose is to keep a stable SCL frequency whatever the SCL rising edge duration.These bits must be programmed with the maximum SCL rise time given in the I2C bus specification, incremented by 1.For instance: in Sm mode, the maximum allowed SCL rise time is 1000 ns.If, in the I2C_CR2 register, the value of FREQ[5:0] bits is equal to 0x08 and TPCLK1 = 125 ns therefore the TRISE[5:0] bits must be programmed with 09h.(1000 ns / 125 ns = 8 + 1)The filter value can also be added to TRISE[5:0].If the result is not an integer, TRISE[5:0] must be programmed with the integer part, in order to respect the tHIGH parameter.Note: TRISE[5:0] must be configured only when the I2C is disabled (PE = 0).

The universal synchronous asynchronous receiver transmitter (USART) offers a flexible means of full-duplex data exchange with external equipment requiring an industry standard NRZ asynchronous serial data format. The USART offers a very wide range of baud rates using a fractional baud rate generator.

It supports synchronous one-way communication and half-duplex single wire communication. It also supports the LIN (local interconnection network), Smartcard Protocol and IrDA (infrared data association) SIR ENDEC specifications, and modem operations (CTS/RTS). It allows multiprocessor communication.

The interface is externally connected to another device by three pins (see Figure 279). Any USART bidirectional communication requires a minimum of two pins: Receive Data In (RX) and Transmit Data Out (TX):

TX: Transmit Data Output. When the transmitter is disabled, the output pin returns to its IO port configuration. When the transmitter is enabled and nothing is to be transmitted, the TX pin is at high level. In single-wire and smartcard modes, this IO is used to transmit and receive the data (at USART level, data are then received on SW_RX).


• CK: Transmitter clock output. This pin outputs the transmitter data clock for synchronous transmission corresponding to SPI master mode (no clock pulses on start bit and stop bit, and a software option to send a clock pulse on the last data bit). In parallel data can be received synchronously on RX. This can be used to control peripherals that have shift registers (e.g. LCD drivers). The clock phase and polarity are software programmable. In Smartcard mode, CK can provide the clock to the smartcard.

An Idle character is interpreted as an entire frame of “1”s followed by the start bit of the next frame which contains data (The number of “1” ‘s will include the number of stop bits).

A Break character is interpreted on receiving “0”s for a frame period. At the end of the break frame the transmitter inserts either 1 or 2 stop bits (logic “1” bit) to acknowledge the start bit.

The transmitter can send data words of either 8 or 9 bits depending on the M bit status. When the transmit enable bit (TE) is set, the data in the transmit shift register is output on the TX pin and the corresponding clock pulses are output on the CK pin.

During a USART transmission, data shifts out least significant bit first on the TX pin. In this mode, the USART_DR register consists of a buffer (TDR) between the internal bus and the transmit shift register (see Figure 279).

Note:The TE bit should not be reset during transmission of data. Resetting the TE bit during the transmission will corrupt the data on the TX pin as the baud rate counters will get frozen. The current data being transmitted will be lost. 

A break transmission will be 10 low bits followed by the configured number of stop bits (when m = 0) and 11 low bits followed by the configured number of stop bits (when m = 1). It is not possible to transmit long breaks (break of length greater than 10/11 low bits).

When a transmission is taking place, a write instruction to the USART_DR register stores the data in the TDR register and which is copied in the shift register at the end of the current transmission.

When no transmission is taking place, a write instruction to the USART_DR register places the data directly in the shift register, the data transmission starts, and the TXE bit is immediately set.

If a frame is transmitted (after the stop bit) and the TXE bit is set, the TC bit goes high. An interrupt is generated if the TCIE bit is set in the USART_CR1 register.

After writing the last data into the USART_DR register, it is mandatory to wait for TC=1 before disabling the USART or causing the microcontroller to enter the low-power mode (see Figure 282).

If the SBK bit is set to ‘1’ a break character is sent on the TX line after completing the current character transmission. This bit is reset by hardware when the break character is completed (during the stop bit of the break character). The USART inserts a logic 1 bit at the end of the last break frame to guarantee the recognition of the start bit of the next frame.

Note:If the software resets the SBK bit before the commencement of break transmission, the break character will not be transmitted. For two consecutive breaks, the SBK bit should be set after the stop bit of the previous break.

In the USART, the start bit is detected when a specific sequence of samples is recognized. This sequence is: 1 1 1 0 X 0 X 0 X 0 0 0 0.

The start bit is confirmed (RXNE flag set, interrupt generated if RXNEIE=1) if the 3 sampled bits are at 0 (first sampling on the 3rd, 5th and 7th bits finds the 3 bits at 0 and second sampling on the 8th, 9th and 10th bits also finds the 3 bits at 0).

The start bit is validated (RXNE flag set, interrupt generated if RXNEIE=1) but the NE noise flag is set if, for both samplings, at least 2 out of the 3 sampled bits are at 0 (sampling on the 3rd, 5th and 7th bits and sampling on the 8th, 9th and 10th bits). If this condition is not met, the start detection aborts and the receiver returns to the idle state (no flag is set).

If, for one of the samplings (sampling on the 3rd, 5th and 7th bits or sampling on the 8th, 9th and 10th bits), 2 out of the 3 bits are found at 0, the start bit is validated but the NE noise flag bit is set.

During a USART reception, data shifts in least significant bit first through the RX pin. In this mode, the USART_DR register consists of a buffer (RDR) between the internal bus and the received shift register.


• The RXNE bit is set. It indicates that the content of the shift register is transferred to the RDR. In other words, data has been received and can be read (as well as its associated error flags).


• In single buffer mode, clearing the RXNE bit is performed by a software read to the USART_DR register. The RXNE flag can also be cleared by writing a zero to it. The RXNE bit must be cleared before the end of the reception of the next character to avoid an overrun error.

An overrun error occurs when a character is received when RXNE has not been reset. Data can not be transferred from the shift register to the RDR register until the RXNE bit is cleared.

The RXNE flag is set after every byte received. An overrun error occurs if RXNE flag is set when the next data is received or the previous DMA request has not been serviced. When an overrun error occurs: 


• if RXNE=0, then it means that the last valid data has already been read and thus there is nothing to be read in the RDR. This case can occur when the last valid data is read in the RDR at the same time as the new (and lost) data is received. It may also occur when the new data is received during the reading sequence (between the USART_SR register read access and the USART_DR read access).


• No interrupt is generated in case of single byte communication. However this bit rises at the same time as the RXNE bit which itself generates an interrupt. In case of multibuffer communication an interrupt will be issued if the EIE bit is set in the USART_CR3 register.


• No interrupt is generated in case of single byte communication. However this bit rises at the same time as the RXNE bit which itself generates an interrupt. In case of multibuffer communication an interrupt will be issued if the EIE bit is set in the USART_CR3 register.

The number of stop bits to be received can be configured through the control bits of Control Register 2 - it can be either 1 or 2 in normal mode and 0.5 or 1.5 in Smartcard mode.

Note:The figures specified in Table 193 and Table 194 may slightly differ in the special case when the received frames contain some Idle frames of exactly 10-bit times when M=0 (11-bit times when M=1).

There is a possibility of performing multiprocessor communication with the USART (several USARTs connected in a network). For instance, one of the USARTs can be the master, its TX output is connected to the RX input of the other USART. The others are slaves, their respective TX outputs are logically ANDed together and connected to the RX input of the master.

In multiprocessor configurations it is often desirable that only the intended message recipient should actively receive the full message contents, thus reducing redundant USART service overhead for all non addressed receivers.

It wakes up when an Idle frame is detected. Then the RWU bit is cleared by hardware but the IDLE bit is not set in the USART_SR register. RWU can also be written to 0 by software.

In this mode, bytes are recognized as addresses if their MSB is a ‘1’ else they are considered as data. In an address byte, the address of the targeted receiver is put on the 4 LSB. This 4-bit word is compared by the receiver with its own address which is programmed in the ADD bits in the USART_CR2 register.

The USART enters mute mode when an address character is received which does not match its programmed address. In this case, the RWU bit is set by hardware. The RXNE flag is not set for this address byte and no interrupt nor DMA request is issued as the USART would have entered mute mode.

It exits from mute mode when an address character is received which matches the programmed address. Then the RWU bit is cleared and subsequent bytes are received normally. The RXNE bit is set for the address character since the RWU bit has been cleared.

Parity control (generation of parity bit in transmission and parity checking in reception) can be enabled by setting the PCE bit in the USART_CR1 register. Depending on the frame length defined by the M bit, the possible USART frame formats are as listed in Table 195.

Even parity: the parity bit is calculated to obtain an even number of “1s” inside the frame made of the 7 or 8 LSB bits (depending on whether M is equal to 0 or 1) and the parity bit.

Odd parity: the parity bit is calculated to obtain an odd number of “1s” inside the frame made of the 7 or 8 LSB bits (depending on whether M is equal to 0 or 1) and the parity bit.

Transmission mode: If the PCE bit is set in USART_CR1, then the MSB bit of the data written in the data register is transmitted but is changed by the parity bit (even number of “1s” if even parity is selected (PS=0) or an odd number of “1s” if odd parity is selected (PS=1)). If the parity check fails, the PE flag is set in the USART_SR register and an interrupt is generated if PEIE is set in the USART_CR1 register.


• Set the LINEN bit to enter LIN mode. In this case, setting the SBK bit sends 13 ‘0’ bits as a break character. Then a bit of value ‘1’ is sent to allow the next start detection.

A break detection circuit is implemented in the USART. The detection is totally independent from the normal USART receiver. A break can be detected whenever it occurs, during idle state or during a frame.

When the receiver is enabled (RE=1 in USART_CR1), the circuit looks at the RX input for a start signal. The method for detecting start bits is the same when searching break characters or data. After a start bit has been detected, the circuit samples the next bits exactly like for the data (on the 8th, 9th and 10th samples). If 10 (when the LBDL = 0 in USART_CR2) or 11 (when LBDL=1 in USART_CR2) consecutive bits are detected as ‘0’, and are followed by a delimiter character, the LBD flag is set in USART_SR. If the LBDIE bit=1, an interrupt is generated. Before validating the break, the delimiter is checked for as it signifies that the RX line has returned to a high level.

If the LIN mode is enabled (LINEN=1), as soon as a framing error occurs (i.e. stop bit detected at ‘0’, which will be the case for any break frame), the receiver stops until the break detection circuit receives either a ‘1’, if the break word was not complete, or a delimiter character if a break has been detected.

The USART allows the user to control a bidirectional synchronous serial communications in master mode. The CK pin is the output of the USART transmitter clock. No clock pulses are sent to the CK pin during start bit and stop bit. Depending on the state of the LBCL bit in the USART_CR2 register clock pulses will or will not be generated during the last valid data bit (address mark). The CPOL bit in the USART_CR2 register allows the user to select the clock polarity, and the CPHA bit in the USART_CR2 register allows the user to select the phase of the external clock (see Figure 289, Figure 290 and Figure 291).

In this mode the USART receiver works in a different manner compared to the asynchronous mode. If RE=1, the data is sampled on CK (rising or falling edge, depending on CPOL and CPHA), without any oversampling. A setup and a hold time must be respected (which depends on the baud rate: 1/16 bit time).

Note:The CK pin works in conjunction with the TX pin. Thus, the clock is provided only if the transmitter is enabled (TE=1) and a data is being transmitted (the data register USART_DR 

The LBCL, CPOL and CPHA bits have to be selected when both the transmitter and the receiver are disabled (TE=RE=0) to ensure that the clock pulses function correctly. These bits should not be changed while the transmitter or the receiver is enabled.

The USART can be configured to follow a single-wire half-duplex protocol. In single-wire half-duplex mode, the TX and RX pins are connected internally. The selection between half- and full-duplex communication is made with a control bit ‘HALF DUPLEX SEL’ (HDSEL in USART_CR3).


• TX is always released when no data is transmitted. Thus, it acts as a standard IO in idle or in reception. It means that the IO must be configured so that TX is configured as floating input (or output high open-drain) when not driven by the USART.

Apart from this, the communications are similar to what is done in normal USART mode. The conflicts on the line must be managed by the software (by the use of a centralized arbiter, for instance). In particular, the transmission is never blocked by hardware and continue to occur as soon as a data is written in the data register while the TE bit is set.

Note:It is also possible to choose 0.5 stop bit for receiving but it is recommended to use 1.5 stop bits for both transmitting and receiving to avoid switching between the two configurations.


• Transmission of data from the transmit shift register is guaranteed to be delayed by a minimum of 1/2 baud clock. In normal operation a full transmit shift register will start shifting on the next baud clock edge. In Smartcard mode this transmission is further delayed by a guaranteed 1/2 baud clock.


• If a parity error is detected during reception of a frame programmed with a 0.5 or 1.5 stop bit period, the transmit line is pulled low for a baud clock period after the completion of the receive frame. This is to indicate to the Smartcard that the data transmitted to USART has not been correctly received. This NACK signal (pulling transmit line low for 1 baud clock) will cause a framing error on the transmitter side (configured with 1.5 stop bits). The application can handle re-sending of data according to the protocol. A parity error is ‘NACK’ed by the receiver if the NACK control bit is set, otherwise a NACK is not transmitted.


• The assertion of the TC flag can be delayed by programming the Guard Time register. In normal operation, TC is asserted when the transmit shift register is empty and no further transmit requests are outstanding. In Smartcard mode an empty transmit shift register triggers the guard time counter to count up to the programmed value in the Guard Time register. TC is forced low during this time. When the guard time counter reaches the programmed value TC is asserted high.


• If a framing error is detected on the transmitter end (due to a NACK from the receiver), the NACK will not be detected as a start bit by the receive block of the transmitter. According to the ISO protocol, the duration of the received NACK can be 1 or 2 baud clock periods.

Figure 294 details how the NACK signal is sampled by the USART. In this example, the USART transmits a data and is configured with 1.5 stop bits. The receiver part of the USART is enabled in order to check the integrity of the data and the NACK signal.

The USART can provide a clock to the smartcard through the CK output. In Smartcard mode, CK is not associated to the communication but is simply derived from the internal peripheral input clock through a 5-bit prescaler. The division ratio is configured in the prescaler register USART_GTPR. CK frequency can be programmed from fCK/2 to fCK/62, where fCK is the peripheral input clock.

The SIR Transmit encoder modulates the Non Return to Zero (NRZ) transmit bit stream output from USART. The output pulse stream is transmitted to an external output driver and infrared LED. USART supports only bit rates up to 115.2Kbps for the SIR ENDEC. In normal mode the transmitted pulse width is specified as 3/16 of a bit period.

The SIR receive decoder demodulates the return-to-zero bit stream from the infrared detector and outputs the received NRZ serial bit stream to USART. The decoder input is normally HIGH (marking state) in the idle state. The transmit encoder output has the opposite polarity to the decoder input. A start bit is detected when the decoder input is low.


• IrDA is a half duplex communication protocol. If the Transmitter is busy (i.e. the USARTsends data to the IrDA encoder), any data on the IrDA receive line is ignored by the IrDA decoder and if the Receiver is busy (USART receives decoded data from the USART), data on the TX from the USART to IrDA is not encoded by IrDA. While receiving data, transmission should be avoided as the data to be transmitted could be corrupted.


• A ‘0’ is transmitted as a high pulse and a ‘1’ is transmitted as a ‘0’. The width of the pulse is specified as 3/16th of the selected bit period in normal mode (see Figure 296).


• The IrDA specification requires the acceptance of pulses greater than 1.41 us. The acceptable pulse width is programmable. Glitch detection logic on the receiver end filters out pulses of width less than 2 PSC periods (PSC is the prescaler value programmed in the IrDA low-power Baud Register, USART_GTPR). Pulses of width less than 1 PSC period are always rejected, but those of width greater than one and less than two periods may be accepted or rejected, those greater than 2 periods will be accepted as a pulse. The IrDA encoder/decoder doesn’t work when PSC=0.

In low-power mode the pulse width is not maintained at 3/16 of the bit period. Instead, the width of the pulse is 3 times the low-power baud rate which can be a minimum of 1.42 MHz. Generally this value is 1.8432 MHz (1.42 MHz < PSC< 2.12 MHz). A low-power mode programmable divisor divides the system clock to achieve this value.

Receiving in low-power mode is similar to receiving in normal mode. For glitch detection, the USART should discard pulses of duration shorter than 1/PSC. A valid low is accepted only if its duration is greater than 2 periods of the IrDA low-power Baud clock (PSC value in USART_GTPR).

The receiver set up time should be managed by software. The IrDA physical layer specification specifies a minimum of 10 ms delay between transmission and reception (IrDA is a half duplex protocol).

DMA mode can be enabled for transmission by setting DMAT bit in the USART_CR3 register. Data is loaded from a SRAM area configured using the DMA peripheral (refer to the DMA specification) to the USART_DR register whenever the TXE bit is set. To map a DMA channel for USART transmission, use the following procedure (x denotes the channel number):

In transmission mode, once the DMA has written all the data to be transmitted (the TCIF flag is set in the DMA_ISR register), the TC flag can be monitored to make sure that the USART communication is complete. This is required to avoid corrupting the last transmission before disabling the USART or entering the Stop mode. The software must wait until TC=1. The TC flag remains cleared during all data transfers and it is set by hardware at the last frame’s end of transmission.

DMA mode can be enabled for reception by setting the DMAR bit in USART_CR3 register. Data is loaded from the USART_DR register to a SRAM area configured using the DMA peripheral (refer to the DMA specification) whenever a data byte is received. To map a DMA channel for USART reception, use the following procedure:

In case of multibuffer communication if any error occurs during the transaction the error flag will be asserted after the current byte. An interrupt will be generated if the interrupt enable flag is set. For framing error, overrun error and noise flag which are asserted with RXNE in case of single byte reception, there will be separate error flag interrupt enable bit (EIE bit in the USART_CR3 register), which if set will issue an interrupt after the current byte with either of these errors.

It is possible to control the serial data flow between two devices by using the CTS input and the RTS output. Figure 299 shows how to connect two devices in this mode:

If the RTS flow control is enabled (RTSE=1), then RTS is asserted (tied low) as long as the USART receiver is ready to receive new data. When the receive register is full, RTS is deasserted, indicating that the transmission is expected to stop at the end of the current frame. Figure 300 shows an example of communication with RTS flow control enabled.

If the CTS flow control is enabled (CTSE=1), then the transmitter checks the CTS input before transmitting the next frame. If CTS is asserted (tied low), then the next data is transmitted (assuming that a data is to be transmitted, in other words, if TXE=0), else the transmission does not occur. When CTS is deasserted during a transmission, the current transmission is completed before the transmitter stops.

When CTSE=1, the CTSIF status bit is automatically set by hardware as soon as the CTS input toggles. It indicates when the receiver becomes ready or not ready for communication. An interrupt is generated if the CTSIE bit in the USART_CR3 register is set. The figure below shows an example of communication with CTS flow control enabled.


• While receiving: Idle Line detection, Overrun error, Receive Data register not empty, Parity error, LIN break detection, Noise Flag (only in multi buffer communication) and Framing Error (only in multi buffer communication).

Bit 9 CTS: CTS flagThis bit is set by hardware when the CTS input toggles, if the CTSE bit is set. It is cleared by software (by writing it to 0). An interrupt is generated if CTSIE=1 in the USART_CR3 register.0: No change occurred on the CTS status line1: A change occurred on the CTS status lineThis bit is not available for UART4 & UART5.

Bit 8 LBD: LIN break detection flagThis bit is set by hardware when the LIN break is detected. It is cleared by software (by writing it to 0). An interrupt is generated if LBDIE = 1 in the USART_CR2 register.0: LIN Break not detected1: LIN break detectedNote: An interrupt is generated when LBD=1 if LBDIE=1

Bit 7 TXE: Transmit data register emptyThis bit is set by hardware when the content of the TDR register has been transferred into the shift register. An interrupt is generated if the TXEIE bit =1 in the USART_CR1 register. It is cleared by a write to the USART_DR register.0: Data is not transferred to the shift register1: Data is transferred to the shift register)Note: This bit is used during single buffer transmission.

Bit 6 TC: Transmission completeThis bit is set by hardware if the transmission of a frame containing data is complete and if TXE is set. An interrupt is generated if TCIE=1 in the USART_CR1 register. It is cleared by a software sequence (a read from the USART_SR register followed by a write to the USART_DR register). The TC bit can also be cleared by writing a '0' to it. This clearing sequence is recommended only for multibuffer communication.0: Transmission is not complete1: Transmission is complete

Bit 5 RXNE: Read data register not emptyThis bit is set by hardware when the content of the RDR shift register has been transferred to the USART_DR register. An interrupt is generated if RXNEIE=1 in the USART_CR1 register. It is cleared by a read to the USART_DR register. The RXNE flag can also be cleared by writing a zero to it. This clearing sequence is recommended only for multibuffer communication.0: Data is not received1: Received data is ready to be read.

Bit 4 IDLE: IDLE line detectedThis bit is set by hardware when an Idle Line is detected. An interrupt is generated if the IDLEIE=1 in the USART_CR1 register. It is cleared by a software sequence (an read to the USART_SR register followed by a read to the USART_DR register). 0: No Idle Line is detected1: Idle Line is detectedNote: The IDLE bit will not be set again until the RXNE bit has been set itself (i.e. a new idle line occurs).

Bit 3 ORE: Overrun errorThis bit is set by hardware when the word currently being received in the shift register is ready to be transferred into the RDR register while RXNE=1. An interrupt is generated if RXNEIE=1 in the USART_CR1 register. It is cleared by a software sequence (an read to the USART_SR register followed by a read to the USART_DR register).0: No Overrun error1: Overrun error is detectedNote: When this bit is set, the RDR register content will not be lost but the shift register will be overwritten. An interrupt is generated on ORE flag in case of Multi Buffer communication if the EIE bit is set.

Bit 2 NE: Noise error flagThis bit is set by hardware when noise is detected on a received frame. It is cleared by a software sequence (an read to the USART_SR register followed by a read to the USART_DR register).0: No noise is detected1: Noise is detectedNote: This bit does not generate interrupt as it appears at the same time as the RXNE bit which itself generates an interrupting interrupt is generated on NE flag in case of Multi Buffer communication if the EIE bit is set.

Bit 1 FE: Framing errorThis bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by a software sequence (an read to the USART_SR register followed by a read to the USART_DR register).0: No Framing error is detected1: Framing error or break character is detectedNote: This bit does not generate interrupt as it appears at the same time as the RXNE bit which itself generates an interrupt. If the word currently being transferred causes both frame error and overrun error, it will be transferred and only the ORE bit will be set.An interrupt is generated on FE flag in case of Multi Buffer communication if the EIE bit is set.

Bit 0 PE: Parity errorThis bit is set by hardware when a parity error occurs in receiver mode. It is cleared by a software sequence (a read to the status register followed by a read to the USART_DR data register). The software must wait for the RXNE flag to be set before clearing the PE bit.An interrupt is generated if PEIE = 1 in the USART_CR1 register.0: No parity error1: Parity error

Bits 8:0 DR[8:0]: Data valueContains the Received or Transmitted data character, depending on whether it is read from or written to.The Data register performs a double function (read and write) since it is composed of two registers, one for transmission (TDR) and one for reception (RDR)The TDR register provides the parallel interface between the internal bus and the output shift register (see Figure 1).The RDR register provides the parallel interface between the input shift register and the internal bus.When transmitting with the parity enabled (PCE bit set to 1 in the USART_CR1 register), the value written in the MSB (bit 7 or bit 8 depending on the data length) has no effect because it is replaced by the parity.When receiving with the parity enabled, the value read in the MSB bit is the received parity bit.

Bit 13 UE: USART enableWhen this bit is cleared the USART prescalers and outputs are stopped and the end of the currentbyte transfer in order to reduce power consumption. This bit is set and cleared by software.0: USART prescaler and outputs disabled1: USART enabled

Bit 12 M: Word lengthThis bit determines the word length. It is set or cleared by software.0: 1 Start bit, 8 Data bits, n Stop bit1: 1 Start bit, 9 Data bits, n Stop bitNote: The M bit must not be modified during a data transfer (both transmission and reception)

Bit 10 PCE: Parity control enableThis bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit if M=0) and parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission).0: Parity control disabled1: Parity control enabled

Bit 9 PS: Parity selectionThis bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity will be selected after the current byte.0: Even parity1: Odd parity

Bit 3 TE: Transmitter enableThis bit enables the transmitter. It is set and cleared by software. 0: Transmitter is disabled1: Transmitter is enabledNote: 1: During transmission, a “0” pulse on the TE bit (“0” followed by “1”) sends a preamble (idle line) after the current word, except in Smartcard mode.2: When TE is set there is a 1 bit-time delay before the transmission starts.

Bit 1 RWU: Receiver wakeupThis bit determines if the USART is in mute mode or not. It is set and cleared by software and can be cleared by hardware when a wakeup sequence is recognized. 0: Receiver in active mode1: Receiver in mute modeNote: 1: Before selecting Mute mode (by setting the RWU bit) the USART must first receive a data byte, otherwise it cannot function in Mute mode with wakeup by Idle line detection.2: In Address Mark Detection wakeup configuration (WAKE bit=1) the RWU bit cannot be modified by software while the RXNE bit is set.

Bit 0 SBK: Send breakThis bit set is used to send break characters. It can be set and cleared by software. It should be set by software, and will be reset by hardware during the stop bit of break.0: No break character is transmitted1: Break character will be transmitted

Bit 14 LINEN: LIN mode enableThis bit is set and cleared by software.0: LIN mode disabled1: LIN mode enabledThe LIN mode enables the capability to send LIN Synch Breaks (13 low bits) using the SBK bit in the USART_CR1 register, and to detect LIN Sync breaks.

Bits 13:12 STOP: STOP bitsThese bits are used for programming the stop bits.00: 1 Stop bit01: 0.5 Stop bit10: 2 Stop bits11: 1.5 Stop bitThe 0.5 Stop bit and 1.5 Stop bit are not available for UART4 & UART5.

Bit 10 CPOL: Clock polarityThis bit allows the user to select the polarity of the clock output on the CK pin in synchronous mode. It works in conjunction with the CPHA bit to produce the desired clock/data relationship 0: Steady low value on CK pin outside transmission window.1: Steady high value on CK pin outside transmission window.This bit is not available for UART4 & UART5.

Bit 9 CPHA: Clock phaseThis bit allows the user to select the phase of the clock output on the CK pin in synchronous mode. It works in conjunction with the CPOL bit to produce the desired clock/data relationship (see figures 290 to 291)0: The first clock transition is the first data capture edge.1: The second clock transition is the first data capture edge.This bit is not available for UART4 & UART5.

Bit 8 LBCL: Last bit clock pulseThis bit allows the user to select whether the clock pulse associated with the last data bit transmitted (MSB) has to be output on the CK pin in synchronous mode. 0: The clock pulse of the last data bit is not output to the CK pin1: The clock pulse of the last data bit is output to the CK pinThe last bit is the 8th or 9th data bit transmitted depending on the 8 or 9 bit format selected by the M bit in the USART_CR1 register.This bit is not available for UART4 & UART5.

Bits 3:0 ADD[3:0]: Address of the USART nodeThis bit-field gives the address of the USART node.This is used in multiprocessor communication during mute mode, for wake up with address mark detection.

Bit 9 CTSE: CTS enable0: CTS hardware flow control disabled1: CTS mode enabled, data is only transmitted when the CTS input is asserted (tied to 0). If the CTS input is deasserted while a data is being transmitted, then the transmission is completed before stopping. If a data is written into the data register while CTS is deasserted, the transmission is postponed until CTS is asserted.This bit is not available for UART4 & UART5.

Bit 8 RTSE: RTS enable0: RTS hardware flow control disabled1: RTS interrupt enabled, data is only requested when there is space in the receive buffer. The transmission of data is expected to cease after the current character has been transmitted. The RTS output is asserted (tied to 0) when a data can be received.This bit is not available for UART4 & UART5.

Bit 0 EIE: Error interrupt enableError Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error or noise error (FE=1 or ORE=1 or NE=1 in the USART_SR register) in case of Multi Buffer Communication (DMAR=1 in the USART_CR3 register).0: Interrupt is inhibited1: An interrupt is generated whenever DMAR=1 in the USART_CR3 register and FE=1 or ORE=1 or NE=1 in the USART_SR register.

Bits 15:8 GT[7:0]: Guard time valueThis bit-field gives the Guard time value in terms of number of baud clocks.This is used in Smartcard mode. The Transmission Complete flag is set after this guard time value.This bit is not available for UART4 & UART5.

The OTG_FS is a dual-role device (DRD) controller that supports both device and host functions and is fully compliant with the On-The-Go Supplement to the USB 2.0 Specification. It can also be configured as a host-only or device-only controller, fully compliant with the USB 2.0 Specification. In host mode, the OTG_FS supports full-speed (FS, 12 Mbits/s) and low-speed (LS, 1.5 Mbits/s) transfers whereas in device mode, it only supports full-speed (FS, 12 Mbits/s) transfers. The OTG_FS supports both HNP and SRP. The only external device required is a charge pump for VBUS in host mode.

The USB OTG FS receives the 48 MHz ±0.25% clock from the reset and clock controller (RCC), via an external quartz. The USB clock is used for driving the 48 MHz domain at full-speed (12 Mbit/s) and must be enabled prior to configuring the OTG FS core.

The CPU reads and writes from/to the OTG FS core registers through the AHB peripheral bus. It is informed of USB events through the single USB OTG interrupt line described in Section 28.15: OTG_FS interrupts.

The CPU submits data over the USB by writing 32-bit words to dedicated OTG_FS locations (push registers). The data are then automatically stored into Tx-data FIFOs configured within the USB data RAM. There is one Tx-FIFO push register for each in-endpoint (peripheral mode) or out-channel (host mode).

The CPU receives the data from the USB by reading 32-bit words from dedicated OTG_FS addresses (pop registers). The data are then automatically retrieved from a shared Rx-FIFO configured within the 1.25 KB USB data RAM. There is one Rx-FIFO pop register for each out-endpoint or in-channel.

The embedded full-speed OTG PHY is controlled by the OTG FS core and conveys USB control & data signals through the full-speed subset of the UTMI+ Bus (UTMIFS). It provides the physical support to USB connectivity.The full-speed OTG PHY includes the following components:


• DP/DM integrated pull-up and pull-down resistors controlled by the OTG_FS core depending on the current role of the device. As a peripheral, it enables the DP pull-up resistor to signal full-speed peripheral connections as soon as VBUS is sensed to be at a valid level (B-session valid). In host mode, pull-down resistors are enabled on both DP/DM. Pull-up and pull-down resistors are dynamically switched when the device’s role is changed via the host negotiation protocol (HNP).


• VBUS sensing comparators with hysteresis used to detect VBUS Valid, A-B Session Valid and session-end voltage thresholds. They are used to drive the session request protocol (SRP), detect valid startup and end-of-session conditions, and constantly monitor the VBUS supply during USB operations.

The host or peripheral (the default) role is assumed depending on the ID input pin (OTG_FS_ID). The ID line status is determined on plugging in the USB, depending on which side of the USB cable is connected to the micro-AB receptacle.

The HNP capable bit in the Global USB configuration register (HNPCAP bit in OTG_FS_ GUSBCFG) enables the OTG_FS core to dynamically change its role from A-host to A-peripheral and vice-versa, or from B-Peripheral to B-host and vice-versa according to the host negotiation protocol (HNP). The current device status can be read by the combined values of the Connector ID Status bit in the Global OTG control and status register (CIDSTS bit in OTG_FS_GOTGCTL) and the current mode of operation bit in the global interrupt and status register (CMOD bit in OTG_FS_GINTSTS).

The SRP capable bit in the global USB configuration register (SRPCAP bit in OTG_FS_GUSBCFG) enables the OTG_FS core to switch off the generation of VBUS for the A-device to save power. Note that the A-device is always in charge of driving VBUS regardless of the host or peripheral role of the OTG_FS.

The SRP capable bit in the Global USB configuration register (SRPCAP bit in OTG_FS_GUSBCFG) enables the OTG_FS to support the session request protocol (SRP). In this way, it allows the remote A-device to save power by switching off VBUS while the USB session is suspended.

The VBUS input also ensures that valid VBUS levels are supplied by the host during USB operations. If a drop in VBUS below B-session valid happens to be detected (for instance because of a power disturbance or if the host port has been switched off), the OTG_FS automatically disconnects and the session end detected (SEDET bit in OTG_FS_GOTGINT) interrupt is generated to notify that the OTG_FS has exited the powered state.

In the powered state, the OTG_FS expects to receive some reset signaling from the host. No other USB operation is possible. When a reset signaling is received the reset detected interrupt (USBRST in OTG_FS_GINTSTS) is generated. When the reset signaling is complete, the enumeration done interrupt (ENUMDNE bit in OTG_FS_GINTSTS) is generated and the OTG_FS enters the Default state.

The powered state can be exited by software with the soft disconnect feature. The DP pull-up resistor is removed by setting the soft disconnect bit in the device control register (SDIS bit in OTG_FS_DCTL), causing a device disconnect detection interrupt on the host side even though the USB cable was not really removed from the host port.

In the Default state the OTG_FS expects to receive a SET_ADDRESS command from the host. No other USB operation is possible. When a valid SET_ADDRESS command is decoded on the USB, the application writes the corresponding number into the device address field in the device configuration register (DAD bit in OTG_FS_DCFG). The OTG_FS then enters the address state and is ready to answer host transactions at the configured USB address.

The OTG_FS peripheral constantly monitors the USB activity. After counting 3 ms of USB idleness, the early suspend interrupt (ESUSP bit in OTG_FS_GINTSTS) is issued, and confirmed 3 ms later, if appropriate, by the suspend interrupt (USBSUSP bit in OTG_FS_GINTSTS). The device suspend bit is then automatically set in the device status register (SUSPSTS bit in OTG_FS_DSTS) and the OTG_FS enters the suspended state.

The suspended state may optionally be exited by the device itself. In this case the application sets the remote wakeup signaling bit in the device control register (RWUSIG bit in OTG_FS_DCTL) and clears it after 1 to 15 ms.

–Support for incomplete isochronous IN transfer interrupt (IISOIXFR bit in OTG_FS_GINTSTS), asserted when there is at least one isochronous IN endpoint on which the transfer is not completed in the current frame. This interrupt is asserted along with the end of periodic frame interrupt (OTG_FS_GINTSTS/EOPF).

–Support for incomplete isochronous OUT transfer interrupt (INCOMPISOOUT bit in OTG_FS_GINTSTS), asserted when there is at least one isochronous OUT endpoint on which the transfer is not completed in the current frame. This interrupt is asserted along with the end of periodic frame interrupt (OTG_FS_GINTSTS/EOPF).

The device endpoint-x transfer size registers (DIEPTSIZx/DOEPTSIZx) allow the application to program the transfer size parameters and read the transfer status. Programming must be done before setting the endpoint enable bit in the endpoint control register. Once the endpoint is enabled, these fields are read-only as the OTG FS core updates them with the current transfer status.

The device endpoint-x interrupt registers (DIEPINTx/DOPEPINTx) indicate the status of an endpoint with respect to USB- and AHB-related events. The application must read these registers when the OUT endpoint interrupt bit or the IN endpoint interrupt bit in the core interrupt register (OEPINT bit in OTG_FS_GINTSTS or IEPINT bit in OTG_FS_GINTSTS, respectively) is set. Before the application can read these registers, it must first read the device all endpoints interrupt (OTG_FS_DAINT) register to get the exact endpoint number for the device endpoint-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the DAINT and GINTSTS registers

–If the ID line is present, functional and connected to the A-side of the USB cable, and the HNP-capable bit is cleared in the Global USB Configuration register (HNPCAP bit in OTG_FS_GUSBCFG). Integrated pull-down resistors are automatically set on the DP/DM lines.

–The force host mode bit in the global USB configuration register (FHMOD bit in OTG_FS_GUSBCFG) forces the OTG_FS core to work as a USB host-only. In this case, the ID line is ignored even if present on the USB connector. Integrated pull-down resistors are automatically set on the DP/DM lines.

Note:On-chip 5 V VBUS generation is not supported. For this reason, a charge pump or, if 5 V are available on the application board, a basic power switch must be added externally to drive the 5 V VBUS line. The external charge pump can be driven by any GPIO output. This is required for the OTG A-host, A-device and host-only configurations.

The VBUS input ensures that valid VBUS levels are supplied by the charge pump during USB operations while the charge pump overcurrent output can be input to any GPIO pin configured to generate port interrupts. The overcurrent ISR must promptly disable the VBUS generation.

SRP support is available through the SRP capable bit in the global USB configuration register (SRPCAP bit in OTG_FS_GUSBCFG). With the SRP feature enabled, the host can save power by switching off the VBUS power while the USB session is suspended.

On-chip 5 V VBUS generation is not supported. For this reason, a charge pump or, if 5 V are available on the application board, a basic power switch, must be added externally to drive the 5 V VBUS line. The external charge pump can be driven by any GPIO output. When the application decides to power on VBUS using the chosen GPIO, it must also set the port power bit in the host port control and status register (PPWR bit in OTG_FS_HPRT).

When HNP or SRP is enabled the VBUS sensing pin (PA9) pin should be connected to VBUS. The VBUS input ensures that valid VBUS levels are supplied by the charge pump during USB operations. Any unforeseen VBUS voltage drop below the VBUS valid threshold (4.25 V) leads to an OTG interrupt triggered by the session end detected bit (SEDET bit in OTG_FS_GOTGINT). The application is then required to remove the VBUS power and clear the port power bit. 

The charge pump overcurrent flag can also be used to prevent electrical damage. Connect the overcurrent flag output from the charge pump to any GPIO input and configure it to generate a port interrupt on the active level. The overcurrent ISR must promptly disable the VBUS generation and clear the port power bit.

If SRP or HNP are enabled, even if USB peripherals or B-devices can be attached at any time, the OTG_FS will not detect any bus connection until the end of the VBUS sensing (VBUS over 4.75 V). When VBUS is at a valid level and a remote B-device is attached, the OTG_FS core issues a host port interrupt triggered by the device connected bit in the host port control and status register (PCDET bit in OTG_FS_HPRT).

When HNP and SRP are both disabled, USB peripherals or B-device are detected as soon as they are connected. The OTG_FS core issues a host port interrupt triggered by the device connected bit in the host port control and status (PCDET bit in OTG_FS_HPRT).

Before starting to drive a USB reset, the application waits for the OTG interrupt triggered by the debounce done bit (DBCDNE bit in OTG_FS_GOTGINT), which indicates that the bus is stable again after the electrical debounce caused by the attachment of a pull-up resistor on DP (FS) or DM (LS).

The application drives a USB reset signaling (single-ended zero) over the USB by keeping the port reset bit set in the host port control and status register (PRST bit in OTG_FS_HPRT) for a minimum of 10 ms and a maximum of 20 ms. The application takes care of the timing count and then of clearing the port reset bit.

Once the USB reset sequence has completed, the host port interrupt is triggered by the port enable/disable change bit (PENCHNG bit in OTG_FS_HPRT). This informs the application that the speed of the enumerated peripheral can be read from the port speed field in the host port control and status register (PSPD bit in OTG_FS_HPRT) and that the host is starting to drive SOFs (FS) or Keep alives (LS). The host is now ready to complete the peripheral enumeration by sending peripheral configuration commands.

The application decides to suspend the USB activity by setting the port suspend bit in the host port control and status register (PSUSP bit in OTG_FS_HPRT). The OTG_FS core stops sending SOFs and enters the suspended state.

The suspended state can be optionally exited on the remote device’s initiative (remote wakeup). In this case the remote wakeup interrupt (WKUPINT bit in OTG_FS_GINTSTS) is generated upon detection of a remote wakeup signaling, the port resume bit in the host port control and status register (PRES bit in OTG_FS_HPRT) self-sets, and resume signaling is automatically driven over the USB. The application must time the resume window and then clear the port resume bit to exit the suspended state and restart the SOF.

If the suspended state is exited on the host initiative, the application must set the port resume bit to start resume signaling on the host port, time the resume window and finally clear the port resume bit.

The OTG_FS core instantiates 8 host channels. Each host channel supports an USB host transfer (USB pipe). The host is not able to support more than 8 transfer requests at the same time. If more than 8 transfer requests are pending from the application, the host controller driver (HCD) must re-allocate channels when they become available from previous duty, that is, after receiving the transfer completed and channel halted interrupts.

Each host channel can be configured to support in/out and any type of periodic/nonperiodic transaction. Each host channel makes us of proper control (HCCHARx), transfer configuration (HCTSIZx) and status/interrupt (HCINTx) registers with associated mask (HCINTMSKx) registers.

The host channel transfer size registers (HCTSIZx) allow the application to program the transfer size parameters, and read the transfer status. Programming must be done before setting the channel enable bit in the host channel characteristics register. Once the endpoint is enabled the packet count field is read-only as the OTG FS core updates it according to the current transfer status.

The host channel-x interrupt register (HCINTx) indicates the status of an endpoint with respect to USB- and AHB-related events. The application must read these register when the host channels interrupt bit in the core interrupt register (HCINT bit in OTG_FS_GINTSTS) is set. Before the application can read these registers, it must first read the host all channels interrupt (HCAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the 

The host core features a built-in hardware scheduler which is able to autonomously re-order and manage the USB transaction requests posted by the application. At the beginning of each frame the host executes the periodic (isochronous and interrupt) transactions first, followed by the nonperiodic (control and bulk) transactions to achieve the higher level of priority granted to the isochronous and interrupt transfer types by the USB specification. 

The host processes the USB transactions through request queues (one for periodic and one for nonperiodic). Each request queue can hold up to 8 entries. Each entry represents a pending transaction request from the application, and holds the IN or OUT channel number along with other information to perform a transaction on the USB. The order in which the requests are written to the queue determines the sequence of the transactions on the USB interface.

At the beginning of each frame, the host processes the periodic request queue first, followed by the nonperiodic request queue. The host issues an incomplete periodic transfer interrupt (IPXFR bit in OTG_FS_GINTSTS) if an isochronous or interrupt transaction scheduled for the current frame is still pending at the end of the current frame. The OTG HS core is fully responsible for the management of the periodic and nonperiodic request queues.The periodic transmit FIFO and queue status register (HPTXSTS) and nonperiodic transmit FIFO and queue status register (HNPTXSTS) are read-only registers which can be used by the application to read the status of each request queue. They contain: 

As request queues can hold a maximum of 8 entries each, the application can push to schedule host transactions in advance with respect to the moment they physically reach the SB for a maximum of 8 pending periodic transactions plus 8 pending nonperiodic transactions.

To post a transaction request to the host scheduler (queue) the application must check that there is at least 1 entry available in the periodic (nonperiodic) request queue by reading the 

Such utilities are especially useful for adaptive audio clock generation techniques, where the audio peripheral needs to synchronize to the isochronous stream provided by the PC, or the host needs to trim its framing rate according to the requirements of the audio peripheral.

In host mode the number of PHY clocks occurring between the generation of two consecutive SOF (FS) or Keep-alive (LS) tokens is programmable in the host frame interval register (HFIR), thus providing application control over the SOF framing period. An interrupt is generated at any start of frame (SOF bit in OTH_FS_GINTSTS). The current frame number and the time remaining until the next SOF are tracked in the host frame number register (HFNUM).

An SOF pulse signal, generated at any SOF starting token and with a width of 20 HCLK cycles, can be made available externally on the OTG_FS_SOF pin using the SOFOUTEN bit in the global control and configuration register. The SOF pulse is also internally connected to the input trigger of timer 2 (TIM2), so that the input capture feature, the output compare feature and the timer can be triggered by the SOF pulse. The TIM2 connection is enabled by  register.

In device mode, the start of frame interrupt is generated each time an SOF token is received on the USB (SOF bit in OTH_FS_GINTSTS). The corresponding frame number can be read from the device status register (FNSOF bit in OTG_FS_DSTS). An SOF pulse signal with a width of 20 HCLK cycles is also generated and can be made available externally on the 

OTG_FS_SOF pin by using the SOF output enable bit in the global control and configuration register (SOFOUTEN bit in OTG_FS_GCCFG). The SOF pulse signal is also internally connected to the TIM2 input trigger, so that the input capture feature, the output compare feature and the timer can be triggered by the SOF pulse. The TIM2 connection is enabled .

The end of periodic frame interrupt (GINTSTS/EOPF) is used to notify the application when 80%, 85%, 90% or 95% of the time frame interval elapsed depending on the periodic frame interval field in the device configuration register (PFIVL bit in OTG_FS_DCFG). This feature can be used to determine if all of the isochronous traffic for that frame is complete.

When setting the stop PHY clock bit in the clock gating control register, most of the 48 MHz clock domain internal to the OTG full-speed core is switched off by clock 

When setting the Gate HCLK bit in the clock gating control register, most of the system clock domain internal to the OTG_FS core is switched off by clock gating. Only the register read and write interface is kept alive. The dynamic power consumption due to the USB clock switching activity is cut even if the system clock is kept running by the application for other purposes.

When the OTG_FS is in the USB suspended state, the application may decide to drastically reduce the overall power consumption by a complete shut down of all the clock sources in the system. USB System Stop is activated by first setting the Stop PHY clock bit and then configuring the system deep sleep mode in the power control system module (PWR).

The USB system features 1.25 Kbyte of dedicated RAM with a sophisticated FIFO control mechanism. The packet FIFO controller module in the OTG_FS core organizes RAM space into Tx-FIFOs into which the application pushes the data to be temporarily stored before the USB transmission, and into a single Rx FIFO where the data received from the USB are temporarily stored before retrieval (popped) by the application. The number of instructed FIFOs and how these are organized inside the RAM depends on the device’s role. In peripheral mode an additional Tx-FIFO is instructed for each active IN endpoint. Any FIFO size is software configured to better meet the application requirements.

The OTG peripheral uses a single receive FIFO that receives the data directed to all OUT endpoints. Received packets are stacked back-to-back until free space is available in the Rx-FIFO. The status of the received packet (which contains the OUT endpoint destination number, the byte count, the data PID and the validity of the received data) is also stored by the core on top of the data payload. When no more space is available, host transactions are NACKed and an interrupt is received on the addressed endpoint. The size of the receive FIFO is configured in the receive FIFO Size register (GRXFSIZ).

The application keeps receiving the Rx-FIFO non-empty interrupt (RXFLVL bit in OTG_FS_GINTSTS) as long as there is at least one packet available for download. It reads the packet information from the receive status read and pop register (GRXSTSP) and finally pops data off the receive FIFO by reading from the endpoint-related pop address.

The core has a dedicated FIFO for each IN endpoint. The application configures FIFO sizes by writing the non periodic transmit FIFO size register (OTG_FS_TX0FSIZ) for IN endpoint0 and the device IN endpoint transmit FIFOx registers (DIEPTXFx) for IN endpoint-x.

The host uses one receiver FIFO for all periodic and nonperiodic transactions. The FIFO is used as a receive buffer to hold the received data (payload of the received packet) from the USB until it is transferred to the system memory. Packets received from any remote IN endpoint are stacked back-to-back until free space is available. The status of each received packet with the host channel destination, byte count, data PID and validity of the received data are also stored into the FIFO. The size of the receive FIFO is configured in the receive FIFO size register (GRXFSIZ).

The application receives the Rx FIFO not-empty interrupt as long as there is at least one packet available for download. It reads the packet information from the receive status read and pop register and finally pops the data off the receive FIFO.

The host uses one transmit FIFO for all non-periodic (control and bulk) OUT transactions and one transmit FIFO for all periodic (isochronous and interrupt) OUT transactions. FIFOs are used as transmit buffers to hold the data (payload of the transmit packet) to be transmitted over the USB. The size of the periodic (nonperiodic) Tx FIFO is configured in the host periodic (nonperiodic) transmit FIFO size (HPTXFSIZ/HNPTXFSIZ) register.

The two Tx FIFO implementation derives from the higher priority granted to the periodic type of traffic over the USB frame. At the beginning of each frame, the built-in host scheduler processes the periodic request queue first, followed by the nonperiodic request queue.

The OTG_FS core issues the periodic Tx FIFO empty interrupt (PTXFE bit in OTG_FS_GINTSTS) as long as the periodic Tx-FIFO is half or completely empty, depending on the value of the periodic Tx-FIFO empty level bit in the AHB configuration register (PTXFELVL bit in OTG_FS_GAHBCFG). The application can push the transmission data in advance as long as free space is available in both the periodic Tx FIFO and the periodic request queue. The host periodic transmit FIFO and queue status register (HPTXSTS) can be read to know how much space is available in both.

OTG_FS core issues the non periodic Tx FIFO empty interrupt (NPTXFE bit in OTG_FS_GINTSTS) as long as the nonperiodic Tx FIFO is half or completely empty depending on the non periodic Tx FIFO empty level bit in the AHB configuration register (TXFELVL bit in OTG_FS_GAHBCFG). The application can push the transmission data as long as free space is available in both the nonperiodic Tx FIFO and nonperiodic request queue. The host nonperiodic transmit FIFO and queue status register (HNPTXSTS) can be read to know how much space is available in both.

Receive FIFO RAM allocation: the application should allocate RAM for SETUP Packets: 10 locations must be reserved in the receive FIFO to receive SETUP packets on control endpoint. The core does not use these locations, which are reserved for SETUP packets, to write any other data. One location is to be allocated for Global OUT NAK. Status information 

is written to the FIFO along with each received packet. Therefore, a minimum space of (Largest Packet Size / 4) + 1 must be allocated to receive packets. If multiple isochronous endpoints are enabled, then at least two (Largest Packet Size / 4) + 1 spaces must be allocated to receive back-to-back packets. Typically, two (Largest Packet Size / 4) + 1 spaces are recommended so that when the previous packet is being transferred to the CPU, the USB can receive the subsequent packet. 

Status information is written to the FIFO along with each received packet. Therefore, a minimum space of (Largest Packet Size / 4) + 1 must be allocated to receive packets. If multiple isochronous channels are enabled, then at least two (Largest Packet Size / 4) + 1 spaces must be allocated to receive back-to-back packets. Typically, two (Largest Packet Size / 4) + 1 spaces are recommended so that when the previous packet is being transferred to the CPU, the USB can receive the subsequent packet. 

The minimum amount of RAM required for host periodic Transmit FIFO is the largest maximum packet size out of all the supported periodic OUT channels. If there is at least one Isochronous OUT endpoint, then the space must be at least two times the maximum packet size of that channel. 

Best USB and system performance is achieved owing to the large RAM buffers, the highly configurable FIFO sizes, the quick 32-bit FIFO access through AHB push/pop registers and, especially, the advanced FIFO control mechanism. Indeed, this mechanism allows the OTG_FS to fill in the available RAM space at best regardless of the current USB sequence. With these features:

As the OTG_FS core is able to fill in the 1.25 Kbyte RAM buffer very efficiently, and as 1.25 Kbyte of transmit/receive data is more than enough to cover a full speed frame, the USB system is able to withstand the maximum full-speed data rate for up to one USB frame (1 ms) without any CPU intervention.

When the OTG_FS controller is operating in one mode, either device or host, the application must not access registers from the other mode. If an illegal access occurs, a mode mismatch interrupt is generated and reflected in the Core interrupt register (MMIS bit in the OTG_FS_GINTSTS register). When the core switches from one mode to the other, the registers in the new mode of operation must be reprogrammed as they would be after a power-on reset.

By reading from and writing to the control and status registers (CSRs) through the AHB slave interface, the application controls the OTG_FS controller. These registers are 32 bits wide, and the addresses are 32-bit block aligned. The OTG_FS registers must be accessed by words (32 bits).

Only the Core global, Power and clock-gating, Data FIFO access, and host port control and status registers can be accessed in both host and device modes. When the OTG_FS controller is operating in one mode, either device or host, the application must not access registers from the other mode. If an illegal access occurs, a mode mismatch interrupt is generated and reflected in the Core interrupt register (MMIS bit in the OTG_FS_GINTSTS register). When the core switches from one mode to the other, the registers in the new mode of operation must be reprogrammed as they would be after a power-on reset.

These registers, available in both host and device modes, are used to read or write the FIFO space for a specific endpoint or a channel, in a given direction. If a host channel is of type IN, the FIFO can only be read on the channel. Similarly, if a host channel is of type OUT, the FIFO can only be written on the channel.

Bit 19 BSVLD: B-session validIndicates the device mode transceiver status.0: B-session is not valid.1: B-session is valid.In OTG mode, you can use this bit to determine if the device is connected or disconnected.Note: Only accessible in device mode.

Bit 17 DBCT: Long/short debounce timeIndicates the debounce time of a detected connection.0: Long debounce time, used for physical connections (100 ms + 2.5 µs)1: Short debounce time, used for soft connections (2.5 µs)Note: Only accessible in host mode.

Bit 16 CIDSTS: Connector ID statusIndicates the connector ID status on a connect event.0: The OTG_FS controller is in A-device mode1: The OTG_FS controller is in B-device modeNote: Accessible in both device and host modes.

Bit 11 DHNPEN: Device HNP enabledThe application sets this bit when it successfully receives a SetFeature.SetHNPEnable command from the connected USB host.0: HNP is not enabled in the application1: HNP is enabled in the applicationNote: Only accessible in device mode.

Bit 10 HSHNPEN: host set HNP enableThe application sets this bit when it has successfully enabled HNP (using the SetFeature.SetHNPEnable command) on the connected device.0: Host Set HNP is not enabled1: Host Set HNP is enabledNote: Only accessible in host mode.

Bit 9 HNPRQ: HNP requestThe application sets this bit to initiate an HNP request to the connected USB host. The application can clear this bit by writing a 0 when the host negotiation success status change bit in the OTG_FS_GOTGINT register (HNSSCHG bit in OTG_FS_GOTGINT) is set. The core clears this bit when the HNSSCHG bit is cleared.0: No HNP request1: HNP requestNote: Only accessible in device mode.

Bit 8 HNGSCS: Host negotiation successThe core sets this bit when host negotiation is successful. The core clears this bit when the HNP Request (HNPRQ) bit in this register is set.0: Host negotiation failure1: Host negotiation successNote: Only accessible in device mode.

Bit 1 SRQ: Session requestThe application sets this bit to initiate a session request on the USB. The application can clear this bit by writing a 0 when the host negotiation success status change bit in the OTG_FS_GOTGINT register (HNSSCHG bit in OTG_FS_GOTGINT) is set. The core clears this bit when the HNSSCHG bit is cleared.If you use the USB 1.1 full-speed serial transceiver interface to initiate the session request, the application must wait until VBUS discharges to 0.2 V, after the B-Session Valid bit in this register (BSVLD bit in OTG_FS_GOTGCTL) is cleared.0: No session request1: Session requestNote: Only accessible in device mode.

Bit 19 DBCDNE: Debounce doneThe core sets this bit when the debounce is completed after the device connect. The application can start driving USB reset after seeing this interrupt. This bit is only valid when the HNP Capable or SRP Capable bit is set in the OTG_FS_GUSBCFG register (HNPCAP bit or SRPCAP bit in OTG_FS_GUSBCFG, respectively).Note: Only accessible in host mode.

Bit 18 ADTOCHG: A-device timeout changeThe core sets this bit to indicate that the A-device has timed out while waiting for the B-device to connect.Note: Accessible in both device and host modes.

Bit 9 HNSSCHG: Host negotiation success status changeThe core sets this bit on the success or failure of a USB host negotiation request. The application must read the host negotiation success bit of the OTG_FS_GOTGCTL register (HNGSCS in OTG_FS_GOTGCTL) to check for success or failure.Note: Accessible in both device and host modes.

Bit 8 SRSSCHG: Session request success status changeThe core sets this bit on the success or failure of a session request. The application must read the session request success bit in the OTG_FS_GOTGCTL register (SRQSCS bit in OTG_FS_GOTGCTL) to check for success or failure.Note: Accessible in both device and host modes.

Bit 2 SEDET: Session end detectedThe core sets this bit to indicate that the level of the voltage on VBUS is no longer valid for a B-Peripheral session when VBUS < 0.8 V.

This register can be used to configure the core after power-on or a change in mode. This register mainly contains AHB system-related configuration parameters. Do not change this register after the initial programming. The application must program this register before starting any transactions on either the AHB or the USB.

Bit 0 GINTMSK: Global interrupt maskThe application uses this bit to mask or unmask the interrupt line assertion to itself. Irrespective of this bit’s setting, the interrupt status registers are updated by the core.0: Mask the interrupt assertion to the application.1: Unmask the interrupt assertion to the application.Note: Accessible in both device and host modes.

This register can be used to configure the core after power-on or a changing to host mode or device mode. It contains USB and USB-PHY related configuration parameters. The application must program this register before starting any transactions on either the AHB or the USB. Do not make changes to this register after the initial programming.

Bit 30 FDMOD: Force device modeWriting a 1 to this bit forces the core to device mode irrespective of the OTG_FS_ID input pin.0: Normal mode1: Force device modeAfter setting the force bit, the application must wait at least 25 ms before the change takes effect.Note: Accessible in both device and host modes.

Bit 29 FHMOD: Force host modeWriting a 1 to this bit forces the core to host mode irrespective of the OTG_FS_ID input pin.0: Normal mode1: Force host modeAfter setting the force bit, the application must wait at least 25 ms before the change takes effect.Note: Accessible in both device and host modes.

Bits 13:10 TRDT: USB turnaround timeThese bits allow setting the turnaround time in PHY clocks. They must be configured according to Table 206: TRDT values, depending on the application AHB frequency. Higher TRDT values allow stretching the USB response time to IN tokens in order to compensate for longer AHB read access latency to the Data FIFO. Note: Only accessible in device mode.

Bit 9 HNPCAP: HNP-capableThe application uses this bit to control the OTG_FS controller’s HNP capabilities.0: HNP capability is not enabled.1: HNP capability is enabled.Note: Accessible in both device and host modes.

Bit 8 SRPCAP: SRP-capableThe application uses this bit to control the OTG_FS controller’s SRP capabilities. If the core operates as a non-SRP-capable B-device, it cannot request the connected A-device (host) to activate VBUS and start a session.0: SRP capability is not enabled.1: SRP capability is enabled.Note: Accessible in both device and host modes.

Bits 2:0 TOCAL: FS timeout calibrationThe number of PHY clocks that the application programs in this field is added to the full-speed interpacket timeout duration in the core to account for any additional delays introduced by the PHY. This can be required, because the delay introduced by the PHY in generating the line state condition can vary from one PHY to another.The USB standard timeout value for full-speed operation is 16 to 18 (inclusive) bit times. The application must program this field based on the speed of enumeration. The number of bit times added per PHY clock is 0.25 bit times.

Bit 5 TXFFLSH: TxFIFO flushThis bit selectively flushes a single or all transmit FIFOs, but cannot do so if the core is in the midst of a transaction.The application must write this bit only after checking that the core is neither writing to the TxFIFO nor reading from the TxFIFO. Verify using these registers:Read—NAK Effective Interrupt ensures the core is not reading from the FIFOWrite—AHBIDL bit in OTG_FS_GRSTCTL ensures the core is not writing anything to the FIFO.Note: Accessible in both device and host modes.

Bit 4 RXFFLSH: RxFIFO flushThe application can flush the entire RxFIFO using this bit, but must first ensure that the core is not in the middle of a transaction.The application must only write to this bit after checking that the core is neither reading from the RxFIFO nor writing to the RxFIFO.The application must wait until the bit is cleared before performing any other operations. This bit requires 8 clocks (slowest of PHY or AHB clock) to clear.Note: Accessible in both device and host modes.

Bit 2 FCRST: Host frame counter resetThe application writes this bit to reset the frame number counter inside the core. When the frame counter is reset, the subsequent SOF sent out by the core has a frame number of 0.Note: Only accessible in host mode.

Bit 1 HSRST: HCLK soft resetThe application uses this bit to flush the control logic in the AHB Clock domain. Only AHB Clock Domain pipelines are reset.FIFOs are not flushed with this bit.All state machines in the AHB clock domain are reset to the Idle state after terminating the transactions on the AHB, following the protocol.CSR control bits used by the AHB clock domain state machines are cleared.To clear this interrupt, status mask bits that control the interrupt status and are generated by the AHB clock domain state machine are cleared.Because interrupt status bits are not cleared, the application can get the status of any core events that occurred after it set this bit.This is a self-clearing bit that the core clears after all necessary logic is reset in the core. This can take several clocks, depending on the core’s current state.Note: Accessible in both device and host modes.

Bit 0 CSRST: Core soft resetResets the HCLK and PCLK domains as follows:Clears the interrupts and all the CSR register bits except for the following bits:– RSTPDMODL bit in OTG_FS_PCGCCTL– GAYEHCLK bit in OTG_FS_PCGCCTL– PWRCLMP bit in OTG_FS_PCGCCTL– STPPCLK bit in OTG_FS_PCGCCTL– FSLSPCS bit in OTG_FS_HCFG– DSPD bit in OTG_FS_DCFGAll module state machines (except for the AHB slave unit) are reset to the Idle state, and all the transmit FIFOs and the receive FIFO are flushed.Any transactions on the AHB Master are terminated as soon as possible, after completing the last data phase of an AHB transfer. Any transactions on the USB are terminated immediately.The application can write to this bit any time it wants to reset the core. This is a self-clearing bit and the core clears this bit after all the necessary logic is reset in the core, which can take several clocks, depending on the current state of the core. Once this bit has been cleared, the software must wait at least 3 PHY clocks before accessing the PHY domain (synchronization delay). The software must also check that bit 31 in this register is set to 1 (AHB Master is Idle) before starting any operation.Typically, the software reset is used during software development and also when you dynamically change the PHY selection bits in the above listed USB configuration registers. When you change the PHY, the corresponding clock for the PHY is selected and used in the PHY domain. Once a new clock is selected, the PHY domain has to be reset for proper operation.Note: Accessible in both device and host modes.

Some of the bits in this register are valid only in host mode, while others are valid in device mode only. This register also indicates the current mode. To clear the interrupt status bits of the rc_w1 type, the application must write 1 into the bit.

Bit 31 WKUPINT: Resume/remote wakeup detected interruptIn device mode, this interrupt is asserted when a resume is detected on the USB. In host mode, this interrupt is asserted when a remote wakeup is detected on the USB.Note: Accessible in both device and host modes.

Bit 30 SRQINT: Session request/new session detected interruptIn host mode, this interrupt is asserted when a session request is detected from the device. In device mode, this interrupt is asserted when VBUS is in the valid range for a B-peripheral device. Accessible in both device and host modes.

Bit 26 PTXFE: Periodic TxFIFO emptyAsserted when the periodic transmit FIFO is either half or completely empty and there is space for at least one entry to be written in the periodic request queue. The half or completely empty status is determined by the periodic TxFIFO empty level bit in the OTG_FS_GAHBCFG register (PTXFELVL bit in OTG_FS_GAHBCFG).Note: Only accessible in host mode.

Bit 25 HCINT: Host channels interruptThe core sets this bit to indicate that an interrupt is pending on one of the channels of the core (in host mode). The application must read the OTG_FS_HAINT register to determine the exact number of the channel on which the interrupt occurred, and then read the corresponding OTG_FS_HCINTx register to determine the exact cause of the interrupt. The application must clear the appropriate status bit in the OTG_FS_HCINTx register to clear this bit.Note: Only accessible in host mode.

Bit 24 HPRTINT: Host port interruptThe core sets this bit to indicate a change in port status of one of the OTG_FS controller ports in host mode. The application must read the OTG_FS_HPRT register to determine the exact event that caused this interrupt. The application must clear the appropriate status bit in the OTG_FS_HPRT register to clear this bit.Note: Only accessible in host mode.

Bit 21 IPXFR: Incomplete periodic transferIn host mode, the core sets this interrupt bit when there are incomplete periodic transactions still pending, which are scheduled for the current frame.INCOMPISOOUT: Incomplete isochronous OUT transferIn device mode, the core sets this interrupt to indicate that there is at least one isochronous OUT endpoint on which the transfer is not completed in the current frame. This interrupt is asserted along with the End of periodic frame interrupt (EOPF) bit in this register.

Bit 20 IISOIXFR: Incomplete isochronous IN transferThe core sets this interrupt to indicate that there is at least one isochronous IN endpoint on which the transfer is not completed in the current frame. This interrupt is asserted along with the End of periodic frame interrupt (EOPF) bit in this register.Note: Only accessible in device mode.

Bit 19 OEPINT: OUT endpoint interruptThe core sets this bit to indicate that an interrupt is pending on one of the OUT endpoints of the core (in device mode). The application must read the OTG_FS_DAINT register to determine the exact number of the OUT endpoint on which the interrupt occurred, and then read the corresponding OTG_FS_DOEPINTx register to determine the exact cause of the interrupt. The application must clear the appropriate status bit in the corresponding OTG_FS_DOEPINTx register to clear this bit.Note: Only accessible in device mode.

Bit 18 IEPINT: IN endpoint interruptThe core sets this bit to indicate that an interrupt is pending on one of the IN endpoints of the core (in device mode). The application must read the OTG_FS_DAINT register to determine the exact number of the IN endpoint on which the interrupt occurred, and then read the corresponding OTG_FS_DIEPINTx register to determine the exact cause of the interrupt. The application must clear the appropriate status bit in the corresponding OTG_FS_DIEPINTx register to clear this bit.Note: Only accessible in device mode.

Bit 15 EOPF: End of periodic frame interruptIndicates that the period specified in the periodic frame interval field of the OTG_FS_DCFG register (PFIVL bit in OTG_FS_DCFG) has been reached in the current frame.Note: Only accessible in device mode.

Bit 14 ISOODRP: Isochronous OUT packet dropped interruptThe core sets this bit when it fails to write an isochronous OUT packet into the RxFIFO because the RxFIFO does not have enough space to accommodate a maximum size packet for the isochronous OUT endpoint.Note: Only accessible in device mode.

Bit 13 ENUMDNE: Enumeration doneThe core sets this bit to indicate that speed enumeration is complete. The application must read the OTG_FS_DSTS register to obtain the enumerated speed.Note: Only accessible in device mode.

Bit 11 USBSUSP: USB suspendThe core sets this bit to indicate that a suspend was detected on the USB. The core enters the Suspended state when there is no activity on the data lines for a period of 3 ms.Note: Only accessible in device mode.

Bit 6 GINAKEFF: Global IN non-periodic NAK effectiveIndicates that the Set global non-periodic IN NAK bit in the OTG_FS_DCTL register (SGINAK bit in OTG_FS_DCTL), set by the application, has taken effect in the core. That is, the core has sampled the Global IN NAK bit set by the application. This bit can be cleared by clearing the Clear global non-periodic IN NAK bit in the OTG_FS_DCTL register (CGINAK bit in OTG_FS_DCTL).This interrupt does not necessarily mean that a NAK handshake is sent out on the USB. The STALL bit takes precedence over the NAK bit.Note: Only accessible in device mode.

Bit 5 NPTXFE: Non-periodic TxFIFO emptyThis interrupt is asserted when the non-periodic TxFIFO is either half or completely empty, and there is space for at least one entry to be written to the non-periodic transmit request queue. The half or completely empty status is determined by the non-periodic TxFIFO empty level bit in the OTG_FS_GAHBCFG register (TXFELVL bit in OTG_FS_GAHBCFG).Note: Accessible in host mode only.

Bit 3 SOF: Start of frameIn host mode, the core sets this bit to indicate that an SOF (FS), or Keep-Alive (LS) is transmitted on the USB. The application must write a 1 to this bit to clear the interrupt.In device mode, in the core sets this bit to indicate that an SOF token has been received on the USB. The application can read the Device Status register to get the current frame number. This interrupt is seen only when the core is operating in FS.Note: Accessible in both host and device modes.

Bit 2 OTGINT: OTG interruptThe core sets this bit to indicate an OTG protocol event. The application must read the OTG Interrupt Status (OTG_FS_GOTGINT) register to determine the exact event that caused this interrupt. The application must clear the appropriate status bit in the OTG_FS_GOTGINT register to clear this bit.Note: Accessible in both host and device modes.

Bit 1 MMIS: Mode mismatch interruptThe core sets this bit when the application is trying to access:–A host mode register, when the core is operating in device mode–A device mode register, when the core is operating in host modeThe register access is completed on the AHB with an OKAY response, but is ignored by the core internally and does not affect the operation of the core.Note: Accessible in both host and device modes.

This register works with the Core interrupt register to interrupt the application. When an interrupt bit is masked, the interrupt associated with that bit is not generated. However, the Core Interrupt (OTG_FS_GINTSTS) register bit corresponding to that interrupt is still set.

A read to the Receive status debug read register returns the contents of the top of the Receive FIFO. A read to the Receive status read and pop register additionally pops the top data entry out of the RxFIFO.

The receive status contents must be interpreted differently in host and device modes. The core ignores the receive status pop/read when the receive FIFO is empty and returns a value of 0x0000 0000. The application must only pop the Receive Status FIFO when the Receive FIFO non-empty bit of the Core interrupt register (RXFLVL bit in OTG_FS_GINTSTS) is asserted.

Bits 20:17 PKTSTS: Packet statusIndicates the status of the received packet0010: IN data packet received0011: IN transfer completed (triggers an interrupt)0101: Data toggle error (triggers an interrupt)0111: Channel halted (triggers an interrupt)Others: Reserved

Bits 24:21 FRMNUM: Frame numberThis is the least significant 4 bits of the frame number in which the packet is received on the USB. This field is supported only when isochronous OUT endpoints are supported.

Bits 20:17 PKTSTS: Packet statusIndicates the status of the received packet0001: Global OUT NAK (triggers an interrupt)0010: OUT data packet received0011: OUT transfer completed (triggers an interrupt)0100: SETUP transaction completed (triggers an interrupt)0110: SETUP data packet receivedOthers: Reserved

Bits 15:0 RXFD: RxFIFO depthThis value is in terms of 32-bit words.Minimum value is 16Maximum value is 256The power-on reset value of this register is specified as the largest Rx data FIFO depth.

Bits 30:24 NPTXQTOP: Top of the non-periodic transmit request queueEntry in the non-periodic Tx request queue that is currently being processed by the MAC.Bits 30:27: Channel/endpoint numberBits 26:25:–00: IN/OUT token–01: Zero-length transmit packet (device IN/host OUT)–11: Channel halt commandBit 24: Terminate (last entry for selected channel/endpoint)

Bits 23:16 NPTQXSAV: Non-periodic transmit request queue space availableIndicates the amount of free space available in the non-periodic transmit request queue. This queue holds both IN and OUT requests in host mode. Device mode has only IN requests.00: Non-periodic transmit request queue is full01: 1 location available10: 2 locations availablebxn: n locations available (0 ≤ n ≤ 8)Others: Reserved

Bits 15:0 NPTXFSAV: Non-periodic TxFIFO space availableIndicates the amount of free space available in the non-periodic TxFIFO.Values are in terms of 32-bit words.00: Non-periodic TxFIFO is full01: 1 word available10: 2 words available0xn: n words available (where 0 ≤ n ≤ 256)Others: Reserved

Bits 15:0 PTXSA: Host periodic TxFIFO start addressThe power-on reset value of this register is the sum of the largest Rx data FIFO depth and largest non-periodic Tx data FIFO depth.

Host-mode registers affect the operation of the core in the host mode. Host mode registers must not be accessed in device mode, as the results are undefined. Host mode registers can be categorized as follows:

Bits 31:16 INEPTXFD: IN endpoint TxFIFO depthThis value is in terms of 32-bit words.Minimum value is 16The power-on reset value of this register is specified as the largest IN endpoint FIFO number depth.

Bits 15:0 INEPTXSA: IN endpoint FIFOx transmit RAM start addressThis field contains the memory start address for IN endpoint transmit FIFOx. The address must be aligned with a 32-bit memory location. 

Bit 2 FSLSS: FS- and LS-only supportThe application uses this bit to control the core’s enumeration speed. Using this bit, the application can make the core enumerate as an FS host, even if the connected device supports HS traffic. Do not make changes to this field after initial programming.1: FS/LS-only, even if the connected device can support HS (read-only)

Bits 1:0 FSLSPCS: FS/LS PHY clock selectWhen the core is in FS host mode01: PHY clock is running at 48 MHzOthers: ReservedWhen the core is in LS host mode00: Reserved01: Select 48 MHz PHY clock frequency 10: Select 6 MHz PHY clock frequency 11: ReservedNote: The FSLSPCS must be set on a connection event according to the speed of the connected device (after changing this bit, a software reset must be performed).

Bits 15:0 FRIVL: Frame intervalThe value that the application programs to this field specifies the interval between two consecutive SOFs (FS) or Keep-Alive tokens (LS). This field contains the number of PHY clocks that constitute the required frame interval. The application can write a value to this register only after the Port enable bit of the host port control and status register (PENA bit in OTG_FS_HPRT) has been set. If no value is programmed, the core calculates the value based on the PHY clock specified in the FS/LS PHY Clock Select field of the host configuration register (FSLSPCS in OTG_FS_HCFG). Do not change the value of this field after the initial configuration.– Frame interval = 1 ms × (FRIVL - 1)

Bits 31:16 FTREM: Frame time remainingIndicates the amount of time remaining in the current frame, in terms of PHY clocks. This field decrements on each PHY clock. When it reaches zero, this field is reloaded with the value in the Frame interval register and a new SOF is transmitted on the USB.

Bits 31:24 PTXQTOP: Top of the periodic transmit request queueThis indicates the entry in the periodic Tx request queue that is currently being processed by the MAC.This register is used for debugging.Bit 31: Odd/Even frame–0: send in even frame–1: send in odd frameBits 30:27: Channel/endpoint numberBits 26:25: Type–00: IN/OUT–01: Zero-length packet–11: Disable channel commandBit 24: Terminate (last entry for the selected channel/endpoint)

Bits 23:16 PTXQSAV: Periodic transmit request queue space availableIndicates the number of free locations available to be written in the periodic transmit request queue. This queue holds both IN and OUT requests.00: Periodic transmit request queue is full01: 1 location available10: 2 locations availablebxn: n locations available (0 ≤ n ≤ 8)Others: Reserved

When a significant event occurs on a channel, the host all channels interrupt register interrupts the application using the host channels interrupt bit of the Core interrupt register (HCINT bit in OTG_FS_GINTSTS). This is shown in Figure 311. There is one interrupt bit per channel, up to a maximum of 16 bits. Bits in this register are set and cleared when the application sets and clears bits in the corresponding host channel-x interrupt register.

Bits 15:0 PTXFSAVL: Periodic transmit data FIFO space availableIndicates the number of free locations available to be written to in the periodic TxFIFO.Values are in terms of 32-bit words0000: Periodic TxFIFO is full0001: 1 word available0010: 2 words availablebxn: n words available (where 0 ≤ n ≤ PTXFD)Others: Reserved

The host all channel interrupt mask register works with the host all channel interrupt register to interrupt the application when an event occurs on a channel. There is one interrupt mask bit per channel, up to a maximum of 16 bits.

A single register holds USB port-related information such as USB reset, enable, suspend, resume, connect status, and test mode for each port. It is shown in Figure 311. The rc_w1 bits in this register can trigger an interrupt to the application through the host port interrupt bit of the core interrupt register (HPRTINT bit in OTG_FS_GINTSTS). On a Port Interrupt, the application must read this register and clear the bit that caused the interrupt. For the rc_w1 bits, the application must write a 1 to the bit to clear the interrupt.

Bits 16:13 PTCTL: Port test controlThe application writes a nonzero value to this field to put the port into a Test mode, and the corresponding pattern is signaled on the port.0000: Test mode disabled0001: Test_J mode0010: Test_K mode0011: Test_SE0_NAK mode0100: Test_Packet mode0101: Test_Force_EnableOthers: Reserved

Bit 8 PRST: Port resetWhen the application sets this bit, a reset sequence is started on this port. The application must time the reset period and clear this bit after the reset sequence is complete.0: Port not in reset1: Port in resetThe application must leave this bit set for a minimum duration of at least 10 ms to start a reset on the port. The application can leave it set for another 10 ms in addition to the required minimum duration, before clearing the bit, even though there is no maximum limit set by the USB standard.

Bit 7 PSUSP: Port suspendThe application sets this bit to put this port in Suspend mode. The core only stops sending SOFs when this is set. To stop the PHY clock, the application must set the Port clock stop bit, which asserts the suspend input pin of the PHY.The read value of this bit reflects the current suspend status of the port. This bit is cleared by the core after a remote wakeup signal is detected or the application sets the Port reset bit or Port resume bit in this register or the Resume/remote wakeup detected interrupt bit or Disconnect detected interrupt bit in the Core interrupt register (WKUINT or DISCINT in OTG_FS_GINTSTS, respectively).0: Port not in Suspend mode1: Port in Suspend mode

Bit 6 PRES: Port resumeThe application sets this bit to drive resume signaling on the port. The core continues to drive the resume signal until the application clears this bit.If the core detects a USB remote wakeup sequence, as indicated by the Port resume/remote wakeup detected interrupt bit of the Core interrupt register (WKUINT bit in OTG_FS_GINTSTS), the core starts driving resume signaling without application intervention and clears this bit when it detects a disconnect condition. The read value of this bit indicates whether the core is currently driving resume signaling.0: No resume driven1: Resume driven

Bit 2 PENA: Port enableA port is enabled only by the core after a reset sequence, and is disabled by an overcurrent condition, a disconnect condition, or by the application clearing this bit. The application cannot set this bit by a register write. It can only clear it to disable the port. This bit does not trigger any interrupt to the application.0: Port disabled1: Port enabled

Bit 1 PCDET: Port connect detectedThe core sets this bit when a device connection is detected to trigger an interrupt to the application using the host port interrupt bit in the Core interrupt register (HPRTINT bit in OTG_FS_GINTSTS). The application must write a 1 to this bit to clear the interrupt.

Bit 30 CHDIS: Channel disableThe application sets this bit to stop transmitting/receiving data on a channel, even before the transfer for that channel is complete. The application must wait for the Channel disabled interrupt before treating the channel as disabled.

Bit 29 ODDFRM: Odd frameThis field is set (reset) by the application to indicate that the OTG host must perform a transfer in an odd frame. This field is applicable for only periodic (isochronous and interrupt) transactions.0: Even frame1: Odd frame

Bits 21:20 MCNT: MulticountThis field indicates to the host the number of transactions that must be executed per frame for this periodic endpoint. For non-periodic transfers, this field is not used00: Reserved. This field yields undefined results01: 1 transaction10: 2 transactions per frame to be issued for this endpoint11: 3 transactions per frame to be issued for this endpointNote: This field must be set to at least 01.

This register indicates the status of a channel with respect to USB- and AHB-related events. It is shown in Figure 311. The application must read this register when the host channels interrupt bit in the Core interrupt register (HCINT bit in OTG_FS_GINTSTS) is set. Before the application can read this register, it must first read the host all channels interrupt (OTG_FS_HAINT) register to get the exact channel number for the host channel-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_FS_HAINT and OTG_FS_GINTSTS registers.

Bits 30:29 DPID: Data PIDThe application programs this field with the type of PID to use for the initial transaction. The host maintains this field for the rest of the transfer.00: DATA001: DATA210: DATA111: MDATA (non-control)/SETUP (control)

Bits 28:19 PKTCNT: Packet countThis field is programmed by the application with the expected number of packets to be transmitted (OUT) or received (IN).The host decrements this count on every successful transmission or reception of an OUT/IN packet. Once this count reaches zero, the application is interrupted to indicate normal completion.

Bits 18:0 XFRSIZ: Transfer sizeFor an OUT, this field is the number of data bytes the host sends during the transfer.For an IN, this field is the buffer size that the application has reserved for the transfer. The application is expected to program this field as an integer multiple of the maximum packet size for IN transactions (periodic and non-periodic).

Bits 12:11 PFIVL: Periodic frame intervalIndicates the time within a frame at which the application must be notified using the end of periodic frame interrupt. This can be used to determine if all the isochronous traffic for that frame is complete.00: 80% of the frame interval01: 85% of the frame interval10: 90% of the frame interval11: 95% of the frame interval

Bit 2 NZLSOHSK: Non-zero-length status OUT handshakeThe application can use this field to select the handshake the core sends on receiving a nonzero-length data packet during the OUT transaction of a control transfer’s Status stage.1: Send a STALL handshake on a nonzero-length status OUT transaction and do not send the received OUT packet to the application.0: Send the received OUT packet to the application (zero-length or nonzero-length) and send a handshake based on the NAK and STALL bits for the endpoint in the Device endpoint control register.

Bits 1:0 DSPD: Device speedIndicates the speed at which the application requires the core to enumerate, or the maximum speed the application can support. However, the actual bus speed is determined only after the chirp sequence is completed, and is based on the speed of the USB host to which the core is connected.00: Reserved01: Reserved10: Reserved11: Full speed (USB 1.1 transceiver clock is 48 MHz)

Bit 9 SGONAK: Set global OUT NAKWriting 1 to this field sets the Global OUT NAK.The application uses this bit to send a NAK handshake on all OUT endpoints.The application must set the this bit only after making sure that the Global OUT NAK effective bit in the Core interrupt register (GONAKEFF bit in OTG_FS_GINTSTS) is cleared.

Bit 7 SGINAK: Set global IN NAKWriting 1 to this field sets the Global non-periodic IN NAK. The application uses this bit to send a NAK handshake on all non-periodic IN endpoints.The application must set this bit only after making sure that the Global IN NAK effective bit in the Core interrupt register (GINAKEFF bit in OTG_FS_GINTSTS) is cleared.

Bit 3 GONSTS: Global OUT NAK status0: A handshake is sent based on the FIFO Status and the NAK and STALL bit settings.1: No data is written to the RxFIFO, irrespective of space availability. Sends a NAK handshake on all packets, except on SETUP transactions. All isochronous OUT packets are dropped.

Table 207 contains the minimum duration (according to device state) for which the Soft disconnect (SDIS) bit must be set for the USB host to detect a device disconnect. To accommodate clock jitter, it is recommended that the application add some extra delay to the specified minimum duration.

Bit 2 GINSTS: Global IN NAK status0: A handshake is sent out based on the data availability in the transmit FIFO.1: A NAK handshake is sent out on all non-periodic IN endpoints, irrespective of the data availability in the transmit FIFO.

Bit 1 SDIS: Soft disconnectThe application uses this bit to signal the USB OTG core to perform a soft disconnect. As long as this bit is set, the host does not see that the device is connected, and the device does not receive signals on the USB. The core stays in the disconnected state until the application clears this bit.0: Normal operation. When this bit is cleared after a soft disconnect, the core generates a device connect event to the USB host. When the device is reconnected, the USB host restarts device enumeration.1: The core generates a device disconnect event to the USB host.

Bit 0 RWUSIG: Remote wakeup signalingWhen the application sets this bit, the core initiates remote signaling to wake up the USB host. The application must set this bit to instruct the core to exit the Suspend state. As specified in the USB 2.0 specification, the application must clear this bit 1 ms to 15 ms after setting it.

This register works with each of the OTG_FS_DIEPINTx registers for all endpoints to generate an interrupt per IN endpoint. The IN endpoint interrupt for a specific status in the OTG_FS_DIEPINTx register can be masked by writing to the corresponding bit in this register. Status bits are masked by default.

Bit 3 EERR: Erratic errorThe core sets this bit to report any erratic errors.Due to erratic errors, the OTG_FS controller goes into Suspended state and an interrupt is generated to the application with Early suspend bit of the OTG_FS_GINTSTS register (ESUSP bit in OTG_FS_GINTSTS). If the early suspend is asserted due to an erratic error, the application can only perform a soft disconnect recover.

Bits 2:1 ENUMSPD: Enumerated speedIndicates the speed at which the OTG_FS controller has come up after speed detection through a chirp sequence.01: Reserved10: Reserved11: Full speed (PHY clock is running at 48 MHz)Others: reserved

Bit 0 SUSPSTS: Suspend statusIn device mode, this bit is set as long as a Suspend condition is detected on the USB. The core enters the Suspended state when there is no activity on the USB data lines for a period of 3 ms. The core comes out of the suspend:– When there is an activity on the USB data lines– When the application writes to the Remote wakeup signaling bit in the OTG_FS_DCTL register (RWUSIG bit in OTG_FS_DCTL).

This register works with each of the OTG_FS_DOEPINTx registers for all endpoints to generate an interrupt per OUT endpoint. The OUT endpoint interrupt for a specific status in the OTG_FS_DOEPINTx register can be masked by writing into the corresponding bit in this register. Status bits are masked by default.

When a significant event occurs on an endpoint, a OTG_FS_DAINT register interrupts the application using the Device OUT endpoints interrupt bit or Device IN endpoints interrupt bit of the OTG_FS_GINTSTS register (OEPINT or IEPINT in OTG_FS_GINTSTS, respectively). There is one interrupt bit per endpoint, up to a maximum of 16 bits for OUT endpoints and 16 bits for IN endpoints. For a bidirectional endpoint, the corresponding IN and OUT interrupt bits are used. Bits in this register are set and cleared when the application sets and clears bits in the corresponding Device Endpoint-x interrupt register (OTG_FS_DIEPINTx/OTG_FS_DOEPINTx).

The OTG_FS_DAINTMSK register works with the Device endpoint interrupt register to interrupt the application when an event occurs on a device endpoint. However, the OTG_FS_DAINT register bit corresponding to that interrupt is still set.

Bits 15:0 VBUSDT: Device VBUS discharge timeSpecifies the VBUS discharge time after VBUS pulsing during SRP. This value equals:VBUS discharge time in PHY clocks / 1 024Depending on your VBUS load, this value may need adjusting.

Bits 15:0 INEPTXFEM: IN EP Tx FIFO empty interrupt mask bitsThese bits act as mask bits for OTG_FS_DIEPINTx.TXFE interrupt one bit per IN endpoint:Bit 0 for IN endpoint 0, bit 3 for IN endpoint 30: Masked interrupt1: Unmasked interrupt

         Bit 31 EPENA: Endpoint enableThe application sets this bit to start transmitting data on the endpoint 0.The core clears this bit before setting any of the following interrupts on this endpoint:– Endpoint disabled– Transfer completed

Bit 30 EPDIS: Endpoint disableThe application sets this bit to stop transmitting data on an endpoint, even before the transfer for that endpoint is complete. The application must wait for the Endpoint disabled interrupt before treating the endpoint as disabled. The core clears this bit before setting the Endpoint disabled interrupt. The application must set this bit only if Endpoint enable is already set for this endpoint.

Bit 27 SNAK: Set NAKA write to this bit sets the NAK bit for the endpoint.Using this bit, the application can control the transmission of NAK handshakes on an endpoint. The core can also set this bit for an endpoint after a SETUP packet is received on that endpoint.

Bit 21 STALL: STALL handshakeThe application can only set this bit, and the core clears it when a SETUP token is received for this endpoint. If a NAK bit, a Global IN NAK or Global OUT NAK is set along with this bit, the STALL bit takes priority.

Bit 17 NAKSTS: NAK statusIndicates the following:0: The core is transmitting non-NAK handshakes based on the FIFO status1: The core is transmitting NAK handshakes on this endpoint.When this bit is set, either by the application or core, the core stops transmitting data, even if there are data available in the TxFIFO. Irrespective of this bit’s setting, the core always responds to SETUP data packets with an ACK handshake.

Bit 31 EPENA: Endpoint enableThe application sets this bit to start transmitting data on an endpoint.The core clears this bit before setting any of the following interrupts on this endpoint:–SETUP phase done–Endpoint disabled–Transfer completed

Bit 30 EPDIS: Endpoint disableThe application sets this bit to stop transmitting/receiving data on an endpoint, even before the transfer for that endpoint is complete. The application must wait for the Endpoint disabled interrupt before treating the endpoint as disabled. The core clears this bit before setting the Endpoint disabled interrupt. The application must set this bit only if Endpoint enable is already set for this endpoint.

Bit 27 SNAK: Set NAKA write to this bit sets the NAK bit for the endpoint.Using this bit, the application can control the transmission of NAK handshakes on an endpoint. The core can also set this bit for OUT endpoints on a Transfer completed interrupt, or after a SETUP is received on the endpoint.

Bits 25:22 TXFNUM: TxFIFO numberThese bits specify the FIFO number associated with this endpoint. Each active IN endpoint must be programmed to a separate FIFO number.This field is valid only for IN endpoints.

Bit 21 STALL: STALL handshakeApplies to non-control, non-isochronous IN endpoints only (access type is rw).The application sets this bit to stall all tokens from the USB host to this endpoint. If a NAK bit, Global IN NAK, or Global OUT NAK is set along with this bit, the STALL bit takes priority. Only the application can clear this bit, never the core.

Bit 17 NAKSTS: NAK statusIt indicates the following:0: The core is transmitting non-NAK handshakes based on the FIFO status.1: The core is transmitting NAK handshakes on this endpoint.When either the application or the core sets this bit:For non-isochronous IN endpoints: The core stops transmitting any data on an IN endpoint, even if there are data available in the TxFIFO.For isochronous IN endpoints: The core sends out a zero-length data packet, even if there are data available in the TxFIFO.Irrespective of this bit’s setting, the core always responds to SETUP data packets with an ACK handshake.

Bit 16 EONUM: Even/odd frameApplies to isochronous IN endpoints only.Indicates the frame number in which the core transmits/receives isochronous data for this endpoint. The application must program the even/odd frame number in which it intends to transmit/receive isochronous data for this endpoint using the SEVNFRM and SODDFRM fields in this register.0: Even frame1: Odd frameDPID: Endpoint data PIDApplies to interrupt/bulk IN endpoints only.Contains the PID of the packet to be received or transmitted on this endpoint. The application must program the PID of the first packet to be received or transmitted on this endpoint, after the endpoint is activated. The application uses the SD0PID register field to program either DATA0 or DATA1 PID.0: DATA01: DATA1

Bit 15 USBAEP: USB active endpointIndicates whether this endpoint is active in the current configuration and interface. The core clears this bit for all endpoints (other than EP 0) after detecting a USB reset. After receiving the SetConfiguration and SetInterface commands, the application must program endpoint registers accordingly and set this bit.

Bit 31 EPENA: Endpoint enableThe application sets this bit to start transmitting data on endpoint 0.The core clears this bit before setting any of the following interrupts on this endpoint:–SETUP phase done

Bit 27 SNAK: Set NAKA write to this bit sets the NAK bit for the endpoint.Using this bit, the application can control the transmission of NAK handshakes on an endpoint. The core can also set this bit on a Transfer completed interrupt, or after a SETUP is received on the endpoint.

Bit 21 STALL: STALL handshakeThe application can only set this bit, and the core clears it, when a SETUP token is received for this endpoint. If a NAK bit or Global OUT NAK is set along with this bit, the STALL bit takes priority. Irrespective of this bit’s setting, the core always responds to SETUP data packets with an ACK handshake.

Bit 20 SNPM: Snoop modeThis bit configures the endpoint to Snoop mode. In Snoop mode, the core does not check the correctness of OUT packets before transferring them to application memory.

Bit 17 NAKSTS: NAK statusIndicates the following:0: The core is transmitting non-NAK handshakes based on the FIFO status.1: The core is transmitting NAK handshakes on this endpoint.When either the application or the core sets this bit, the core stops receiving data, even if there is space in the RxFIFO to accommodate the incoming packet. Irrespective of this bit’s setting, the core always responds to SETUP data packets with an ACK handshake.

Bits 1:0 MPSIZ: Maximum packet sizeThe maximum packet size for control OUT endpoint 0 is the same as what is programmed in control IN endpoint 0.00: 64 bytes01: 32 bytes10: 16 bytes11: 8 bytes

Bit 31 EPENA: Endpoint enableApplies to IN and OUT endpoints.The application sets this bit to start transmitting data on an endpoint.The core clears this bit before setting any of the following interrupts on this endpoint:–SETUP phase done–Endpoint disabled–Transfer completed

Bit 30 EPDIS: Endpoint disableThe application sets this bit to stop transmitting/receiving data on an endpoint, even before the transfer for that endpoint is complete. The application must wait for the Endpoint disabled interrupt before treating the endpoint as disabled. The core clears this bit before setting the Endpoint disabled interrupt. The application must set this bit only if Endpoint enable is already set for this endpoint.

Bit 29 SD1PID: Set DATA1 PIDApplies to interrupt/bulk IN and OUT endpoints only. Writing to this field sets the endpoint data PID (DPID) field in this register to DATA1.SODDFRM: Set odd frameApplies to isochronous IN and OUT endpoints only. Writing to this field sets the Even/Odd frame (EONUM) field to odd frame.

Bit 27 SNAK: Set NAKA write to this bit sets the NAK bit for the endpoint.Using this bit, the application can control the transmission of NAK handshakes on an endpoint. The core can also set this bit for OUT endpoints on a Transfer Completed interrupt, or after a SETUP is received on the endpoint.

Bit 21 STALL: STALL handshakeApplies to non-control, non-isochronous OUT endpoints only (access type is rw).The application sets this bit to stall all tokens from the USB host to this endpoint. If a NAK bit, Global IN NAK, or Global OUT NAK is set along with this bit, the STALL bit takes priority. Only the application can clear this bit, never the core.

Bit 20 SNPM: Snoop modeThis bit configures the endpoint to Snoop mode. In Snoop mode, the core does not check the correctness of OUT packets before transferring them to application memory.

Bit 17 NAKSTS: NAK statusIndicates the following:0: The core is transmitting non-NAK handshakes based on the FIFO status.1: The core is transmitting NAK handshakes on this endpoint.When either the application or the core sets this bit:The core stops receiving any data on an OUT endpoint, even if there is space in the RxFIFO to accommodate the incoming packet.Irrespective of this bit’s setting, the core always responds to SETUP data packets with an ACK handshake.

Bit 16 EONUM: Even/odd frameApplies to isochronous IN and OUT endpoints only.Indicates the frame number in which the core transmits/receives isochronous data for this endpoint. The application must program the even/odd frame number in which it intends to transmit/receive isochronous data for this endpoint using the SEVNFRM and SODDFRM fields in this register.0: Even frame1: Odd frameDPID: Endpoint data PIDApplies to interrupt/bulk OUT endpoints only.Contains the PID of the packet to be received or transmitted on this endpoint. The application must program the PID of the first packet to be received or transmitted on this endpoint, after the endpoint is activated. The application uses the SD0PID register field to program either DATA0 or DATA1 PID.0: DATA01: DATA1

Bit 15 USBAEP: USB active endpointIndicates whether this endpoint is active in the current configuration and interface. The core clears this bit for all endpoints (other than EP 0) after detecting a USB reset. After receiving the SetConfiguration and SetInterface commands, the application must program endpoint registers accordingly and set this bit.

This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure 311. The application must read this register when the IN endpoints interrupt bit of the Core interrupt register (IEPINT in OTG_FS_GINTSTS) is set. Before the application can read this register, it must first read the device all endpoints interrupt (OTG_FS_DAINT) register to get the exact endpoint number for the Device endpoint-x interrupt register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_FS_DAINT and OTG_FS_GINTSTS registers.

Bit 13 NAK: NAK inputThe core generates this interrupt when a NAK is transmitted or received by the device. In case of isochronous IN endpoints the interrupt gets generated when a zero length packet is transmitted due to unavailability of data in the Tx FIFO.

Bit 11 PKTDRPSTS: Packet dropped statusThis bit indicates to the application that an ISOC OUT packet has been dropped. This bit does not have an associated mask bit and does not generate an interrupt.

Bit 6 INEPNE: IN endpoint NAK effectiveThis bit can be cleared when the application clears the IN endpoint NAK by writing to the CNAK bit in OTG_FS_DIEPCTLx.This interrupt indicates that the core has sampled the NAK bit set (either by the application or by the core). The interrupt indicates that the IN endpoint NAK bit set by the application has taken effect in the core.This interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL bit takes priority over a NAK bit.

Bit 5 INEPNM: IN token received with EP mismatch.Indicates that the data in the top of the non-periodic TxFIFO belongs to an endpoint other than the one for which the IN token was received. This interrupt is asserted on the endpoint for which the IN token was received.

This register indicates the status of an endpoint with respect to USB- and AHB-related events. It is shown in Figure 311. The application must read this register when the OUT Endpoints Interrupt bit of the OTG_FS_GINTSTS register (OEPINT bit in OTG_FS_GINTSTS) is set. Before the application can read this register, it must first read the OTG_FS_DAINT register to get the exact endpoint number for the OTG_FS_DOEPINTx register. The application must clear the appropriate bit in this register to clear the corresponding bits in the OTG_FS_DAINT and OTG_FS_GINTSTS registers.

Bit 4 ITTXFE: IN token received when TxFIFO is emptyApplies to non-periodic IN endpoints only.Indicates that an IN token was received when the associated TxFIFO (periodic/non-periodic) was empty. This interrupt is asserted on the endpoint for which the IN token was received.

Bit 13 NAK: NAK inputThe core generates this interrupt when a NAK is transmitted or received by the device. In case of isochronous IN endpoints the interrupt gets generated when a zero length packet is transmitted due to unavailability of data in the Tx FIFO.

The application must modify this register before enabling endpoint 0. Once endpoint 0 is enabled using the endpoint enable bit in the device control endpoint 0 control registers (EPENA in OTG_FS_DIEPCTL0), the core modifies this register. The application can only read this register once the core has cleared the Endpoint enable bit.

Bit 8 OUTPKTERR: OUT packet errorThis interrupt is asserted when the core detects an overflow or a CRC error for an OUT packet. This interrupt is valid only when thresholding is enabled.

Bit 5 STSPHSRX: Status phase received for control writeThis interrupt is generated only after the core has transferred all the data that the host has sent during the data phase of a control write transfer, to the system memory buffer. The interrupt indicates to the application that the host has switched from data phase to the status phase of a control write transfer. The application can use this interrupt to ACK or STALL the status phase, after it has decoded the data phase.

Bit 4 OTEPDIS: OUT token received when endpoint disabledApplies only to control OUT endpoints.Indicates that an OUT token was received when the endpoint was not yet enabled. This interrupt is asserted on the endpoint for which the OUT token was received.

Bit 3 STUP: SETUP phase doneApplies to control OUT endpoint only.Indicates that the SETUP phase for the control endpoint is complete and no more back-to-back SETUP packets were received for the current control transfer. On this interrupt, the application can decode the received SETUP data packet.

Bits 20:19 PKTCNT: Packet countIndicates the total number of USB packets that constitute the Transfer Size amount of data for endpoint 0.This field is decremented every time a packet (maximum size or short packet) is read from the TxFIFO.

Bits 6:0 XFRSIZ: Transfer sizeIndicates the transfer size in bytes for endpoint 0. The core interrupts the application only after it has exhausted the transfer size amount of data. The transfer size can be set to the maximum packet size of the endpoint, to be interrupted at the end of each packet.The core decrements this field every time a packet from the external memory is written to the TxFIFO.

The application must modify this register before enabling endpoint 0. Once endpoint 0 is enabled using the Endpoint enable bit in the OTG_FS_DOEPCTL0 registers (EPENA bit in OTG_FS_DOEPCTL0), the core modifies this register. The application can only read this register once the core has cleared the Endpoint enable bit.

Bits 6:0 XFRSIZ: Transfer sizeIndicates the transfer size in bytes for endpoint 0. The core interrupts the application only after it has exhausted the transfer size amount of data. The transfer size can be set to the maximum packet size of the endpoint, to be interrupted at the end of each packet.The core decrements this field every time a packet is read from the RxFIFO and written to the external memory.

The application must modify this register before enabling the endpoint. Once the endpoint is enabled using the Endpoint enable bit in the OTG_FS_DIEPCTLx registers (EPENA bit in OTG_FS_DIEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the Endpoint enable bit.

Bit 28:19 PKTCNT: Packet countIndicates the total number of USB packets that constitute the Transfer Size amount of data for this endpoint. This field is decremented every time a packet (maximum size or short packet) is read from the TxFIFO.

Bits 18:0 XFRSIZ: Transfer sizeThis field contains the transfer size in bytes for the current endpoint. The core only interrupts the application after it has exhausted the transfer size amount of data. The transfer size can be set to the maximum packet size of the endpoint, to be interrupted at the end of each packet.The core decrements this field every time a packet from the external memory is written to the TxFIFO.

The application must modify this register before enabling the endpoint. Once the endpoint is enabled using Endpoint Enable bit of the OTG_FS_DOEPCTLx registers (EPENA bit in OTG_FS_DOEPCTLx), the core modifies this register. The application can only read this register once the core has cleared the Endpoint enable bit.

15:0 INEPTFSAV: IN endpoint TxFIFO space availableIndicates the amount of free space available in the Endpoint TxFIFO.Values are in terms of 32-bit words:0x0: Endpoint TxFIFO is full0x1: 1 word available0x2: 2 words available0xn: n words availableOthers: Reserved

Bit 28:19 PKTCNT: Packet countIndicates the total number of USB packets that constitute the Transfer Size amount of data for this endpoint.This field is decremented every time a packet (maximum size or short packet) is written to the RxFIFO.

Bits 18:0 XFRSIZ: Transfer sizeThis field contains the transfer size in bytes for the current endpoint. The core only interrupts the application after it has exhausted the transfer size amount of data. The transfer size can be set to the maximum packet size of the endpoint, to be interrupted at the end of each packet.The core decrements this field every time a packet is read from the RxFIFO and written to the external memory.

Bit 1 GATEHCLK: Gate HCLKThe application sets this bit to gate HCLK to modules other than the AHB Slave and Master and wakeup logic when the USB is suspended or the session is not valid. The application clears this bit when the USB is resumed or a new session starts.

Bit 0 STPPCLK: Stop PHY clockThe application sets this bit to stop the PHY clock when the USB is suspended, the session is not valid, or the device is disconnected. The application clears this bit when the USB is resumed or a new session starts.

The application must perform the core initialization sequence. If the cable is connected during power-up, the current mode of operation bit in the OTG_FS_GINTSTS (CMOD bit in OTG_FS_GINTSTS) reflects the mode. The OTG_FS controller enters host mode when an “A” plug is connected or device mode when a “B” plug is connected.

This section explains the initialization of the OTG_FS controller after power-on. The application must follow the initialization sequence irrespective of host or device mode operation. All core global registers are initialized according to the core’s configuration:

The application can disable any channel by programming the OTG_FS_HCCHARx register with the CHDIS and CHENA bits set to 1. This enables the OTG_FS host to flush the posted requests (if any) and generates a channel halted interrupt. The application must wait for the CHH interrupt in OTG_FS_HCINTx before reallocating the channel for other transactions. The OTG_FS host does not interrupt the transaction that has already been started on the USB.

Before disabling a channel, the application must ensure that there is at least one free space available in the non-periodic request queue (when disabling a non-periodic channel) or the periodic request queue (when disabling a periodic channel). The application can simply flush the posted requests when the Request queue is full (before disabling the channel), by programming the OTG_FS_HCCHARx register with the CHDIS bit set to 1, and the CHENA bit cleared to 0.

The OTG_FS host automatically writes an entry (OUT request) to the periodic/non-periodic request queue, along with the last word write of a packet. The application must ensure that at least one free space is available in the periodic/non-periodic request queue before starting to write to the transmit FIFO. The application must always write to the transmit FIFO in words. If the packet size is non-word aligned, the application must use padding. The OTG_FS host determines the actual packet size based on the programmed maximum packet size and transfer size.

A typical bulk or control OUT/SETUP pipelined transaction-level operation is shown in Figure 315. See channel 1 (ch_1). Two bulk OUT packets are transmitted. A control SETUP transaction operates in the same way but has only one packet. The assumptions are:

Reset Error CountMask ACKDe-allocate Channel}else if (STALL){Transfer Done = 1Unmask CHHDisable Channel}else if (NAK or TXERR ){Rewind Buffer PointersUnmask CHHDisable Channelif (TXERR){Increment Error CountUnmask ACK}else{Reset Error Count}}else if (CHH){Mask CHHif (Transfer Done or (Error_count == 3)){De-allocate Channel}else{Re-initialize Channel}}else if (ACK){Reset Error CountMask ACK}

The application is expected to write the data packets into the transmit FIFO as and when the space is available in the transmit FIFO and the Request queue. The application can make use of the NPTXFE interrupt in OTG_FS_GINTSTS to find the transmit FIFO space.

e) In response to the RXFLVL interrupt, mask the RXFLVL interrupt and read the received packet status to determine the number of bytes received, then read the receive FIFO accordingly. Following this, unmask the RXFLVL interrupt.

i) In response to the XFRC interrupt, disable the channel and stop writing the OTG_FS_HCCHAR2 register for further requests. The core writes a channel disable request to the non-periodic request queue as soon as the OTG_FS_HCCHAR2 register is written.

Setup, Data, and Status stages of a control transfer must be performed as three separate transfers. Setup-, Data- or Status-stage OUT transactions are performed similarly to the bulk OUT transactions explained previously. Data- or Status-stage IN transactions are performed similarly to the bulk IN transactions explained previously. For all three stages, the application is expected to set the EPTYP field in OTG_FS_HCCHAR1 to Control. During the Setup stage, the application is expected to set the PID field in OTG_FS_HCTSIZ1 to SETUP.

Disable Channelif (STALL){Transfer Done = 1}}elseif (NAK or TXERR){Rewind Buffer PointersReset Error CountMask ACKUnmask CHHDisable Channel}elseif (CHH){Mask CHHif (Transfer Done or (Error_count == 3)){De-allocate Channel}else{Re-initialize Channel (in next b_interval - 1 Frame)}}elseif (ACK){Reset Error CountMask ACK}

f) In response to the RXFLVL interrupt, read the received packet status to determine the number of bytes received, then read the receive FIFO accordingly. The application must mask the RXFLVL interrupt before reading the receive FIFO, and unmask after reading the entire packet.

g) The core generates the RXFLVL interrupt for the transfer completion status entry in the receive FIFO. The application must read and ignore the receive packet status when the receive packet status is not an IN data packet (PKTSTS in GRXSTSR ≠ 0b0010).

i) In response to the XFRC interrupt, read the PKTCNT field in OTG_FS_HCTSIZ2. If the PKTCNT bit in OTG_FS_HCTSIZ2 is not equal to 0, disable the channel before re-initializing the channel for the next transfer, if any). If PKTCNT bit in 

f) In response to the RXFLVL interrupt, read the received packet status to determine the number of bytes received, then read the receive FIFO accordingly. The application must mask the RXFLVL interrupt before reading the receive FIFO, and unmask it after reading the entire packet.

g) The core generates an RXFLVL interrupt for the transfer completion status entry in the receive FIFO. This time, the application must read and ignore the receive packet status when the receive packet status is not an IN data packet (PKTSTS bit in OTG_FS_GRXSTSR ≠ 0b0010).

The non-periodic request queue depth affects the performance of non-periodic transfers. The deeper the queue (along with sufficient FIFO size), the more often the core is able to pipeline non-periodic transfers. If the queue size is small, the core is able to put in new requests only when the queue space is freed up.

The core’s periodic request queue depth is critical to perform periodic transfers as scheduled. Select the periodic queue depth, based on the number of periodic transfers scheduled in a microframe. If the periodic request queue depth is smaller than the periodic transfers scheduled in a microframe, a frame overrun condition occurs.

When OTG_FS controller detects a packet babble, it stops writing data into the Rx buffer and waits for the end of packet (EOP). When it detects an EOP, it flushes already written data in the Rx buffer and generates a Babble interrupt to the application.

When OTG_FS controller detects a port babble, it flushes the RxFIFO and disables the port. The core then generates a Port disabled interrupt (HPRTINT in OTG_FS_GINTSTS, PENCHNG in OTG_FS_HPRT). On receiving this interrupt, the application must determine that this is not due to an overcurrent condition (another cause of the Port Disabled interrupt) by checking POCA in OTG_FS_HPRT, then perform a soft reset. The core does not send any more tokens after it has detected a port babble condition.

–Program the OTG_FS_GRXFSIZ register, to be able to receive control OUT data and setup data. If thresholding is not enabled, at a minimum, this must be equal to 1 max packet size of control endpoint 0 + 2 words (for the status of the control OUT data packet) + 10 words (for setup packets).

–Program the OTG_FS_TX0FSIZ register (depending on the FIFO number chosen) to be able to transmit control IN data. At a minimum, this must be equal to 1 max packet size of control endpoint 0.

c) Setup stage done pattern:PKTSTS = Setup Stage Done, BCNT = 0x0, EPNUM = Control EP Num, DPID = Don’t Care (0b00).These data indicate that the Setup stage for the specified endpoint has completed and the Data stage has started. After this entry is popped from the receive FIFO, the core asserts a Setup interrupt on the specified control OUT endpoint.

e) Data transfer completed pattern:PKTSTS = Data OUT Transfer Done, BCNT = 0x0, EPNUM = OUT EP Num on which the data transfer is complete, DPID = Don’t Care (0b00).These data indicate that an OUT data transfer for the specified OUT endpoint has completed. After this entry is popped from the receive FIFO, the core asserts a Transfer Completed interrupt on the specified OUT endpoint.

–The space to be reserved is 10 words. Three words are required for the first SETUP packet, 1 word is required for the Setup stage done word and 6 words are required to store two extra SETUP packets among all control endpoints.

–3 words per SETUP packet are required to store 8 bytes of SETUP data and 4 bytes of SETUP status (Setup packet pattern). The core reserves this space in the receive data FIFO to write SETUP data only, and never uses this space for data packets.

Per the USB 2.0 specification, normally, during a SETUP packet error, a host does not send more than three back-to-back SETUP packets to the same endpoint. However, the USB 2.0 specification does not limit the number of back-to-back SETUP packets a host can send to the same endpoint. When this condition occurs, the OTG_FS controller generates an interrupt (B2BSTUP in OTG_FS_DOEPINTx).

–After sending an ACK for the packet on the USB, the core discards non-isochronous OUT data packets that the host, which cannot detect the ACK, re-sends. The application does not detect multiple back-to-back data OUT packets on the same endpoint with the same data PID. In this case the packet count is not decremented.

–If there is no space in the receive FIFO, isochronous or non-isochronous data packets are ignored and not written to the receive FIFO. Additionally, non-isochronous OUT tokens receive a NAK handshake reply.

–When all data are emptied from the receive FIFO, the application can detect the XFRC interrupt (OTG_FS_DOEPINTx). In this case, the application must re-enable the endpoint to receive isochronous OUT data in the next frame.

The application can write multiple packets for the same endpoint into the transmit FIFO, if space is available. For periodic IN endpoints, the application must write packets only for one microframe. It can write packets for the next periodic transaction only after getting transfer complete for the previous transaction.

The application must poll the OTG_FS_GRSTCTL register, until the TXFFLSH bit is cleared by the core, which indicates the end of flush operation. To transmit new data on this endpoint, the application can re-enable the endpoint at a later point.

–The application can only transmit multiples of maximum-packet-size data packets or multiples of maximum-packet-size packets, plus a short packet at the end. To transmit a few maximum-packet-size packets and a short packet at the end of the transfer, the following conditions must be met:

–The application cannot transmit a zero-length data packet at the end of a transfer. It can transmit a single zero-length data packet by itself. To transmit a single zero-length data packet:

a) The core receives a corrupted isochronous IN token on at least one isochronous IN endpoint. In this case, the application detects an incomplete isochronous IN transfer interrupt (IISOIXFR in OTG_FS_GINTSTS).

b) The application is slow to write the complete data payload to the transmit FIFO and an IN token is received before the complete data payload is written to the FIFO. In this case, the application detects an IN token received when TxFIFO empty interrupt in OTG_FS_DIEPINTx. The application can ignore this interrupt, as it eventually results in an incomplete isochronous IN transfer interrupt (IISOIXFR in OTG_FS_GINTSTS) at the end of periodic frame.

–At this point, the application must flush the data in the associated transmit FIFO or overwrite the existing data in the FIFO by enabling the endpoint for a new transfer in the next microframe. To flush the data, the application must use the OTG_FS_GRSTCTL register.

The core must stall IN/OUT tokens if, during the data stage of a control transfer, the host sends more IN/OUT tokens than are specified in the SETUP packet. In this case, the application must enable the ITTXFE interrupt in OTG_FS_DIEPINTx and the OTEPDIS interrupt in OTG_FS_DOEPINTx during the data stage of the control transfer, after the core has transferred the amount of data specified in the SETUP packet. Then, when the application receives this interrupt, it must set the STALL bit in the corresponding endpoint control register, and clear this interrupt.

When the OTG_FS controller acts as a device, there is a worst case response time for any tokens that follow an isochronous OUT. This worst case response time depends on the AHB clock frequency.

The core registers are in the AHB domain, and the core does not accept another token before updating these register values. The worst case is for any token following an isochronous OUT, because for an isochronous transaction, there is no handshake and the next token could come sooner. This worst case value is 7 PHY clocks when the AHB clock is the same as the PHY clock. When the AHB clock is faster, this value is smaller.

If this worst case condition occurs, the core responds to bulk/interrupt tokens with a NAK and drops isochronous and SETUP tokens. The host interprets this as a timeout condition for SETUP and retries the SETUP packet. For isochronous transfers, the Incomplete isochronous IN transfer interrupt (IISOIXFR) and Incomplete isochronous OUT transfer interrupt (IISOOXFR) inform the application that isochronous IN/OUT packets were dropped.

The value in TRDT (OTG_FS_GUSBCFG) is the time it takes for the MAC, in terms of PHY clocks after it has received an IN token, to get the FIFO status, and thus the first data from the PFC block. This time involves the synchronization delay between the PHY and AHB clocks. The worst case delay for this is when the AHB clock is the same as the PHY clock. In this case, the delay is 5 clocks.

Once the MAC receives an IN token, this information (token received) is synchronized to the AHB clock by the PFC (the PFC runs on the AHB clock). The PFC then reads the data from the SPRAM and writes them into the dual clock source buffer. The MAC then reads the data out of the source buffer (4 deep).

The OTG_FS controller is an OTG device supporting HNP and SRP. When the core is connected to an “A” plug, it is referred to as an A-device. When the core is connected to a “B” plug it is referred to as a B-device. In host mode, the OTG_FS controller turns off VBUS to conserve power. SRP is a method by which the B-device signals the A-device to turn on VBUS power. A device must perform both data-line pulsing and VBUS pulsing, but a host can detect either data-line pulsing or VBUS pulsing for SRP. HNP is a method by which the B-device negotiates and switches to host role. In Negotiated mode after HNP, the B-device suspends the bus and reverts to the device role.

The application must set the SRP-capable bit in the Core USB configuration register. This enables the OTG_FS controller to initiate SRP as a B-device. SRP is a means by which the OTG_FS controller can request a new session from the host.

The OTG_FS controller sets the early suspend bit in the Core interrupt register after 3 ms of bus idleness. Following this, the OTG_FS controller sets the USB suspend bit in the Core interrupt register.

For a USB 1.1 full-speed serial transceiver, the application must wait until VBUS discharges to 0.2 V after BSVLD (in OTG_FS_GOTGCTL) is deasserted. This discharge time can be obtained from the transceiver vendor and varies from one transceiver to another.

The host starts a new session by turning on VBUS, indicating SRP success. The OTG_FS controller interrupts the application by setting the session request success status change bit in the OTG interrupt status register. The application reads the session request success bit in the OTG control and status register.

HNP switches the USB host role from the A-device to the B-device. The application must set the HNP-capable bit in the Core USB configuration register to enable the OTG_FS controller to perform HNP as an A-device.

The OTG_FS controller deasserts the DM pull down and DM pull down in the PHY to indicate a device role. The PHY enables the OTG_FS_DP pull-up resistor to indicate a connect for B-device.

The OTG_FS controller sets the early suspend bit in the Core interrupt register after 3 ms of bus idleness. Following this, the OTG_FS controller sets the USB Suspend bit in the Core interrupt register.

HNP switches the USB host role from B-device to A-device. The application must set the HNP-capable bit in the Core USB configuration register to enable the OTG_FS controller to perform HNP as a B-device.

The OTG_FS controller sets the Early suspend bit in the Core interrupt register after 3 ms of bus idleness. Following this, the OTG_FS controller sets the USB suspend bit in the Core interrupt register.

The OTG_FS controller disconnects and the A-device detects SE0 on the bus, indicating HNP. The OTG_FS controller asserts the DP pull down and DM pull down in the PHY to indicate its assumption of the host role.

The OTG_FS controller sets the host negotiation success status change interrupt in the OTG Interrupt status register, indicating the HNP status. The application must read the host negotiation success bit in the OTG Control and status register to determine host negotiation success. The application must read the current Mode bit in the Core interrupt register (OTG_FS_GINTSTS) to determine host mode operation.

The Ethernet provides a configurable, flexible peripheral to meet the needs of various applications and customers. It supports two industry standard interfaces to the external physical layer (PHY): the default media independent interface (MII) defined in the IEEE 802.3 specifications and the reduced media independent interface (RMII). It can be used in number of applications such as switches, network interface cards, etc.

Table 209 shows the MAC signals and the corresponding MII/RMII default or remapped signals. It also indicates the pins onto which the signals are input or output, and the pin configuration.

The Ethernet peripheral consists of a MAC 802.3 (media access control) with a dedicated DMA controller. It supports both default media-independent interface (MII) and reduced media-independent interface (RMII) through one selection bit (refer to AFIO_MAPR register).

The DMA controller interfaces with the Core and memories through the AHB Master and Slave interfaces. The AHB Master Interface controls data transfers while the AHB Slave interface accesses Control and Status Registers (CSR) space.

The Transmit FIFO (Tx FIFO) buffers data read from system memory by the DMA before transmission by the MAC Core. Similarly, the Receive FIFO (Rx FIFO) stores the Ethernet frames received from the line until they are transferred to system memory by the DMA. 

The Ethernet peripheral also includes an SMI to communicate with external PHY. A set of configuration registers permit the user to select the desired mode and features for the MAC and the DMA controller.

The application can select one of the 32 PHYs and one of the 32 registers within any PHY and send control data or receive status information. Only one register in one PHY can be addressed at any given time.


• MDC: a periodic clock that provides the timing reference for the data transfer at the maximum frequency of 2.5 MHz. The minimum high and low times for MDC must be 160 ns each, and the minimum period for MDC must be 400 ns. In idle state the SMI management interface drives the MDC clock signal low.


• Preamble: each transaction (read or write) can be initiated with the preamble field that corresponds to 32 contiguous logic one bits on the MDIO line with 32 corresponding cycles on MDC. This field is used to establish synchronization with the PHY device.


• RADDR: the register address is 5 bits, allowing 32 individual registers to be addressed within the selected PHY device. The MSB bit of the address is the first transmitted and received.


• TA: the turn-around field defines a 2-bit pattern between the RADDR and DATA fields to avoid contention during a read transaction. For a read transaction the MAC controller drives high-impedance on the MDIO line for the 2 bits of TA. The PHY device must drive a high-impedance state on the first bit of TA, a zero bit on the second one.

When the application sets the MII Write and Busy bits (in Ethernet MAC MII address register (ETH_MACMIIAR)), the SMI initiates a write operation into the PHY registers by transferring the PHY address, the register address in PHY, and the write data (in Ethernet MAC MII data register (ETH_MACMIIDR). The application should not change the MII Address register contents or the MII Data register while the transaction is ongoing. Write operations to the MII Address register or the MII Data Register during this period are ignored (the Busy bit is high), and the transaction is completed without any error. After the Write operation has completed, the SMI indicates this by resetting the Busy bit.

When the user sets the MII Busy bit in the Ethernet MAC MII address register (ETH_MACMIIAR) with the MII Write bit at 0, the SMI initiates a read operation in the PHY registers by transferring the PHY address and the register address in PHY. The application should not change the MII Address register contents or the MII Data register while the transaction is ongoing. Write operations to the MII Address register or MII Data Register during this period are ignored (the Busy bit is high) and the transaction is completed without any error. After the read operation has completed, the SMI resets the Busy bit and then updates the MII Data register with the data read from the PHY. 

The MAC initiates the Management Write/Read operation. The SMI clock is a divided clock whose source is the application clock (AHB clock). The divide factor depends on the clock range setting in the MII Address register.


• MII_TX_EN: transmission enable indicates that the MAC is presenting nibbles on the MII for transmission. It must be asserted synchronously (MII_TX_CLK) with the first nibble of the preamble and must remain asserted while all nibbles to be transmitted are presented to the MII.


• MII_TXD[3:0]: transmit data is a bundle of 4 data signals driven synchronously by the MAC sublayer and qualified (valid data) on the assertion of the MII_TX_EN signal. MII_TXD[0] is the least significant bit, MII_TXD[3] is the most significant bit. While MII_TX_EN is deasserted the transmit data must have no effect upon the PHY.


• MII_CRS: carrier sense is asserted by the PHY when either the transmit or receive medium is non idle. It shall be deasserted by the PHY when both the transmit and receive media are idle. The PHY must ensure that the MII_CS signal remains asserted throughout the duration of a collision condition. This signal is not required to transition synchronously with respect to the TX and RX clocks. In full duplex mode the state of this signal is don’t care for the MAC sublayer.


• MII_COL: collision detection must be asserted by the PHY upon detection of a collision on the medium and must remain asserted while the collision condition persists. This signal is not required to transition synchronously with respect to the TX and RX clocks. In full duplex mode the state of this signal is don’t care for the MAC sublayer.


• MII_RXD[3:0]: reception data is a bundle of 4 data signals driven synchronously by the PHY and qualified (valid data) on the assertion of the MII_RX_DV signal. MII_RXD[0] is the least significant bit, MII_RXD[3] is the most significant bit. While MII_RX_EN is deasserted and MII_RX_ER is asserted, a specific MII_RXD[3:0] value is used to transfer specific information from the PHY (see Table 213).


• MII_RX_DV: receive data valid indicates that the PHY is presenting recovered and decoded nibbles on the MII for reception. It must be asserted synchronously (MII_RX_CLK) with the first recovered nibble of the frame and must remain asserted through the final recovered nibble. It must be deasserted prior to the first clock cycle that follows the final nibble. In order to receive the frame correctly, the MII_RX_DV signal must encompass the frame, starting no later than the SFD field.


• MII_RX_ER: receive error must be asserted for one or more clock periods (MII_RX_CLK) to indicate to the MAC sublayer that an error was detected somewhere in the frame. This error condition must be qualified by MII_RX_DV assertion as described in Table 213.

To generate both TX_CLK and RX_CLK clock signals, the external PHY must be clocked with an external 25 MHz as shown in Figure 332. Instead of using an external 25 MHz quartz to provide this clock, the STM32F10xxx microcontroller can output this signal on its MCO pin. In this case, the PLL multiplier has to be configured so as to get the desired frequency on the MCO pin, from the 25 MHz external quartz.

The reduced media-independent interface (RMII) specification reduces the pin count between the microcontroller Ethernet peripheral and the external Ethernet in 10/100 Mbit/s. According to the IEEE 802.3u standard, an MII contains 16 pins for data and control. The RMII specification is dedicated to reduce the pin count to 7 pins (a 62.5% decrease in pin count).

As described in the RMII clock sources section, the STM32F10xxxSTM32F107xx could provide this 50 MHz clock signal on its MCO output pin and you then have to configure this output value through PLL configuration.

The mode, MII or RMII, is selected using the configuration bit 23, MII_RMII_SEL, in the AFIO_MAPR register. The application has to set the MII/RMII mode while the Ethernet controller is under reset or before enabling the clocks.

The MAC block implements the LAN CSMA/CD sublayer for the following families of systems: 10 Mbit/s and 100 Mbit/s of data rates for baseband and broadband systems. Half- and full-duplex operation modes are supported. The collision detection access method is applied only to the half-duplex operation mode. The MAC control frame sublayer is supported.

–The first LSB bit (I/G) in the destination address field is used to indicate an individual (I/G = 0) or a group address (I/G = 1). A group address could identify 


• QTag Prefix: 4-byte field inserted between the Source address field and the MAC Client Length/Type field. This field is an extension of the basic frame (untagged) to obtain the tagged MAC frame. The untagged MAC frames do not include this field. The extensions for tagging are as follows:

–2-byte constant Length/Type field value consistent with the Type interpretation (greater than 0x0600) equal to the value of the 802.1Q Tag Protocol Type (0x8100 hexadecimal). This constant field is used to distinguish tagged and untagged MAC frames.

–2-byte field containing the Tag control information field subdivided as follows: a 3-bit user priority, a canonical format indicator (CFI) bit and a 12-bit VLAN Identifier. The length of the tagged MAC frame is extended by 4 bytes by the QTag Prefix.

–If the value is less than or equal to maxValidFrame (0d1500) then this field indicates the number of MAC client data bytes contained in the subsequent data field of the 802.3 frame (length interpretation).

–If the value is greater than or equal to MinTypeValue (0d1536 decimal, 0x0600) then this field indicates the nature of the MAC client protocol (Type interpretation) related to the Ethernet frame.

Regardless of the interpretation of the length/type field, if the length of the data field is less than the minimum required for proper operation of the protocol, a PAD field is 

For length/type field values in the range between maxValidLength and minTypeValue (boundaries excluded), the behavior of the MAC sublayer is not specified: they may or may not be passed by the MAC sublayer.


• Data and PAD fields: n-byte data field. Full data transparency is provided, it means that any arbitrary sequence of byte values may appear in the data field. The size of the PAD, if any, is determined by the size of the data field. Max and min length of the data and PAD field are:

When the data field length is less than the minimum required, the PAD field is added to match the minimum length (42 bytes for tagged frames, 46 bytes for untagged frames).


• Frame check sequence: 4-byte field that contains the cyclic redundancy check (CRC) value. The CRC computation is based on the following fields: source address, destination address, QTag prefix, length/type, LLC data and PAD (that is, all fields except the preamble, SFD). The generating polynomial is the following:


• The n-bits of the frame are the coefficients of a polynomial M(x) of degree (n – 1). The first bit of the destination address corresponds to the xn – 1 term and the last bit of the data field corresponds to the x0 term


• The frame length is inconsistent with the expected value as specified by the length/type field. If the length/type field contains a type value, then the frame length is assumed to be consistent with this field (no invalid frame)

The DMA controls all transactions for the transmit path. Ethernet frames read from the system memory are pushed into the FIFO by the DMA. The frames are then popped out and transferred to the MAC core. When the end-of-frame is transferred, the status of the transmission is taken from the MAC core and transferred back to the DMA. The Transmit FIFO has a depth of 2 Kbyte. FIFO-fill level is indicated to the DMA so that it can initiate a data fetch in required bursts from the system memory, using the AHB interface. The data from the AHB Master interface is pushed into the FIFO.

When the SOF is detected, the MAC accepts the data and begins transmitting to the MII. The time required to transmit the frame data to the MII after the application initiates transmission is variable, depending on delay factors like IFG delay, time to transmit preamble/SFD, and any back-off delays for Half-duplex mode. After the EOF is transferred to the MAC core, the core completes normal transmission and then gives the status of transmission back to the DMA. If a normal collision (in Half-duplex mode) occurs during transmission, the MAC core makes the transmit status valid, then accepts and drops all further data until the next SOF is received. The same frame should be retransmitted from SOF on observing a Retry request (in the Status) from the MAC. The MAC issues an underflow status if the data are not provided continuously during the transmission. During the normal transfer of a frame, if the MAC receives an SOF without getting an EOF for the previous frame, then the SOF is ignored and the new frame is considered as the continuation of the previous frame.


• In Threshold mode, as soon as the number of bytes in the FIFO crosses the configured threshold level (or when the end-of-frame is written before the threshold is crossed), the data is ready to be popped out and forwarded to the MAC core. The threshold level is configured using the TTC bits of ETH_DMABMR.


• In Store-and-forward mode, only after a complete frame is stored in the FIFO, the frame is popped towards the MAC core. If the Tx FIFO size is smaller than the Ethernet frame to be transmitted, then the frame is popped towards the MAC core when the Tx FIFO becomes almost full.

The application can flush the Transmit FIFO of all contents by setting the FTF (ETH_DMAOMR register [20]) bit. This bit is self-clearing and initializes the FIFO pointers to the default state. If the FTF bit is set during a frame transfer to the MAC core, then transfer is stopped as the FIFO is considered to be empty. Hence an underflow event occurs at the MAC transmitter and the corresponding Status word is forwarded to the DMA.

When a new frame transmission is requested, the MAC sends out the preamble and SFD, followed by the data. The preamble is defined as 7 bytes of 0b10101010 pattern, and the SFD is defined as 1 byte of 0b10101011 pattern. The collision window is defined as 1 slot time (512 bit times for 10/100 Mbit/s Ethernet). The jam pattern generation is applicable only to Half-duplex mode, not to Full-duplex mode.

In MII mode, if a collision occurs at any time from the beginning of the frame to the end of the CRC field, the MAC sends a 32-bit jam pattern of 0x5555 5555 on the MII to inform all other stations that a collision has occurred. If the collision is seen during the preamble transmission phase, the MAC completes the transmission of the preamble and SFD and then sends the jam pattern.

A jabber timer is maintained to cut off the transmission of Ethernet frames if more than 2048 (default) bytes have to be transferred. The MAC uses the deferral mechanism for flow control (back pressure) in Half-duplex mode. When the application requests to stop receiving frames, the MAC sends a JAM pattern of 32 bytes whenever it senses the reception of a frame, provided that transmit flow control is enabled. This results in a collision and the remote station backs off. The application requests flow control by setting the BPA bit (bit 0) in the ETH_MACFCR register. If the application requests a frame to be transmitted, then it is scheduled and transmitted even when back pressure is activated. Note that if back pressure is kept activated for a long time (and more than 16 consecutive collision events occur) then the remote stations abort their transmissions due to excessive collisions. If IEEE 1588 time stamping is enabled for the transmit frame, this block takes a snapshot of the system time when the SFD is put onto the transmit MII bus.

The MAC is responsible for scheduling the frame transmission on the MII. It maintains the interframe gap between two transmitted frames and follows the truncated binary exponential backoff algorithm for Half-duplex mode. The MAC enables transmission after satisfying the IFG and backoff delays. It maintains an idle period of the configured interframe gap (IFG bits in the ETH_MACCR register) between any two transmitted frames. If frames to be transmitted arrive sooner than the configured IFG time, the MII waits for the enable signal from the MAC before starting the transmission on it. The MAC starts its IFG counter as soon as the carrier signal of the MII goes inactive. At the end of the programmed IFG value, the MAC enables transmission in Full-duplex mode. In Half-duplex mode and when IFG is 

When the Transmit Flow Control Enable bit (TFE bit in ETH_MACFCR) is set, the MAC generates Pause frames and transmits them as necessary, in Full-duplex mode. The Pause frame is appended with the calculated CRC, and is sent. Pause frame generation can be initiated in two ways.


• If the application has requested flow control by setting the FCB bit in ETH_MACFCR, the MAC generates and transmits a single Pause frame. The value of the pause time in the generated frame contains the programmed pause time value in ETH_MACFCR. To extend the pause or end the pause prior to the time specified in the previously transmitted Pause frame, the application must request another Pause frame transmission after programming the Pause Time value (PT in ETH_MACFCR register) with the appropriate value.


• If the application has requested flow control when the receive FIFO is full, the MAC generates and transmits a Pause frame. The value of the pause time in the generated frame is the programmed pause time value in ETH_MACFCR. If the receive FIFO remains full at a configurable number of slot-times (PLT bits in ETH_MACFCR) before this Pause time runs out, a second Pause frame is transmitted. The process is repeated as long as the receive FIFO remains full. If this condition is no more satisfied prior to the sampling time, the MAC transmits a Pause frame with zero pause time to indicate to the remote end that the receive buffer is ready to receive new data frames.

frame is being transmitted. As soon as the first frame has been transferred and the status is received from the MAC, it is pushed to the DMA. If the DMA has already completed sending the second packet to the FIFO, the second transmission must wait for the status of the first packet before proceeding to the next frame.

While a frame is being transferred to the MAC, a collision event may occur on the MAC line interface in Half-duplex mode. The MAC would then indicate a retry attempt by giving the status even before the end of frame is received. Then the retransmission is enabled and the frame is popped out again from the FIFO. After more than 96 bytes have been popped towards the MAC core, the FIFO controller frees up that space and makes it available to the DMA to push in more data. This means that the retransmission is not possible after this threshold is crossed or when the MAC core indicates a late collision event.

The MAC provides a control to the software to flush the Transmit FIFO through the use of Bit 20 in the Operation mode register. The Flush operation is immediate and the Tx FIFO and the corresponding pointers are cleared to the initial state even if the Tx FIFO is in the middle of transferring a frame to the MAC Core. This results in an underflow event in the MAC transmitter, and the frame transmission is aborted. The status of such a frame is marked with both underflow and frame flush events (TDES0 bits 13 and 1). No data are coming to the FIFO from the application (DMA) during the Flush operation. Transfer transmit status words are transferred to the application for the number of frames that is flushed (including partial frames). Frames that are completely flushed have the Frame flush status bit (TDES0 13) set. The Flush operation is completed when the application (DMA) has accepted all of the Status words for the frames that were flushed. The Transmit FIFO Flush control register bit is then cleared. At this point, new frames from the application (DMA) are accepted. All data presented for transmission after a Flush operation are discarded unless they start with an SOF marker.

At the end of the Ethernet frame transfer to the MAC core and after the core has completed the transmission of the frame, the transmit status is given to the application. The detailed description of the Transmit Status is the same as for bits [23:0] in TDES0. If IEEE 1588 time stamping is enabled, a specific frames’ 64-bit time stamp is returned, along with the transmit status.

Communication protocols such as TCP and UDP implement checksum fields, which helps determine the integrity of data transmitted over a network. Because the most widespread use of Ethernet is to encapsulate TCP and UDP over IP datagrams, the Ethernet controller has a transmit checksum offload feature that supports checksum calculation and insertion in the transmit path, and error detection in the receive path. This section explains the operation of the checksum offload feature for transmitted frames.

Note:The checksum for TCP, UDP or ICMP is calculated over a complete frame, then inserted into its corresponding header field. Due to this requirement, this function is enabled only when the Transmit FIFO is configured for Store-and-forward mode (that is, when the TSF bit 

You must make sure the Transmit FIFO is deep enough to store a complete frame before that frame is transferred to the MAC Core transmitter. If the FIFO depth is less than the input Ethernet frame size, the payload (TCP/UDP/ICMP) checksum insertion function is bypassed and only the frame’s IPv4 Header checksum is modified, even in Store-and-forward mode.

The transmit checksum offload supports two types of checksum calculation and insertion. This checksum can be controlled for each frame by setting the CIC bits (Bits 28:27 in TDES1, described in TDES1: Transmit descriptor Word1).

In IPv4 datagrams, the integrity of the header fields is indicated by the 16-bit header checksum field (the eleventh and twelfth bytes of the IPv4 datagram). The checksum offload detects an IPv4 datagram when the Ethernet frame’s Type field has the value 0x0800 and the IP datagram’s Version field has the value 0x4. The input frame’s checksum field is ignored during calculation and replaced by the calculated value. IPv6 headers do not have a checksum field; thus, the checksum offload does not modify IPv6 header fields. The result of this IP header checksum calculation is indicated by the IP Header Error status bit in the Transmit status (Bit 16). This status bit is set whenever the values of the Ethernet Type field and the IP header’s Version field are not consistent, or when the Ethernet frame does not have enough data, as indicated by the IP header Length field. In other words, this bit is set when an IP header error is asserted under the following circumstances:

–The frame ends before the IPv6 header (40 bytes) or extension header (as given in the corresponding Header Length field in an extension header) has been completely received. Even when the checksum offload detects such an IP header 

b) Fragmented IP frames (IPv4 or IPv6), IP frames with security features (such as an authentication header or encapsulated security payload), and IPv6 frames with routing headers are bypassed and not processed by the checksum.

–In the first mode, the TCP, UDP, or ICMPv6 pseudo-header is not included in the checksum calculation and is assumed to be present in the input frame’s checksum field. The checksum field is included in the checksum calculation, and then replaced by the final calculated checksum.

–In the second mode, the checksum field is ignored, the TCP, UDP, or ICMPv6 pseudo-header data are included into the checksum calculation, and the checksum field is overwritten with the final calculated value.

Note that: for ICMP-over-IPv4 packets, the checksum field in the ICMP packet must always be 0x0000 in both modes, because pseudo-headers are not defined for such packets. If it does not equal 0x0000, an incorrect checksum may be inserted into the packet.

The result of this operation is indicated by the payload checksum error status bit in the Transmit Status vector (bit 12). The payload checksum error status bit is set when either of the following is detected:

When the packet is longer than the indicated payload length, the bytes are ignored as stuff bytes, and no error is reported. When the first type of error is detected, the TCP, UDP or ICMP header is not modified. For the second error type, still, the calculated checksum is inserted into the corresponding header field.

Each nibble from the MII is transmitted on the RMII a dibit at a time with the order of dibit transmission shown in Figure 339. Lower order bits (D1 and D0) are transmitted first followed by higher order bits (D2 and D3).

The MAC received frames are pushes into the Rx FIFO. The status (fill level) of this FIFO is indicated to the DMA once it crosses the configured receive threshold (RTC in the ETH_DMAOMR register) so that the DMA can initiate pre-configured burst transfers towards the AHB interface.

In the default Cut-through mode, when 64 bytes (configured with the RTC bits in the ETH_DMAOMR register) or a full packet of data are received into the FIFO, the data are popped out and the DMA is notified of its availability. Once the DMA has initiated the transfer to the AHB interface, the data transfer continues from the FIFO until a complete 

In Rx FIFO Store-and-forward mode (configured by the RSF bit in the ETH_DMAOMR register), a frame is read only after being written completely into the Receive FIFO. In this mode, all error frames are dropped (if the core is configured to do so) such that only valid frames are read and forwarded to the application. In Cut-through mode, some error frames are not dropped, because the error status is received at the end of the frame, by which time the start of that frame has already been read of the FIFO.

A receive operation is initiated when the MAC detects an SFD on the MII. The core strips the preamble and SFD before proceeding to process the frame. The header fields are checked for the filtering and the FCS field used to verify the CRC for the frame. The frame is dropped in the core if it fails the address filter.

The received frame preamble and SFD are stripped. Once the SFD has been detected, the MAC starts sending the Ethernet frame data to the receive FIFO, beginning with the first byte following the SFD (destination address). If IEEE 1588 time stamping is enabled, a snapshot of the system time is taken when any frame's SFD is detected on the MII. Unless the MAC filters out and drops the frame, this time stamp is passed on to the application.

If the received frame length/type field is less than 0x600 and if the MAC is programmed for the auto CRC/pad stripping option, the MAC sends the data of the frame to RxFIFO up to the count specified in the length/type field, then starts dropping bytes (including the FCS field). If the Length/Type field is greater than or equal to 0x600, the MAC sends all received Ethernet frame data to Rx FIFO, regardless of the value on the programmed auto-CRC strip option. The MAC watchdog timer is enabled by default, that is, frames above 2048 bytes (DA + SA + LT + Data + pad + FCS) are cut off. This feature can be disabled by programming the watchdog disable (WD) bit in the MAC configuration register. However, even if the watchdog timer is disabled, frames greater than 16 KB in size are cut off and a watchdog timeout status is given.

The MAC checks for any CRC error in the receiving frame. It calculates the 32-bit CRC for the received frame that includes the Destination address field through the FCS field. The encoding is defined by the following polynomial.

Both IPv4 and IPv6 frames in the received Ethernet frames are detected and processed for data integrity. You can enable the receive checksum offload by setting the IPCO bit in the ETH_MACCR register. The MAC receiver identifies IPv4 or IPv6 frames by checking for value 0x0800 or 0x86DD, respectively, in the received Ethernet frame Type field. This identification applies to VLAN-tagged frames as well. The receive checksum offload calculates IPv4 header checksums and checks that they match the received IPv4 header checksums. The IP Header Error bit is set for any mismatch between the indicated payload 

type (Ethernet Type field) and the IP header version, or when the received frame does not have enough bytes, as indicated by the IPv4 header’s Length field (or when fewer than 20 bytes are available in an IPv4 or IPv6 header). The receive checksum offload also identifies a TCP, UDP or ICMP payload in the received IP datagrams (IPv4 or IPv6) and calculates the checksum of such payloads properly, as defined in the TCP, UDP or ICMP specifications. It includes the TCP/UDP/ICMPv6 pseudo-header bytes for checksum calculation and checks whether the received checksum field matches the calculated value. The result of this operation is given as a Payload Checksum Error bit in the receive status word. This status bit is also set if the length of the TCP, UDP or ICMP payload does not match the expected payload length given in the IP header. As mentioned in TCP/UDP/ICMP checksum, the receive checksum offload bypasses the payload of fragmented IP datagrams, IP datagrams with security features, IPv6 routing headers, and payloads other than TCP, UDP or ICMP. This information (whether the checksum is bypassed or not) is given in the receive status, as described in the RDES0: Receive descriptor Word0 section. In this configuration, the core does not append any payload checksum bytes to the received Ethernet frames.

The MAC detects the receiving Pause frame and pauses the frame transmission for the delay specified within the received Pause frame (only in Full-duplex mode). The Pause frame detection function can be enabled or disabled with the RFCE bit in ETH_MACFCR. Once receive flow control has been enabled, the received frame destination address begins to be monitored for any match with the multicast address of the control frame (0x0180 C200 0001). If a match is detected (the destination address of the received frame matches the reserved control frame destination address), the MAC then decides whether or not to transfer the received control frame to the application, based on the level of the PCF bit in ETH_MACFFR.

The MAC also decodes the type, opcode, and Pause Timer fields of the receiving control frame. If the byte count of the status indicates 64 bytes, and if there is no CRC error, the MAC transmitter pauses the transmission of any data frame for the duration of the decoded Pause time value, multiplied by the slot time (64 byte times for both 10/100 Mbit/s modes). Meanwhile, if another Pause frame is detected with a zero Pause time value, the MAC resets the Pause time and manages this new pause request.

If the received control frame matches neither the type field (0x8808), the opcode (0x00001), nor the byte length (64 bytes), or if there is a CRC error, the MAC does not generate a Pause.

For a pause frame with a unicast destination address, the MAC filtering depends on whether the DA matched the contents of the MAC address 0 register and whether the UPDF bit in ETH_MACFCR is set (detecting a pause frame even with a unicast destination address). The PCF register bits (bits [7:6] in ETH_MACFFR) control filtering for control frames in addition to address filtering.

If the Rx FIFO is full before it receives the EOF data from the MAC, an overflow is declared and the whole frame is dropped, and the overflow counter in the (ETH_DMAMFBOCR register) is incremented. The status indicates a partial frame due to overflow. The Rx FIFO can filter error and undersized frames, if enabled (using the FEF and FUGF bits in ETH_DMAOMR).If the Receive FIFO is configured to operate in Store-and-forward mode, all error frames can be filtered and dropped.In Cut-through mode, if a frame's status and length are available when that frame's SOF is read from the Rx FIFO, then the complete erroneous frame can be dropped. The DMA can flush the error frame being read from the FIFO, by enabling the receive frame flash bit. The data transfer to the application (DMA) is then stopped and the rest of the frame is internally read and dropped. The next frame transfer can then be started, if available.

At the end of the Ethernet frame reception, the MAC outputs the receive status to the application (DMA). The detailed description of the receive status is the same as for bits[31:0] in RDES0, given in RDES0: Receive descriptor Word0.

In case of switch applications, data transmission and reception between the application and MAC happen as complete frame transfers. The application layer should be aware of the length of the frames received from the ingress port in order to transfer the frame to the egress port. The MAC core provides the frame length of each received frame inside the status at the end of each frame reception.

Each nibble is transmitted to the MII from the dibit received from the RMII in the nibble transmission order shown in Figure 343. The lower-order bits (D0 and D1) are received first, followed by the higher-order bits (D2 and D3).

The ETH_MACSR register describes the events that can cause an interrupt from the MAC core. You can prevent each event from asserting the interrupt by setting the corresponding mask bits in the Interrupt Mask register.

The interrupt register bits only indicate the block from which the event is reported. You have to read the corresponding status registers and other registers to clear the interrupt. For example, bit 3 of the Interrupt register, set high, indicates that the Magic packet or Wake-on-LAN frame is received in Power-down mode. You must read the ETH_MACPMTCSR Register to clear this interrupt event.

Address filtering checks the destination and source addresses on all received frames and the address filtering status is reported accordingly. Address checking is based on different parameters (Frame filter register) chosen by the application. The filtered frame can also be identified: multicast or broadcast frame.

The MAC supports up to 4 MAC addresses for unicast perfect filtering. If perfect filtering is selected (HU bit in the Frame filter register is reset), the MAC compares all 48 bits of the received unicast address with the programmed MAC address for any match. Default MacAddr0 is always enabled, other addresses MacAddr1–MacAddr3 are selected with an individual enable bit. Each byte of these other addresses (MacAddr1–MacAddr3) can be masked during comparison with the corresponding received DA byte by setting the corresponding Mask Byte Control bit in the register. This helps group address filtering for the DA. In Hash filtering mode (when HU bit is set), the MAC performs imperfect filtering for unicast addresses using a 64-bit Hash table. For hash filtering, the MAC uses the 6 upper CRC (see note 1 below) bits of the received destination address to index the content of the Hash table. A value of 000000 selects bit 0 in the selected register, and a value of 111111 selects bit 63 in the Hash Table register. If the corresponding bit (indicated by the 6-bit CRC) is set to 1, the unicast frame is said to have passed the Hash filter; otherwise, the frame has failed the Hash filter.

The MAC can be programmed to pass all multicast frames by setting the PAM bit in the Frame filter register. If the PAM bit is reset, the MAC performs the filtering for multicast addresses based on the HM bit in the Frame filter register. In Perfect filtering mode, the multicast address is compared with the programmed MAC destination address registers (1–3). Group address filtering is also supported. In Hash filtering mode, the MAC performs imperfect filtering using a 64-bit Hash table. For hash filtering, the MAC uses the 6 upper CRC (see note 1 below) bits of the received multicast address to index the content of the Hash table. A value of 000000 selects bit 0 in the selected register and a value of 111111 selects bit 63 in the Hash Table register. If the corresponding bit is set to 1, then the multicast frame is said to have passed the Hash filter; otherwise, the frame has failed the Hash filter.

The DA filter can be configured to pass a frame when its DA matches either the Hash filter or the Perfect filter by setting the HPF bit in the Frame filter register and setting the corresponding HU or HM bits. This configuration applies to both unicast and multicast frames. If the HPF bit is reset, only one of the filters (Hash or Perfect) is applied to the received frame.

The MAC does not filter any broadcast frames in the default mode. However, if the MAC is programmed to reject all broadcast frames by setting the BFD bit in the Frame filter register, any broadcast frames are dropped.

The MAC can also perform perfect filtering based on the source address field of the received frames. By default, the MAC compares the SA field with the values programmed in the SA registers. The MAC address registers [1:3] can be configured to contain SA instead of DA for comparison, by setting bit 30 in the corresponding register. Group filtering with SA is also supported. The frames that fail the SA filter are dropped by the MAC if the SAF bit in the Frame filter register is set. Otherwise, the result of the SA filter is given as a status bit in the Receive Status word (see RDES0: Receive descriptor Word0).

When the SAF bit is set, the result of the SA and DA filters is AND’ed to decide whether the frame needs to be forwarded. This means that either of the filter fail result will drop the frame. Both filters have to pass the frame for the frame to be forwarded to the application.

For both destination and source address filtering, there is an option to invert the filter-match result at the final output. These are controlled by the DAIF and SAIF bits in the Frame filter register, respectively. The DAIF bit is applicable for both Unicast and Multicast DA frames. The result of the unicast/multicast destination address filter is inverted in this mode. Similarly, when the SAIF bit is set, the result of the unicast SA filter is inverted. Table 215 

The MAC supports loopback of transmitted frames onto its receiver. By default, the MAC loopback function is disabled, but this feature can be enabled by programming the Loopback bit in the MAC ETH_MACCR register.

The MAC management counters (MMC) maintain a set of registers for gathering statistics on the received and transmitted frames. These include a control register for controlling the behavior of the registers, two 32-bit registers containing generated interrupts (receive and transmit), and two 32-bit registers containing masks for the Interrupt register (receive and transmit). These registers are accessible from the application. Each register is 32 bits wide.

The Receive MMC counters are updated for frames that pass address filtering. Dropped frames statistics are not updated unless the dropped frames are runt frames of less than 6 bytes (DA bytes are not received fully).

This section describes the power management (PMT) mechanisms supported by the MAC. PMT supports the reception of network (remote) wakeup frames and Magic Packet frames. PMT generates interrupts for wakeup frames and Magic Packets received by the MAC. The PMT block is enabled with remote wakeup frame enable and Magic Packet enable. These enable bits (WFE and MPE) are in the ETH_MACPMTCSR register and are programmed by the application. When the power down mode is enabled in the PMT, then all received frames are dropped by the MAC and they are not forwarded to the application. The MAC comes out of the power down mode only when either a Magic Packet or a Remote wakeup frame is received and the corresponding detection is enabled.

There are eight wakeup frame filter registers. To write on each of them, load the wakeup frame filter register value by value. The wanted values of the wakeup frame filter are loaded by sequentially loading eight times the wakeup frame filter register. The read operation is identical to the write operation. To read the eight values, you have to read eight times the wakeup frame filter register to reach the last register. Each read/write points the wakeup frame filter register to the next filter register.

This register defines which bytes of the frame are examined by filter i (0, 1, 2, and 3) in order to determine whether or not the frame is a wakeup frame. The MSB (thirty-first bit) must be zero. Bit j [30:0] is the Byte Mask. If bit j (byte number) of the Byte Mask is set, then Filter i Offset + j of the incoming frame is processed by the CRC block; otherwise Filter i Offset + j is ignored.

This 4-bit command controls the filter i operation. Bit 3 specifies the address type, defining the pattern’s destination address type. When the bit is set, the pattern applies to only multicast frames. When the bit is reset, the pattern applies only to unicast frames. Bit 2 and bit 1 are reserved. Bit 0 is the enable bit for filter i; if bit 0 is not set, filter i is disabled.

This register defines the offset (within the frame) from which the frames are examined by filter i. This 8-bit pattern offset is the offset for the filter i first byte to be examined. The minimum allowed is 12, which refers to the 13th byte of the frame (offset value 0 refers to the first byte of the frame).

When the MAC is in sleep mode and the remote wakeup bit is enabled in the ETH_MACPMTCSR register, normal operation is resumed after receiving a remote wakeup frame. The application writes all eight wakeup filter registers, by performing a sequential write to the wakeup frame filter register address. The application enables remote wakeup by writing a 1 to bit 2 in the ETH_MACPMTCSR register. PMT supports four programmable filters that provide different receive frame patterns. If the incoming frame passes the address filtering of Filter Command, and if Filter CRC-16 matches the incoming examined pattern, then the wakeup frame is received. Filter_offset (minimum value 12, which refers to the 13th byte of the frame) determines the offset from which the frame is to be examined. Filter Byte Mask determines which bytes of the frame must be examined. The thirty-first bit of Byte Mask must be set to zero. The wakeup frame is checked only for length error, FCS error, dribble bit error, MII error, collision, and to ensure that it is not a runt frame. Even if the wakeup frame is more than 512 bytes long, if the frame has a valid CRC value, it is considered valid. Wakeup frame detection is updated in the ETH_MACPMTCSR register for every remote wakeup frame received. If enabled, a PMT interrupt is generated to indicate the reception of a remote wakeup frame.

The Magic Packet frame is based on a method that uses Advanced Micro Device’s Magic Packet technology to power up the sleeping device on the network. The MAC receives a specific packet of information, called a Magic Packet, addressed to the node on the network. Only Magic Packets that are addressed to the device or a broadcast address are checked to determine whether they meet the wakeup requirements. Magic Packets that pass address filtering (unicast or broadcast) are checked to determine whether they meet the remote Wake-on-LAN data format of 6 bytes of all ones followed by a MAC address appearing 16 times. The application enables Magic Packet wakeup by writing a 1 to bit 1 in the ETH_MACPMTCSR register. The PMT block constantly monitors each frame addressed to 

the node for a specific Magic Packet pattern. Each received frame is checked for a 0xFFFF FFFF FFFF pattern following the destination and source address field. The PMT block then checks the frame for 16 repetitions of the MAC address without any breaks or interruptions. In case of a break in the 16 repetitions of the address, the 0xFFFF FFFF FFFF pattern is scanned for again in the incoming frame. The 16 repetitions can be anywhere in the frame, but must be preceded by the synchronization stream (0xFFFF FFFF FFFF). The device also accepts a multicast frame, as long as the 16 duplications of the MAC address are detected. If the MAC address of a node is 0x0011 2233 4455, then the MAC scans for the data sequence:

The MAC receiver state machine should remain enabled during the power-down mode. This means that the RE bit has to remain set in the ETH_MACCR register because it is involved in magic packet/ wake-on-LAN frame detection. The transmit state machine should however be turned off during the power-down mode by clearing the TE bit in the ETH_MACCR register. Moreover, the Ethernet DMA should be disabled during the power-down mode, because it is not necessary to copy the magic packet/wake-on-LAN frame into the SRAM. To disable the Ethernet DMA, clear the ST bit and the SR bit (for the transmit DMA and the receive DMA, respectively) in the ETH_DMAOMR register.

The IEEE 1588 standard defines a protocol that allows precise clock synchronization in measurement and control systems implemented with technologies such as network communication, local computing and distributed objects. The protocol applies to systems that communicate by local area networks supporting multicast messaging, including (but not limited to) Ethernet. This protocol is used to synchronize heterogeneous systems that include clocks of varying inherent precision, resolution and stability. The protocol supports system-wide synchronization accuracy in the submicrosecond range with minimum network and local clock computing resources. The message-based protocol, known as the precision time protocol (PTP), is transported over UDP/IP. The system or network is classified into Master and Slave nodes for distributing the timing/clock information. The protocol’s technique for synchronizing a slave node to a master node by exchanging PTP messages is described in Figure 349.

Most of the protocol implementation occurs in the software, above the UDP layer. As described above, however, hardware support is required to capture the exact time when specific PTP packets enter or leave the Ethernet port at the MII. This timing information has to be captured and returned to the software for a proper, high-accuracy implementation of PTP.

To get a snapshot of the time, the core requires a reference time in 64-bit format (split into two 32-bit channels, with the upper 32 bits providing time in seconds, and the lower 32 bits indicating time in nanoseconds) as defined in the IEEE 1588 specification.

The PTP reference clock input is used to internally generate the reference time (also called the System Time) and to capture time stamps. The frequency of this reference clock must 

Due to the synchronization from the Tx and Rx clock input domain to the PTP reference clock domain, the uncertainty on the time stamp latched value is 1 reference clock period. If we add the uncertainty due to resolution, we will add half the period for time stamping.

When a frame’s SFD is output on the MII, a time stamp is captured. Frames for which time stamp capture is required are controllable on a per-frame basis. In other words, each transmitted frame can be marked to indicate whether a time stamp must be captured or not for that frame. The transmitted frames are not processed to identify PTP frames. Frame control is exercised through the control bits in the transmit descriptor. Captured time stamps are returned to the application in the same way as the status is provided for frames. The time stamp is sent back along with the Transmit status of the frame, inside the corresponding transmit descriptor, thus connecting the time stamp automatically to the specific PTP frame. The 64-bit time stamp information is written back to the TDES2 and TDES3 fields, with TDES2 holding the time stamp’s 32 least significant bits.

When the IEEE 1588 time stamping feature is enabled, the Ethernet MAC captures the time stamp of all frames received on the MII. The MAC provides the time stamp as soon as the frame reception is complete. Captured time stamps are returned to the application in the same way as the frame status is provided. The time stamp is sent back along with the Receive status of the frame, inside the corresponding receive descriptor. The 64-bit time stamp information is written back to the RDES2 and RDES3 fields, with RDES2 holding the time stamp’s 32 least significant bits.

The 64-bit PTP time is updated using the PTP input reference clock, HCLK. This PTP time is used as a source to take snapshots (time stamps) of the Ethernet frames being transmitted or received at the MII. The System Time counter can be initialized or corrected using either the Coarse or the Fine correction method.

In the Fine correction method, the slave clock (reference clock) frequency drift with respect to the master clock (as defined in IEEE 1588) is corrected over a period of time, unlike in the Coarse correction method where it is corrected in a single clock cycle. The longer correction time helps maintain linear time and does not introduce drastic changes (or a large jitter) in the reference time between PTP Sync message intervals. In this method, an accumulator sums up the contents of the Addend register as shown in Figure 350. The arithmetic carry that the accumulator generates is used as a pulse to increment the system time counter. 

If the reference clock drifts lower, to 65 MHz for example, the ratio is 65/50 or 1.3 and the value to set in the addend register is 232/1.30 equal to 0xC4EC 4EC4. If the clock drifts higher, to 67 MHz for example, the addend register must be set to 0xBF0 B7672. When the clock drift is zero, the default addend value of 0xC1F0 7C1F (232/1.32) should be programmed.

In Figure 350, the constant value used to increment the subsecond register is 0d43. This makes an accuracy of 20 ns in the system time (in other words, it is incremented by 20 ns steps).

The software has to calculate the drift in frequency based on the Sync messages, and to update the Addend register accordingly. Initially, the slave clock is set with FreqCompensationValue0 in the Addend register. This value is as follows:

If MasterToSlaveDelay is initially assumed to be the same for consecutive Sync messages, the algorithm described below must be applied. After a few Sync cycles, frequency lock occurs. The slave clock can then determine a precise MasterToSlaveDelay value and re-synchronize with the master using the new value.

This algorithm is self-correcting: if for any reason the slave clock is initially set to a value from the master that is incorrect, the algorithm corrects it at the cost of more Sync cycles.

The time stamping feature can be enabled by setting bit 0 in the Time stamp control register (ETH__PTPTSCR). However, it is essential to initialize the time stamp counter after this bit is set to start time stamp operation. The proper sequence is the following:

The MAC provides a trigger interrupt when the system time becomes greater than the target time. Using an interrupt introduces a known latency plus an uncertainty in the command execution time.

In order to avoid this uncertainty, a PTP trigger output signal is set high when the system time is greater than the target time. It is internally connected to the TIM2 input trigger. With this signal, the input capture feature, the output compare feature and the waveforms of the timer can be used, triggered by the synchronized PTP system time. No uncertainty is introduced since the clock of the timer (PCLK1: TIM2 APB1 clock) and PTP reference clock (HCLK) are synchronous.This PTP trigger signal is connected to the TIM2 ITR1 input selectable by software. The connection is enabled through bit 29 in the AFIO_MAPR register. Figure 351 shows the connection.

This PTP pulse output is used to check the synchronization between all nodes in the network. To be able to test the difference between the local slave clock and the master reference clock, both clocks were given a pulse-per-second (PPS) output signal that may be connected to an oscilloscope if necessary. The deviation between the two signals can therefore be measured. The pulse width of the PPS output is 125 ms.

The DMA has independent transmit and receive engines, and a CSR space. The transmit engine transfers data from system memory into the Tx FIFO while the receive engine transfers data from the Rx FIFO into system memory. The controller utilizes descriptors to efficiently move data from source to destination with minimum CPU intervention. The DMA is designed for packet-oriented data transfers such as frames in Ethernet. The controller can be programmed to interrupt the CPU in cases such as frame transmit and receive transfer completion, and other normal/error conditions. The DMA and the STM32F107xx communicate through two data structures:

The DMA transfers the received data frames to the receive buffer in the STM32F107xxmemory, and transmits data frames from the transmit buffer in the STM32F107xx memory. Descriptors that reside in the STM32F107xx memory act as pointers to these buffers. There are two descriptor lists: one for reception, and one for transmission. The base address of each list is written into DMA Registers 3 and 4, respectively. A descriptor list is forward-linked (either implicitly or explicitly). The last descriptor may point back to the first entry to create a ring structure. Explicit chaining of descriptors is accomplished by configuring the second address chained in both the receive and transmit descriptors (RDES1[14] and TDES0[20]). The descriptor lists reside in the Host’s physical memory space. Each descriptor can point to a maximum of two buffers. This enables the use of two physically addressed buffers, instead of two contiguous buffers in memory. A data buffer resides in the Host’s physical memory space, and consists of an entire frame or part of a frame, but cannot exceed a single frame. Buffers contain only data. The buffer status is maintained in the descriptor. Data chaining refers to frames that span multiple data buffers. However, a single descriptor cannot span multiple frames. The DMA skips to the next frame buffer when the end of frame is detected. Data chaining can be enabled or disabled. The descriptor ring and chain structure is shown in Figure 353.

The DMA attempts to execute fixed-length burst transfers on the AHB master interface if configured to do so (FB bit in ETH_DMABMR). The maximum burst length is indicated and limited by the PBL field (ETH_DMABMR [13:8]). The receive and transmit descriptors are always accessed in the maximum possible burst size (limited by PBL) for the 16 bytes to be read.

The Transmit DMA initiates a data transfer only when there is sufficient space in the Transmit FIFO to accommodate the configured burst or the number of bytes until the end of frame (when it is less than the configured burst length). The DMA indicates the start address and the number of transfers required to the AHB Master Interface. When the AHB Interface is configured for fixed-length burst, then it transfers data using the best combination of 

The Receive DMA initiates a data transfer only when sufficient data for the configured burst is available in Receive FIFO or when the end of frame (when it is less than the configured burst length) is detected in the Receive FIFO. The DMA indicates the start address and the number of transfers required to the AHB master interface. When the AHB interface is configured for fixed-length burst, then it transfers data using the best combination of INCR4, INCR8, INCR16 and SINGLE transactions. If the end of frame is reached before the fixed-burst ends on the AHB interface, then dummy transfers are performed in order to complete the fixed-length burst. Otherwise (FB bit in ETH_DMABMR is reset), it transfers data using INCR (undefined length) and SINGLE transactions.

When the AHB interface is configured for address-aligned beats, both DMA engines ensure that the first burst transfer the AHB initiates is less than or equal to the size of the configured PBL. Thus, all subsequent beats start at an address that is aligned to the configured PBL. The DMA can only align the address for beats up to size 16 (for PBL > 16), because the AHB interface does not support more than INCR16.

The transmit and receive data buffers do not have any restrictions on start address alignment. In our system with 32-bit memory, the start address for the buffers can be aligned to any of the four bytes. However, the DMA always initiates transfers with address aligned to the bus width with dummy data for the byte lanes not required. This typically happens during the transfer of the beginning or end of an Ethernet frame.

If the Transmit buffer address is 0x0000 0FF2, and 15 bytes need to be transferred, then the DMA will read five full words from address 0x0000 0FF0, but when transferring data to the Transmit FIFO, the extra bytes (the first two bytes) will be dropped or ignored. Similarly, the last 3 bytes of the last transfer will also be ignored. The DMA always ensures it transfers a full 32-bit data items to the Transmit FIFO, unless it is the end of frame.

If the Receive buffer address is 0x0000 0FF2, and 16 bytes of a received frame need to be transferred, then the DMA will write five full 32-bit data items from address 0x0000 0FF0. But the first 2 bytes of the first transfer and the last 2 bytes of the third transfer will have dummy data.

The DMA does not update the size fields in the transmit and receive descriptors. The DMA updates only the status fields (xDES0) of the descriptors. The driver has to calculate the sizes. The transmit DMA transfers the exact number of bytes (indicated by buffer size field in TDES1) towards the MAC core. If a descriptor is marked as first (FS bit in TDES0 is set), then the DMA marks the first transfer from the buffer as the start of frame. If a descriptor is marked as last (LS bit in TDES0), then the DMA marks the last transfer from that data buffer as the end of frame. The receive DMA transfers data to a buffer until the buffer is full or the end of frame is received. If a descriptor is not marked as last (LS bit in RDES0), then the buffer(s) that correspond to the descriptor are full and the amount of valid data in a buffer is accurately indicated by the buffer size field minus the data buffer pointer offset when the descriptor’s FS bit is set. The offset is zero when the data buffer pointer is aligned to the 

databus width. If a descriptor is marked as last, then the buffer may not be full (as indicated by the buffer size in RDES1). To compute the amount of valid data in this final buffer, the driver must read the frame length (FL bits in RDES0[29:16]) and subtract the sum of the buffer sizes of the preceding buffers in this frame. The receive DMA always transfers the start of next frame with a new descriptor.

Note:Even when the start address of a receive buffer is not aligned to the system databus width the system should allocate a receive buffer of a size aligned to the system bus width. For example, if the system allocates a 1024 byte (1 KB) receive buffer starting from address 0x1000, the software can program the buffer start address in the receive descriptor to have a 0x1002 offset. The receive DMA writes the frame to this buffer with dummy data in the first two locations (0x1000 and 0x1001). The actual frame is written from location 0x1002. Thus, the actual useful space in this buffer is 1022 bytes, even though the buffer size is programmed as 1024 bytes, due to the start address offset.

The arbiter inside the DMA takes care of the arbitration between transmit and receive channel accesses to the AHB master interface. Two types of arbitrations are possible: round-robin, and fixed-priority. When round-robin arbitration is selected (DA bit in ETH_DMABMR is reset), the arbiter allocates the databus in the ratio set by the PM bits in ETH_DMABMR, when both transmit and receive DMAs request access simultaneously. When the DA bit is set, the receive DMA always gets priority over the transmit DMA for data access.

For any data transfer initiated by a DMA channel, if the slave replies with an error response, that DMA stops all operations and updates the error bits and the fatal bus error bit in the Status register (ETH_DMASR register). That DMA controller can resume operation only after soft- or hard-resetting the peripheral and re-initializing the DMA.

While in the Run state, the transmit process can simultaneously acquire two frames without closing the Status descriptor of the first (if the OSF bit is set in ETH_DMAOMR register[2]). As the transmit process finishes transferring the first frame, it immediately polls the transmit descriptor list for the second frame. If the second frame is valid, the transmit process transfers this frame before writing the first frame’s status information. In OSF mode, the Run-state transmit DMA operates according to the following sequence:

The transmit DMA expects that the data buffers contain complete Ethernet frames, excluding preamble, pad bytes, and FCS fields. The DA, SA, and Type/Len fields contain valid data. If the transmit descriptor indicates that the MAC core must disable CRC or pad insertion, the buffer must have complete Ethernet frames (excluding preamble), including the CRC bytes. Frames can be data-chained and span over several buffers. Frames have to be delimited by the first descriptor (TDES0[28]) and the last descriptor (TDES0[29]). As the transmission starts, TDES0[28] has to be set in the first descriptor. When this occurs, the frame data are transferred from the memory buffer to the Transmit FIFO. Concurrently, if the last descriptor (TDES0[29]) of the current frame is cleared, the transmit process attempts to acquire the next descriptor. The transmit process expects TDES0[28] to be cleared in this descriptor. If TDES0[29] is cleared, it indicates an intermediary buffer. If TDES0[29] is set, it 

indicates the last buffer of the frame. After the last buffer of the frame has been transmitted, the DMA writes back the final status information to the transmit descriptor 0 (TDES0) word of the descriptor that has the last segment set in transmit descriptor 0 (TDES0[29]). At this time, if Interrupt on Completion (TDES0[30]) is set, Transmit Interrupt (in ETH_DMASR register [0]) is set, the next descriptor is fetched, and the process repeats. Actual frame transmission begins after the Transmit FIFO has reached either a programmable transmit threshold (ETH_DMAOMR register[16:14]), or a full frame is contained in the FIFO. There is also an option for the Store and forward mode (ETH_DMAOMR register[21]). Descriptors are released (OWN bit TDES0[31] is cleared) when the DMA finishes transferring the frame.


• The DMA detects a descriptor owned by the CPU (TDES0[31]=0) and the Transmit buffer unavailable flag is set (ETH_DMASR register[2]). To resume, the driver must give descriptor ownership to the DMA and then issue a Poll Demand command.


• A frame transmission is aborted when a transmit error due to underflow is detected. The appropriate Transmit Descriptor 0 (TDES0) bit is set. If the second condition occurs, both the Abnormal Interrupt Summary (in ETH_DMASR register [15]) and Transmit Underflow bits (in ETH_DMASR register[5]) are set, and the information is written to Transmit Descriptor 0, causing the suspension. If the DMA goes into Suspend state due to the first condition, then both the Normal Interrupt Summary (ETH_DMASR register [16]) and Transmit Buffer Unavailable (ETH_DMASR register[2]) bits are set. In both cases, the position in the transmit list is retained. The retained position is that of the descriptor following the last descriptor closed by the DMA. The driver must explicitly issue a Transmit Poll Demand command after rectifying the suspension cause.

The application software has to program the control bits [30:26]+[23:20] plus the OWN bit [31] during descriptor initialization. When the DMA updates the descriptor (or writes it back), it resets all the control bits plus the OWN bit, and reports only the status bits.

Bit 31 OWN: Own bitWhen set, this bit indicates that the descriptor is owned by the DMA. When this bit is reset, it indicates that the descriptor is owned by the CPU. The DMA clears this bit either when it completes the frame transmission or when the buffers allocated in the descriptor are read completely. The ownership bit of the frame’s first descriptor must be set after all subsequent descriptors belonging to the same frame have been set.

Bit 27 DC: Disable CRCWhen this bit is set, the MAC does not append a cyclic redundancy check (CRC) to the end of the transmitted frame. This is valid only when the first segment (TDES0[28]) is set.

Bit 26 DP: Disable padWhen set, the MAC does not automatically add padding to a frame shorter than 64 bytes. When this bit is reset, the DMA automatically adds padding and CRC to a frame shorter than 64 bytes, and the CRC field is added despite the state of the DC (TDES0[27]) bit. This is valid only when the first segment (TDES0[28]) is set.

Bit 25 TTSE: Transmit time stamp enable When TTSE is set and when TSE is set (ETH_PTPTSCR bit 0), IEEE1588 hardware time stamping is activated for the transmit frame described by the descriptor. This field is only valid when the First segment control bit (TDES0[28]) is set.

Bits 23:22 CIC: Checksum insertion controlThese bits control the checksum calculation and insertion. Bit encoding is as shown below:00: Checksum Insertion disabled01: Only IP header checksum calculation and insertion are enabled10: IP header checksum and payload checksum calculation and insertion are enabled, but pseudo-header checksum is not calculated in hardware11: IP Header checksum and payload checksum calculation and insertion are enabled, and pseudo-header checksum is calculated in hardware.

Bit 21 TER: Transmit end of ringWhen set, this bit indicates that the descriptor list reached its final descriptor. The DMA returns to the base address of the list, creating a descriptor ring.

Bit 20 TCH: Second address chainedWhen set, this bit indicates that the second address in the descriptor is the next descriptor address rather than the second buffer address. When TDES0[20] is set, TBS2 (TDES1[28:16]) is a “don’t care” value. TDES0[21] takes precedence over TDES0[20].

Bit 17 TTSS: Transmit time stamp statusThis field is used as a status bit to indicate that a time stamp was captured for the described transmit frame. When this bit is set, TDES2 and TDES3 have a time stamp value captured for the transmit frame. This field is only valid when the descriptor’s Last segment control bit (TDES0[29]) is set.

Bit 16 IHE: IP header errorWhen set, this bit indicates that the MAC transmitter detected an error in the IP datagram header. The transmitter checks the header length in the IPv4 packet against the number of header bytes received from the application and indicates an error status if there is a mismatch. For IPv6 frames, a header error is reported if the main header length is not 40 bytes. Furthermore, the Ethernet length/type field value for an IPv4 or IPv6 frame must match the IP header version received with the packet. For IPv4 frames, an error status is also indicated if the Header Length field has a value less than 0x5.

Bit 15 ES: Error summaryIndicates the logical OR of the following bits:TDES0[14]: Jabber timeout TDES0[13]: Frame flush TDES0[11]: Loss of carrier TDES0[10]: No carrier TDES0[9]: Late collision TDES0[8]: Excessive collision TDES0[2]:Excessive deferral TDES0[1]: Underflow error TDES0[16]: IP header error TDES0[12]: IP payload error

Bit 14 JT: Jabber timeoutWhen set, this bit indicates the MAC transmitter has experienced a jabber timeout. This bit is only set when the MAC configuration register’s JD bit is not set.

Bit 12 IPE: IP payload errorWhen set, this bit indicates that MAC transmitter detected an error in the TCP, UDP, or ICMP IP datagram payload. The transmitter checks the payload length received in the IPv4 or IPv6 header against the actual number of TCP, UDP or ICMP packet bytes received from the application and issues an error status in case of a mismatch.

Bit 11 LCA: Loss of carrierWhen set, this bit indicates that a loss of carrier occurred during frame transmission (that is, the MII_CRS signal was inactive for one or more transmit clock periods during frame transmission). This is valid only for the frames transmitted without collision when the MAC operates in Half-duplex mode.

Bit 9 LCO: Late collisionWhen set, this bit indicates that frame transmission was aborted due to a collision occurring after the collision window (64 byte times, including preamble, in MII mode). This bit is not valid if the Underflow Error bit is set.

Bit 8 EC: Excessive collisionWhen set, this bit indicates that the transmission was aborted after 16 successive collisions while attempting to transmit the current frame. If the RD (Disable retry) bit in the MAC Configuration register is set, this bit is set after the first collision, and the transmission of the frame is aborted.

Bits 6:3 CC: Collision countThis 4-bit counter value indicates the number of collisions occurring before the frame was transmitted. The count is not valid when the Excessive collisions bit (TDES0[8]) is set.

Bit 2 ED: Excessive deferralWhen set, this bit indicates that the transmission has ended because of excessive deferral of over 24 288 bit times if the Deferral check (DC) bit in the MAC Control register is set high.

Bit 1 UF: Underflow errorWhen set, this bit indicates that the MAC aborted the frame because data arrived late from the RAM memory. Underflow error indicates that the DMA encountered an empty transmit buffer while transmitting the frame. The transmission process enters the Suspended state and sets both Transmit underflow (Register 5[5]) and Transmit interrupt (Register 5[0]).

12:0 TBS1: Transmit buffer 1 sizeThese bits indicate the first data buffer byte size, in bytes. If this field is 0, the DMA ignores this buffer and uses Buffer 2 or the next descriptor, depending on the value of TCH (TDES0[20]).

Bits 31:0 TBAP1: Transmit buffer 1 address pointer / Transmit frame time stamp lowThese bits have two different functions: they indicate to the DMA the location of data in memory, and after all data are transferred, the DMA can then use these bits to pass back time stamp data.TBAP: When the software makes this descriptor available to the DMA (at the moment that the OWN bit is set to 1 in TDES0), these bits indicate the physical address of Buffer 1. There is no limitation on the buffer address alignment. See Host data buffer alignment for further details on buffer address alignment.TTSL: Before it clears the OWN bit in TDES0, the DMA updates this field with the 32 least significant bits of the time stamp captured for the corresponding transmit frame (overwriting the value for TBAP1). This field has the time stamp only if time stamping is activated for this frame (see TTSE, TDES0 bit 25) and if the Last segment control bit (LS) in the descriptor is set.

Bits 31:0 TBAP2: Transmit buffer 2 address pointer (Next descriptor address) / Transmit frame time stamp highThese bits have two different functions: they indicate to the DMA the location of data in memory, and after all data are transferred, the DMA can then use these bits to pass back time stamp data.TBAP2: When the software makes this descriptor available to the DMA (at the moment when the OWN bit is set to 1 in TDES0), these bits indicate the physical address of Buffer 2 when a descriptor ring structure is used. If the Second address chained (TDES1 [20]) bit is set, this address contains the pointer to the physical memory where the next descriptor is present. The buffer address pointer must be aligned to the bus width only when TDES1 [20] is set. (LSBs are ignored internally.)TTSH: Before it clears the OWN bit in TDES0, the DMA updates this field with the 32 most significant bits of the time stamp captured for the corresponding transmit frame (overwriting the value for TBAP2). This field has the time stamp only if time stamping is activated for this frame (see TDES0 bit 25, TTSE) and if the Last segment control bit (LS) in the descriptor is set.

The DMA does not acknowledge accepting the status until it has completed the time stamp write-back and is ready to perform status write-back to the descriptor. If software has enabled time stamping through CSR, when a valid time stamp value is not available for the frame (for example, because the receive FIFO was full before the time stamp could be written to it), the DMA writes all ones to RDES2 and RDES3. Otherwise (that is, if time stamping is not enabled), RDES2 and RDES3 remain unchanged.

The MAC transfers the received frames to the STM32F107xx memory only when the frame passes the address filter and the frame size is greater than or equal to the configurable threshold bytes set for the Receive FIFO, or when the complete frame is written to the FIFO in Store-and-forward mode. If the frame fails the address filtering, it is dropped in the MAC block itself (unless Receive All ETH_MACFFR [31] bit is set). Frames that are shorter than 64 bytes, because of collision or premature termination, can be purged from the Receive FIFO. After 64 (configurable threshold) bytes have been received, the DMA block begins transferring the frame data to the receive buffer pointed to by the current descriptor. The DMA sets the first descriptor (RDES0[9]) after the DMA AHB Interface becomes ready to receive a data transfer (if DMA is not fetching transmit data from the memory), to delimit the frame. The descriptors are released when the OWN (RDES0[31]) bit is reset to 0, either as the data buffer fills up or as the last segment of the frame is transferred to the receive buffer. If the frame is contained in a single descriptor, both the last descriptor (RDES0[8]) and first descriptor (RDES0[9]) bits are set. The DMA fetches the next descriptor, sets the last descriptor (RDES0[8]) bit, and releases the RDES0 status bits in the previous frame descriptor. Then the DMA sets the receive interrupt bit (ETH_DMASR register [6]). The same process repeats unless the DMA encounters a descriptor flagged as being owned by the CPU. If this occurs, the receive process sets the receive buffer unavailable bit (ETH_DMASR register[7]) and then enters the Suspend state. The position in the receive list is retained.

If a new receive frame arrives while the receive process is in Suspend state, the DMA re-fetches the current descriptor in the STM32F107xx memory. If the descriptor is now owned by the DMA, the receive process re-enters the Run state and starts frame reception. If the descriptor is still owned by the host, by default, the DMA discards the current frame at the top of the Rx FIFO and increments the missed frame counter. If more than one frame is stored in the Rx FIFO, the process repeats. The discarding or flushing of the frame at the top of the Rx FIFO can be avoided by setting the DMA Operation mode register bit 24 (DFRF). In such conditions, the receive process sets the receive buffer unavailable status bit and returns to the Suspend state.

Bit 31 OWN: Own bitWhen set, this bit indicates that the descriptor is owned by the DMA of the MAC Subsystem. When this bit is reset, it indicates that the descriptor is owned by the Host. The DMA clears this bit either when it completes the frame reception or when the buffers that are associated with this descriptor are full.

Bits 29:16 FL: Frame lengthThese bits indicate the byte length of the received frame that was transferred to host memory (including CRC). This field is valid only when last descriptor (RDES0[8]) is set and descriptor error (RDES0[14]) is reset.This field is valid when last descriptor (RDES0[8]) is set. When the last descriptor and error summary bits are not set, this field indicates the accumulated number of bytes that have been transferred for the current frame.

Bit 15 ES: Error summaryIndicates the logical OR of the following bits:RDES0[1]: CRC errorRDES0[3]: Receive errorRDES0[4]: Watchdog timeoutRDES0[6]: Late collisionRDES0[7]: Giant frame (This is not applicable when RDES0[7] indicates an IPV4 header checksum error.) RDES0[11]: Overflow error RDES0[14]: Descriptor error.This field is valid only when the last descriptor (RDES0[8]) is set.

Bit 14 DE: Descriptor errorWhen set, this bit indicates a frame truncation caused by a frame that does not fit within the current descriptor buffers, and that the DMA does not own the next descriptor. The frame is truncated. This field is valid only when the last descriptor (RDES0[8]) is set.

Bit 12 LE: Length errorWhen set, this bit indicates that the actual length of the received frame does not match the value in the Length/ Type field. This bit is valid only when the Frame type (RDES0[5]) bit is reset.

Bit 9 FS: First descriptorWhen set, this bit indicates that this descriptor contains the first buffer of the frame. If the size of the first buffer is 0, the second buffer contains the beginning of the frame. If the size of the second buffer is also 0, the next descriptor contains the beginning of the frame.

Bit 7 IPHCE: IPv header checksum errorIf IPHCE is set, it indicates an error in the IPv4 or IPv6 header. This error can be due to inconsistent Ethernet Type field and IP header Version field values, a header checksum mismatch in IPv4, or an Ethernet frame lacking the expected number of IP header bytes.

Bit 5 FT: Frame typeWhen set, this bit indicates that the Receive frame is an Ethernet-type frame (the LT field is greater than or equal to 0x0600). When this bit is reset, it indicates that the received frame is an IEEE802.3 frame. This bit is not valid for Runt frames less than 14 bytes.

Bit 4 RWT: Receive watchdog timeoutWhen set, this bit indicates that the Receive watchdog timer has expired while receiving the current frame and the current frame is truncated after the watchdog timeout.

Bit 1 CE: CRC errorWhen set, this bit indicates that a cyclic redundancy check (CRC) error occurred on the received frame. This field is valid only when the last descriptor (RDES0[8]) is set.

Bit 0 PCE: Payload checksum errorWhen set, it indicates that the TCP, UDP or ICMP checksum the core calculated does not match the received encapsulated TCP, UDP or ICMP segment’s Checksum field. This bit is also set when the received number of payload bytes does not match the value indicated in the Length field of the encapsulated IPv4 or IPv6 datagram in the received Ethernet frame.

Bit 31 DIC: Disable interrupt on completionWhen set, this bit prevents setting the Status register’s RS bit (CSR5[6]) for the received frame ending in the buffer indicated by this descriptor. This, in turn, disables the assertion of the interrupt to Host due to RS for that frame.

Bits 28:16 RBS2: Receive buffer 2 sizeThese bits indicate the second data buffer size, in bytes. The buffer size must be a multiple of 4, 8, or 16, depending on the bus widths (32, 64 or 128, respectively), even if the value of RDES3 (buffer2 address pointer) is not aligned to bus width. If the buffer size is not an appropriate multiple of 4, 8 or 16, the resulting behavior is undefined. This field is not valid if RDES1 [14] is set.

Bit 15 RER: Receive end of ringWhen set, this bit indicates that the descriptor list reached its final descriptor. The DMA returns to the base address of the list, creating a descriptor ring.

Bit 14 RCH: Second address chainedWhen set, this bit indicates that the second address in the descriptor is the next descriptor address rather than the second buffer address. When this bit is set, RBS2 (RDES1[28:16]) is a “don’t care” value. RDES1[15] takes precedence over RDES1[14].

Bits 12:0 RBS1: Receive buffer 1 sizeIndicates the first data buffer size in bytes. The buffer size must be a multiple of 4, 8 or 16, depending upon the bus widths (32, 64 or 128), even if the value of RDES2 (buffer1 address pointer) is not aligned. When the buffer size is not a multiple of 4, 8 or 16, the resulting behavior is undefined. If this field is 0, the DMA ignores this buffer and uses Buffer 2 or next descriptor depending on the value of RCH (bit 14).

Bits 31:0 RBAP1 / RTSL: Receive buffer 1 address pointer  / Receive frame time stamp lowThese bits take on two different functions: the application uses them to indicate to the DMA where to store the data in memory, and then after transferring all the data the DMA may use these bits to pass back time stamp data.RBAP1: When the software makes this descriptor available to the DMA (at the moment that the OWN bit is set to 1 in RDES0), these bits indicate the physical address of Buffer 1. There are no limitations on the buffer address alignment except for the following condition: the DMA uses the configured value for its address generation when the RDES2 value is used to store the start of frame. Note that the DMA performs a write operation with the RDES2[3/2/1:0] bits as 0 during the transfer of the start of frame but the frame data is shifted as per the actual Buffer address pointer. The DMA ignores RDES2[3/2/1:0] (corresponding to bus width of 128/64/32) if the address pointer is to a buffer where the middle or last part of the frame is stored.RTSL: Before it clears the OWN bit in RDES0, the DMA updates this field with the 32 least significant bits of the time stamp captured for the corresponding receive frame (overwriting the value for RBAP1). This field has the time stamp only if time stamping is activated for this frame and if the Last segment control bit (LS) in the descriptor is set.

Interrupts can be generated as a result of various events. The ETH_DMASR register contains all the bits that might cause an interrupt. The ETH_DMAIER register contains an enable bit for each of the events that can cause an interrupt.

There are two groups of interrupts, Normal and Abnormal, as described in the ETH_DMASR register. Interrupts are cleared by writing a 1 to the corresponding bit position. When all the enabled interrupts within a group are cleared, the corresponding summary bit is cleared. If the MAC core is the cause for assertion of the interrupt, then any of the TSTS or PMTS bits in the ETH_DMASR register is set high.

Interrupts are not queued and if the interrupt event occurs before the driver has responded to it, no additional interrupts are generated. For example, the Receive Interrupt bit (ETH_DMASR register [6]) indicates that one or more frames were transferred to the STM32F107xx buffer. The driver must scan all descriptors, from the last recorded position to the first one owned by the DMA.

An interrupt is generated only once for simultaneous, multiple events. The driver must scan the ETH_DMASR register for the cause of the interrupt. The interrupt is not generated again unless a new interrupting event occurs, after the driver has cleared the appropriate bit in the ETH_DMASR register. For example, the controller generates a Receive interrupt (ETH_DMASR register[6]) and the driver begins reading the ETH_DMASR register. Next, receive buffer unavailable (ETH_DMASR register[7]) occurs. The driver clears the Receive 

Bits 31:0 RBAP2 / RTSH: Receive buffer 2 address pointer (next descriptor address) / Receive frame time stamp highThese bits take on two different functions: the application uses them to indicate to the DMA the location of where to store the data in memory, and then after transferring all the data the DMA may use these bits to pass back time stamp data.RBAP1: When the software makes this descriptor available to the DMA (at the moment that the OWN bit is set to 1 in RDES0), these bits indicate the physical address of buffer 2 when a descriptor ring structure is used. If the second address chained (RDES1 [24]) bit is set, this address contains the pointer to the physical memory where the next descriptor is present. If RDES1 [24] is set, the buffer (next descriptor) address pointer must be bus width-aligned (RDES3[3, 2, or 1:0] = 0, corresponding to a bus width of 128, 64 or 32. LSBs are ignored internally.) However, when RDES1 [24] is reset, there are no limitations on the RDES3 value, except for the following condition: the DMA uses the configured value for its buffer address generation when the RDES3 value is used to store the start of frame. The DMA ignores RDES3[3, 2, or 1:0] (corresponding to a bus width of 128, 64 or 32) if the address pointer is to a buffer where the middle or last part of the frame is stored.RTSH: Before it clears the OWN bit in RDES0, the DMA updates this field with the 32 most significant bits of the time stamp captured for the corresponding receive frame (overwriting the value for RBAP2). This field has the time stamp only if time stamping is activated and if the Last segment control bit (LS) in the descriptor is set.

The Ethernet controller has two interrupt vectors: one dedicated to normal Ethernet operations and the other, used only for the Ethernet wakeup event (with wakeup frame or Magic Packet detection) when it is mapped on EXTI lIne19.

The second vector is reserved for interrupts generated by the PMT on wakeup events. The mapping of a wakeup event on EXTI line19 causes the STM32F107xx to exit the low-power mode, and generates an interrupt.

When an Ethernet wakeup event mapped on EXTI Line19 occurs and the MAC PMT interrupt is enabled and the EXTI Line19 interrupt, with detection on rising edge, is also enabled, both interrupts are generated.

A watchdog timer (see ETH_DMARSWTR register) is given for flexible control of the RS bit (ETH_DMASR register). When this watchdog timer is programmed with a non-zero value, it gets activated as soon as the RxDMA completes a transfer of a received frame to system memory without asserting the Receive Status because it is not enabled in the corresponding Receive descriptor (RDES1[31]). When this timer runs out as per the programmed value, the RS bit is set and the interrupt is asserted if the corresponding RIE is enabled in the 

Note:Reading the PMT control and status register automatically clears the Wakeup Frame Received and Magic Packet Received PMT interrupt flags. However, since the registers for these flags are in the CLK_RX domain, there may be a significant delay before this update is visible by the firmware. The delay is especially long when the RX clock is slow (in 10 Mbit mode) and when the AHB bus is high-frequency.Since interrupt requests from the PMT to the CPU are based on the same registers in the CLK_RX domain, the CPU may spuriously call the interrupt routine a second time even after reading PMT_CSR. Thus, it may be necessary that the firmware polls the Wakeup Frame Received and Magic Packet Received bits and exits the interrupt service routine only when they are found to be at ‘0’.

Bit 23 WD: Watchdog disableWhen this bit is set, the MAC disables the watchdog timer on the receiver, and can receive frames of up to 16 384 bytes.When this bit is reset, the MAC allows no more than 2 048 bytes of the frame being received and cuts off any bytes received after that.

Bit 22 JD: Jabber disableWhen this bit is set, the MAC disables the jabber timer on the transmitter, and can transfer frames of up to 16 384 bytes.When this bit is reset, the MAC cuts off the transmitter if the application sends out more than 2 048 bytes of data during transmission.

Bits 19:17 IFG: Interframe gapThese bits control the minimum interframe gap between frames during transmission.000: 96 bit times001: 88 bit times010: 80 bit times….111: 40 bit timesNote: In Half-duplex mode, the minimum IFG can be configured for 64 bit times (IFG = 100) only. Lower values are not considered.

Bit 16 CSD: Carrier sense disableWhen set high, this bit makes the MAC transmitter ignore the MII CRS signal during frame transmission in Half-duplex mode. No error is generated due to Loss of Carrier or No Carrier during such transmission.When this bit is low, the MAC transmitter generates such errors due to Carrier Sense and even aborts the transmissions.

Bit 13 ROD: Receive own disableWhen this bit is set, the MAC disables the reception of frames in Half-duplex mode.When this bit is reset, the MAC receives all packets that are given by the PHY while transmitting.This bit is not applicable if the MAC is operating in Full-duplex mode.

Bit 12 LM: Loopback modeWhen this bit is set, the MAC operates in loopback mode at the MII. The MII receive clock input (RX_CLK) is required for the loopback to work properly, as the transmit clock is not looped-back internally.

Bit 10 IPCO: IPv4 checksum offloadWhen set, this bit enables IPv4 checksum checking for received frame payloads' TCP/UDP/ICMP headers. When this bit is reset, the checksum offload function in the receiver is disabled and the corresponding PCE and IP HCE status bits (see Table 214) are always cleared.

Bit 9 RD: Retry disableWhen this bit is set, the MAC attempts only 1 transmission. When a collision occurs on the MII, the MAC ignores the current frame transmission and reports a Frame Abort with excessive collision error in the transmit frame status.When this bit is reset, the MAC attempts retries based on the settings of BL.Note: This bit is applicable only in the Half-duplex mode.

Bit 7 APCS: Automatic pad/CRC strippingWhen this bit is set, the MAC strips the Pad/FCS field on incoming frames only if the length’s field value is less than or equal to 1 500 bytes. All received frames with length field greater than or equal to 1 501 bytes are passed on to the application without stripping the Pad/FCS field.When this bit is reset, the MAC passes all incoming frames unmodified.

Bits 6:5 BL: Back-off limitThe Back-off limit determines the random integer number (r) of slot time delays (4 096 bit times for 1000 Mbit/s and 512 bit times for 10/100 Mbit/s) the MAC waits before rescheduling a transmission attempt during retries after a collision.Note: This bit is applicable only to Half-duplex mode.00: k = min (n, 10)01: k = min (n, 8)10: k = min (n, 4)11: k = min (n, 1),where n = retransmission attempt. The random integer r takes the value in the range 0 ≤ r < 2k

Bit 4 DC: Deferral checkWhen this bit is set, the deferral check function is enabled in the MAC. The MAC issues a Frame Abort status, along with the excessive deferral error bit set in the transmit frame status when the transmit state machine is deferred for more than 24 288 bit times in 10/100-Mbit/s mode. Deferral begins when the transmitter is ready to transmit, but is prevented because of an active CRS (carrier sense) signal on the MII. Defer time is not cumulative. If the transmitter defers for 10 000 bit times, then transmits, collides, backs off, and then has to defer again after completion of back-off, the deferral timer resets to 0 and restarts.When this bit is reset, the deferral check function is disabled and the MAC defers until the CRS signal goes inactive. This bit is applicable only in Half-duplex mode.

Bit 3 TE: Transmitter enableWhen this bit is set, the transmit state machine of the MAC is enabled for transmission on the MII. When this bit is reset, the MAC transmit state machine is disabled after the completion of the transmission of the current frame, and does not transmit any further frames.

Bit 2 RE: Receiver enableWhen this bit is set, the receiver state machine of the MAC is enabled for receiving frames from the MII. When this bit is reset, the MAC receive state machine is disabled after the completion of the reception of the current frame, and will not receive any further frames from the MII.

The MAC frame filter register contains the filter controls for receiving frames. Some of the controls from this register go to the address check block of the MAC, which performs the first level of address filtering. The second level of filtering is performed on the incoming frame, based on other controls such as pass bad frames and pass control frames.

Bit 31 RA: Receive allWhen this bit is set, the MAC receiver passes all received frames on to the application, irrespective of whether they have passed the address filter. The result of the SA/DA filtering is updated (pass or fail) in the corresponding bits in the receive status word. When this bit is reset, the MAC receiver passes on to the application only those frames that have passed the SA/DA address filter.

Bit 10 HPF: Hash or perfect filterWhen this bit is set and if the HM or HU bit is set, the address filter passes frames that match either the perfect filtering or the hash filtering.When this bit is cleared and if the HU or HM bit is set, only frames that match the Hash filter are passed.

Bit 9 SAF: Source address filterThe MAC core compares the SA field of the received frames with the values programmed in the enabled SA registers. If the comparison matches, then the SAMatch bit in the RxStatus word is set high. When this bit is set high and the SA filter fails, the MAC drops the frame.When this bit is reset, the MAC core forwards the received frame to the application. It also forwards the updated SA Match bit in RxStatus depending on the SA address comparison.

Bit 8 SAIF: Source address inverse filteringWhen this bit is set, the address check block operates in inverse filtering mode for the SA address comparison. The frames whose SA matches the SA registers are marked as failing the SA address filter.When this bit is reset, frames whose SA does not match the SA registers are marked as failing the SA address filter.

Bits 7:6 PCF: Pass control framesThese bits control the forwarding of all control frames (including unicast and multicast PAUSE frames). Note that the processing of PAUSE control frames depends only on RFCE in Flow Control Register[2].00 or 01: MAC prevents all control frames from reaching the application10: MAC forwards all control frames to application even if they fail the address filter11: MAC forwards control frames that pass the address filter.

The most significant bit determines the register to be used (hash table high/hash table low), and the other 5 bits determine which bit within the register. A hash value of 0b0 0000 selects bit 0 in the selected register, and a value of 0b1 1111 selects bit 31 in the selected register.

For example, if the DA of the incoming frame is received as 0x1F52 419C B6AF (0x1F is the first byte received on the MII interface), then the internally calculated 6-bit Hash value is 0x2C and the HTH register bit[12] is checked for filtering. If the DA of the incoming frame is received as 0xA00A 9800 0045, then the calculated 6-bit Hash value is 0x07 and the HTL register bit[7] is checked for filtering.

If the corresponding bit value in the register is 1, the frame is accepted. Otherwise, it is rejected. If the PAM (pass all multicast) bit is set in the ETH_MACFFR register, then all multicast frames are accepted regardless of the multicast hash values.

Bit 4 PAM: Pass all multicastWhen set, this bit indicates that all received frames with a multicast destination address (first bit in the destination address field is '1') are passed.When reset, filtering of multicast frame depends on the HM bit.

Bit 3 DAIF: Destination address inverse filteringWhen this bit is set, the address check block operates in inverse filtering mode for the DA address comparison for both unicast and multicast frames.When reset, normal filtering of frames is performed.

Bit 2 HM: Hash multicastWhen set, MAC performs destination address filtering of received multicast frames according to the hash table.When reset, the MAC performs a perfect destination address filtering for multicast frames, that is, it compares the DA field with the values programmed in DA registers.

Bit 1 HU: Hash unicastWhen set, MAC performs destination address filtering of unicast frames according to the hash table.When reset, the MAC performs a perfect destination address filtering for unicast frames, that is, it compares the DA field with the values programmed in DA registers.

Bit 0 PM: Promiscuous modeWhen this bit is set, the address filters pass all incoming frames regardless of their destination or source address. The SA/DA filter fails status bits in the receive status word are always cleared when PM is set.

Bits 4:2 CR: Clock rangeThe CR clock range selection determines the HCLK frequency and is used to decide the frequency of the MDC clock:Selection HCLK MDC Clock000 60-72 MHz HCLK/42001 Reserved -010 20-35 MHz HCLK/16011 35-60 MHz HCLK/26100, 101, 110, 111 Reserved -

The MAC MII Data register stores write data to be written to the PHY register located at the address specified in ETH_MACMIIAR. ETH_MACMIIDR also stores read data from the PHY register located at the address specified by ETH_MACMIIAR.

The Flow control register controls the generation and reception of the control (Pause Command) frames by the MAC. A write to a register with the Busy bit set to '1' causes the MAC to generate a pause control frame. The fields of the control frame are selected as specified in the 802.3x specification, and the Pause Time value from this register is used in the Pause Time field of the control frame. The Busy bit remains set until the control frame is transferred onto the cable. The Host must make sure that the Busy bit is cleared before writing to the register.

Bit 1 MW: MII writeWhen set, this bit tells the PHY that this will be a Write operation using the MII Data register. If this bit is not set, this will be a Read operation, placing the data in the MII Data register.

Bit 0 MB: MII busyThis bit should read a logic 0 before writing to ETH_MACMIIAR and ETH_MACMIIDR. This bit must also be reset to 0 during a Write to ETH_MACMIIAR. During a PHY register access, this bit is set to 0b1 by the application to indicate that a read or write access is in progress. ETH_MACMIIDR (MII Data) should be kept valid until this bit is cleared by the MAC during a PHY Write operation. The ETH_MACMIIDR is invalid until this bit is cleared by the MAC during a PHY Read operation. The ETH_MACMIIAR (MII Address) should not be written to until this bit is cleared.

Bits 15:0 MD: MII dataThis contains the 16-bit data value read from the PHY after a Management Read operation, or the 16-bit data value to be written to the PHY before a Management Write operation.

         Bits 31:16 PT: Pause timeThis field holds the value to be used in the Pause Time field in the transmit control frame. If the Pause Time bits is configured to be double-synchronized to the MII clock domain, then consecutive write operations to this register should be performed only after at least 4 clock cycles in the destination clock domain.

Bit 7 ZQPD: Zero-quanta pause disableWhen set, this bit disables the automatic generation of Zero-quanta pause control frames on the deassertion of the flow-control signal from the FIFO layer.When this bit is reset, normal operation with automatic Zero-quanta pause control frame generation is enabled.

Bits 5:4 PLT: Pause low thresholdThis field configures the threshold of the Pause timer at which the Pause frame is automatically retransmitted. The threshold values should always be less than the Pause Time configured in bits[31:16]. For example, if PT = 100H (256 slot-times), and PLT = 01, then a second PAUSE frame is automatically transmitted if initiated at 228 (256 – 28) slot-times after the first PAUSE frame is transmitted. Selection Threshold00 Pause time minus 4 slot times01 Pause time minus 28 slot times10 Pause time minus 144 slot times11 Pause time minus 256 slot timesSlot time is defined as time taken to transmit 512 bits (64 bytes) on the MII interface.

Bit 3 UPFD: Unicast pause frame detectWhen this bit is set, the MAC detects the Pause frames with the station’s unicast address specified in the ETH_MACA0HR and ETH_MACA0LR registers, in addition to detecting Pause frames with the unique multicast address.When this bit is reset, the MAC detects only a Pause frame with the unique multicast address specified in the 802.3x standard.

Bit 2 RFCE: Receive flow control enableWhen this bit is set, the MAC decodes the received Pause frame and disables its transmitter for a specified (Pause Time) time.When this bit is reset, the decode function of the Pause frame is disabled.

The VLAN tag register contains the IEEE 802.1Q VLAN Tag to identify the VLAN frames. The MAC compares the 13th and 14th bytes of the receiving frame (Length/Type) with 0x8100, and the following 2 bytes are compared with the VLAN tag; if a match occurs, the received VLAN bit in the receive frame status is set. The legal length of the frame is increased from 1518 bytes to 1522 bytes.

Bit 1 TFCE: Transmit flow control enableIn Full-duplex mode, when this bit is set, the MAC enables the flow control operation to transmit Pause frames. When this bit is reset, the flow control operation in the MAC is disabled, and the MAC does not transmit any Pause frames.In Half-duplex mode, when this bit is set, the MAC enables the back-pressure operation. When this bit is reset, the back pressure feature is disabled.

Bit 0 FCB/BPA: Flow control busy/back pressure activateThis bit initiates a Pause Control frame in Full-duplex mode and activates the back pressure function in Half-duplex mode if TFCE bit is set.In Full-duplex mode, this bit should be read as 0 before writing to the Flow control register. To initiate a Pause control frame, the Application must set this bit to 1. During a transfer of the Control frame, this bit continues to be set to signify that a frame transmission is in progress. After completion of the Pause control frame transmission, the MAC resets this bit to 0. The Flow control register should not be written to until this bit is cleared.In Half-duplex mode, when this bit is set (and TFCE is set), back pressure is asserted by the MAC core. During back pressure, when the MAC receives a new frame, the transmitter starts sending a JAM pattern resulting in a collision. When the MAC is configured to Full-duplex mode, the BPA is automatically disabled.

This is the address through which the remote wakeup frame filter registers are written/read by the application. The Wakeup frame filter register is actually a pointer to eight (not transparent) such wakeup frame filter registers. Eight sequential write operations to this address with the offset (0x0028) will write all wakeup frame filter registers. Eight sequential read operations from this address with the offset (0x0028) will read all wakeup frame filter registers. This register contains the higher 16 bits of the 7th MAC address. Refer to Remote wakeup frame filter register section for additional information.

Bit 16 VLANTC: 12-bit VLAN tag comparisonWhen this bit is set, a 12-bit VLAN identifier, rather than the complete 16-bit VLAN tag, is used for comparison and filtering. Bits[11:0] of the VLAN tag are compared with the corresponding field in the received VLAN-tagged frame.When this bit is reset, all 16 bits of the received VLAN frame’s fifteenth and sixteenth bytes are used for comparison.

Bits 15:0 VLANTI: VLAN tag identifier (for receive frames)This contains the 802.1Q VLAN tag to identify VLAN frames, and is compared to the fifteenth and sixteenth bytes of the frames being received for VLAN frames. Bits[15:13] are the user priority, Bit[12] is the canonical format indicator (CFI) and bits[11:0] are the VLAN tag’s VLAN identifier (VID) field. When the VLANTC bit is set, only the VID (bits[11:0]) is used for comparison.If VLANTI (VLANTI[11:0] if VLANTC is set) is all zeros, the MAC does not check the fifteenth and sixteenth bytes for VLAN tag comparison, and declares all frames with a Type field value of 0x8100 as VLAN frames.

Bit 6 WFR: Wakeup frame receivedWhen set, this bit indicates the power management event was generated due to reception of a wakeup frame. This bit is cleared by a read into this register.

Bit 5 MPR: Magic packet receivedWhen set, this bit indicates the power management event was generated by the reception of a Magic Packet. This bit is cleared by a read into this register.

Bit 0 PD: Power downWhen this bit is set, all received frames will be dropped. This bit is cleared automatically when a magic packet or wakeup frame is received, and Power-down mode is disabled. Frames received after this bit is cleared are forwarded to the application. This bit must only be set when either the Magic Packet Enable or Wakeup Frame Enable bit is set high.

Bit 9 TSTS: Time stamp trigger status This bit is set high when the system time value equals or exceeds the value specified in the Target time high and low registers. This bit is cleared by reading the ETH_PTPTSSR register.

Bit 6 MMCTS: MMC transmit status This bit is set high whenever an interrupt is generated in the ETH_MMCTIR Register. This bit is cleared when all the bits in this interrupt register (ETH_MMCTIR) are cleared.

Bit 5 MMCRS: MMC receive status This bit is set high whenever an interrupt is generated in the ETH_MMCRIR register. This bit is cleared when all the bits in this interrupt register (ETH_MMCRIR) are cleared.

Bit 3 PMTS: PMT status This bit is set whenever a Magic packet or Wake-on-LAN frame is received in Power-down mode (see bits 5 and 6 in the ETH_MACPMTCSR register Ethernet MAC PMT control and status register (ETH_MACPMTCSR)). This bit is cleared when both bits[6:5], of this last register, are cleared due to a read operation to the ETH_MACPMTCSR register.

The MAC address 0 high register holds the upper 16 bits of the 6-byte first MAC address of the station. Note that the first DA byte that is received on the MII interface corresponds to the LS Byte (bits [7:0]) of the MAC address low register. For example, if 0x1122 3344 5566 is received (0x11 is the first byte) on the MII as the destination address, then the MAC address 0 register [47:0] is compared with 0x6655 4433 2211.

Bits 15:0 MACA0H: MAC address0 high [47:32]This field contains the upper 16 bits (47:32) of the 6-byte MAC address0. This is used by the MAC for filtering for received frames and for inserting the MAC address in the transmit flow control (Pause) frames.

Bits 31:0 MACA0L: MAC address0 low [31:0]This field contains the lower 32 bits of the 6-byte MAC address0. This is used by the MAC for filtering for received frames and for inserting the MAC address in the transmit flow control (Pause) frames.

Bit 31 AE: Address enableWhen this bit is set, the address filters use the MAC address1 for perfect filtering. When this bit is cleared, the address filters ignore the address for filtering.

Bit 30 SA: Source addressWhen this bit is set, the MAC address1[47:0] is used for comparison with the SA fields of the received frame.When this bit is cleared, the MAC address1[47:0] is used for comparison with the DA fields of the received frame.

Bits 29:24 MBC: Mask byte controlThese bits are mask control bits for comparison of each of the MAC address1 bytes. When they are set high, the MAC core does not compare the corresponding byte of received DA/SA with the contents of the MAC address1 registers. Each bit controls the masking of the bytes as follows:– Bit 29: ETH_MACA1HR [15:8]– Bit 28: ETH_MACA1HR [7:0]– Bit 27: ETH_MACA1LR [31:24]…– Bit 24: ETH_MACA1LR [7:0]

Bits 31:0 MACA1L: MAC address1 low [31:0]This field contains the lower 32 bits of the 6-byte MAC address1. The content of this field is undefined until loaded by the application after the initialization process.

Bit 30 SA: Source addressWhen this bit is set, the MAC address 2 [47:0] is used for comparison with the SA fields of the received frame.When this bit is reset, the MAC address 2 [47:0] is used for comparison with the DA fields of the received frame.

Bits 29:24 MBC: Mask byte controlThese bits are mask control bits for comparison of each of the MAC address2 bytes. When set high, the MAC core does not compare the corresponding byte of received DA/SA with the contents of the MAC address 2 registers. Each bit controls the masking of the bytes as follows:– Bit 29: ETH_MACA2HR [15:8]– Bit 28: ETH_MACA2HR [7:0]– Bit 27: ETH_MACA2LR [31:24]…– Bit 24: ETH_MACA2LR [7:0]

Bits 31:0 MACA2L: MAC address2 low [31:0]This field contains the lower 32 bits of the 6-byte second MAC address2. The content of this field is undefined until loaded by the application after the initialization process.

Bit 31 AE: Address enableWhen this bit is set, the address filters use the MAC address3 for perfect filtering. When this bit is cleared, the address filters ignore the address for filtering.

Bit 30 SA: Source addressWhen this bit is set, the MAC address 3 [47:0] is used for comparison with the SA fields of the received frame.When this bit is cleared, the MAC address 3[47:0] is used for comparison with the DA fields of the received frame.

Bits 29:24 MBC: Mask byte controlThese bits are mask control bits for comparison of each of the MAC address3 bytes. When these bits are set high, the MAC core does not compare the corresponding byte of received DA/SA with the contents of the MAC address 3 registers. Each bit controls the masking of the bytes as follows:– Bit 29: ETH_MACA3HR [15:8]– Bit 28: ETH_MACA3HR [7:0]– Bit 27: ETH_MACA3LR [31:24]…– Bit 24: ETH_MACA3LR [7:0]

Bits 31:0 MACA3L: MAC address3 low [31:0]This field contains the lower 32 bits of the 6-byte second MAC address3. The content of this field is undefined until loaded by the application after the initialization process.

The Ethernet MMC receive interrupt register maintains the interrupts generated when receive statistic counters reach half their maximum values. (MSB of the counter is set.) It is a 32-bit wide register. An interrupt bit is cleared when the respective MMC counter that caused the interrupt is read. The least significant byte lane (bits [7:0]) of the respective counter must be read in order to clear the interrupt bit.

Bit 3 MCF: MMC counter freezeWhen set, this bit freezes all the MMC counters to their current value. (None of the MMC counters are updated due to any transmitted or received frame until this bit is cleared to 0. If any MMC counter is read with the Reset on Read bit set, then that counter is also cleared in this mode.)

Bit 2 ROR: Reset on readWhen this bit is set, the MMC counters is reset to zero after read (self-clearing after reset). The counters are cleared when the least significant byte lane (bits [7:0]) is read.

The Ethernet MMC transmit Interrupt register maintains the interrupts generated when transmit statistic counters reach half their maximum values. (MSB of the counter is set.) It is a 32-bit wide register. An interrupt bit is cleared when the respective MMC counter that caused the interrupt is read. The least significant byte lane (bits [7:0]) of the respective counter must be read in order to clear the interrupt bit.

The Ethernet MMC receive interrupt mask register maintains the masks for interrupts generated when the receive statistic counters reach half their maximum value. (MSB of the counter is set.) It is a 32-bit wide register.

The Ethernet MMC transmit interrupt mask register maintains the masks for interrupts generated when the transmit statistic counters reach half their maximum value. (MSB of the counter is set). It is a 32-bit wide register.

Bit 15 TGFMSCM: Transmitted good frames more single collision maskSetting this bit masks the interrupt when the transmitted good frames after more than a single collision counter reaches half the maximum value.

Bit 5 TSARU: Time stamp addend register updateWhen this bit is set, the Time stamp addend register’s contents are updated to the PTP block for fine correction. This bit is cleared when the update is completed. This register bit must be read as zero before you can set it.

Bit 4 TSITE: Time stamp interrupt trigger enableWhen this bit is set, a time stamp interrupt is generated when the system time becomes greater than the value written in Target Time register. When the Time Stamp Trigger interrupt is generated, this bit is cleared.

Bit 3 TSSTU: Time stamp system time updateWhen this bit is set, the system time is updated (added to or subtracted from) with the value specified in the Time stamp high update and Time stamp low update registers. Both the TSSTU and TSSTI bits must be read as zero before you can set this bit. Once the update is completed in hardware, this bit is cleared.

Bit 2 TSSTI: Time stamp system time initializeWhen this bit is set, the system time is initialized (overwritten) with the value specified in the Time stamp high update and Time stamp low update registers. This bit must be read as zero before you can set it. When initialization is complete, this bit is cleared.

Bit 1 TSFCU: Time stamp fine or coarse updateWhen set, this bit indicates that the system time stamp is to be updated using the Fine Update method. When cleared, it indicates the system time stamp is to be updated using the Coarse method.

Bit 0 TSE: Time stamp enableWhen this bit is set, time stamping is enabled for transmit and receive frames. When this bit is cleared, the time stamp function is suspended and time stamps are not added for transmit and receive frames. Because the maintained system time is suspended, you must always initialize the time stamp feature (system time) after setting this bit high.

This register contains the 8-bit value by which the subsecond register is incremented. In Coarse update mode (TSFCU bit in ETH_PTPTSCR), the value in this register is added to the system time every clock cycle of HCLK. In Fine update mode, the value in this register is added to the system time whenever the accumulator gets an overflow.

This register contains the most significant (higher) 32 time bits. This read-only register contains the seconds system time value. The Time stamp high register, along with Time stamp low register, indicates the current value of the system time maintained by the MAC. Though it is updated on a continuous basis.

Bits 7:0 STSSI: System time subsecond incrementThe value programmed in this register is added to the contents of the subsecond value of the system time in every update.For example, to achieve 20 ns accuracy, the value is: 20 / 0.467 = ~ 43 (or 0x2A).

This register contains the most significant (higher) 32 bits of the time to be written to, added to, or subtracted from the System Time value. The Time stamp high update register, along with the Time stamp update low register, initializes or updates the system time maintained by the MAC. You have to write both of these registers before setting the TSSTI or TSSTU bits in the Time stamp control register.

Bit 31 STPNS: System time positive or negative signThis bit indicates a positive or negative time value. When set, the bit indicates that time representation is negative. When cleared, it indicates that time representation is positive. Because the system time should always be positive, this bit is normally zero.

This register is used by the software to readjust the clock frequency linearly to match the master clock frequency. This register value is used only when the system time is configured for Fine update mode (TSFCU bit in ETH_PTPTSCR). This register content is added to a 32-bit accumulator in every clock cycle and the system time is updated whenever the accumulator overflows.

Bit 31 TSUPNS: Time stamp update positive or negative signThis bit indicates positive or negative time value. When set, the bit indicates that time representation is negative. When cleared, it indicates that time representation is positive. When TSSTI is set (system time initialization) this bit should be zero. If this bit is set when TSSTU is set, the value in the Time stamp update registers is subtracted from the system time. Otherwise it is added to the system time.

Bits 30:0 TSUSS: Time stamp update subsecondsThe value in this field indicates the subsecond time to be initialized or added to the system time. This value has an accuracy of 0.46 ns (in other words, a value of 0x0000_0001 is 0.46 ns).

This register contains the higher 32 bits of time to be compared with the system time for interrupt event generation. The Target time high register, along with Target time low register, is used to schedule an interrupt event (TSARU bit in ETH_PTPTSCR) when the system time exceeds the value programmed in these registers.

Bits 31:0 TTSH: Target time stamp highThis register stores the time in seconds. When the time stamp value matches or exceeds both Target time stamp registers, the MAC, if enabled, generates an interrupt.

Bits 31:0 TTSL: Target time stamp lowThis register stores the time in (signed) nanoseconds. When the value of the time stamp matches or exceeds both Target time stamp registers, the MAC, if enabled, generates an interrupt.

Bit 25 AAB: Address-aligned beatsWhen this bit is set high and the FB bit equals 1, the AHB interface generates all bursts aligned to the start address LS bits. If the FB bit equals 0, the first burst (accessing the data buffer’s start address) is not aligned, but subsequent bursts are aligned to the address.

Bit 24 FPM: 4xPBL modeWhen set high, this bit multiplies the PBL value programmed (bits [22:17] and bits [13:8]) four times. Thus the DMA transfers data in a maximum of 4, 8, 16, 32, 64 and 128 beats depending on the PBL value.

Bit 23 USP: Use separate PBLWhen set high, it configures the RxDMA to use the value configured in bits [22:17] as PBL while the PBL value in bits [13:8] is applicable to TxDMA operations only. When this bit is cleared, the PBL value in bits [13:8] is applicable for both DMA engines.

Bits 22:17 RDP: Rx DMA PBLThese bits indicate the maximum number of beats to be transferred in one RxDMA transaction. This is the maximum value that is used in a single block read/write operation. The RxDMA always attempts to burst as specified in RDP each time it starts a burst transfer on the host bus. RDP can be programmed with permissible values of 1, 2, 4, 8, 16, and 32. Any other value results in undefined behavior.These bits are valid and applicable only when USP is set high.

Bit 16 FB: Fixed burstThis bit controls whether the AHB Master interface performs fixed burst transfers or not. When set, the AHB uses only SINGLE, INCR4, INCR8 or INCR16 during start of normal burst transfers. When reset, the AHB uses SINGLE and INCR burst transfer operations.

Bits 13:8 PBL: Programmable burst lengthThese bits indicate the maximum number of beats to be transferred in one DMA transaction. This is the maximum value that is used in a single block read/write operation. The DMA always attempts to burst as specified in PBL each time it starts a burst transfer on the host bus. PBL can be programmed with permissible values of 1, 2, 4, 8, 16, and 32. Any other value results in undefined behavior. When USP is set, this PBL value is applicable for TxDMA transactions only.The PBL values have the following limitations:– The maximum number of beats (PBL) possible is limited by the size of the Tx FIFO and Rx FIFO.– The FIFO has a constraint that the maximum beat supported is half the depth of the FIFO.– If the PBL is common for both transmit and receive DMA, the minimum Rx FIFO and Tx FIFO depths must be considered.– Do not program out-of-range PBL values, because the system may not behave properly.

This register is used by the application to instruct the DMA to poll the transmit descriptor list. The transmit poll demand register enables the Transmit DMA to check whether or not the current descriptor is owned by DMA. The Transmit Poll Demand command is given to wake up the TxDMA if it is in Suspend mode. The TxDMA can go into Suspend mode due to an underflow error in a transmitted frame or due to the unavailability of descriptors owned by transmit DMA. You can issue this command anytime and the TxDMA resets it once it starts re-fetching the current descriptor from host memory.

This register is used by the application to instruct the DMA to poll the receive descriptor list. The Receive poll demand register enables the receive DMA to check for new descriptors. This command is given to wake up the RxDMA from Suspend state. The RxDMA can go into Suspend state only due to the unavailability of descriptors owned by it.

Bits 6:2 DSL: Descriptor skip lengthThis bit specifies the number of words to skip between two unchained descriptors. The address skipping starts from the end of current descriptor to the start of next descriptor. When DSL value equals zero, the descriptor table is taken as contiguous by the DMA, in Ring mode.

Bit 0 SR: Software resetWhen this bit is set, the MAC DMA controller resets all MAC Subsystem internal registers and logic. It is cleared automatically after the reset operation has completed in all of the core clock domains. Read a 0 value in this bit before re-programming any register of the core.

Bits 31:0 TPD: Transmit poll demandWhen these bits are written with any value, the DMA reads the current descriptor pointed to by the ETH_DMACHTDR register. If that descriptor is not available (owned by Host), transmission returns to the Suspend state and ETH_DMASR register bit 2 is asserted. If the descriptor is available, transmission resumes.

The Receive descriptor list address register points to the start of the receive descriptor list. The descriptor lists reside in the STM32F107xx's physical memory space and must be word-aligned. The DMA internally converts it to bus-width aligned address by making the corresponding LS bits low. Writing to the ETH_DMARDLAR register is permitted only when reception is stopped. When stopped, the ETH_DMARDLAR register must be written to before the receive Start command is given.

The Transmit descriptor list address register points to the start of the transmit descriptor list. The descriptor lists reside in the STM32F107xx's physical memory space and must be word-aligned. The DMA internally converts it to bus-width-aligned address by taking the corresponding LSB to low. Writing to the ETH_DMATDLAR register is permitted only when transmission has stopped. Once transmission has stopped, the ETH_DMATDLAR register can be written before the transmission Start command is given.

Bits 31:0 RPD: Receive poll demandWhen these bits are written with any value, the DMA reads the current descriptor pointed to by the ETH_DMACHRDR register. If that descriptor is not available (owned by Host), reception returns to the Suspended state and ETH_DMASR register bit 7 is not asserted. If the descriptor is available, the Receive DMA returns to active state.

Bits 31:0 SRL: Start of receive listThis field contains the base address of the first descriptor in the receive descriptor list. The LSB bits [1/2/3:0] for 32/64/128-bit bus width) are internally ignored and taken as all-zero by the DMA. Hence these LSB bits are read only.

Bits 31:0 STL: Start of transmit listThis field contains the base address of the first descriptor in the transmit descriptor list. The LSB bits [1/2/3:0] for 32/64/128-bit bus width) are internally ignored and taken as all-zero by the DMA. Hence these LSB bits are read-only.

The Status register contains all the status bits that the DMA reports to the application. The ETH_DMASR register is usually read by the software driver during an interrupt service routine or polling. Most of the fields in this register cause the host to be interrupted. The ETH_DMASR register bits are not cleared when read. Writing 1 to (unreserved) bits in ETH_DMASR register[16:0] clears them and writing 0 has no effect. Each field (bits [16:0]) can be masked by masking the appropriate bit in the ETH_DMAIER register.

Bit 29 TSTS: Time stamp trigger statusThis bit indicates an interrupt event in the MAC core's Time stamp generator block. The software must read the MAC core’s status register, clearing its source (bit 9), to reset this bit to 0. When this bit is high an interrupt is generated if enabled.

Bit 28 PMTS: PMT statusThis bit indicates an event in the MAC core’s PMT. The software must read the corresponding registers in the MAC core to get the exact cause of interrupt and clear its source to reset this bit to 0. The interrupt is generated when this bit is high if enabled.

Bit 27 MMCS: MMC statusThis bit reflects an event in the MMC of the MAC core. The software must read the corresponding registers in the MAC core to get the exact cause of interrupt and clear the source of interrupt to make this bit as 0. The interrupt is generated when this bit is high if enabled.

Bits 25:23 EBS: Error bits statusThese bits indicate the type of error that caused a bus error (error response on the AHB interface). Valid only with the fatal bus error bit (ETH_DMASR register [13]) set. This field does not generate an interrupt.Bit 231 Error during data transfer by TxDMA 0 Error during data transfer by RxDMABit 24 1 Error during read transfer0 Error during write transferBit 25 1 Error during descriptor access0 Error during data buffer access

Bits 22:20 TPS: Transmit process stateThese bits indicate the Transmit DMA FSM state. This field does not generate an interrupt.000: Stopped; Reset or Stop Transmit Command issued001: Running; Fetching transmit transfer descriptor010: Running; Waiting for status011: Running; Reading Data from host memory buffer and queuing it to transmit buffer (Tx FIFO)100, 101: Reserved for future use110: Suspended; Transmit descriptor unavailable or transmit buffer underflow111: Running; Closing transmit descriptor

Bits 19:17 RPS: Receive process state These bits indicate the Receive DMA FSM state. This field does not generate an interrupt.000: Stopped: Reset or Stop Receive Command issued001: Running: Fetching receive transfer descriptor010: Reserved for future use011: Running: Waiting for receive packet100: Suspended: Receive descriptor unavailable101: Running: Closing receive descriptor110: Reserved for future use111: Running: Transferring the receive packet data from receive buffer to host memory

Bit 16 NIS: Normal interrupt summaryThe normal interrupt summary bit value is the logical OR of the following when the corresponding interrupt bits are enabled in the ETH_DMAIER register:– ETH_DMASR [0]: Transmit interrupt– ETH_DMASR [2]: Transmit buffer unavailable– ETH_DMASR [6]: Receive interrupt– ETH_DMASR [14]: Early receive interruptOnly unmasked bits affect the normal interrupt summary bit.This is a sticky bit and it must be cleared (by writing a 1 to this bit) each time a corresponding bit that causes NIS to be set is cleared.

Bit 15 AIS: Abnormal interrupt summaryThe abnormal interrupt summary bit value is the logical OR of the following when the corresponding interrupt bits are enabled in the ETH_DMAIER register:– ETH_DMASR [1]:Transmit process stopped– ETH_DMASR [3]:Transmit jabber timeout– ETH_DMASR [4]: Receive FIFO overflow– ETH_DMASR [5]: Transmit underflow– ETH_DMASR [7]: Receive buffer unavailable– ETH_DMASR [8]: Receive process stopped– ETH_DMASR [9]: Receive watchdog timeout– ETH_DMASR [10]: Early transmit interrupt– ETH_DMASR [13]: Fatal bus errorOnly unmasked bits affect the abnormal interrupt summary bit.This is a sticky bit and it must be cleared each time a corresponding bit that causes AIS to be set is cleared.

Bit 13 FBES: Fatal bus error statusThis bit indicates that a bus error occurred, as detailed in [25:23]. When this bit is set, the corresponding DMA engine disables all its bus accesses.

Bit 7 RBUS: Receive buffer unavailable statusThis bit indicates that the next descriptor in the receive list is owned by the host and cannot be acquired by the DMA. Receive process is suspended. To resume processing receive descriptors, the host should change the ownership of the descriptor and issue a Receive Poll Demand command. If no Receive Poll Demand is issued, receive process resumes when the next recognized incoming frame is received. ETH_DMASR [7] is set only when the previous receive descriptor was owned by the DMA.

Bit 4 ROS: Receive overflow statusThis bit indicates that the receive buffer had an overflow during frame reception. If the partial frame is transferred to the application, the overflow status is set in RDES0[11].

Bit 3 TJTS: Transmit jabber timeout statusThis bit indicates that the transmit jabber timer expired, meaning that the transmitter had been excessively active. The transmission process is aborted and placed in the Stopped state. This causes the transmit jabber timeout TDES0[14] flag to be asserted.

Bit 2 TBUS: Transmit buffer unavailable statusThis bit indicates that the next descriptor in the transmit list is owned by the host and cannot be acquired by the DMA. Transmission is suspended. Bits [22:20] explain the transmit process state transitions. To resume processing transmit descriptors, the host should change the ownership of the bit of the descriptor and then issue a Transmit Poll Demand command.

Bit 26 DTCEFD: Dropping of TCP/IP checksum error frames disableWhen this bit is set, the core does not drop frames that only have errors detected by the receive checksum offload engine. Such frames do not have any errors (including FCS error) in the Ethernet frame received by the MAC but have errors in the encapsulated payload only. When this bit is cleared, all error frames are dropped if the FEF bit is reset.

Bit 25 RSF: Receive store and forwardWhen this bit is set, a frame is read from the Rx FIFO after the complete frame has been written to it, ignoring RTC bits. When this bit is cleared, the Rx FIFO operates in Cut-through mode, subject to the threshold specified by the RTC bits.

Bit 24 DFRF: Disable flushing of received framesWhen this bit is set, the RxDMA does not flush any frames due to the unavailability of receive descriptors/buffers as it does normally when this bit is cleared (see Receive process suspended).

Bit 21 TSF: Transmit store and forwardWhen this bit is set, transmission starts when a full frame resides in the Transmit FIFO. When this bit is set, the TTC values specified by the ETH_DMAOMR register bits [16:14] are ignored.When this bit is cleared, the TTC values specified by the ETH_DMAOMR register bits [16:14] are taken into account.This bit should be changed only when transmission is stopped.

Bit 20 FTF: Flush transmit FIFOWhen this bit is set, the transmit FIFO controller logic is reset to its default values and thus all data in the Tx FIFO are lost/flushed. This bit is cleared internally when the flushing operation is complete. The Operation mode register should not be written to until this bit is cleared.

Bits 16:14 TTC: Transmit threshold controlThese three bits control the threshold level of the Transmit FIFO. Transmission starts when the frame size within the Transmit FIFO is larger than the threshold. In addition, full frames with a length less than the threshold are also transmitted. These bits are used only when the TSF bit (Bit 21) is cleared.000: 64001: 128010: 192011: 256100: 40101: 32110: 24111: 16

Bit 13 ST: Start/stop transmission When this bit is set, transmission is placed in the Running state, and the DMA checks the transmit list at the current position for a frame to be transmitted. Descriptor acquisition is attempted either from the current position in the list, which is the transmit list base address set by the ETH_DMATDLAR register, or from the position retained when transmission was stopped previously. If the current descriptor is not owned by the DMA, transmission enters the Suspended state and the transmit buffer unavailable bit (ETH_DMASR [2]) is set. The Start Transmission command is effective only when transmission is stopped. If the command is issued before setting the DMA ETH_DMATDLAR register, the DMA behavior is unpredictable.When this bit is cleared, the transmission process is placed in the Stopped state after completing the transmission of the current frame. The next descriptor position in the transmit list is saved, and becomes the current position when transmission is restarted. The Stop Transmission command is effective only when the transmission of the current frame is complete or when the transmission is in the Suspended state.

Bit 7 FEF: Forward error framesWhen this bit is set, all frames except runt error frames are forwarded to the DMA.When this bit is cleared, the Rx FIFO drops frames with error status (CRC error, collision error, giant frame, watchdog timeout, overflow). However, if the frame’s start byte (write) pointer is already transferred to the read controller side (in Threshold mode), then the frames are not dropped. The Rx FIFO drops the error frames if that frame's start byte is not transferred (output) on the ARI bus.

Bit 6 FUGF: Forward undersized good framesWhen this bit is set, the Rx FIFO forwards undersized frames (frames with no error and length less than 64 bytes) including pad-bytes and CRC).When this bit is cleared, the Rx FIFO drops all frames of less than 64 bytes, unless such a frame has already been transferred due to lower value of receive threshold (e.g., RTC = 01).

Bits 4:3 RTC: Receive threshold controlThese two bits control the threshold level of the Receive FIFO. Transfer (request) to DMA starts when the frame size within the Receive FIFO is larger than the threshold. In addition, full frames with a length less than the threshold are transferred automatically.Note: Note that value of 11 is not applicable if the configured Receive FIFO size is 128 bytes.Note: These bits are valid only when the RSF bit is zero, and are ignored when the RSF bit is set to 1.00: 6401: 3210: 9611: 128

Bit 2 OSF: Operate on second frameWhen this bit is set, this bit instructs the DMA to process a second frame of Transmit data even before status for first frame is obtained.

Bit 1 SR: Start/stop receiveWhen this bit is set, the receive process is placed in the Running state. The DMA attempts to acquire the descriptor from the receive list and processes incoming frames. Descriptor acquisition is attempted from the current position in the list, which is the address set by the DMA ETH_DMARDLAR register or the position retained when the receive process was previously stopped. If no descriptor is owned by the DMA, reception is suspended and the receive buffer unavailable bit (ETH_DMASR [7]) is set. The Start Receive command is effective only when reception has stopped. If the command was issued before setting the DMA ETH_DMARDLAR register, the DMA behavior is unpredictable.When this bit is cleared, RxDMA operation is stopped after the transfer of the current frame. The next descriptor position in the receive list is saved and becomes the current position when the receive process is restarted. The Stop Receive command is effective only when the Receive process is in either the Running (waiting for receive packet) or the Suspended state.

Bit 16 NISE: Normal interrupt summary enableWhen this bit is set, a normal interrupt is enabled. When this bit is cleared, a normal interrupt is disabled. This bit enables the following bits:– ETH_DMASR [0]: Transmit Interrupt– ETH_DMASR [2]: Transmit buffer unavailable– ETH_DMASR [6]: Receive interrupt– ETH_DMASR [14]: Early receive interrupt

Bit 15 AISE: Abnormal interrupt summary enableWhen this bit is set, an abnormal interrupt is enabled. When this bit is cleared, an abnormal interrupt is disabled. This bit enables the following bits:– ETH_DMASR [1]: Transmit process stopped– ETH_DMASR [3]: Transmit jabber timeout– ETH_DMASR [4]: Receive overflow– ETH_DMASR [5]: Transmit underflow– ETH_DMASR [7]: Receive buffer unavailable– ETH_DMASR [8]: Receive process stopped– ETH_DMASR [9]: Receive watchdog timeout– ETH_DMASR [10]: Early transmit interrupt– ETH_DMASR [13]: Fatal bus error

Bit 14 ERIE: Early receive interrupt enableWhen this bit is set with the normal interrupt summary enable bit (ETH_DMAIER register[16]), the early receive interrupt is enabled.When this bit is cleared, the early receive interrupt is disabled.

Bit 13 FBEIE: Fatal bus error interrupt enableWhen this bit is set with the abnormal interrupt summary enable bit (ETH_DMAIER register[15]), the fatal bus error interrupt is enabled.When this bit is cleared, the fatal bus error enable interrupt is disabled.

Bit 10 ETIE: Early transmit interrupt enableWhen this bit is set with the abnormal interrupt summary enable bit (ETH_DMAIER register [15]), the early transmit interrupt is enabled.When this bit is cleared, the early transmit interrupt is disabled.

The Ethernet interrupt is generated only when the TSTS or PMTS bits of the DMA Status register is asserted with their corresponding interrupt are unmasked, or when the NIS/AIS Status bit is asserted and the corresponding Interrupt Enable bits (NISE/AISE) are enabled.

Bit 9 RWTIE: receive watchdog timeout interrupt enableWhen this bit is set with the abnormal interrupt summary enable bit (ETH_DMAIER register[15]), the receive watchdog timeout interrupt is enabled.When this bit is cleared, the receive watchdog timeout interrupt is disabled.

Bit 8 RPSIE: Receive process stopped interrupt enableWhen this bit is set with the abnormal interrupt summary enable bit (ETH_DMAIER register[15]), the receive stopped interrupt is enabled. When this bit is cleared, the receive stopped interrupt is disabled.

Bit 7 RBUIE: Receive buffer unavailable interrupt enableWhen this bit is set with the abnormal interrupt summary enable bit (ETH_DMAIER register[15]), the receive buffer unavailable interrupt is enabled.When this bit is cleared, the receive buffer unavailable interrupt is disabled.

Bit 6 RIE: Receive interrupt enableWhen this bit is set with the normal interrupt summary enable bit (ETH_DMAIER register[16]), the receive interrupt is enabled.When this bit is cleared, the receive interrupt is disabled.

Bit 5 TUIE: Underflow interrupt enableWhen this bit is set with the abnormal interrupt summary enable bit (ETH_DMAIER register[15]), the transmit underflow interrupt is enabled.When this bit is cleared, the underflow interrupt is disabled.

Bit 4ROIE: Overflow interrupt enableWhen this bit is set with the abnormal interrupt summary enable bit (ETH_DMAIER register[15]), the receive overflow interrupt is enabled.When this bit is cleared, the overflow interrupt is disabled.

Bit 3 TJTIE: Transmit jabber timeout interrupt enableWhen this bit is set with the abnormal interrupt summary enable bit (ETH_DMAIER register[15]), the transmit jabber timeout interrupt is enabled.When this bit is cleared, the transmit jabber timeout interrupt is disabled.

Bit 2 TBUIE: Transmit buffer unavailable interrupt enableWhen this bit is set with the normal interrupt summary enable bit (ETH_DMAIER register[16]), the transmit buffer unavailable interrupt is enabled.When this bit is cleared, the transmit buffer unavailable interrupt is disabled.

Bit 1 TPSIE: Transmit process stopped interrupt enableWhen this bit is set with the abnormal interrupt summary enable bit (ETH_DMAIER register[15]), the transmission stopped interrupt is enabled.When this bit is cleared, the transmission stopped interrupt is disabled.

Bit 0 TIE: Transmit interrupt enableWhen this bit is set with the normal interrupt summary enable bit (ETH_DMAIER register[16]), the transmit interrupt is enabled.When this bit is cleared, the transmit interrupt is disabled.

The DMA maintains two counters to track the number of missed frames during reception. This register reports the current value of the counter. The counter is used for diagnostic purposes. Bits [15:0] indicate missed frames due to the STM32F107xx buffer being unavailable (no receive descriptor was available). Bits [27:17] indicate missed frames due to Rx FIFO overflow conditions and runt frames (good frames of less than 64 bytes).

Bits 15:0 MFC: Missed frames by the controllerIndicates the number of frames missed by the Controller due to the host receive buffer being unavailable. This counter is incremented each time the DMA discards an incoming frame.

The electronic signature is stored in the System memory area in the Flash memory module, and can be read using the JTAG/SWD or the CPU. It contains factory-programmed identification data that allow the user firmware or other external devices to automatically match its interface to the characteristics of the STM32F10xxx microcontroller.


• for use as security keys in order to increase the security of code in Flash memory while using and combining this unique ID with software cryptographic primitives and protocols before programming the internal Flash memory

The STM32F10xxx are built around a Cortex®-M3 core which contains hardware extensions for advanced debugging features. The debug extensions allow the core to be stopped either on a given instruction fetch (breakpoint) or data access (watchpoint). When stopped, the core’s internal state and the system’s external state may be examined. Once examination is complete, the core and the system may be restored and program execution resumed.

The core of the STM32F10xxx integrates the Serial Wire / JTAG Debug Port (SWJ-DP). It is an Arm® standard CoreSight debug port that combines a JTAG-DP (5-pin) interface and a SW-DP (2-pin) interface.

If the debugger host wants to switch to the SW-DP, it must provide a dedicated JTAG sequence on TMS/TCK (respectively mapped to SWDIO and SWCLK) which disables the JTAG-DP and enables the SW-DP. This way it is possible to activate the SWDP using only the SWCLK and SWDIO pins.

After RESET (SYSRESETn or PORESETn), all five pins used for the SWJ-DP are assigned as dedicated pins immediately usable by the debugger host (note that the trace outputs are not assigned except if explicitly programmed by the debugger host).

However, the STM32F10xxx MCU implements the AF remap and debug I/O configuration register (AFIO_MAPR) register to disable some part or all of the SWJ-DP port and so releases the associated pins for General Purpose IOs usage. This register is mapped on an APB bridge connected to the Cortex®-M3 System Bus. Programming of this register is done by the user software program and not the debugger host.

These bits are used to configure the number of pins assigned to the SWJ debug port. The goal is to release as much as possible the number of pins to be used as General Purpose IOs if using a small size for the debug port.

The default state after reset is “000” (whole pins assigned for a full JTAG-DP connection). Only one of the 3 bits can be set (it is forbidden to set more than one bit).

Note:When the APB bridge write buffer is full, it takes one extra APB cycle when writing the AFIO_MAPR register. This is because the deactivation of the JTAGSW pins is done in two cycles to guarantee a clean level on the nTRST and TCK input signals of the core. 

It is necessary to ensure that the JTAG input pins are not floating since they are directly connected to flip-flops to control the debug mode features. Special care must be taken with the SWCLK/TCK pin which is directly connected to the clock of some of these flip-flops.

Once a JTAG IO is released by the user software, the GPIO controller takes control again. The reset states of the GPIO control registers put the I/Os in the equivalent state:

To use the serial wire DP to release some GPIOs, the user software must set SWJ_CFG=010 just after reset. This releases PA15, PB3 and PB4 which now become available as GPIOs.

To release the debug pins, remember that they will be first configured either in input-pull-up (nTRST, TMS, TDI) or pull-down (TCK) or output tristate (TDO) for a certain duration after reset until the instant when the user software releases the pins.

There are several ID codes inside the STM32F10xxx MCUs. ST strongly recommends tools designers to lock their debuggers using the MCU DEVICE ID code located in the external PPB memory map at address 0xE0042000.

Bits 31:16 REV_ID[15:0] Revision identifierThis field indicates the revision of the device:In low-density devices:–0x1000 = Revision AIn medium-density devices:–0x0000 = Revision A–0x2000 = Revision B–0x2001 = Revision Z–0x2003 = Revision 1, 2, 3, X or YIn high-density devices:–0x1000 = Revision A or 1–0x1001 = Revision Z–0x1003 = Revision 1, 2, 3, X or YIn XL-density devices:–0x1000 = Revision A or 1In connectivity line devices:–0x1000 = Revision A–0x1001 = Revision Z

Bits 11:0 DEV_ID[11:0]: Device identifierThis field indicates the device ID.For low-density devices, the device ID is 0x412For medium-density devices, the device ID is 0x410For high-density devices, the device ID is 0x414For XL-density devices, the device ID is 0x430For connectivity devices, the device ID is 0x418

Debug port access registerThis initiates a debug port and allows access to a debug port register.– When transferring data IN: Bits 34:3 = DATA[31:0] = 32-bit data to transfer for a write requestBits 2:1 = A[3:2] = 2-bit address of a debug port register.Bit 0 = RnW = Read request (1) or write request (0).– When transferring data OUT: Bits 34:3 = DATA[31:0] = 32-bit data which is read following a read requestBits 2:0 = ACK[2:0] = 3-bit Acknowledge:010 = OK/FAULT001 = WAITOTHER = reservedRefer to Table 222 for a description of the A[3:2] bits

Access port access registerInitiates an access port and allows access to an access port register.– When transferring data IN: Bits 34:3 = DATA[31:0] = 32-bit data to shift in for a write requestBits 2:1 = A[3:2] = 2-bit address (sub-address AP registers).Bit 0 = RnW= Read request (1) or write request (0).– When transferring data OUT: Bits 34:3 = DATA[31:0] = 32-bit data which is read following a read request Bits 2:0 = ACK[2:0] = 3-bit Acknowledge:010 = OK/FAULT001 = WAITOTHER = reservedThere are many AP Registers (see AHB-AP) addressed as the combination of:– The shifted value A[3:2]– The current value of the DP SELECT register

Each time the direction of SWDIO changes in the protocol, a turnaround time is inserted where the line is not driven by the host nor the target. By default, this turnaround time is one bit time, however this can be adjusted by configuring the SWCLK frequency.

DP CTRL/STAT register. Used to:– Request a system or debug power-up– Configure the transfer operation for AP accesses– Control the pushed compare and pushed verify operations.– Read some status flags (overrun, power-up acknowledges)

DP SELECT register: Used to select the current access port and the active 4-words register window.– Bits 31:24: APSEL: select the current AP– Bits 23:8: reserved– Bits 7:4: APBANKSEL: select the active 4-words register window on the current AP– Bits 3:0: reserved

The State Machine of the SW-DP has an internal ID code which identifies the SW-DP. It follows the JEP-106 standard. This ID code is the default Arm® one and is set to 0x1BA01477 (corresponding to Cortex®-M3 r1p1). 


• The SW-DP state machine is in RESET STATE either after power-on reset, or after the DP has switched from JTAG to SWD or after the line is high for more than 50 cycles 


• After RESET state, it is mandatory to first enter into an IDLE state AND to perform a READ access of the DP-SW ID CODE register. Otherwise, the target will issue a FAULT acknowledge response on another transactions.


• Read accesses to the AP are posted. This means that the result of the access is returned on the next transfer. If the next access to be done is NOT an AP access, then the DP-RDBUFF register must be read to obtain the result.The READOK flag of the DP-CTRL/STAT register is updated on every AP read access or RDBUFF read request to know if the AP read access was successful.


• The SW-DP implements a write buffer (for both DP or AP writes), that enables it to accept a write operation even when other transactions are still outstanding. If the write buffer is full, the target acknowledge response is “WAIT”. With the exception of IDCODE read or CTRL/STAT read or ABORT write which are accepted even if the write buffer is full.


• Because of the asynchronous clock domains SWCLK and HCLK, two extra SWCLK cycles are needed after a write transaction (after the parity bit) to make the write effective internally. These cycles should be applied while driving the line low (IDLE state)This is particularly important when writing the CTRL/STAT for a power-up request. If the next transaction (requiring a power-up) occurs immediately, it will fail.


• The AHB-AP is an AHB master into the Bus Matrix. Consequently, it can access all the data buses (Dcode Bus, System Bus, internal and external PPB bus) but the ICode bus.

Purpose is to:– request a system or debug power-up– configure the transfer operation for AP accesses– control the pushed compare and pushed verify operations.– read some status flags (overrun, power-up acknowledges)

This read buffer is useful because AP accesses are posted (the result of a read AP request is available on the next AP transaction).This read buffer captures data from the AP, presented as the result of a previous read, without initiating a new transaction

Core debug is accessed through the core debug registers. Debug access to these registers is by means of the Advanced High-performance Bus (AHB-AP) port. The processor can access these registers directly over the internal Private Peripheral Bus (PPB).

This way, it is possible for the debugger to connect under System Reset, programming the Core Debug Registers to halt the core when fetching the reset vector. Then the host can release the system reset and the core will immediately halt without having executed any instructions. In addition, it is possible to program any debug features under System Reset.


• 6 instruction comparators for matching against instruction fetches from Code Space. They can be used either to remap to a corresponding area in the System Space or to generate a Breakpoint Instruction to the core.

The ITM is an application-driven trace source that supports printf style debugging to trace Operating System (OS) and application events, and emits diagnostic system information. The ITM emits trace information as packets which can be generated as:


• Time stamping. Timestamps are emitted relative to packets. The ITM contains a 21-bit counter to generate the timestamp. The Cortex®-M3 clock or the bit clock rate of the Serial Wire Viewer (SWV) output clocks the counter.

The packets emitted by the ITM are output to the TPIU (Trace Port Interface Unit). The formatter of the TPIU adds some extra packets (refer to TPIU) and then output the complete packets sequence to the debugger host.

Time stamp packets encode time stamp information, generic control and synchronization. It uses a 21-bit timestamp counter (with possible prescalers) which is reset at each time stamp packet emission. This counter can be either clocked by the CPU clock or the SWV clock.

For this, the DWT must be configured to trigger the ITM: the bit CYCCNTENA (bit0) of the DWT Control Register must be set. In addition, the bit2 (SYNCENA) of the ITM Trace Control Register must be set.

The ETM enables the reconstruction of program execution. Data are traced using the Data Watchpoint and Trace (DWT) component or the Instruction Trace Macrocell (ITM) whereas instructions are traced using the Embedded Trace Macrocell (ETM).

The ETM transmits information as packets and is triggered by embedded resources. These resources must be programmed independently and the trigger source is selected using the Trigger Event Register (0xE0041008). An event could be a simple event (address match from an address comparator) or a logic equation between 2 events. The trigger source is one of the fourth comparators of the DWT module, The following events can be monitored:

The packets transmitted by the ETM are output to the TPIU (Trace Port Interface Unit). The formatter of the TPIU adds some extra packets (refer to Section 31.17) and then outputs the complete packet sequence to the debugger host.

The core does not allow FCLK or HCLK to be turned off during a debug session. As these are required for the debugger connection, during a debug, they must remain active. The MCU integrates special means to allow the user to debug software in low-power modes.


• In Sleep mode, DBG_SLEEP bit of DBGMCU_CR register must be previously set by the debugger. This will feed HCLK with the same clock that is provided to FCLK (system clock previously configured by the software).

Bit 9 DBG_WWDG_STOP: Debug window watchdog stopped when core is halted0: The window watchdog counter clock continues even if the core is halted1: The window watchdog counter clock is stopped when the core is halted

Bit 8 DBG_IWDG_STOP: Debug independent watchdog stopped when core is halted0: The watchdog counter clock continues even if the core is halted1: The watchdog counter clock is stopped when the core is halted

Bit 2 DBG_STANDBY: Debug Standby mode0: (FCLK=Off, HCLK=Off) The whole digital part is unpowered.From software point of view, exiting from Standby is identical than fetching reset vector (except a few status bit indicated that the MCU is resuming from Standby)1: (FCLK=On, HCLK=On) In this case, the digital part is not unpowered and FCLK and HCLK are provided by the internal RC oscillator which remains active. In addition, the MCU generate a system reset during Standby mode so that exiting from Standby is identical than fetching from reset

Bit 1 DBG_STOP: Debug Stop mode0: (FCLK=Off, HCLK=Off) In STOP mode, the clock controller disables all clocks (including HCLK and FCLK). When exiting from STOP mode, the clock configuration is identical to the one after RESET (CPU clocked by the 8 MHz internal RC oscillator (HSI)). Consequently, the software must reprogram the clock controller to enable the PLL, the Xtal, etc.1: (FCLK=On, HCLK=On) In this case, when entering STOP mode, FCLK and HCLK are provided by the internal RC oscillator which remains active in STOP mode. When exiting STOP mode, the software must reprogram the clock controller to enable the PLL, the Xtal, etc. (in the same way it would do in case of DBG_STOP=0)

Bit 0 DBG_SLEEP: Debug Sleep mode0: (FCLK=On, HCLK=Off) In Sleep mode, FCLK is clocked by the system clock as previously configured by the software while HCLK is disabled.In Sleep mode, the clock controller configuration is not reset and remains in the previously programmed state. Consequently, when exiting from Sleep mode, the software does not need to reconfigure the clock controller.1: (FCLK=On, HCLK=On) In this case, when entering Sleep mode, HCLK is fed by the same clock that is provided to FCLK (system clock as previously configured by the software). 

The synchronous mode requires from 2 to 6 extra pins depending on the data trace size and is only available in the larger packages. In addition it is available in JTAG mode and in Serial Wire mode and provides better bandwidth output capabilities than asynchronous trace.

By default, these pins are NOT assigned. They can be assigned by setting the  TRACE_IOEN and TRACE_MODE bits in the MCU Debug component configuration register. This configuration has to be done by the debugger host.

These packets are only generated in continuous mode and enable the TPA to detect that the TRACE port is in IDLE mode (no TRACE to be captured). When detected by the TPA, it must be discarded.

There is no Synchronization Counter register implemented in the TPIU of the core. Consequently, the synchronization trigger can only be generated by the DWT. Refer to the registers DWT Control Register (bits SYNCTAP[11:10]) and the DWT Current PC Sampler Cycle Count Register.


• after each TPIU reset release. This reset is synchronously released with the rising edge of the TRACECLKIN clock. This means that this packet is transmitted when the TRACE_IOEN bit in the DBGMCU_CFG register is set. In this case, the word 0x7F_FF_FF_FF is not followed by any formatted packet.

In the STM32F10xxx, this TRACECLKIN input is internally connected to HCLK. This means that when in asynchronous trace mode, the application is restricted to use to time frames where the CPU frequency is stable.

The default clock of the STM32F10xxx MCUs is the internal RC oscillator. Its frequency under reset is different from the one after reset release. This is because the RC calibration is the default one under system reset and is updated at each system reset release.

Consequently, the trace port analyzer (TPA) should not enable the trace (with the TRACE_IOEN bit) under system reset, because a Synchronization Frame Packet will be issued with a different bit time than trace packets which will be transmitted after reset release.

The TPIU APB registers can be read and written only if the bit TRCENA of the Debug Exception and Monitor Control Register (DEMCR) is set. Otherwise, the registers are read as zero (the output of this bit enables the PCLK of the TPIU).

Allows the trace port size to be selected:Bit 0: Port size = 1Bit 1: Port size = 2Bit 2: Port size = 3, not supportedBit 3: Port Size = 4Only 1 bit must be set. By default, the port size is one bit. (0x00000001)

Bits 31-9 = always ‘0Bit 8 = TrigIn = always ‘1 to indicate that triggers are indicatedBits 7-4 = always 0Bits 3-2 = always 0Bit 1 = EnFCont. In Sync Trace mode (Select_Pin_Protocol register bit1:0=00), this bit is forced to ‘1: the formatter is automatically enabled in continuous mode. In asynchronous mode (Select_Pin_Protocol register bit1:0 <> 00), this bit can be written to activate or not the formatter.Bit 0 = always 0The resulting default value is 0x102Note: In synchronous mode, because the TRACECTL pin is not mapped outside the chip, the formatter is always enabled in continuous mode -this way the formatter inserts some control packets to identify the source of the trace packets).

Reference manual updated to apply to devices containing up to 512 Kbytes of Flash memory (High-density devices). Document restructured. Small text changes. Definitions of Medium-density and High-density devices added to all sections.In Section 3: Memory and bus architecture on page 47:– Figure 1: System architecture (low-, medium-, XL-density devices) on page 47, 

Figure 7: Simplified diagram of the reset circuit on page 91 updated– APB2 peripheral reset register (RCC_APB2RSTR) on page 106 updated– APB1 peripheral reset register (RCC_APB1RSTR) on page 109 updated– AHB peripheral clock enable register (RCC_AHBENR) updated– APB2 peripheral clock enable register (RCC_APB2ENR) updated– APB1 peripheral clock enable register (RCC_APB1ENR) on page 115 updated (see 

STMicroelectronics NV and its subsidiaries (“ST”) reserve the right to make changes, corrections, enhancements, modifications, and improvements to ST products and/or to this document at any time without notice. Purchasers should obtain the latest relevant information on ST products before placing orders. ST products are sold pursuant to ST’s terms and conditions of sale in place at the time of order acknowledgement.
This user manual is structured as follows:
• Overview of HAL drivers
• Overview of low-layer drivers
• Cohabiting of HAL and LL drivers
• Detailed description of each peripheral driver: configuration structures, functions, and how to use the given API to buildyour application

Extension file of a peripheral/module driver. It includes the specific APIs for a given partnumber or family, as well as the newly defined APIs that overwrite the default generic APIs ifthe internal process is implemented in different way.

This file contains SystemInit() which is called at startup just after reset and before branching to themain program. It does not configure the system clock at startup (contrary to the standard library).This is to be done using the HAL APIs in the user files.

The STM32Cube package comes with ready-to-use project templates, one for each supported board. Eachproject contains the files listed above and a preconfigured project for the supported toolchains.Each project template provides empty main loop function and can be used as a starting point to get familiar withproject settings for STM32Cube. Its features are the following:
• It contains the sources of HAL, CMSIS and BSP drivers which are the minimal components to develop acode on a given board.
• It contains the include paths for all the firmware components.
• It defines the STM32 device supported, and allows configuring the CMSIS and HAL drivers accordingly.

The APIs have a modular generic multi-instance architecture that allows working with several IP instancessimultaneously.PPP_HandleTypeDef *handle is the main structure that is implemented in the HAL drivers. It handles theperipheral/module configuration and registers and embeds all the structures and variables needed to follow theperipheral device flow.The peripheral handle is used for the following purposes:
• Multi-instance support: each peripheral/module instance has its own handle. As a result instance resourcesare independent.


• Peripheral process intercommunication: the handle is used to manage shared data resources between theprocess routines.Example: global pointers, DMA handles, state machine.
• Storage : this handle is used also to manage global variables within a given HAL driver.

typedef struct{USART_TypeDef *Instance; /* USART registers base address */USART_InitTypeDef Init; /* Usart communication parameters */uint8_t *pTxBuffPtr;/* Pointer to Usart Tx transfer Buffer */uint16_t TxXferSize; /* Usart Tx Transfer size */__IO uint16_t TxXferCount;/* Usart Tx Transfer Counter */uint8_t *pRxBuffPtr;/* Pointer to Usart Rx transfer Buffer */uint16_t RxXferSize; /* Usart Rx Transfer size */__IO uint16_t RxXferCount; /* Usart Rx Transfer Counter */DMA_HandleTypeDef *hdmatx; /* Usart Tx DMA Handle parameters */DMA_HandleTypeDef *hdmarx; /* Usart Rx DMA Handle parameters */HAL_LockTypeDef Lock; /* Locking object */__IO HAL_USART_StateTypeDef State; /* Usart communication state */__IO HAL_USART_ErrorTypeDef ErrorCode;/* USART Error code */}USART_HandleTypeDef;

These structures are defined in the generic driver header file when it is common to all part numbers. When theycan change from one part number to another, the structures are defined in the extension header file for each partnumber.

typedef struct{uint32_t BaudRate; /*!< This member configures the UART communication baudrate.*/uint32_t WordLength; /*!< Specifies the number of data bits transmitted or received in a frame.*/uint32_t StopBits; /*!< Specifies the number of stop bits transmitted.*/uint32_t Parity; /*!< Specifies the parity mode. */uint32_t Mode; /*!< Specifies wether the Receive or Transmit mode is enabled or disabled.*/uint32_t HwFlowCtl; /*!< Specifies wether the hardware flow control mode is enabled or disabled.*/uint32_t OverSampling; /*!< Specifies wether the Over sampling 8 is enabled or disabled,to achieve higher speed (up to fPCLK/8).*/}UART_InitTypeDef;

The HAL APIs are classified into three categories:
• Generic APIs: common generic APIs applying to all STM32 devices. These APIs are consequently presentin the generic HAL driver files of all STM32 microcontrollers.


• Extension APIs:This set of API is divided into two sub-categories :–Family specific APIs: APIs applying to a given family. They are located in the extension HAL driver file(see example below related to the ADC).

Note:The data structure related to the specific APIs is delimited by the device part number define statement. It islocated in the corresponding extension header C file.The following table summarizes the location of the different categories of HAL APIs in the driver files.

Note:Family specific APIs are only related to a given family. This means that if a specific API is implemented inanother family, and the arguments of this latter family are different, additional structures and arguments mightneed to be added.


• The PPP prefix refers to the peripheral functional mode and not to the peripheral itself. For example, if theUSART, PPP can be USART, IRDA, UART or SMARTCARD depending on the peripheral mode.


• The constants used in one file are defined within this file. A constant used in several files is defined in aheader file. All constants are written in uppercase, except for peripheral driver function parameters.


• Peripheral function names are prefixed by HAL_, then the corresponding peripheral acronym in uppercasefollowed by an underscore. The first letter of each word is in uppercase (e.g. HAL_UART_Transmit()). Onlyone underscore is allowed in a function name to separate the peripheral acronym from the rest of thefunction name.


• The MODE suffix refers to the process mode, which can be polling, interrupt or DMA. As an example, whenthe DMA is used in addition to the native resources, the function should be called: HAL_PPP_Function_DMA().


• The macros that handle interrupts and specific clock configurations are defined in each peripheral/moduledriver. These macros are exported in the peripheral driver header files so that they can be used by theextension file. The list of these macros is defined below:


• NVIC and SYSTICK are two Arm® Cortex® core features. The APIs related to these features are located inthe stm32f1xx_hal_cortex.c file.
• When a status bit or a flag is read from registers, it is composed of shifted values depending on the numberof read values and of their size. In this case, the returned status width is 32 bits. Example : STATUS = XX |(YY << 16) or STATUS = XX | (YY << 8) | (YY << 16) | (YY << 24)".
• The PPP handles are valid before using the HAL_PPP_Init() API. The init function performs a check beforemodifying the handle fields.

The user callback functions are defined as empty functions with “weak” attribute. They have to be defined in theuser code.There are three types of user callbacks functions:
• Peripheral system level initialization/ de-Initialization callbacks: HAL_PPP_MspInit() andHAL_PPP_MspDeInit
• Process complete callbacks : HAL_PPP_ProcessCpltCallback
• Error callback: HAL_PPP_ErrorCallback.

The extension APIs provide specific functions or overwrite modified APIs for a specific family (series) or specificpart number within the same family.The extension model consists of an additional file, stm32f1xx_hal_ppp_ex.c, that includes all the specificfunctions and define statements (stm32f1xx_hal_ppp_ex.h) for a given part number.Below an example based on the ADC peripheral:

When a peripheral which is available only in a specific device is required, the APIs corresponding to this newperipheral/module (newPPP) are added in a new stm32f1xx_hal_newppp.c. However the inclusion of this file isselected in the stm32f1xx_hal_conf.h using the macro:

In this case, the routines are defined with the same names in the stm32f1xx_hal_ppp_ex.c extension file, whilethe generic API is defined as weak, so that the compiler will overwrite the original routine by the new definedfunction.

The data structure for a specific device part number (e.g. PPP_InitTypeDef) can have different fields. In this case,the data structure is defined in the extension header file and delimited by the specific part number definestatement.Example:

The header of the common HAL driver file (stm32f1xx_hal.h) includes the common configurations for the wholeHAL library. It is the only header file that is included in the user sources and the HAL C sources files to be able touse the HAL resources.


• HAL StatusThe HAL status is used by almost all HAL APIs, except for boolean functions and IRQ handler. It returns thestatus of the current API operations. It has four possible values as described below:

The configuration file, stm32f1xx_hal_conf.h, allows customizing the drivers for the user application. Modifyingthis configuration is not mandatory: the application can use the default configuration without any modification.To configure these parameters, the user should enable, disable or modify some options by uncommenting,commenting or modifying the values of the related define statements as described in the table below:

Note:By default, the values defined in the stm32f1xx_hal_conf_template.h file are the same as the ones used for theexamples and demonstrations. All HAL include files are enabled so that they can be used in the user codewithout modifications.

Two main functions can be used to configure the system clock:
• HAL_RCC_OscConfig (RCC_OscInitTypeDef *RCC_OscInitStruct). This function configures/enablesmultiple clock sources (HSE, HSI, LSE, LSI, PLL).
• HAL_RCC_ClockConfig (RCC_ClkInitTypeDef *RCC_ClkInitStruct, uint32_t FLatency). This function–selects the system clock source–configures AHB, APB1 and APB2 clock dividers–configures the number of Flash memory wait states–updates the SysTick configuration when HCLK clock changes.

Some peripheral clocks are not derived from the system clock (such as RTC, USB). In this case, the clockconfiguration is performed by an extended API defined in stm32f1xx_hal_rcc_ex.c:HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef *PeriphClkInit).Additional RCC HAL driver functions are available:
• HAL_RCC_DeInit() Clock de-initialization function that returns clock configuration to reset state
• Get clock functions that allow retreiving various clock configurations (system clock, HCLK, PCLK1, PCLK2,…)
• MCO and CSS configuration functions

In addition to standard GPIO modes (input, output, analog), the pin mode can be configured as EXTI with interruptor event generation.When selecting EXTI mode with interrupt generation, the user must call HAL_GPIO_EXTI_IRQHandler() fromstm32f1xx_it.c and implement HAL_GPIO_EXTI_Callback()The table below describes the GPIO_InitTypeDef structure field.

The EXTI is not considered as a standalone peripheral but rather as a service used by other peripheral, that arehandled through EXTI HAL APIs. In addition, each peripheral HAL driver implements the associated EXTIconfiguration and function as macros in its header file.The first 16 EXTI lines connected to the GPIOs are managed within the GPIO driver. The GPIO_InitTypeDefstructure allows configuring an I/O as external interrupt or external event.The EXTI lines connected internally to the PVD, RTC, USB, and Ethernet are configured within the HAL drivers ofthese peripheral through the macros given in the table below.The EXTI internal connections depend on the targeted STM32 microcontroller (refer to the product datasheet formore details):

The DMA HAL driver allows enabling and configuring the peripheral to be connected to the DMA Channels(except for internal SRAM/FLASH memory which do not require any initialization). Refer to the product referencemanual for details on the DMA request corresponding to each peripheral.For a given channel, HAL_DMA_Init() API allows programming the required configuration through the followingparameters:
• Transfer direction
• Source and destination data formats
• Circular, Normal or peripheral flow control mode
• Channel priority level
• Source and destination Increment mode

Additional functions and macros are available to ensure efficient DMA management:
• Use HAL_DMA_GetState() function to return the DMA state and HAL_DMA_GetError() in case of errordetection.
• Use HAL_DMA_Abort() function to abort the current transfer

Note:When a peripheral is used in DMA mode, the DMA initialization should be done in the HAL_PPP_MspInit()callback. In addition, the user application should associate the DMA handle to the PPP handle (refer to section“HAL IO operation functions”).

Note:DMA channel callbacks need to be initialized by the user application only in case of memory-to-memory transfer.However when peripheral-to-memory transfers are used, these callbacks are automatically initialized by calling aprocess API function that uses the DMA.

Note:The functions implemented in the HAL driver are shown in green, the functions called from interrupt handlers indotted lines, and the msp functions implemented in the user application in red. Non-dotted lines represent theinteractions between the user application functions.Basically, the HAL driver APIs are called from user files and optionally from interrupt handlers file when the APIsbased on the DMA or the PPP peripheral dedicated interrupts are used.When DMA or PPP peripheral interrupts are used, the PPP process complete callbacks are called to inform theuser about the process completion in real-time event mode (interrupts). Note that the same process completioncallbacks are used for DMA in interrupt mode.


• HAL_DeInit()–resets all peripherals–calls function HAL_MspDeInit() which a is user callback function to do system level De-Initalizations.
• HAL_GetTick(): this function gets current SysTick counter value (incremented in SysTick interrupt) used byperipherals drivers to handle timeouts.
• HAL_Delay(). this function implements a delay (expressed in milliseconds) using the SysTick timer.Care must be taken when using HAL_Delay() since this function provides an accurate delay (expressed inmilliseconds) based on a variable incremented in SysTick ISR. This means that if HAL_Delay() is called froma peripheral ISR, then the SysTick interrupt must have highest priority (numerically lower) than theperipheral interrupt, otherwise the caller ISR will be blocked.

/*** @brief Initializes the PPP MSP.* @param hppp: PPP handle* @retval None */void __weak HAL_PPP_MspInit(PPP_HandleTypeDef *hppp) {/* NOTE : This function Should not be modified, when the callback is needed,the HAL_PPP_MspInit could be implemented in the user file */}/*** @brief DeInitializes PPP MSP.* @param hppp: PPP handle* @retval None */void __weak HAL_PPP_MspDeInit(PPP_HandleTypeDef *hppp) {/* NOTE : This function Should not be modified, when the callback is needed,the HAL_PPP_MspDeInit could be implemented in the user file */}

The MSP callbacks are declared empty as weak functions in each peripheral driver. The user can use them to setthe low level initialization code or omit them and use his own initialization routine.The HAL MSP callback is implemented inside the stm32f1xx_hal_msp.c file in the user folders. Anstm32f1xx_hal_msp.c file template is located in the HAL folder and should be copied to the user folder. It can begenerated automatically by STM32CubeMX tool and further modified. Note that all the routines are declared asweak functions and could be overwritten or removed to use user low level initialization code.stm32f1xx_hal_msp.c file contains the following functions:

By default, if no peripheral needs to be de-initialized during the program execution, the whole MSP initialization isdone in Hal_MspInit() and MSP De-Initialization in the Hal_MspDeInit(). In this case the HAL_PPP_MspInit() andHAL_PPP_MspDeInit() are not implemented.When one or more peripherals needs to be de-initialized in run time and the low level resources of a givenperipheral need to be released and used by another peripheral, HAL_PPP_MspDeInit() and HAL_PPP_MspInit()are implemented for the concerned peripheral and other peripherals initialization and de-Initialization are kept inthe global HAL_MspInit() and the HAL_MspDeInit().If there is nothing to be initialized by the global HAL_MspInit() and HAL_MspDeInit(), the two routines can simplybe omitted.

To use a process in Interrupt mode, HAL_PPP_Process_IT() is called in the user file and HAL_PPP_IRQHandlerin stm32f1xx_it.c.The HAL_PPP_ProcessCpltCallback() function is declared as weak function in the driver. This means that theuser can declare it again in the application. The function in the driver is not modified.An example of use is illustrated below:main.c file:

To use a process in DMA mode, HAL_PPP_Process_DMA() is called in the user file and theHAL_PPP_DMA_IRQHandler() is placed in the stm32f1xx_it.c. When DMA mode is used, the DMA initialization isdone in the HAL_PPP_MspInit() callback. The user should also associate the DMA handle to the PPP handle. Forthis purpose, the handles of all the peripheral drivers that use the DMA must be declared as follows:

The HAL_PPP_ProcessCpltCallback() function is declared as weak function in the driver that means, the user candeclare it again in the application code. The function in the driver should not be modified.An example of use is illustrated below:main.c file:

However, in some cases, a fixed timeout is used for system peripherals or internal HAL driver processes. In thesecases, the timeout has the same meaning and is used in the same way, except when it is defined locally in thedrivers and cannot be modified or introduced as an argument in the user application.Example of fixed timeout:

If the expression passed to the assert_param macro is false, theassert_failed function is called and returns thename of the source file and the source line number of the call that failed. If the expression is true, no value isreturned.The assert_param macro is implemented in stm32f1xx_hal_conf.h:

#ifdef USE_FULL_ASSERT /*** @brief Reports the name of the source file and the source line number* where the assert_param error has occurred.* @param file: pointer to the source file name* @param line: assert_param error line source number* @retval None */void assert_failed(uint8_t* file, uint32_t line){/* User can add his own implementation to report the file name and line number,ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) *//* Infinite loop */while (1){}}

Note:Because of the overhead run-time checking introduces, it is recommended to use it during applicationcode development and debugging, and to remove it from the final application to improve code size andspeed.

The low-layer (LL) drivers are designed to offer a fast light-weight expert-oriented layer which is closer to thehardware than the HAL. Contrary to the HAL, LL APIs are not provided for peripherals where optimized access isnot a key feature, or those requiring heavy software configuration and/or complex upper-level stack (such asUSB).The LL drivers feature:
• A set of functions to initialize peripheral main features according to the parameters specified in datastructures
• A set of functions used to fill initialization data structures with the reset values of each field
• Functions to perform peripheral de-initialization (peripheral registers restored to their default values)
• A set of inline functions for direct and atomic register access
• Full independence from HAL since LL drivers can be used either in standalone mode (without HAL drivers)or in mixed mode (with HAL drivers)
• Full coverage of the supported peripheral features.

The low-layer drivers provide hardware services based on the available features of the STM32 peripherals. Theseservices reflect exactly the hardware capabilities and provide one-shot operations that must be called followingthe programming model described in the microcontroller line reference manual. As a result, the LL services do notimplement any processing and do not require any additional memory resources to save their states, counter ordata pointers: all the operations are performed by changing the associated peripheral registers content.

The LL drivers offer three sets of initialization functions. They are defined in stm32f1xx_ll_ppp.c file:
• Functions to initialize peripheral main features according to the parameters specified in data structures
• A set of functions used to fill initialization data structures with the reset values of each field
• Function for peripheral de-initialization (peripheral registers restored to their default values)

The definition of these LL initialization functions and associated resources (structure, literals and prototypes) isconditioned by a compilation switch: USE_FULL_LL_DRIVER. To use these functions, this switch must be addedin the toolchain compiler preprocessor or to any generic header file which is processed before the LL drivers.The below table shows the list of the common functions provided for all the supported peripherals:

Note:'x' corresponds to the group index and refers to the index of the modified register on a given bus. 'bus'corresponds to the bus name.
• Peripheral activation/deactivation management : Enable/disable a peripheral or activate/deactivatespecific peripheral features

The low-ayer APIs are designed to be used in standalone mode or combined with the HAL. They cannot beautomatically used with the HAL for the same peripheral instance. If you use the LL APIs for a specific instance,you can still use the HAL APIs for other instances. Be careful that the low-layer APIs might overwrite someregisters which content is mirrored in the HAL handles.

The low-layer APIs can be used without calling the HAL driver services. This is done by simply includingstm32f1xx_ll_ppp.h in the application files. The LL APIs for a given peripheral are called by executing the samesequence as the one recommended by the programming model in the corresponding product line referencemanual. In this case the HAL drivers associated to the used peripheral can be removed from the workspace.However the STM32CubeF1 framework should be used in the same way as in the HAL drivers case which meansthat System file, startup file and CMSIS should always be used.

Note:When the BSP drivers are included, the used HAL drivers associated with the BSP functions drivers should beincluded in the workspace, even if they are not used by the application layer.

In this case the low-layer APIs are used in conjunction with the HAL drivers to achieve direct and register levelbased operations.Mixed use is allowed, however some consideration should be taken into account:
• It is recommended to avoid using simultaneously the HAL APIs and the combination of low-layer APIs for agiven peripheral instance. If this is the case, one or more private fields in the HAL PPP handle structureshould be updated accordingly.
• For operations and processes that do not alter the handle fields including the initialization structure, the HALdriver APIs and the low-layer services can be used together for the same peripheral instance.
• The low-layer drivers can be used without any restriction with all the HAL drivers that are not based onhandle objects (RCC, common HAL, flash and GPIO).

The common HAL driver contains a set of generic and common APIs that can be used by the PPP peripheraldrivers and the user to start using the HAL.The HAL contains two APIs' categories:
• Common HAL APIs
• Services HAL APIs

This section provides functions allowing to:
• Initializes the Flash interface, the NVIC allocation and initial clock configuration. It initializes the systick alsowhen timeout is needed and the backup domain when enabled.
• de-Initializes common part of the HAL.
• Configure The time base source to have 1ms time base with a dedicated Tick interrupt priority.–SysTick timer is used by default as source of time base, but user can eventually implement his propertime base source (a general purpose timer for example or other time source), keeping in mind thatTime base duration should be kept 1ms since PPP_TIMEOUT_VALUEs are defined and handled inmilliseconds basis.–Time base configuration function (HAL_InitTick ()) is called automatically at the beginning of theprogram after reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig().–Source of time base is configured to generate interrupts at regular time intervals. Care must be taken ifHAL_Delay() is called from a peripheral ISR process, the Tick interrupt line must have higher priority(numerically lower) than the peripheral interrupt. Otherwise the caller ISR process will be blocked.–functions affecting time base configurations are declared as __weak to make override possible in caseof other implementations in user file.

This section provides functions allowing to:
• Provide a tick value in millisecond
• Provide a blocking delay in millisecond
• Suspend the time base source interrupt
• Resume the time base source interrupt
• Get the HAL API driver version
• Get the device identifier
• Get the device revision identifier
• Enable/Disable Debug module during SLEEP mode
• Enable/Disable Debug module during STOP mode
• Enable/Disable Debug module during STANDBY mode

This function is used to initialize the HAL Library; it must be the first instruction to be executed in the mainprogram (before to call any other HAL function), it performs the following: Configure the Flash prefetch.


• This function is called automatically at the beginning of program after reset by HAL_Init() or at any timewhen clock is reconfigured by HAL_RCC_ClockConfig().
• In the default implementation, SysTick timer is the source of time base. It is used to generate interrupts atregular time intervals. Care must be taken if HAL_Delay() is called from a peripheral ISR process, TheSysTick interrupt must have higher priority (numerically lower) than the peripheral interrupt. Otherwise thecaller ISR process will be blocked. The function is declared as __weak to be overwritten in case of otherimplementation in user file.


• In the default implementation , SysTick timer is the source of time base. It is used to generate interrupts atregular time intervals where uwTick is incremented.
• This function is declared as __weak to be overwritten in case of other implementations in user file.


• In the default implementation , SysTick timer is the source of time base. It is used to generate interrupts atregular time intervals. Once HAL_SuspendTick() is called, the SysTick interrupt will be disabled and so Tickincrement is suspended.
• This function is declared as __weak to be overwritten in case of other implementations in user file.


• In the default implementation , SysTick timer is the source of time base. It is used to generate interrupts atregular time intervals. Once HAL_ResumeTick() is called, the SysTick interrupt will be enabled and so Tickincrement is resumed.
• This function is declared as __weak to be overwritten in case of other implementations in user file.

Field Documentation
• uint32_t ADC_InitTypeDef::DataAlignSpecifies ADC data alignment to right (MSB on register bit 11 and LSB on register bit 0) (default setting) orto left (if regular group: MSB on register bit 15 and LSB on register bit 4, if injected group (MSB kept assigned value due to potential negative value after offset application): MSB on register bit 14 and LSB onregister bit 3). This parameter can be a value of ADC_Data_align


• uint32_t ADC_InitTypeDef::ScanConvModeConfigures the sequencer of regular and injected groups. This parameter can be associated to parameter'DiscontinuousConvMode' to have main sequence subdivided in successive parts. If disabled: Conversion isperformed in single mode (one channel converted, the one defined in rank 1). Parameters 'NbrOfConversion'and 'InjectedNbrOfConversion' are discarded (equivalent to set to 1). If enabled: Conversions are performedin sequence mode (multiple ranks defined by 'NbrOfConversion'/'InjectedNbrOfConversion' and eachchannel rank). Scan direction is upward: from rank1 to rank 'n'. This parameter can be a value ofADC_Scan_mode Note: For regular group, this parameter should be enabled in conversion either by polling(HAL_ADC_Start with Discontinuous mode and NbrOfDiscConversion=1) or by DMA(HAL_ADC_Start_DMA), but not by interruption (HAL_ADC_Start_IT): in scan mode, interruption is triggeredonly on the the last conversion of the sequence. All previous conversions would be overwritten by the lastone. Injected group used with scan mode has not this constraint: each rank has its own result register, nodata is overwritten.
• FunctionalState ADC_InitTypeDef::ContinuousConvModeSpecifies whether the conversion is performed in single mode (one conversion) or continuous mode forregular group, after the selected trigger occurred (software start or external trigger). This parameter can beset to ENABLE or DISABLE.
• uint32_t ADC_InitTypeDef::NbrOfConversionSpecifies the number of ranks that will be converted within the regular group sequencer. To use regulargroup sequencer and convert several ranks, parameter 'ScanConvMode' must be enabled. This parametermust be a number between Min_Data = 1 and Max_Data = 16.
• FunctionalState ADC_InitTypeDef::DiscontinuousConvModeSpecifies whether the conversions sequence of regular group is performed in Complete-sequence/Discontinuous-sequence (main sequence subdivided in successive parts). Discontinuous mode is used onlyif sequencer is enabled (parameter 'ScanConvMode'). If sequencer is disabled, this parameter is discarded.Discontinuous mode can be enabled only if continuous mode is disabled. If continuous mode is enabled, thisparameter setting is discarded. This parameter can be set to ENABLE or DISABLE.
• uint32_t ADC_InitTypeDef::NbrOfDiscConversionSpecifies the number of discontinuous conversions in which the main sequence of regular group (parameterNbrOfConversion) will be subdivided. If parameter 'DiscontinuousConvMode' is disabled, this parameter isdiscarded. This parameter must be a number between Min_Data = 1 and Max_Data = 8.


• uint32_t ADC_InitTypeDef::ExternalTrigConvSelects the external event used to trigger the conversion start of regular group. If set toADC_SOFTWARE_START, external triggers are disabled. If set to external trigger source, triggering is onevent rising edge. This parameter can be a value of ADC_External_trigger_source_Regular

Field Documentation
• uint32_t ADC_ChannelConfTypeDef::ChannelSpecifies the channel to configure into ADC regular group. This parameter can be a value of ADC_channelsNote: Depending on devices, some channels may not be available on package pins. Refer to devicedatasheet for channels availability. Note: On STM32F1 devices with several ADC: Only ADC1 can accessinternal measurement channels (VrefInt/TempSensor) Note: On STM32F10xx8 and STM32F10xxB devices:A low-amplitude voltage glitch may be generated (on ADC input 0) on the PA0 pin, when the ADC isconverting with injection trigger. It is advised to distribute the analog channels so that Channel 0 isconfigured as an injected channel. Refer to errata sheet of these devices for more details.
• uint32_t ADC_ChannelConfTypeDef::RankSpecifies the rank in the regular group sequencer This parameter can be a value of ADC_regular_rankNote: In case of need to disable a channel or change order of conversion sequencer, rank containing aprevious channel setting can be overwritten by the new channel setting (or parameter number ofconversions can be adjusted)
• uint32_t ADC_ChannelConfTypeDef::SamplingTimeSampling time value to be set for the selected channel. Unit: ADC clock cycles Conversion time is theaddition of sampling time and processing time (12.5 ADC clock cycles at ADC resolution 12 bits). Thisparameter can be a value of ADC_sampling_times Caution: This parameter updates the parameterproperty of the channel, that can be used into regular and/or injected groups. If this same channel has beenpreviously configured in the other group (regular/injected), it will be updated to last setting. Note: In case ofusage of internal measurement channels (VrefInt/TempSensor), sampling time constraints must berespected (sampling time can be adjusted in function of ADC clock frequency and sampling time setting)Refer to device datasheet for timings values, parameters TS_vrefint, TS_temp (values rough order: 5us to17.1us min).

Field Documentation
• uint32_t ADC_AnalogWDGConfTypeDef::WatchdogModeConfigures the ADC analog watchdog mode: single/all channels, regular/injected group. This parameter canbe a value of ADC_analog_watchdog_mode.
• uint32_t ADC_AnalogWDGConfTypeDef::ChannelSelects which ADC channel to monitor by analog watchdog. This parameter has an effect only if watchdogmode is configured on single channel (parameter WatchdogMode) This parameter can be a value ofADC_channels.


• FunctionalState ADC_AnalogWDGConfTypeDef::ITModeSpecifies whether the analog watchdog is configured in interrupt or polling mode. This parameter can be setto ENABLE or DISABLE
• uint32_t ADC_AnalogWDGConfTypeDef::HighThresholdConfigures the ADC analog watchdog High threshold value. This parameter must be a number betweenMin_Data = 0x000 and Max_Data = 0xFFF.
• uint32_t ADC_AnalogWDGConfTypeDef::LowThresholdConfigures the ADC analog watchdog High threshold value. This parameter must be a number betweenMin_Data = 0x000 and Max_Data = 0xFFF.
• uint32_t ADC_AnalogWDGConfTypeDef::WatchdogNumberReserved for future use, can be set to 0


• 12-bit resolution
• Interrupt generation at the end of regular conversion, end of injected conversion, and in case of analogwatchdog or overrun events.
• Single and continuous conversion modes.
• Scan mode for conversion of several channels sequentially.
• Data alignment with in-built data coherency.
• Programmable sampling time (channel wise)
• ADC conversion of regular group and injected group.
• External trigger (timer or EXTI) for both regular and injected groups.
• DMA request generation for transfer of conversions data of regular group.
• Multimode Dual mode (available on devices with 2 ADCs or more).


• Configurable DMA data storage in Multimode Dual mode (available on devices with 2 DCs or more).
• Configurable delay between conversions in Dual interleaved mode (available on devices with 2 DCs ormore).
• ADC calibration
• ADC supply requirements: 2.4 V to 3.6 V at full speed and down to 1.8 V at slower speed.
• ADC input range: from Vref- (connected to Vssa) to Vref+ (connected to Vdda or to an external voltagereference).

The compilation flag USE_HAL_ADC_REGISTER_CALLBACKS, when set to 1, allows the user to configuredynamically the driver callbacks. Use Functions @ref HAL_ADC_RegisterCallback() to register an interruptcallback.Function @ref HAL_ADC_RegisterCallback() allows to register following callbacks:
• ConvCpltCallback : ADC conversion complete callback
• ConvHalfCpltCallback : ADC conversion DMA half-transfer callback
• LevelOutOfWindowCallback : ADC analog watchdog 1 callback
• ErrorCallback : ADC error callback
• InjectedConvCpltCallback : ADC group injected conversion complete callback
• MspInitCallback : ADC Msp Init callback
• MspDeInitCallback : ADC Msp DeInit callback This function takes as parameters the HAL peripheral handle,the Callback ID and a pointer to the user callback function.

Use function @ref HAL_ADC_UnRegisterCallback to reset a callback to the default weak function.@ref HAL_ADC_UnRegisterCallback takes as parameters the HAL peripheral handle, and the Callback ID. Thisfunction allows to reset following callbacks:
• ConvCpltCallback : ADC conversion complete callback
• ConvHalfCpltCallback : ADC conversion DMA half-transfer callback
• LevelOutOfWindowCallback : ADC analog watchdog 1 callback
• ErrorCallback : ADC error callback
• InjectedConvCpltCallback : ADC group injected conversion complete callback
• MspInitCallback : ADC Msp Init callback
• MspDeInitCallback : ADC Msp DeInit callback

By default, after the @ref HAL_ADC_Init() and when the state is @ref HAL_ADC_STATE_RESET all callbacksare set to the corresponding weak functions: examples @ref HAL_ADC_ConvCpltCallback(), @refHAL_ADC_ErrorCallback(). Exception done for MspInit and MspDeInit functions that are reset to the legacy weakfunctions in the @ref HAL_ADC_Init()/ @ref HAL_ADC_DeInit() only when these callbacks are null (not registeredbeforehand).If MspInit or MspDeInit are not null, the @ref HAL_ADC_Init()/ @ref HAL_ADC_DeInit() keep and use the userMspInit/MspDeInit callbacks (registered beforehand) whatever the state.Callbacks can be registered/unregistered in @ref HAL_ADC_STATE_READY state only. Exception done MspInit/MspDeInit functions that can be registered/unregistered in @ref HAL_ADC_STATE_READY or @refHAL_ADC_STATE_RESET state, thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.Then, the user first registers the MspInit/MspDeInit user callbacks using @ref HAL_ADC_RegisterCallback()before calling @ref HAL_ADC_DeInit() or @ref HAL_ADC_Init() function.When the compilation flag USE_HAL_ADC_REGISTER_CALLBACKS is set to 0 or not defined, the callbackregistration feature is not available and all callbacks are set to the corresponding weak functions.

This section provides functions allowing to:
• Start conversion of regular group.
• Stop conversion of regular group.
• Poll for conversion complete on regular group.
• Poll for conversion event.
• Get result of regular channel conversion.
• Start conversion of regular group and enable interruptions.
• Stop conversion of regular group and disable interruptions.
• Handle ADC interrupt request
• Start conversion of regular group and enable DMA transfer.
• Stop conversion of regular group and disable ADC DMA transfer.


• As prerequisite, ADC clock must be configured at RCC top level (clock source APB2). See commentedexample code below that can be copied and uncommented into HAL_ADC_MspInit().
• Possibility to update parameters on the fly: This function initializes the ADC MSP (HAL_ADC_MspInit())only when coming from ADC state reset. Following calls to this function can be used to reconfigure someparameters of ADC_InitTypeDef structure on the fly, without modifying MSP configuration. If ADC MSP hasto be modified again, HAL_ADC_DeInit() must be called before HAL_ADC_Init(). The setting of theseparameters is conditioned to ADC state. For parameters constraints, see comments of structure"ADC_InitTypeDef".
• This function configures the ADC within 2 scopes: scope of entire ADC and scope of regular group. Forparameters details, see comments of structure "ADC_InitTypeDef".


• This function cannot be used in a particular setup: ADC configured in DMA mode. In this case, DMA resetsthe flag EOC and polling cannot be performed on each conversion.
• On STM32F1 devices, limitation in case of sequencer enabled (several ranks selected): polling cannot bedone on each conversion inside the sequence. In this case, polling is replaced by wait for maximumconversion time.


• : ADC peripheral disable is forcing stop of potential conversion on injected group. If injected group is underuse, it should be preliminarily stopped using HAL_ADCEx_InjectedStop function.
• For devices with several ADCs: This function is for single-ADC mode only. For multimode, use thededicated MultimodeStop function.
• On STM32F1 devices, only ADC1 and ADC3 (ADC availability depending on devices) have DMA capability.


• Reading register DR automatically clears ADC flag EOC (ADC group regular end of unitary conversion).
• This function does not clear ADC flag EOS (ADC group regular end of sequence conversion). Occurrenceof flag EOS rising: If sequencer is composed of 1 rank, flag EOS is equivalent to flag EOC.If sequencer iscomposed of several ranks, during the scan sequence flag EOC only is raised, at the end of the scansequence both flags EOC and EOS are raised. To clear this flag, either use function: in programming modelIT: HAL_ADC_IRQHandler(), in programming model polling: HAL_ADC_PollForConversion() or__HAL_ADC_CLEAR_FLAG(&hadc, ADC_FLAG_EOS).


• In case of usage of internal measurement channels: Vbat/VrefInt/TempSensor. These internal paths can bebe disabled using function HAL_ADC_DeInit().
• Possibility to update parameters on the fly: This function initializes channel into regular group, followingcalls to this function can be used to reconfigure some parameters of structure "ADC_ChannelConfTypeDef"on the fly, without reseting the ADC. The setting of these parameters is conditioned to ADC state. Forparameters constraints, see comments of structure "ADC_ChannelConfTypeDef".


• Analog watchdog thresholds can be modified while ADC conversion is on going. In this case, someconstraints must be taken into account: the programmed threshold values are effective from the next ADCEOC (end of unitary conversion). Considering that registers write delay may happen due to bus activity, thismight cause an uncertainty on the effective timing of the new programmed threshold values.

Notes:
• ADC enable requires a delay for ADC stabilization time (refer to device datasheet, parameter tSTAB) OnSTM32F1, if ADC is already enabled this macro trigs a conversion SW start on regular group.

Parameters:
• __HANDLE__: ADC handle
• __INTERRUPT__: ADC interrupt source to check This parameter can be any combination of the followingvalues:–ADC_IT_EOC: ADC End of Regular Conversion interrupt source–ADC_IT_JEOC: ADC End of Injected Conversion interrupt source–ADC_IT_AWD: ADC Analog watchdog interrupt source

Field Documentation
• uint32_t ADC_InjectionConfTypeDef::InjectedChannelSelection of ADC channel to configure This parameter can be a value of ADC_channels Note: Dependingon devices, some channels may not be available on package pins. Refer to device datasheet for channelsavailability. Note: On STM32F1 devices with several ADC: Only ADC1 can access internal measurementchannels (VrefInt/TempSensor) Note: On STM32F10xx8 and STM32F10xxB devices: A low-amplitudevoltage glitch may be generated (on ADC input 0) on the PA0 pin, when the ADC is converting with injectiontrigger. It is advised to distribute the analog channels so that Channel 0 is configured as an injected channel.Refer to errata sheet of these devices for more details.
• uint32_t ADC_InjectionConfTypeDef::InjectedRankRank in the injected group sequencer This parameter must be a value of ADCEx_injected_rank Note: Incase of need to disable a channel or change order of conversion sequencer, rank containing a previouschannel setting can be overwritten by the new channel setting (or parameter number of conversions can beadjusted)
• uint32_t ADC_InjectionConfTypeDef::InjectedSamplingTimeSampling time value to be set for the selected channel. Unit: ADC clock cycles Conversion time is theaddition of sampling time and processing time (12.5 ADC clock cycles at ADC resolution 12 bits). Thisparameter can be a value of ADC_sampling_times Caution: This parameter updates the parameterproperty of the channel, that can be used into regular and/or injected groups. If this same channel has beenpreviously configured in the other group (regular/injected), it will be updated to last setting. Note: In case ofusage of internal measurement channels (VrefInt/TempSensor), sampling time constraints must berespected (sampling time can be adjusted in function of ADC clock frequency and sampling time setting)Refer to device datasheet for timings values, parameters TS_vrefint, TS_temp (values rough order: 5us to17.1us min).
• uint32_t ADC_InjectionConfTypeDef::InjectedOffsetDefines the offset to be subtracted from the raw converted data (for channels set on injected group only).Offset value must be a positive number. Depending of ADC resolution selected (12, 10, 8 or 6 bits), thisparameter must be a number between Min_Data = 0x000 and Max_Data = 0xFFF, 0x3FF, 0xFF or 0x3Frespectively.
• uint32_t ADC_InjectionConfTypeDef::InjectedNbrOfConversionSpecifies the number of ranks that will be converted within the injected group sequencer. To use the injectedgroup sequencer and convert several ranks, parameter 'ScanConvMode' must be enabled. This parametermust be a number between Min_Data = 1 and Max_Data = 4. Caution: this setting impacts the entireinjected group. Therefore, call of HAL_ADCEx_InjectedConfigChannel() to configure a channel on injectedgroup can impact the configuration of other channels previously set.


• FunctionalState ADC_InjectionConfTypeDef::InjectedDiscontinuousConvModeSpecifies whether the conversions sequence of injected group is performed in Complete-sequence/Discontinuous-sequence (main sequence subdivided in successive parts). Discontinuous mode is used onlyif sequencer is enabled (parameter 'ScanConvMode'). If sequencer is disabled, this parameter is discarded.Discontinuous mode can be enabled only if continuous mode is disabled. If continuous mode is enabled, thisparameter setting is discarded. This parameter can be set to ENABLE or DISABLE. Note: For injectedgroup, number of discontinuous ranks increment is fixed to one-by-one. Caution: this setting impacts theentire injected group. Therefore, call of HAL_ADCEx_InjectedConfigChannel() to configure a channel oninjected group can impact the configuration of other channels previously set.
• FunctionalState ADC_InjectionConfTypeDef::AutoInjectedConvEnables or disables the selected ADC automatic injected group conversion after regular one This parametercan be set to ENABLE or DISABLE. Note: To use Automatic injected conversion, discontinuous mode mustbe disabled ('DiscontinuousConvMode' and 'InjectedDiscontinuousConvMode' set to DISABLE) Note: To useAutomatic injected conversion, injected group external triggers must be disabled ('ExternalTrigInjecConv' setto ADC_SOFTWARE_START) Note: In case of DMA used with regular group: if DMA configured in normalmode (single shot) JAUTO will be stopped upon DMA transfer complete. To maintain JAUTO alwaysenabled, DMA must be configured in circular mode. Caution: this setting impacts the entire injected group.Therefore, call of HAL_ADCEx_InjectedConfigChannel() to configure a channel on injected group canimpact the configuration of other channels previously set.
• uint32_t ADC_InjectionConfTypeDef::ExternalTrigInjecConvSelects the external event used to trigger the conversion start of injected group. If set toADC_INJECTED_SOFTWARE_START, external triggers are disabled. If set to external trigger source,triggering is on event rising edge. This parameter can be a value ofADCEx_External_trigger_source_Injected Note: This parameter must be modified when ADC is disabled(before ADC start conversion or after ADC stop conversion). If ADC is enabled, this parameter setting isbypassed without error reporting (as it can be the expected behaviour in case of another parameter updateon the fly) Caution: this setting impacts the entire injected group. Therefore, call ofHAL_ADCEx_InjectedConfigChannel() to configure a channel on injected group can impact theconfiguration of other channels previously set.

Field Documentation
• uint32_t ADC_MultiModeTypeDef::ModeConfigures the ADC to operate in independent or multi mode. This parameter can be a value ofADCEx_Common_mode Note: In dual mode, a change of channel configuration generates a restart thatcan produce a loss of synchronization. It is recommended to disable dual mode before any configurationchange. Note: In case of simultaneous mode used: Exactly the same sampling time should be configured forthe 2 channels that will be sampled simultaneously by ACD1 and ADC2. Note: In case of interleaved modeused: To avoid overlap between conversions, maximum sampling time allowed is 7 ADC clock cycles for fastinterleaved mode and 14 ADC clock cycles for slow interleaved mode. Note: Some multimode parametersare fixed on STM32F1 and can be configured on other STM32 devices with several ADC (multimodeconfiguration structure can have additional parameters). The equivalences are:–Parameter 'DMAAccessMode': On STM32F1, this parameter is fixed to 1 DMA channel (one DMAchannel for both ADC, DMA of ADC master). On other STM32 devices with several ADC, this isequivalent to parameter 'ADC_DMAACCESSMODE_12_10_BITS'.–Parameter 'TwoSamplingDelay': On STM32F1, this parameter is fixed to 7 or 14 ADC clock cyclesdepending on fast or slow interleaved mode selected. On other STM32 devices with several ADC, thisis equivalent to parameter 'ADC_TWOSAMPLINGDELAY_7CYCLES' (for fast interleaved mode).

This section provides functions allowing to:
• Start conversion of injected group.
• Stop conversion of injected group.
• Poll for conversion complete on injected group.
• Get result of injected channel conversion.
• Start conversion of injected group and enable interruptions.
• Stop conversion of injected group and disable interruptions.
• Start multimode and enable DMA transfer.
• Stop multimode and disable ADC DMA transfer.
• Get result of multimode conversion.
• Perform the ADC self-calibration for single or differential ending.
• Get calibration factors for single or differential ending.
• Set calibration factors for single or differential ending.


• If ADC must be disabled and if conversion is on going on regular group, function HAL_ADC_Stop must beused to stop both injected and regular groups, and disable the ADC.
• If injected group mode auto-injection is enabled, function HAL_ADC_Stop must be used.
• In case of auto-injection mode, HAL_ADC_Stop must be used.


• If ADC must be disabled and if conversion is on going on regular group, function HAL_ADC_Stop must beused to stop both injected and regular groups, and disable the ADC.
• If injected group mode auto-injection is enabled, function HAL_ADC_Stop must be used.


• Multimode is kept enabled after this function. To disable multimode (set withHAL_ADCEx_MultiModeConfigChannel(), ADC must be reinitialized using HAL_ADC_Init() orHAL_ADC_ReInit().
• In case of DMA configured in circular mode, function HAL_ADC_Stop_DMA must be called after thisfunction with handle of ADC slave, to properly disable the DMA channel.


• Reading register JDRx automatically clears ADC flag JEOC (ADC group injected end of unitaryconversion).
• This function does not clear ADC flag JEOS (ADC group injected end of sequence conversion) Occurrenceof flag JEOS rising: If sequencer is composed of 1 rank, flag JEOS is equivalent to flag JEOC.If sequenceris composed of several ranks, during the scan sequence flag JEOC only is raised, at the end of the scansequence both flags JEOC and EOS are raised. Flag JEOS must not be cleared by this function because itwould not be compliant with low power features (feature low power auto-wait, not available on all STM32families). To clear this flag, either use function: in programming model IT: HAL_ADC_IRQHandler(), inprogramming model polling: HAL_ADCEx_InjectedPollForConversion() or__HAL_ADC_CLEAR_FLAG(&hadc, ADC_FLAG_JEOS).


• Possibility to update parameters on the fly: This function initializes injected group, following calls to thisfunction can be used to reconfigure some parameters of structure "ADC_InjectionConfTypeDef" on the fly,without reseting the ADC. The setting of these parameters is conditioned to ADC state: this function mustbe called when ADC is not under conversion.


• Possibility to update parameters on the fly: This function initializes multimode parameters, following calls tothis function can be used to reconfigure some parameters of structure "ADC_MultiModeTypeDef" on the fly,without reseting the ADCs (both ADCs of the common group). The setting of these parameters isconditioned to ADC state. For parameters constraints, see comments of structure"ADC_MultiModeTypeDef".
• To change back configuration from multimode to single mode, ADC must be reset (using functionHAL_ADC_Init() ).

ADC dual mode enabled: Combined injected simultaneous + fast interleaved mode, on groups regular andinjected (delay between ADC sampling phases: 7 ADC clock cycles (equivalent to parameter"TwoSamplingDelay" set to "ADC_TWOSAMPLINGDELAY_7CYCLES" on other STM32 devices))

ADC dual mode enabled: Combined injected simultaneous + slow Interleaved mode, on groups regular andinjected (delay between ADC sampling phases: 14 ADC clock cycles (equivalent to parameter"TwoSamplingDelay" set to "ADC_TWOSAMPLINGDELAY_7CYCLES" on other STM32 devices))

Field Documentation
• uint32_t CAN_InitTypeDef::PrescalerSpecifies the length of a time quantum. This parameter must be a number between Min_Data = 1 andMax_Data = 1024.
• uint32_t CAN_InitTypeDef::ModeSpecifies the CAN operating mode. This parameter can be a value of CAN_operating_mode


• FunctionalState CAN_InitTypeDef::TimeTriggeredModeEnable or disable the time triggered communication mode. This parameter can be set to ENABLE orDISABLE.
• FunctionalState CAN_InitTypeDef::AutoBusOffEnable or disable the automatic bus-off management. This parameter can be set to ENABLE or DISABLE.
• FunctionalState CAN_InitTypeDef::AutoWakeUpEnable or disable the automatic wake-up mode. This parameter can be set to ENABLE or DISABLE.
• FunctionalState CAN_InitTypeDef::AutoRetransmissionEnable or disable the non-automatic retransmission mode. This parameter can be set to ENABLE orDISABLE.
• FunctionalState CAN_InitTypeDef::ReceiveFifoLockedEnable or disable the Receive FIFO Locked mode. This parameter can be set to ENABLE or DISABLE.
• FunctionalState CAN_InitTypeDef::TransmitFifoPriorityEnable or disable the transmit FIFO priority. This parameter can be set to ENABLE or DISABLE.

Field Documentation
• uint32_t CAN_FilterTypeDef::FilterIdHighSpecifies the filter identification number (MSBs for a 32-bit configuration, first one for a 16-bit configuration).This parameter must be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF.
• uint32_t CAN_FilterTypeDef::FilterIdLowSpecifies the filter identification number (LSBs for a 32-bit configuration, second one for a 16-bitconfiguration). This parameter must be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF.
• uint32_t CAN_FilterTypeDef::FilterMaskIdHighSpecifies the filter mask number or identification number, according to the mode (MSBs for a 32-bitconfiguration, first one for a 16-bit configuration). This parameter must be a number between Min_Data =0x0000 and Max_Data = 0xFFFF.
• uint32_t CAN_FilterTypeDef::FilterMaskIdLowSpecifies the filter mask number or identification number, according to the mode (LSBs for a 32-bitconfiguration, second one for a 16-bit configuration). This parameter must be a number between Min_Data =0x0000 and Max_Data = 0xFFFF.
• uint32_t CAN_FilterTypeDef::FilterFIFOAssignmentSpecifies the FIFO (0 or 1U) which will be assigned to the filter. This parameter can be a value ofCAN_filter_FIFO


• uint32_t CAN_FilterTypeDef::FilterBankSpecifies the filter bank which will be initialized. For single CAN instance(14 dedicated filter banks), thisparameter must be a number between Min_Data = 0 and Max_Data = 13. For dual CAN instances(28 filterbanks shared), this parameter must be a number between Min_Data = 0 and Max_Data = 27.
• uint32_t CAN_FilterTypeDef::FilterModeSpecifies the filter mode to be initialized. This parameter can be a value of CAN_filter_mode


• uint32_t CAN_FilterTypeDef::SlaveStartFilterBankSelect the start filter bank for the slave CAN instance. For single CAN instances, this parameter ismeaningless. For dual CAN instances, all filter banks with lower index are assigned to master CAN instance,whereas all filter banks with greater index are assigned to slave CAN instance. This parameter must be anumber between Min_Data = 0 and Max_Data = 27.

Field Documentation
• uint32_t CAN_TxHeaderTypeDef::StdIdSpecifies the standard identifier. This parameter must be a number between Min_Data = 0 and Max_Data =0x7FF.
• uint32_t CAN_TxHeaderTypeDef::ExtIdSpecifies the extended identifier. This parameter must be a number between Min_Data = 0 and Max_Data =0x1FFFFFFF.
• uint32_t CAN_TxHeaderTypeDef::IDESpecifies the type of identifier for the message that will be transmitted. This parameter can be a value ofCAN_identifier_type


• uint32_t CAN_TxHeaderTypeDef::DLCSpecifies the length of the frame that will be transmitted. This parameter must be a number betweenMin_Data = 0 and Max_Data = 8.
• FunctionalState CAN_TxHeaderTypeDef::TransmitGlobalTimeSpecifies whether the timestamp counter value captured on start of frame transmission, is sent in DATA6and DATA7 replacing pData[6] and pData[7].Note:–: Time Triggered Communication Mode must be enabled.–: DLC must be programmed as 8 bytes, in order these 2 bytes are sent. This parameter can be set toENABLE or DISABLE.

Field Documentation
• uint32_t CAN_RxHeaderTypeDef::StdIdSpecifies the standard identifier. This parameter must be a number between Min_Data = 0 and Max_Data =0x7FF.
• uint32_t CAN_RxHeaderTypeDef::ExtIdSpecifies the extended identifier. This parameter must be a number between Min_Data = 0 and Max_Data =0x1FFFFFFF.
• uint32_t CAN_RxHeaderTypeDef::IDESpecifies the type of identifier for the message that will be transmitted. This parameter can be a value ofCAN_identifier_type


• uint32_t CAN_RxHeaderTypeDef::DLCSpecifies the length of the frame that will be transmitted. This parameter must be a number betweenMin_Data = 0 and Max_Data = 8.
• uint32_t CAN_RxHeaderTypeDef::TimestampSpecifies the timestamp counter value captured on start of frame reception.Note:–: Time Triggered Communication Mode must be enabled. This parameter must be a number betweenMin_Data = 0 and Max_Data = 0xFFFF.
• uint32_t CAN_RxHeaderTypeDef::FilterMatchIndexSpecifies the index of matching acceptance filter element. This parameter must be a number betweenMin_Data = 0 and Max_Data = 0xFF.

This section provides functions allowing to:
• HAL_CAN_Start : Start the CAN module
• HAL_CAN_Stop : Stop the CAN module
• HAL_CAN_RequestSleep : Request sleep mode entry.
• HAL_CAN_WakeUp : Wake up from sleep mode.
• HAL_CAN_IsSleepActive : Check is sleep mode is active.
• HAL_CAN_AddTxMessage : Add a message to the Tx mailboxes and activate the correspondingtransmission request
• HAL_CAN_AbortTxRequest : Abort transmission request
• HAL_CAN_GetTxMailboxesFreeLevel : Return Tx mailboxes free level
• HAL_CAN_IsTxMessagePending : Check if a transmission request is pending on the selected Tx mailbox
• HAL_CAN_GetRxMessage : Get a CAN frame from the Rx FIFO
• HAL_CAN_GetRxFifoFillLevel : Return Rx FIFO fill level


• hcan: pointer to a CAN_HandleTypeDef structure that contains the configuration information for thespecified CAN.
• pHeader: pointer to a CAN_TxHeaderTypeDef structure.
• aData: array containing the payload of the Tx frame.
• pTxMailbox: pointer to a variable where the function will return the TxMailbox used to store the Txmessage. This parameter can be a value of–CAN_Tx_Mailboxes.


• hcan: pointer to a CAN_HandleTypeDef structure that contains the configuration information for thespecified CAN.
• TxMailbox: Tx Mailbox where the timestamp of message sent will be read. This parameter can be onevalue of–CAN_Tx_Mailboxes.


• hcan: pointer to an CAN_HandleTypeDef structure that contains the configuration information for thespecified CAN.
• RxFifo: Fifo number of the received message to be read. This parameter can be a value of–CAN_receive_FIFO_number.
• pHeader: pointer to a CAN_RxHeaderTypeDef structure where the header of the Rx frame will be stored.
• aData: array where the payload of the Rx frame will be stored.


• PriorityGroup: The priority grouping bits length. This parameter can be one of the following values:–NVIC_PRIORITYGROUP_0: 0 bits for preemption priority 4 bits for subpriority–NVIC_PRIORITYGROUP_1: 1 bits for preemption priority 3 bits for subpriority–NVIC_PRIORITYGROUP_2: 2 bits for preemption priority 2 bits for subpriority–NVIC_PRIORITYGROUP_3: 3 bits for preemption priority 1 bits for subpriority–NVIC_PRIORITYGROUP_4: 4 bits for preemption priority 0 bits for subpriority


• IRQn: External interrupt number. This parameter can be an enumerator of IRQn_Type enumeration (Forthe complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file(stm32f10xx.h))
• PreemptPriority: The preemption priority for the IRQn channel. This parameter can be a value between 0and 15 A lower priority value indicates a higher priority
• SubPriority: the subpriority level for the IRQ channel. This parameter can be a value between 0 and 15 Alower priority value indicates a higher priority.


• IRQn: External interrupt number. This parameter can be an enumerator of IRQn_Type enumeration (Forthe complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file(stm32f10xxx.h))
• PriorityGroup: the priority grouping bits length. This parameter can be one of the following values:–NVIC_PRIORITYGROUP_0: 0 bits for preemption priority 4 bits for subpriority–NVIC_PRIORITYGROUP_1: 1 bits for preemption priority 3 bits for subpriority–NVIC_PRIORITYGROUP_2: 2 bits for preemption priority 2 bits for subpriority–NVIC_PRIORITYGROUP_3: 3 bits for preemption priority 1 bits for subpriority–NVIC_PRIORITYGROUP_4: 4 bits for preemption priority 0 bits for subpriority
• pPreemptPriority: Pointer on the Preemptive priority value (starting from 0).
• pSubPriority: Pointer on the Subpriority value (starting from 0).


• Enable CRC AHB clock using __HAL_RCC_CRC_CLK_ENABLE();
• Initialize CRC calculator–specify generating polynomial (peripheral default or non-default one)–specify initialization value (peripheral default or non-default one)–specify input data format–specify input or output data inversion mode if any
• Use HAL_CRC_Accumulate() function to compute the CRC value of the input data buffer starting with thepreviously computed CRC as initialization value
• Use HAL_CRC_Calculate() function to compute the CRC value of the input data buffer starting with thedefined initialization value (default or non-default) to initiate CRC calculation

This section provides functions allowing to:
• Initialize the CRC according to the specified parameters in the CRC_InitTypeDef and create the associatedhandle
• DeInitialize the CRC peripheral
• Initialize the CRC MSP (MCU Specific Package)
• DeInitialize the CRC MSP

Field Documentation
• uint32_t DAC_ChannelConfTypeDef::DAC_TriggerSpecifies the external trigger for the selected DAC channel. This parameter can be a value ofDAC_trigger_selection
• uint32_t DAC_ChannelConfTypeDef::DAC_OutputBufferSpecifies whether the DAC channel output buffer is enabled or disabled. This parameter can be a value ofDAC_output_buffer

Each DAC channel integrates an output buffer that can be used to reduce the output impedance, and to driveexternal loads directly without having to add an external operational amplifier. To enable, the output buffer usesConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;

When a DAC channel is used (ex channel1 on PA4) and the other is not (ex channel2 on PA5 is configured inAnalog and disabled). Channel1 may disturb channel2 as coupling effect. Note that there is no coupling onchannel2 as soon as channel2 is turned on. Coupling on adjacent channel could be avoided as follows: whenunused PA5 is configured as INPUT PULL-UP or DOWN. PA5 is configured in ANALOG just before it is turned on.

A DMA request can be generated when an external trigger (but not a software trigger) occurs if DMA1 requestsare enabled using HAL_DAC_Start_DMA(). DMA1 requests are mapped as following:1.DAC channel1 mapped on DMA1 channel3 for STM32F100x low-density, medium-density, high-density withDAC DMA remap:2.DAC channel2 mapped on DMA2 channel3 for STM32F100x high-density without DAC DMA remap andother STM32F1 devices


• Start the DAC peripheral using HAL_DAC_Start_DMA(), at this stage the user specify the length of data tobe transferred at each end of conversion First issued trigger will start the conversion of the value previouslyset by HAL_DAC_SetValue().
• At the middle of data transfer HAL_DAC_ConvHalfCpltCallbackCh1() orHAL_DACEx_ConvHalfCpltCallbackCh2() function is executed and user can add his own code bycustomization of function pointer HAL_DAC_ConvHalfCpltCallbackCh1() orHAL_DACEx_ConvHalfCpltCallbackCh2()
• At The end of data transfer HAL_DAC_ConvCpltCallbackCh1() or HAL_DACEx_ConvHalfCpltCallbackCh2()function is executed and user can add his own code by customization of function pointerHAL_DAC_ConvCpltCallbackCh1() or HAL_DACEx_ConvHalfCpltCallbackCh2()
• In case of transfer Error, HAL_DAC_ErrorCallbackCh1() function is executed and user can add his own codeby customization of function pointer HAL_DAC_ErrorCallbackCh1
• For STM32F100x devices with specific feature: DMA underrun. In case of DMA underrun, DAC interruptiontriggers and execute internal function HAL_DAC_IRQHandler. HAL_DAC_DMAUnderrunCallbackCh1() orHAL_DACEx_DMAUnderrunCallbackCh2() function is executed and user can add his own code bycustomization of function pointer HAL_DAC_DMAUnderrunCallbackCh1() orHAL_DACEx_DMAUnderrunCallbackCh2() and add his own code by customization of function pointerHAL_DAC_ErrorCallbackCh1()
• Stop the DAC peripheral using HAL_DAC_Stop_DMA()

The compilation define USE_HAL_DAC_REGISTER_CALLBACKS when set to 1 allows the user to configuredynamically the driver callbacks. Use Functions @ref HAL_DAC_RegisterCallback() to register a user callback, itallows to register following callbacks:
• ConvCpltCallbackCh1 : callback when a half transfer is completed on Ch1.
• ConvHalfCpltCallbackCh1 : callback when a transfer is completed on Ch1.
• ErrorCallbackCh1 : callback when an error occurs on Ch1.
• DMAUnderrunCallbackCh1 : callback when an underrun error occurs on Ch1.


• ConvCpltCallbackCh2 : callback when a half transfer is completed on Ch2.
• ConvHalfCpltCallbackCh2 : callback when a transfer is completed on Ch2.
• ErrorCallbackCh2 : callback when an error occurs on Ch2.
• DMAUnderrunCallbackCh2 : callback when an underrun error occurs on Ch2.
• MspInitCallback : DAC MspInit.
• MspDeInitCallback : DAC MspdeInit. This function takes as parameters the HAL peripheral handle, theCallback ID and a pointer to the user callback function. Use function @ref HAL_DAC_UnRegisterCallback()to reset a callback to the default weak (surcharged) function. It allows to reset following callbacks:
• ConvCpltCallbackCh1 : callback when a half transfer is completed on Ch1.
• ConvHalfCpltCallbackCh1 : callback when a transfer is completed on Ch1.
• ErrorCallbackCh1 : callback when an error occurs on Ch1.
• DMAUnderrunCallbackCh1 : callback when an underrun error occurs on Ch1.
• ConvCpltCallbackCh2 : callback when a half transfer is completed on Ch2.
• ConvHalfCpltCallbackCh2 : callback when a transfer is completed on Ch2.
• ErrorCallbackCh2 : callback when an error occurs on Ch2.
• DMAUnderrunCallbackCh2 : callback when an underrun error occurs on Ch2.
• MspInitCallback : DAC MspInit.
• MspDeInitCallback : DAC MspdeInit.
• All Callbacks This function) takes as parameters the HAL peripheral handle and the Callback ID. By default,after the @ref HAL_DAC_Init and if the state is HAL_DAC_STATE_RESET all callbacks are reset to thecorresponding legacy weak (surcharged) functions. Exception done for MspInit and MspDeInit callbacks thatare respectively reset to the legacy weak (surcharged) functions in the @ref HAL_DAC_Init and @refHAL_DAC_DeInit only when these callbacks are null (not registered beforehand). If not, MspInit orMspDeInit are not null, the @ref HAL_DAC_Init and @ref HAL_DAC_DeInit keep and use the user MspInit/MspDeInit callbacks (registered beforehand) Callbacks can be registered/unregistered in READY state only.Exception done for MspInit/MspDeInit callbacks that can be registered/unregistered in READY or RESETstate, thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit. In that case firstregister the MspInit/MspDeInit user callbacks using @ref HAL_DAC_RegisterCallback before calling @refHAL_DAC_DeInit or @ref HAL_DAC_Init function. When The compilation defineUSE_HAL_DAC_REGISTER_CALLBACKS is set to 0 or not defined, the callback registering feature is notavailable and weak (surcharged) callbacks are used.


• hdac: pointer to a DAC_HandleTypeDef structure that contains the configuration information for thespecified DAC.
• Channel: The selected DAC channel. This parameter can be one of the following values:–DAC_CHANNEL_1: DAC Channel1 selected–DAC_CHANNEL_2: DAC Channel2 selected


• hdac: pointer to a DAC_HandleTypeDef structure that contains the configuration information for thespecified DAC.
• Channel: The selected DAC channel. This parameter can be one of the following values:–DAC_CHANNEL_1: DAC Channel1 selected–DAC_CHANNEL_2: DAC Channel2 selected


• hdac: pointer to a DAC_HandleTypeDef structure that contains the configuration information for thespecified DAC.
• Channel: The selected DAC channel. This parameter can be one of the following values:–DAC_CHANNEL_1: DAC Channel1 selected–DAC_CHANNEL_2: DAC Channel2 selected
• pData: The destination peripheral Buffer address.
• Length: The length of data to be transferred from memory to DAC peripheral
• Alignment: Specifies the data alignment for DAC channel. This parameter can be one of the followingvalues:–DAC_ALIGN_8B_R: 8bit right data alignment selected–DAC_ALIGN_12B_L: 12bit left data alignment selected–DAC_ALIGN_12B_R: 12bit right data alignment selected


• hdac: pointer to a DAC_HandleTypeDef structure that contains the configuration information for thespecified DAC.
• Channel: The selected DAC channel. This parameter can be one of the following values:–DAC_CHANNEL_1: DAC Channel1 selected–DAC_CHANNEL_2: DAC Channel2 selected


• hdac: pointer to a DAC_HandleTypeDef structure that contains the configuration information for thespecified DAC.
• Channel: The selected DAC channel. This parameter can be one of the following values:–DAC_CHANNEL_1: DAC Channel1 selected–DAC_CHANNEL_2: DAC Channel2 selected
• Alignment: Specifies the data alignment. This parameter can be one of the following values:–DAC_ALIGN_8B_R: 8bit right data alignment selected–DAC_ALIGN_12B_L: 12bit left data alignment selected–DAC_ALIGN_12B_R: 12bit right data alignment selected
• Data: Data to be loaded in the selected data holding register.


• hdac: pointer to a DAC_HandleTypeDef structure that contains the configuration information for thespecified DAC.
• Channel: The selected DAC channel. This parameter can be one of the following values:–DAC_CHANNEL_1: DAC Channel1 selected–DAC_CHANNEL_2: DAC Channel2 selected


• hdac: pointer to a DAC_HandleTypeDef structure that contains the configuration information for thespecified DAC.
• sConfig: DAC configuration structure.
• Channel: The selected DAC channel. This parameter can be one of the following values:–DAC_CHANNEL_1: DAC Channel1 selected–DAC_CHANNEL_2: DAC Channel2 selected


• hdac: pointer to a DAC_HandleTypeDef structure that contains the configuration information for thespecified DAC.
• Alignment: Specifies the data alignment for dual channel DAC. This parameter can be one of the followingvalues: DAC_ALIGN_8B_R: 8bit right data alignment selected DAC_ALIGN_12B_L: 12bit left dataalignment selected DAC_ALIGN_12B_R: 12bit right data alignment selected
• Data1: Data for DAC Channel1 to be loaded in the selected data holding register.
• Data2: Data for DAC Channel2 to be loaded in the selected data holding register.


• uint32_t DMA_InitTypeDef::ModeSpecifies the operation mode of the DMAy Channelx. This parameter can be a value of DMA_modeNote:–The circular buffer mode cannot be used if the memory-to-memory data transfer is configured on theselected Channel
• uint32_t DMA_InitTypeDef::PrioritySpecifies the software priority for the DMAy Channelx. This parameter can be a value ofDMA_Priority_level

Field Documentation
• DMA_Channel_TypeDef* __DMA_HandleTypeDef::InstanceRegister base address
• DMA_InitTypeDef __DMA_HandleTypeDef::InitDMA communication parameters
• HAL_LockTypeDef __DMA_HandleTypeDef::LockDMA locking object
• HAL_DMA_StateTypeDef __DMA_HandleTypeDef::StateDMA transfer state
• void* __DMA_HandleTypeDef::ParentParent object state
• void(* __DMA_HandleTypeDef::XferCpltCallback)(struct __DMA_HandleTypeDef *hdma)DMA transfer complete callback
• void(* __DMA_HandleTypeDef::XferHalfCpltCallback)(struct __DMA_HandleTypeDef *hdma)DMA Half transfer complete callback
• void(* __DMA_HandleTypeDef::XferErrorCallback)(struct __DMA_HandleTypeDef *hdma)DMA transfer error callback
• void(* __DMA_HandleTypeDef::XferAbortCallback)(struct __DMA_HandleTypeDef *hdma)DMA transfer abort callback
• __IO uint32_t __DMA_HandleTypeDef::ErrorCodeDMA Error code
• DMA_TypeDef* __DMA_HandleTypeDef::DmaBaseAddressDMA Channel Base Address
• uint32_t __DMA_HandleTypeDef::ChannelIndexDMA Channel Index


• Use HAL_DMA_Start() to start DMA transfer after the configuration of Source address and destinationaddress and the Length of data to be transferred
• Use HAL_DMA_PollForTransfer() to poll for the end of current transfer, in this case a fixed Timeout can beconfigured by User depending from his application.


• Configure the DMA interrupt priority using HAL_NVIC_SetPriority()
• Enable the DMA IRQ handler using HAL_NVIC_EnableIRQ()
• Use HAL_DMA_Start_IT() to start DMA transfer after the configuration of Source address and destinationaddress and the Length of data to be transferred. In this case the DMA interrupt is configured
• Use HAL_DMA_IRQHandler() called under DMA_IRQHandler() Interrupt subroutine
• At the end of data transfer HAL_DMA_IRQHandler() function is executed and user can add his own functionby customization of function pointer XferCpltCallback and XferErrorCallback (i.e. a member of DMA handlestructure).

This section provides functions allowing to initialize the DMA Channel source and destination addresses,incrementation and data sizes, transfer direction, circular/normal mode selection, memory-to-memory modeselection and Channel priority value.The HAL_DMA_Init() function follows the DMA configuration procedures as described in reference manual.This section contains the following APIs:
• HAL_DMA_Init

This section provides functions allowing to:
• Configure the source, destination address and data length and Start DMA transfer
• Configure the source, destination address and data length and Start DMA transfer with interrupt
• Abort DMA transfer
• Poll for transfer complete
• Handle DMA interrupt request


• hdma: pointer to a DMA_HandleTypeDef structure that contains the configuration information for thespecified DMA Channel.
• SrcAddress: The source memory Buffer address
• DstAddress: The destination memory Buffer address
• DataLength: The length of data to be transferred from source to destination


• hdma: pointer to a DMA_HandleTypeDef structure that contains the configuration information for thespecified DMA Channel.
• SrcAddress: The source memory Buffer address
• DstAddress: The destination memory Buffer address
• DataLength: The length of data to be transferred from source to destination


• hdma: pointer to a DMA_HandleTypeDef structure that contains the configuration information for thespecified DMA Channel.
• CallbackID: User Callback identifer a HAL_DMA_CallbackIDTypeDef ENUM as parameter.
• pCallback: pointer to private callbacsk function which has pointer to a DMA_HandleTypeDef structure asparameter.

Parameters:
• __HANDLE__: DMA handle
• __INTERRUPT__: specifies the DMA interrupt sources to be enabled or disabled. This parameter can beany combination of the following values:–DMA_IT_TC: Transfer complete interrupt mask–DMA_IT_HT: Half transfer complete interrupt mask–DMA_IT_TE: Transfer error interrupt mask

Parameters:
• __HANDLE__: DMA handle
• __INTERRUPT__: specifies the DMA interrupt sources to be enabled or disabled. This parameter can beany combination of the following values:–DMA_IT_TC: Transfer complete interrupt mask–DMA_IT_HT: Half transfer complete interrupt mask–DMA_IT_TE: Transfer error interrupt mask

Parameters:
• __HANDLE__: DMA handle
• __INTERRUPT__: specifies the DMA interrupt source to check. This parameter can be one of the followingvalues:–DMA_IT_TC: Transfer complete interrupt mask–DMA_IT_HT: Half transfer complete interrupt mask–DMA_IT_TE: Transfer error interrupt mask

Parameters:
• __HANDLE__: DMA handle
• __FLAG__: Get the specified flag. This parameter can be any combination of the following values:–DMA_FLAG_TCx: Transfer complete flag–DMA_FLAG_HTx: Half transfer complete flag–DMA_FLAG_TEx: Transfer error flag Where x can be 1_7 or 1_5 (depending on DMA1 or DMA2) toselect the DMA Channel flag.

Parameters:
• __HANDLE__: DMA handle
• __FLAG__: specifies the flag to clear. This parameter can be any combination of the following values:–DMA_FLAG_TCx: Transfer complete flag–DMA_FLAG_HTx: Half transfer complete flag–DMA_FLAG_TEx: Transfer error flag Where x can be 1_7 or 1_5 (depending on DMA1 or DMA2) toselect the DMA Channel flag.

Field Documentation
• uint32_t ETH_InitTypeDef::AutoNegotiationSelects or not the AutoNegotiation mode for the external PHY The AutoNegotiation allows an automaticsetting of the Speed (10/100Mbps) and the mode (half/full-duplex). This parameter can be a value ofETH_AutoNegotiation


• uint16_t ETH_InitTypeDef::PhyAddressEthernet PHY address. This parameter must be a number between Min_Data = 0 and Max_Data = 32
• uint8_t* ETH_InitTypeDef::MACAddrMAC Address of used Hardware: must be pointer on an array of 6 bytes
• uint32_t ETH_InitTypeDef::RxModeSelects the Ethernet Rx mode: Polling mode, Interrupt mode. This parameter can be a value ofETH_Rx_Mode

Field Documentation
• uint32_t ETH_MACInitTypeDef::WatchdogSelects or not the Watchdog timer When enabled, the MAC allows no more then 2048 bytes to be received.When disabled, the MAC can receive up to 16384 bytes. This parameter can be a value of ETH_Watchdog


• uint32_t ETH_MACInitTypeDef::JabberSelects or not Jabber timer When enabled, the MAC allows no more then 2048 bytes to be sent. Whendisabled, the MAC can send up to 16384 bytes. This parameter can be a value of ETH_Jabber


• uint32_t ETH_MACInitTypeDef::HashTableHighThis field holds the higher 32 bits of Hash table. This parameter must be a number between Min_Data = 0x0and Max_Data = 0xFFFFFFFFU
• uint32_t ETH_MACInitTypeDef::HashTableLowThis field holds the lower 32 bits of Hash table. This parameter must be a number between Min_Data = 0x0and Max_Data = 0xFFFFFFFFU
• uint32_t ETH_MACInitTypeDef::PauseTimeThis field holds the value to be used in the Pause Time field in the transmit control frame. This parametermust be a number between Min_Data = 0x0 and Max_Data = 0xFFFFU
• uint32_t ETH_MACInitTypeDef::ZeroQuantaPauseSelects or not the automatic generation of Zero-Quanta Pause Control frames. This parameter can be avalue of ETH_Zero_Quanta_Pause


• uint32_t ETH_DMAInitTypeDef::ForwardUndersizedGoodFramesEnables or disables the Rx FIFO to forward Undersized frames (frames with no Error and length less than64 bytes) including pad-bytes and CRC) This parameter can be a value ofETH_Forward_Undersized_Good_Frames


• uint32_t ETH_DMAInitTypeDef::SecondFrameOperateSelects or not the Operate on second frame mode, which allows the DMA to process a second frame ofTransmit data even before obtaining the status for the first frame. This parameter can be a value ofETH_Second_Frame_Operate


• uint32_t ETH_DMAInitTypeDef::DescriptorSkipLengthSpecifies the number of word to skip between two unchained descriptors (Ring mode) This parameter mustbe a number between Min_Data = 0 and Max_Data = 32
• uint32_t ETH_DMAInitTypeDef::DMAArbitrationSelects the DMA Tx/Rx arbitration. This parameter can be a value of ETH_DMA_Arbitration

This section provides functions allowing to:
• Enable MAC and DMA transmission and reception. HAL_ETH_Start();
• Disable MAC and DMA transmission and reception. HAL_ETH_Stop();
• Set the MAC configuration in runtime mode HAL_ETH_ConfigMAC();
• Set the DMA configuration in runtime mode HAL_ETH_ConfigDMA();


• heth: pointer to a ETH_HandleTypeDef structure that contains the configuration information forETHERNET module
• DMATxDescTab: Pointer to the first Tx desc list
• TxBuff: Pointer to the first TxBuffer list
• TxBuffCount: Number of the used Tx desc in the list


• heth: pointer to a ETH_HandleTypeDef structure that contains the configuration information forETHERNET module
• DMARxDescTab: Pointer to the first Rx desc list
• RxBuff: Pointer to the first RxBuffer list
• RxBuffCount: Number of the used Rx desc in the list


• heth: pointer to a ETH_HandleTypeDef structure that contains the configuration information forETHERNET module
• PHYReg: PHY register address, is the index of one of the 32 PHY register. This parameter can be one ofthe following values: PHY_BCR: Transceiver Basic Control Register, PHY_BSR: Transceiver Basic StatusRegister. More PHY register could be read depending on the used PHY
• RegValue: PHY register value


• heth: pointer to a ETH_HandleTypeDef structure that contains the configuration information forETHERNET module
• PHYReg: PHY register address, is the index of one of the 32 PHY register. This parameter can be one ofthe following values: PHY_BCR: Transceiver Control Register. More PHY register could be writtendepending on the used PHY
• RegValue: the value to write

Parameters:
• __HANDLE__: ETH Handle.
• __INTERRUPT__: specifies the ETHERNET MMC interrupt sources to be enabled or disabled. Thisparameter can be one of the following values:–ETH_MMC_IT_RGUF : When Rx good unicast frames counter reaches half the maximum value–ETH_MMC_IT_RFAE : When Rx alignment error counter reaches half the maximum value–ETH_MMC_IT_RFCE : When Rx crc error counter reaches half the maximum value

Parameters:
• __HANDLE__: ETH Handle.
• __INTERRUPT__: specifies the ETHERNET MMC interrupt sources to be enabled or disabled. Thisparameter can be one of the following values:–ETH_MMC_IT_RGUF : When Rx good unicast frames counter reaches half the maximum value–ETH_MMC_IT_RFAE : When Rx alignment error counter reaches half the maximum value–ETH_MMC_IT_RFCE : When Rx crc error counter reaches half the maximum value

Parameters:
• __HANDLE__: ETH Handle.
• __INTERRUPT__: specifies the ETHERNET MMC interrupt sources to be enabled or disabled. Thisparameter can be one of the following values:–ETH_MMC_IT_TGF : When Tx good frame counter reaches half the maximum value–ETH_MMC_IT_TGFMSC: When Tx good multi col counter reaches half the maximum value–ETH_MMC_IT_TGFSC : When Tx good single col counter reaches half the maximum value

Parameters:
• __HANDLE__: ETH Handle.
• __INTERRUPT__: specifies the ETHERNET MMC interrupt sources to be enabled or disabled. Thisparameter can be one of the following values:–ETH_MMC_IT_TGF : When Tx good frame counter reaches half the maximum value–ETH_MMC_IT_TGFMSC: When Tx good multi col counter reaches half the maximum value–ETH_MMC_IT_TGFSC : When Tx good single col counter reaches half the maximum value


• When set in interrupt mode, configurable Exti lines have two different interrupts pending registers whichallow to distinguish which transition occurs:–Rising edge pending interrupt–Falling
• Exti lines 0 to 15 are linked to gpio pin number 0 to 15. Gpio port can be selected through multiplexer.

Field Documentation
• __IO FLASH_ProcedureTypeDef FLASH_ProcessTypeDef::ProcedureOnGoingInternal variable to indicate which procedure is ongoing or not in IT context
• __IO uint32_t FLASH_ProcessTypeDef::DataRemainingInternal variable to save the remaining pages to erase or half-word to program in IT context
• __IO uint32_t FLASH_ProcessTypeDef::AddressInternal variable to save address selected for program or erase
• __IO uint64_t FLASH_ProcessTypeDef::DataInternal variable to save data to be programmed
• HAL_LockTypeDef FLASH_ProcessTypeDef::LockFLASH locking object
• __IO uint32_t FLASH_ProcessTypeDef::ErrorCodeFLASH error code This parameter can be a value of FLASH_Error_Codes

The Flash memory interface manages CPU AHB I-Code and D-Code accesses to the Flash memory. Itimplements the erase and program Flash memory operations and the read and write protection mechanisms.The Flash memory interface accelerates code execution with a system of instruction prefetch.The FLASH main features are:
• Flash memory read operations
• Flash memory program/erase operations
• Read / write protections
• Prefetch on I-Code
• Option Bytes programming


• TypeProgram: Indicate the way to program at a specified address. This parameter can be a value ofFLASH Type Program
• Address: Specifies the address to be programmed.
• Data: Specifies the data to be programmed


• The function HAL_FLASH_Unlock() should be called before to unlock the FLASH interface The functionHAL_FLASH_Lock() should be called after to lock the FLASH interface
• If an erase and a program operations are requested simultaneously, the erase operation is performedbefore the program one.
• FLASH should be previously erased before new programmation (only exception to this is when 0x0000 isprogrammed)


• TypeProgram: Indicate the way to program at a specified address. This parameter can be a value ofFLASH Type Program
• Address: Specifies the address to be programmed.
• Data: Specifies the data to be programmed


• The function HAL_FLASH_Unlock() should be called before to unlock the FLASH interface The functionHAL_FLASH_Lock() should be called after to lock the FLASH interface
• If an erase and a program operations are requested simultaneously, the erase operation is performedbefore the program one.


• ReturnValue: The value saved in this parameter depends on the ongoing procedure–Mass Erase: No return value expected–Pages Erase: Address of the page which has been erased (if 0xFFFFFFFF, it means that all theselected pages have been erased)–Program: Address which was selected for data program


• ReturnValue: The value saved in this parameter depends on the ongoing procedure–Mass Erase: No return value expected–Pages Erase: Address of the page which returned an error–Program: Address which was selected for data program


• uint32_t FLASH_EraseInitTypeDef::PageAddressPageAdress: Initial FLASH page address to erase when mass erase is disabled This parameter must be anumber between Min_Data = 0x08000000 and Max_Data = FLASH_BANKx_END (x = 1 or 2 depending ondevices)
• uint32_t FLASH_EraseInitTypeDef::NbPagesNbPages: Number of pagess to be erased. This parameter must be a value between Min_Data = 1 andMax_Data = (max number of pages - value of initial page)


• pEraseInit: pointer to an FLASH_EraseInitTypeDef structure that contains the configuration information forthe erasing.
• PageError: pointer to variable that contains the configuration information on faulty page in case of error(0xFFFFFFFF means that all the pages have been correctly erased)


• This functions erases all option bytes except the Read protection (RDP). The functionHAL_FLASH_Unlock() should be called before to unlock the FLASH interface The functionHAL_FLASH_OB_Unlock() should be called before to unlock the options bytes The functionHAL_FLASH_OB_Launch() should be called after to force the reload of the options bytes (system reset willoccur)


• The function HAL_FLASH_Unlock() should be called before to unlock the FLASH interface The functionHAL_FLASH_OB_Unlock() should be called before to unlock the options bytes The functionHAL_FLASH_OB_Launch() should be called after to force the reload of the options bytes (system reset willoccur)

Subject to the specific hardware characteristics of each I/O port listed in the datasheet, each port bit of theGeneral Purpose IO (GPIO) Ports, can be individually configured by software in several modes:
• Input mode
• Analog mode
• Output mode
• Alternate function mode
• External interrupt/event lines

During and just after reset, the alternate functions and external interrupt lines are not active and the I/O ports areconfigured in input floating mode.All GPIO pins have weak internal pull-up and pull-down resistors, which can be activated or not.In Output or Alternate mode, each IO can be configured on open-drain or push-pull type and the IO speed can beselected depending on the VDD value.All ports have external interrupt/event capability. To use external interrupt lines, the port must be configured ininput mode. All available GPIO pins are connected to the 16 external interrupt/event lines from EXTI0 to EXTI15.The external interrupt/event controller consists of up to 20 edge detectors in connectivity line devices, or 19 edgedetectors in other devices for generating event/interrupt requests. Each input line can be independentlyconfigured to select the type (event or interrupt) and the corresponding trigger event (rising or falling or both).Each line can also masked independently. A pending register maintains the status line of the interrupt requests


• The locking mechanism allows the IO configuration to be frozen. When the LOCK sequence has beenapplied on a port bit, it is no longer possible to modify the value of the port bit until the next reset.


• hhcd: HCD handle
• ch_num: Channel number. This parameter can be a value from 1 to 15
• epnum: Endpoint number. This parameter can be a value from 1 to 15
• dev_address: Current device address This parameter can be a value from 0 to 255
• speed: Current device speed. This parameter can be one of these values: HCD_SPEED_FULL: Full speedmode, HCD_SPEED_LOW: Low speed mode
• ep_type: Endpoint Type. This parameter can be one of these values: EP_TYPE_CTRL: Control type,EP_TYPE_ISOC: Isochronous type, EP_TYPE_BULK: Bulk type, EP_TYPE_INTR: Interrupt type
• mps: Max Packet Size. This parameter can be a value from 0 to32K


• hhcd: HCD handle
• ch_num: Channel number. This parameter can be a value from 1 to 15
• direction: Channel number. This parameter can be one of these values: 0 : Output / 1 : Input
• ep_type: Endpoint Type. This parameter can be one of these values: EP_TYPE_CTRL: Control type/EP_TYPE_ISOC: Isochronous type/ EP_TYPE_BULK: Bulk type/ EP_TYPE_INTR: Interrupt type/
• token: Endpoint Type. This parameter can be one of these values: 0: HC_PID_SETUP / 1:HC_PID_DATA1
• pbuff: pointer to URB data
• length: Length of URB data
• do_ping: activate do ping protocol (for high speed only). This parameter can be one of these values: 0 : doping inactive / 1 : do ping active

Field Documentation
• uint32_t I2C_InitTypeDef::ClockSpeedSpecifies the clock frequency. This parameter must be set to a value lower than 400kHz
• uint32_t I2C_InitTypeDef::DutyCycleSpecifies the I2C fast mode duty cycle. This parameter can be a value of I2C_duty_cycle_in_fast_mode


• uint32_t I2C_InitTypeDef::OwnAddress1Specifies the first device own address. This parameter can be a 7-bit or 10-bit address.
• uint32_t I2C_InitTypeDef::AddressingModeSpecifies if 7-bit or 10-bit addressing mode is selected. This parameter can be a value ofI2C_addressing_mode


• uint32_t I2C_InitTypeDef::OwnAddress2Specifies the second device own address if dual addressing mode is selected This parameter can be a 7-bitaddress.
• uint32_t I2C_InitTypeDef::GeneralCallModeSpecifies if general call mode is selected. This parameter can be a value ofI2C_general_call_addressing_mode

Field Documentation
• I2C_TypeDef* __I2C_HandleTypeDef::InstanceI2C registers base address
• I2C_InitTypeDef __I2C_HandleTypeDef::InitI2C communication parameters
• uint8_t* __I2C_HandleTypeDef::pBuffPtrPointer to I2C transfer buffer
• uint16_t __I2C_HandleTypeDef::XferSizeI2C transfer size
• __IO uint16_t __I2C_HandleTypeDef::XferCountI2C transfer counter
• __IO uint32_t __I2C_HandleTypeDef::XferOptionsI2C transfer options
• __IO uint32_t __I2C_HandleTypeDef::PreviousStateI2C communication Previous state and mode context for internal usage
• DMA_HandleTypeDef* __I2C_HandleTypeDef::hdmatxI2C Tx DMA handle parameters
• DMA_HandleTypeDef* __I2C_HandleTypeDef::hdmarxI2C Rx DMA handle parameters
• HAL_LockTypeDef __I2C_HandleTypeDef::LockI2C locking object
• __IO HAL_I2C_StateTypeDef __I2C_HandleTypeDef::StateI2C communication state
• __IO HAL_I2C_ModeTypeDef __I2C_HandleTypeDef::ModeI2C communication mode
• __IO uint32_t __I2C_HandleTypeDef::ErrorCodeI2C Error code
• __IO uint32_t __I2C_HandleTypeDef::DevaddressI2C Target device address
• __IO uint32_t __I2C_HandleTypeDef::MemaddressI2C Target memory address
• __IO uint32_t __I2C_HandleTypeDef::MemaddSizeI2C Target memory address size
• __IO uint32_t __I2C_HandleTypeDef::EventCountI2C Event counter


• Transmit in master mode an amount of data in blocking mode using @ref HAL_I2C_Master_Transmit()
• Receive in master mode an amount of data in blocking mode using @ref HAL_I2C_Master_Receive()
• Transmit in slave mode an amount of data in blocking mode using @ref HAL_I2C_Slave_Transmit()
• Receive in slave mode an amount of data in blocking mode using @ref HAL_I2C_Slave_Receive()


• Transmit in master mode an amount of data in non-blocking mode using @refHAL_I2C_Master_Transmit_IT()
• At transmission end of transfer, @ref HAL_I2C_MasterTxCpltCallback() is executed and user can add hisown code by customization of function pointer @ref HAL_I2C_MasterTxCpltCallback()
• Receive in master mode an amount of data in non-blocking mode using @refHAL_I2C_Master_Receive_IT()
• At reception end of transfer, @ref HAL_I2C_MasterRxCpltCallback() is executed and user can add his owncode by customization of function pointer @ref HAL_I2C_MasterRxCpltCallback()
• Transmit in slave mode an amount of data in non-blocking mode using @ref HAL_I2C_Slave_Transmit_IT()
• At transmission end of transfer, @ref HAL_I2C_SlaveTxCpltCallback() is executed and user can add hisown code by customization of function pointer @ref HAL_I2C_SlaveTxCpltCallback()
• Receive in slave mode an amount of data in non-blocking mode using @ref HAL_I2C_Slave_Receive_IT()
• At reception end of transfer, @ref HAL_I2C_SlaveRxCpltCallback() is executed and user can add his owncode by customization of function pointer @ref HAL_I2C_SlaveRxCpltCallback()


• In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can add his owncode by customization of function pointer @ref HAL_I2C_ErrorCallback()
• Abort a master I2C process communication with Interrupt using @ref HAL_I2C_Master_Abort_IT()
• End of abort process, @ref HAL_I2C_AbortCpltCallback() is executed and user can add his own code bycustomization of function pointer @ref HAL_I2C_AbortCpltCallback()

Note:These interfaces allow to manage a sequential transfer with a repeated start condition when a direction changeduring transfer
• A specific option field manage the different steps of a sequential transfer
• Option field values are defined through @ref I2C_XferOptions_definition and are listed below:–I2C_FIRST_AND_LAST_FRAME: No sequential usage, functionnal is same as associated interfaces inno sequential mode–I2C_FIRST_FRAME: Sequential usage, this option allow to manage a sequence with start condition,address and data to transfer without a final stop condition–I2C_FIRST_AND_NEXT_FRAME: Sequential usage (Master only), this option allow to manage asequence with start condition, address and data to transfer without a final stop condition, an thenpermit a call the same master sequential interface several times (like @refHAL_I2C_Master_Seq_Transmit_IT() then @ref HAL_I2C_Master_Seq_Transmit_IT() or @refHAL_I2C_Master_Seq_Transmit_DMA() then @ref HAL_I2C_Master_Seq_Transmit_DMA())–I2C_NEXT_FRAME: Sequential usage, this option allow to manage a sequence with a restartcondition, address and with new data to transfer if the direction change or manage only the new data totransfer if no direction change and without a final stop condition in both cases–I2C_LAST_FRAME: Sequential usage, this option allow to manage a sequance with a restart condition,address and with new data to transfer if the direction change or manage only the new data to transfer ifno direction change and with a final stop condition in both cases–I2C_LAST_FRAME_NO_STOP: Sequential usage (Master only), this option allow to manage a restartcondition after several call of the same master sequential interface several times (link with optionI2C_FIRST_AND_NEXT_FRAME). Usage can, transfer several bytes one by one usingHAL_I2C_Master_Seq_Transmit_IT(option I2C_FIRST_AND_NEXT_FRAME thenI2C_NEXT_FRAME) or HAL_I2C_Master_Seq_Receive_IT(option I2C_FIRST_AND_NEXT_FRAMEthen I2C_NEXT_FRAME) or HAL_I2C_Master_Seq_Transmit_DMA(optionI2C_FIRST_AND_NEXT_FRAME then I2C_NEXT_FRAME) orHAL_I2C_Master_Seq_Receive_DMA(option I2C_FIRST_AND_NEXT_FRAME thenI2C_NEXT_FRAME). Then usage of this option I2C_LAST_FRAME_NO_STOP at the last Transmit orReceive sequence permit to call the oposite interface Receive or Transmit without stopping thecommunication and so generate a restart condition.–I2C_OTHER_FRAME: Sequential usage (Master only), this option allow to manage a restart conditionafter each call of the same master sequential interface. Usage can, transfer several bytes one by onewith a restart with slave address between each bytes using HAL_I2C_Master_Seq_Transmit_IT(optionI2C_FIRST_FRAME then I2C_OTHER_FRAME) or HAL_I2C_Master_Seq_Receive_IT(optionI2C_FIRST_FRAME then I2C_OTHER_FRAME) or HAL_I2C_Master_Seq_Transmit_DMA(optionI2C_FIRST_FRAME then I2C_OTHER_FRAME) or HAL_I2C_Master_Seq_Receive_DMA(optionI2C_FIRST_FRAME then I2C_OTHER_FRAME). Then usage of this optionI2C_OTHER_AND_LAST_FRAME at the last frame to help automatic generation of STOP condition.


• Differents sequential I2C interfaces are listed below:–Sequential transmit in master I2C mode an amount of data in non-blocking mode using @refHAL_I2C_Master_Seq_Transmit_IT() or using @ref HAL_I2C_Master_Seq_Transmit_DMA()◦At transmission end of current frame transfer, @ref HAL_I2C_MasterTxCpltCallback() is executedand user can add his own code by customization of function pointer @refHAL_I2C_MasterTxCpltCallback()–Sequential receive in master I2C mode an amount of data in non-blocking mode using @refHAL_I2C_Master_Seq_Receive_IT() or using @ref HAL_I2C_Master_Seq_Receive_DMA()◦At reception end of current frame transfer, @ref HAL_I2C_MasterRxCpltCallback() is executedand user can add his own code by customization of function pointer @refHAL_I2C_MasterRxCpltCallback()–Abort a master IT or DMA I2C process communication with Interrupt using @refHAL_I2C_Master_Abort_IT()◦End of abort process, @ref HAL_I2C_AbortCpltCallback() is executed and user can add his owncode by customization of function pointer @ref HAL_I2C_AbortCpltCallback()–Enable/disable the Address listen mode in slave I2C mode using @ref HAL_I2C_EnableListen_IT()@ref HAL_I2C_DisableListen_IT()◦When address slave I2C match, @ref HAL_I2C_AddrCallback() is executed and user can add hisown code to check the Address Match Code and the transmission direction request by master(Write/Read).◦At Listen mode end @ref HAL_I2C_ListenCpltCallback() is executed and user can add his owncode by customization of function pointer @ref HAL_I2C_ListenCpltCallback()–Sequential transmit in slave I2C mode an amount of data in non-blocking mode using @refHAL_I2C_Slave_Seq_Transmit_IT() or using @ref HAL_I2C_Slave_Seq_Transmit_DMA()◦At transmission end of current frame transfer, @ref HAL_I2C_SlaveTxCpltCallback() is executedand user can add his own code by customization of function pointer @refHAL_I2C_SlaveTxCpltCallback()–Sequential receive in slave I2C mode an amount of data in non-blocking mode using @refHAL_I2C_Slave_Seq_Receive_IT() or using @ref HAL_I2C_Slave_Seq_Receive_DMA()◦At reception end of current frame transfer, @ref HAL_I2C_SlaveRxCpltCallback() is executed anduser can add his own code by customization of function pointer @refHAL_I2C_SlaveRxCpltCallback()–In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can add his owncode by customization of function pointer @ref HAL_I2C_ErrorCallback()


• Write an amount of data in non-blocking mode with Interrupt to a specific memory address using @refHAL_I2C_Mem_Write_IT()
• At Memory end of write transfer, @ref HAL_I2C_MemTxCpltCallback() is executed and user can add hisown code by customization of function pointer @ref HAL_I2C_MemTxCpltCallback()
• Read an amount of data in non-blocking mode with Interrupt from a specific memory address using @refHAL_I2C_Mem_Read_IT()
• At Memory end of read transfer, @ref HAL_I2C_MemRxCpltCallback() is executed and user can add hisown code by customization of function pointer @ref HAL_I2C_MemRxCpltCallback()
• In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can add his owncode by customization of function pointer @ref HAL_I2C_ErrorCallback()


• Transmit in master mode an amount of data in non-blocking mode (DMA) using @refHAL_I2C_Master_Transmit_DMA()
• At transmission end of transfer, @ref HAL_I2C_MasterTxCpltCallback() is executed and user can add hisown code by customization of function pointer @ref HAL_I2C_MasterTxCpltCallback()
• Receive in master mode an amount of data in non-blocking mode (DMA) using @refHAL_I2C_Master_Receive_DMA()


• At reception end of transfer, @ref HAL_I2C_MasterRxCpltCallback() is executed and user can add his owncode by customization of function pointer @ref HAL_I2C_MasterRxCpltCallback()
• Transmit in slave mode an amount of data in non-blocking mode (DMA) using @refHAL_I2C_Slave_Transmit_DMA()
• At transmission end of transfer, @ref HAL_I2C_SlaveTxCpltCallback() is executed and user can add hisown code by customization of function pointer @ref HAL_I2C_SlaveTxCpltCallback()
• Receive in slave mode an amount of data in non-blocking mode (DMA) using @refHAL_I2C_Slave_Receive_DMA()
• At reception end of transfer, @ref HAL_I2C_SlaveRxCpltCallback() is executed and user can add his owncode by customization of function pointer @ref HAL_I2C_SlaveRxCpltCallback()
• In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can add his owncode by customization of function pointer @ref HAL_I2C_ErrorCallback()
• Abort a master I2C process communication with Interrupt using @ref HAL_I2C_Master_Abort_IT()
• End of abort process, @ref HAL_I2C_AbortCpltCallback() is executed and user can add his own code bycustomization of function pointer @ref HAL_I2C_AbortCpltCallback()


• Write an amount of data in non-blocking mode with DMA to a specific memory address using @refHAL_I2C_Mem_Write_DMA()
• At Memory end of write transfer, @ref HAL_I2C_MemTxCpltCallback() is executed and user can add hisown code by customization of function pointer @ref HAL_I2C_MemTxCpltCallback()
• Read an amount of data in non-blocking mode with DMA from a specific memory address using @refHAL_I2C_Mem_Read_DMA()
• At Memory end of read transfer, @ref HAL_I2C_MemRxCpltCallback() is executed and user can add hisown code by customization of function pointer @ref HAL_I2C_MemRxCpltCallback()
• In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can add his owncode by customization of function pointer @ref HAL_I2C_ErrorCallback()

The compilation flag USE_HAL_I2C_REGISTER_CALLBACKS when set to 1 allows the user to configuredynamically the driver callbacks. Use Functions @ref HAL_I2C_RegisterCallback() or @refHAL_I2C_RegisterAddrCallback() to register an interrupt callback.Function @ref HAL_I2C_RegisterCallback() allows to register following callbacks:
• MasterTxCpltCallback : callback for Master transmission end of transfer.
• MasterRxCpltCallback : callback for Master reception end of transfer.
• SlaveTxCpltCallback : callback for Slave transmission end of transfer.
• SlaveRxCpltCallback : callback for Slave reception end of transfer.
• ListenCpltCallback : callback for end of listen mode.
• MemTxCpltCallback : callback for Memory transmission end of transfer.
• MemRxCpltCallback : callback for Memory reception end of transfer.
• ErrorCallback : callback for error detection.
• AbortCpltCallback : callback for abort completion process.
• MspInitCallback : callback for Msp Init.

For specific callback AddrCallback use dedicated register callbacks : @ref HAL_I2C_RegisterAddrCallback().Use function @ref HAL_I2C_UnRegisterCallback to reset a callback to the default weak function. @refHAL_I2C_UnRegisterCallback takes as parameters the HAL peripheral handle, and the Callback ID. This functionallows to reset following callbacks:
• MasterTxCpltCallback : callback for Master transmission end of transfer.
• MasterRxCpltCallback : callback for Master reception end of transfer.
• SlaveTxCpltCallback : callback for Slave transmission end of transfer.
• SlaveRxCpltCallback : callback for Slave reception end of transfer.
• ListenCpltCallback : callback for end of listen mode.
• MemTxCpltCallback : callback for Memory transmission end of transfer.
• MemRxCpltCallback : callback for Memory reception end of transfer.
• ErrorCallback : callback for error detection.
• AbortCpltCallback : callback for abort completion process.
• MspInitCallback : callback for Msp Init.
• MspDeInitCallback : callback for Msp DeInit.

For callback AddrCallback use dedicated register callbacks : @ref HAL_I2C_UnRegisterAddrCallback().By default, after the @ref HAL_I2C_Init() and when the state is @ref HAL_I2C_STATE_RESET all callbacks areset to the corresponding weak functions: examples @ref HAL_I2C_MasterTxCpltCallback(), @refHAL_I2C_MasterRxCpltCallback(). Exception done for MspInit and MspDeInit functions that are reset to thelegacy weak functions in the @ref HAL_I2C_Init()/ @ref HAL_I2C_DeInit() only when these callbacks are null (notregistered beforehand). If MspInit or MspDeInit are not null, the @ref HAL_I2C_Init()/ @ref HAL_I2C_DeInit()keep and use the user MspInit/MspDeInit callbacks (registered beforehand) whatever the state.Callbacks can be registered/unregistered in @ref HAL_I2C_STATE_READY state only. Exception done MspInit/MspDeInit functions that can be registered/unregistered in @ref HAL_I2C_STATE_READY or @refHAL_I2C_STATE_RESET state, thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.Then, the user first registers the MspInit/MspDeInit user callbacks using @ref HAL_I2C_RegisterCallback() beforecalling @ref HAL_I2C_DeInit() or @ref HAL_I2C_Init() function.When the compilation flag USE_HAL_I2C_REGISTER_CALLBACKS is set to 0 or not defined, the callbackregistration feature is not available and all callbacks are set to the corresponding weak functions.

Note:See ErrataSheet to know full silicon limitation list of your product. (+) Workarounds Implemented inside I2C HALDriver (++) Wrong data read into data register (Polling and Interrupt mode) (++) Start cannot be generated aftera misplaced Stop (++) Some software events must be managed before the current byte is being transferred:Workaround: Use DMA in general, except when the Master is receiving a single byte. For Interupt mode, I2Cshould have the highest priority in the application. (++) Mismatch on the "Setup time for a repeated Startcondition" timing parameter: Workaround: Reduce the frequency down to 88 kHz or use the I2C Fast-mode ifsupported by the slave. (++) Data valid time (tVD;DAT) violated without the OVR flag being set: Workaround: Ifthe slave device allows it, use the clock stretching mechanism by programming NoStretchMode =I2C_NOSTRETCH_DISABLE in @ref HAL_I2C_Init.

This subsection provides a set of functions allowing to initialize and deinitialize the I2Cx peripheral:
• User must Implement HAL_I2C_MspInit() function in which he configures all related peripherals resources(CLOCK, GPIO, DMA, IT and NVIC).


• Call the function HAL_I2C_Init() to configure the selected device with the selected configuration:–Communication Speed–Duty cycle–Addressing mode–Own Address 1–Dual Addressing mode–Own Address 2–General call mode–Nostretch mode
• Call the function HAL_I2C_DeInit() to restore the default configuration of the selected I2Cx peripheral.


• hi2c: Pointer to a I2C_HandleTypeDef structure that contains the configuration information for the specifiedI2C.
• DevAddress: Target device address: The device 7 bits address value in datasheet must be shifted to theleft before calling the interface
• pData: Pointer to data buffer
• Size: Amount of data to be sent
• Timeout: Timeout duration


• hi2c: Pointer to a I2C_HandleTypeDef structure that contains the configuration information for the specifiedI2C.
• DevAddress: Target device address: The device 7 bits address value in datasheet must be shifted to theleft before calling the interface
• pData: Pointer to data buffer
• Size: Amount of data to be sent
• Timeout: Timeout duration


• hi2c: Pointer to a I2C_HandleTypeDef structure that contains the configuration information for the specifiedI2C.
• DevAddress: Target device address: The device 7 bits address value in datasheet must be shifted to theleft before calling the interface
• MemAddress: Internal memory address
• MemAddSize: Size of internal memory address
• pData: Pointer to data buffer
• Size: Amount of data to be sent
• Timeout: Timeout duration


• hi2c: Pointer to a I2C_HandleTypeDef structure that contains the configuration information for the specifiedI2C.
• DevAddress: Target device address: The device 7 bits address value in datasheet must be shifted to theleft before calling the interface
• MemAddress: Internal memory address
• MemAddSize: Size of internal memory address
• pData: Pointer to data buffer
• Size: Amount of data to be sent
• Timeout: Timeout duration


• hi2c: Pointer to a I2C_HandleTypeDef structure that contains the configuration information for the specifiedI2C.
• DevAddress: Target device address: The device 7 bits address value in datasheet must be shifted to theleft before calling the interface
• Trials: Number of trials
• Timeout: Timeout duration


• hi2c: Pointer to a I2C_HandleTypeDef structure that contains the configuration information for the specifiedI2C.
• DevAddress: Target device address: The device 7 bits address value in datasheet must be shifted to theleft before calling the interface
• pData: Pointer to data buffer
• Size: Amount of data to be sent


• hi2c: Pointer to a I2C_HandleTypeDef structure that contains the configuration information for the specifiedI2C.
• DevAddress: Target device address: The device 7 bits address value in datasheet must be shifted to theleft before calling the interface
• pData: Pointer to data buffer
• Size: Amount of data to be sent


• hi2c: Pointer to a I2C_HandleTypeDef structure that contains the configuration information for the specifiedI2C.
• DevAddress: Target device address: The device 7 bits address value in datasheet must be shifted to theleft before calling the interface
• MemAddress: Internal memory address
• MemAddSize: Size of internal memory address
• pData: Pointer to data buffer
• Size: Amount of data to be sent


• hi2c: Pointer to a I2C_HandleTypeDef structure that contains the configuration information for the specifiedI2C.
• DevAddress: Target device address
• MemAddress: Internal memory address
• MemAddSize: Size of internal memory address
• pData: Pointer to data buffer
• Size: Amount of data to be sent


• hi2c: Pointer to a I2C_HandleTypeDef structure that contains the configuration information for the specifiedI2C.
• DevAddress: Target device address: The device 7 bits address value in datasheet must be shifted to theleft before calling the interface
• pData: Pointer to data buffer
• Size: Amount of data to be sent
• XferOptions: Options of Transfer, value of I2C XferOptions definition


• hi2c: Pointer to a I2C_HandleTypeDef structure that contains the configuration information for the specifiedI2C.
• DevAddress: Target device address: The device 7 bits address value in datasheet must be shifted to theleft before calling the interface
• pData: Pointer to data buffer
• Size: Amount of data to be sent
• XferOptions: Options of Transfer, value of I2C XferOptions definition


• hi2c: Pointer to a I2C_HandleTypeDef structure that contains the configuration information for the specifiedI2C.
• pData: Pointer to data buffer
• Size: Amount of data to be sent
• XferOptions: Options of Transfer, value of I2C XferOptions definition


• hi2c: Pointer to a I2C_HandleTypeDef structure that contains the configuration information for the specifiedI2C.
• pData: Pointer to data buffer
• Size: Amount of data to be sent
• XferOptions: Options of Transfer, value of I2C XferOptions definition


• hi2c: Pointer to a I2C_HandleTypeDef structure that contains the configuration information for the specifiedI2C.
• DevAddress: Target device address: The device 7 bits address value in datasheet must be shifted to theleft before calling the interface


• hi2c: Pointer to a I2C_HandleTypeDef structure that contains the configuration information for the specifiedI2C.
• DevAddress: Target device address: The device 7 bits address value in datasheet must be shifted to theleft before calling the interface
• pData: Pointer to data buffer
• Size: Amount of data to be sent


• hi2c: Pointer to a I2C_HandleTypeDef structure that contains the configuration information for the specifiedI2C.
• DevAddress: Target device address: The device 7 bits address value in datasheet must be shifted to theleft before calling the interface
• pData: Pointer to data buffer
• Size: Amount of data to be sent


• hi2c: Pointer to a I2C_HandleTypeDef structure that contains the configuration information for the specifiedI2C.
• DevAddress: Target device address: The device 7 bits address value in datasheet must be shifted to theleft before calling the interface
• MemAddress: Internal memory address
• MemAddSize: Size of internal memory address
• pData: Pointer to data buffer
• Size: Amount of data to be sent


• hi2c: Pointer to a I2C_HandleTypeDef structure that contains the configuration information for the specifiedI2C.
• DevAddress: Target device address: The device 7 bits address value in datasheet must be shifted to theleft before calling the interface
• MemAddress: Internal memory address
• MemAddSize: Size of internal memory address
• pData: Pointer to data buffer
• Size: Amount of data to be read


• hi2c: Pointer to a I2C_HandleTypeDef structure that contains the configuration information for the specifiedI2C.
• DevAddress: Target device address: The device 7 bits address value in datasheet must be shifted to theleft before calling the interface
• pData: Pointer to data buffer
• Size: Amount of data to be sent
• XferOptions: Options of Transfer, value of I2C XferOptions definition


• hi2c: Pointer to a I2C_HandleTypeDef structure that contains the configuration information for the specifiedI2C.
• DevAddress: Target device address: The device 7 bits address value in datasheet must be shifted to theleft before calling the interface
• pData: Pointer to data buffer
• Size: Amount of data to be sent
• XferOptions: Options of Transfer, value of I2C XferOptions definition


• hi2c: Pointer to a I2C_HandleTypeDef structure that contains the configuration information for the specifiedI2C.
• pData: Pointer to data buffer
• Size: Amount of data to be sent
• XferOptions: Options of Transfer, value of I2C XferOptions definition


• hi2c: Pointer to a I2C_HandleTypeDef structure that contains the configuration information for the specifiedI2C.
• pData: Pointer to data buffer
• Size: Amount of data to be sent
• XferOptions: Options of Transfer, value of I2C XferOptions definition

Parameters:
• __HANDLE__: specifies the I2C Handle.
• __FLAG__: specifies the flag to clear. This parameter can be any combination of the following values:–I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)–I2C_FLAG_AF: Acknowledge failure flag–I2C_FLAG_ARLO: Arbitration lost flag (Master mode)–I2C_FLAG_BERR: Bus error flag

I2S_HandleTypeDef is defined in the stm32f1xx_hal_i2s.hData Fields
• SPI_TypeDef * Instance
• I2S_InitTypeDef Init
• uint16_t * pTxBuffPtr
• __IO uint16_t TxXferSize
• __IO uint16_t TxXferCount
• uint16_t * pRxBuffPtr
• __IO uint16_t RxXferSize
• __IO uint16_t RxXferCount
• DMA_HandleTypeDef * hdmatx
• DMA_HandleTypeDef * hdmarx
• __IO HAL_LockTypeDef Lock
• __IO HAL_I2S_StateTypeDef State
• __IO uint32_t ErrorCode


• SPI_TypeDef* I2S_HandleTypeDef::InstanceI2S registers base address
• I2S_InitTypeDef I2S_HandleTypeDef::InitI2S communication parameters
• uint16_t* I2S_HandleTypeDef::pTxBuffPtrPointer to I2S Tx transfer buffer
• __IO uint16_t I2S_HandleTypeDef::TxXferSizeI2S Tx transfer size
• __IO uint16_t I2S_HandleTypeDef::TxXferCountI2S Tx transfer Counter
• uint16_t* I2S_HandleTypeDef::pRxBuffPtrPointer to I2S Rx transfer buffer
• __IO uint16_t I2S_HandleTypeDef::RxXferSizeI2S Rx transfer size
• __IO uint16_t I2S_HandleTypeDef::RxXferCountI2S Rx transfer counter (This field is initialized at the same value as transfer size at the beginning of thetransfer and decremented when a sample is received NbSamplesReceived = RxBufferSize-RxBufferCount)
• DMA_HandleTypeDef* I2S_HandleTypeDef::hdmatxI2S Tx DMA handle parameters
• DMA_HandleTypeDef* I2S_HandleTypeDef::hdmarxI2S Rx DMA handle parameters
• __IO HAL_LockTypeDef I2S_HandleTypeDef::LockI2S locking object
• __IO HAL_I2S_StateTypeDef I2S_HandleTypeDef::StateI2S communication state
• __IO uint32_t I2S_HandleTypeDef::ErrorCodeI2S Error code This parameter can be a value of I2S_Error

Note:The I2SxCLK source is the system clock (provided by the HSI, the HSE or the PLL, and sourcing the AHBclock). For connectivity line devices, the I2SxCLK source can be either SYSCLK or the PLL3 VCO (2 xPLL3CLK) clock in order to achieve the maximum accuracy.


• Send an amount of data in non blocking mode using HAL_I2S_Transmit_IT()
• At transmission end of half transfer HAL_I2S_TxHalfCpltCallback is executed and user can add his owncode by customization of function pointer HAL_I2S_TxHalfCpltCallback
• At transmission end of transfer HAL_I2S_TxCpltCallback is executed and user can add his own code bycustomization of function pointer HAL_I2S_TxCpltCallback
• Receive an amount of data in non blocking mode using HAL_I2S_Receive_IT()
• At reception end of half transfer HAL_I2S_RxHalfCpltCallback is executed and user can add his own codeby customization of function pointer HAL_I2S_RxHalfCpltCallback
• At reception end of transfer HAL_I2S_RxCpltCallback is executed and user can add his own code bycustomization of function pointer HAL_I2S_RxCpltCallback
• In case of transfer Error, HAL_I2S_ErrorCallback() function is executed and user can add his own code bycustomization of function pointer HAL_I2S_ErrorCallback


• At transmission end of half transfer HAL_I2S_TxHalfCpltCallback is executed and user can add his owncode by customization of function pointer HAL_I2S_TxHalfCpltCallback
• At transmission end of transfer HAL_I2S_TxCpltCallback is executed and user can add his own code bycustomization of function pointer HAL_I2S_TxCpltCallback
• Receive an amount of data in non blocking mode (DMA) using HAL_I2S_Receive_DMA()
• At reception end of half transfer HAL_I2S_RxHalfCpltCallback is executed and user can add his own codeby customization of function pointer HAL_I2S_RxHalfCpltCallback
• At reception end of transfer HAL_I2S_RxCpltCallback is executed and user can add his own code bycustomization of function pointer HAL_I2S_RxCpltCallback
• In case of transfer Error, HAL_I2S_ErrorCallback() function is executed and user can add his own code bycustomization of function pointer HAL_I2S_ErrorCallback
• Pause the DMA Transfer using HAL_I2S_DMAPause()
• Resume the DMA Transfer using HAL_I2S_DMAResume()
• Stop the DMA Transfer using HAL_I2S_DMAStop()

By default, after the HAL_I2S_Init() and when the state is HAL_I2S_STATE_RESET all callbacks are set to thecorresponding weak functions: examples HAL_I2S_MasterTxCpltCallback(), HAL_I2S_MasterRxCpltCallback().Exception done for MspInit and MspDeInit functions that are reset to the legacy weak functions in theHAL_I2S_Init()/ HAL_I2S_DeInit() only when these callbacks are null (not registered beforehand). If MspInit orMspDeInit are not null, the HAL_I2S_Init()/ HAL_I2S_DeInit() keep and use the user MspInit/MspDeInit callbacks(registered beforehand) whatever the state.Callbacks can be registered/unregistered in HAL_I2S_STATE_READY state only. Exception done MspInit/MspDeInit functions that can be registered/unregistered in HAL_I2S_STATE_READY orHAL_I2S_STATE_RESET state, thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.Then, the user first registers the MspInit/MspDeInit user callbacks using HAL_I2S_RegisterCallback() beforecalling HAL_I2S_DeInit() or HAL_I2S_Init() function.When the compilation define USE_HAL_I2S_REGISTER_CALLBACKS is set to 0 or not defined, the callbackregistering feature is not available and weak (surcharged) callbacks are used.

This subsection provides a set of functions allowing to initialize and de-initialize the I2Sx peripheral in simplexmode:
• User must Implement HAL_I2S_MspInit() function in which he configures all related peripherals resources(CLOCK, GPIO, DMA, IT and NVIC ).
• Call the function HAL_I2S_Init() to configure the selected device with the selected configuration:–Mode–Standard–Data Format–MCLK Output–Audio frequency–Polarity
• Call the function HAL_I2S_DeInit() to restore the default configuration of the selected I2Sx peripheral.


• When a 16-bit data frame or a 16-bit data frame extended is selected during the I2S configuration phase,the Size parameter means the number of 16-bit data length in the transaction and when a 24-bit data frameor a 32-bit data frame is selected the Size parameter means the number of 16-bit data length.
• The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization between Masterand Slave(example: audio streaming).


• When a 16-bit data frame or a 16-bit data frame extended is selected during the I2S configuration phase,the Size parameter means the number of 16-bit data length in the transaction and when a 24-bit data frameor a 32-bit data frame is selected the Size parameter means the number of 16-bit data length.
• The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization between Masterand Slave(example: audio streaming).
• In I2S Master Receiver mode, just after enabling the peripheral the clock will be generate in continuousway and as the I2S is not disabled at the end of the I2S transaction.


• When a 16-bit data frame or a 16-bit data frame extended is selected during the I2S configuration phase,the Size parameter means the number of 16-bit data length in the transaction and when a 24-bit data frameor a 32-bit data frame is selected the Size parameter means the number of 16-bit data length.
• The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization between Masterand Slave(example: audio streaming).


• When a 16-bit data frame or a 16-bit data frame extended is selected during the I2S configuration phase,the Size parameter means the number of 16-bit data length in the transaction and when a 24-bit data frameor a 32-bit data frame is selected the Size parameter means the number of 16-bit data length.
• The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization between Masterand Slave(example: audio streaming).
• It is recommended to use DMA for the I2S receiver to avoid de-synchronization between Master and Slaveotherwise the I2S interrupt should be optimized.


• When a 16-bit data frame or a 16-bit data frame extended is selected during the I2S configuration phase,the Size parameter means the number of 16-bit data length in the transaction and when a 24-bit data frameor a 32-bit data frame is selected the Size parameter means the number of 16-bit data length.
• The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization between Masterand Slave(example: audio streaming).


• When a 16-bit data frame or a 16-bit data frame extended is selected during the I2S configuration phase,the Size parameter means the number of 16-bit data length in the transaction and when a 24-bit data frameor a 32-bit data frame is selected the Size parameter means the number of 16-bit data length.
• The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization between Masterand Slave(example: audio streaming).

Parameters:
• __HANDLE__: specifies the I2S Handle.
• __INTERRUPT__: specifies the interrupt source to enable or disable. This parameter can be one of thefollowing values:–I2S_IT_TXE: Tx buffer empty interrupt enable–I2S_IT_RXNE: RX buffer not empty interrupt enable–I2S_IT_ERR: Error interrupt enable

Parameters:
• __HANDLE__: specifies the I2S Handle.
• __INTERRUPT__: specifies the interrupt source to enable or disable. This parameter can be one of thefollowing values:–I2S_IT_TXE: Tx buffer empty interrupt enable–I2S_IT_RXNE: RX buffer not empty interrupt enable–I2S_IT_ERR: Error interrupt enable

Parameters:
• __HANDLE__: specifies the I2S Handle. This parameter can be I2S where x: 1, 2, or 3 to select the I2Speripheral.
• __INTERRUPT__: specifies the I2S interrupt source to check. This parameter can be one of the followingvalues:–I2S_IT_TXE: Tx buffer empty interrupt enable–I2S_IT_RXNE: RX buffer not empty interrupt enable–I2S_IT_ERR: Error interrupt enable

Field Documentation
• uint32_t IRDA_InitTypeDef::BaudRateThis member configures the IRDA communication baud rate. The baud rate is computed using the followingformula:–IntegerDivider = ((PCLKx) / (16 * (hirda->Init.BaudRate)))–FractionalDivider = ((IntegerDivider - ((uint32_t) IntegerDivider)) * 16) + 0.5
• uint32_t IRDA_InitTypeDef::WordLengthSpecifies the number of data bits transmitted or received in a frame. This parameter can be a value ofIRDA_Word_Length


• uint32_t IRDA_InitTypeDef::ParitySpecifies the parity mode. This parameter can be a value of IRDA_ParityNote:–When parity is enabled, the computed parity is inserted at the MSB position of the transmitted data (9thbit when the word length is set to 9 data bits; 8th bit when the word length is set to 8 data bits).
• uint32_t IRDA_InitTypeDef::ModeSpecifies whether the Receive or Transmit mode is enabled or disabled. This parameter can be a value ofIRDA_Mode


• uint8_t IRDA_InitTypeDef::PrescalerSpecifies the Prescaler value to be programmed in the IrDA low-power Baud Register, for defining pulsewidth on which burst acceptance/rejection will be decided. This value is used as divisor of system clock toachieve required pulse width.
• uint32_t IRDA_InitTypeDef::IrDAModeSpecifies the IrDA mode This parameter can be a value of IRDA_Low_Power


• Send an amount of data in non blocking mode using HAL_IRDA_Transmit_IT()
• At transmission end of transfer HAL_IRDA_TxCpltCallback is executed and user can add his own code bycustomization of function pointer HAL_IRDA_TxCpltCallback
• Receive an amount of data in non blocking mode using HAL_IRDA_Receive_IT()
• At reception end of transfer HAL_IRDA_RxCpltCallback is executed and user can add his own code bycustomization of function pointer HAL_IRDA_RxCpltCallback
• In case of transfer Error, HAL_IRDA_ErrorCallback() function is executed and user can add his own code bycustomization of function pointer HAL_IRDA_ErrorCallback


• Send an amount of data in non blocking mode (DMA) using HAL_IRDA_Transmit_DMA()
• At transmission end of half transfer HAL_IRDA_TxHalfCpltCallback is executed and user can add his owncode by customization of function pointer HAL_IRDA_TxHalfCpltCallback
• At transmission end of transfer HAL_IRDA_TxCpltCallback is executed and user can add his own code bycustomization of function pointer HAL_IRDA_TxCpltCallback
• Receive an amount of data in non blocking mode (DMA) using HAL_IRDA_Receive_DMA()


• At reception end of half transfer HAL_IRDA_RxHalfCpltCallback is executed and user can add his own codeby customization of function pointer HAL_IRDA_RxHalfCpltCallback
• At reception end of transfer HAL_IRDA_RxCpltCallback is executed and user can add his own code bycustomization of function pointer HAL_IRDA_RxCpltCallback
• In case of transfer Error, HAL_IRDA_ErrorCallback() function is executed and user can add his own code bycustomization of function pointer HAL_IRDA_ErrorCallback
• Pause the DMA Transfer using HAL_IRDA_DMAPause()
• Resume the DMA Transfer using HAL_IRDA_DMAResume()
• Stop the DMA Transfer using HAL_IRDA_DMAStop()

The compilation define USE_HAL_IRDA_REGISTER_CALLBACKS when set to 1 allows the user to configuredynamically the driver callbacks.Use Function @ref HAL_IRDA_RegisterCallback() to register a user callback. Function @refHAL_IRDA_RegisterCallback() allows to register following callbacks:
• TxHalfCpltCallback : Tx Half Complete Callback.
• TxCpltCallback : Tx Complete Callback.
• RxHalfCpltCallback : Rx Half Complete Callback.
• RxCpltCallback : Rx Complete Callback.
• ErrorCallback : Error Callback.
• AbortCpltCallback : Abort Complete Callback.
• AbortTransmitCpltCallback : Abort Transmit Complete Callback.
• AbortReceiveCpltCallback : Abort Receive Complete Callback.
• MspInitCallback : IRDA MspInit.
• MspDeInitCallback : IRDA MspDeInit. This function takes as parameters the HAL peripheral handle, theCallback ID and a pointer to the user callback function.

Use function @ref HAL_IRDA_UnRegisterCallback() to reset a callback to the default weak (surcharged) function.@ref HAL_IRDA_UnRegisterCallback() takes as parameters the HAL peripheral handle, and the Callback ID. Thisfunction allows to reset following callbacks:
• TxHalfCpltCallback : Tx Half Complete Callback.
• TxCpltCallback : Tx Complete Callback.
• RxHalfCpltCallback : Rx Half Complete Callback.
• RxCpltCallback : Rx Complete Callback.
• ErrorCallback : Error Callback.
• AbortCpltCallback : Abort Complete Callback.
• AbortTransmitCpltCallback : Abort Transmit Complete Callback.
• AbortReceiveCpltCallback : Abort Receive Complete Callback.
• MspInitCallback : IRDA MspInit.
• MspDeInitCallback : IRDA MspDeInit.

By default, after the @ref HAL_IRDA_Init() and when the state is HAL_IRDA_STATE_RESET all callbacks are setto the corresponding weak (surcharged) functions: examples @ref HAL_IRDA_TxCpltCallback(), @refHAL_IRDA_RxHalfCpltCallback(). Exception done for MspInit and MspDeInit functions that are respectively resetto the legacy weak (surcharged) functions in the @ref HAL_IRDA_Init() and @ref HAL_IRDA_DeInit() only whenthese callbacks are null (not registered beforehand). If not, MspInit or MspDeInit are not null, the @refHAL_IRDA_Init() and @ref HAL_IRDA_DeInit() keep and use the user MspInit/MspDeInit callbacks (registeredbeforehand).Callbacks can be registered/unregistered in HAL_IRDA_STATE_READY state only. Exception done MspInit/MspDeInit that can be registered/unregistered in HAL_IRDA_STATE_READY or HAL_IRDA_STATE_RESETstate, thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit. In that case first registerthe MspInit/MspDeInit user callbacks using @ref HAL_IRDA_RegisterCallback() before calling @refHAL_IRDA_DeInit() or @ref HAL_IRDA_Init() function.When The compilation define USE_HAL_IRDA_REGISTER_CALLBACKS is set to 0 or not defined, the callbackregistration feature is not available and weak (surcharged) callbacks are used.

This subsection provides a set of functions allowing to initialize the USARTx or the UARTy in asynchronous IrDAmode.
• For the asynchronous mode only these parameters can be configured:–BaudRate–WordLength–Parity: If the parity is enabled, then the MSB bit of the data written in the data register is transmitted butis changed by the parity bit. Depending on the frame length defined by the M bit (8-bits or 9-bits),please refer to Reference manual for possible IRDA frame formats.–Prescaler: A pulse of width less than two and greater than one PSC period(s) may or may not berejected. The receiver set up time should be managed by software. The IrDA physical layerspecification specifies a minimum of 10 ms delay between transmission and reception (IrDA is a halfduplex protocol).–Mode: Receiver/transmitter modes–IrDAMode: the IrDA can operate in the Normal mode or in the Low power mode.

This subsection provides a set of functions allowing to manage the IRDA data transfers. IrDA is a half duplexcommunication protocol. If the Transmitter is busy, any data on the IrDA receive line will be ignored by the IrDAdecoder and if the Receiver is busy, data on the TX from the USART to IrDA will not be encoded by IrDA. Whilereceiving data, transmission should be avoided as the data to be transmitted could be corrupted.

This subsection provides a set of functions allowing to manage the IRDA data transfers. IrDA is a half duplexcommunication protocol. If the Transmitter is busy, any data on the IrDA receive line will be ignored by the IrDAdecoder and if the Receiver is busy, data on the TX from the USART to IrDA will not be encoded by IrDA. Whilereceiving data, transmission should be avoided as the data to be transmitted could be corrupted. (#) There aretwo modes of transfer: (++) Blocking mode: The communication is performed in polling mode. The HAL status ofall data processing is returned by the same function after finishing transfer. (++) Non-Blocking mode: Thecommunication is performed using Interrupts or DMA, these API's return the HAL status. The end of the dataprocessing will be indicated through the dedicated IRDA IRQ when using Interrupt mode or the DMA IRQ whenusing DMA mode. The HAL_IRDA_TxCpltCallback(), HAL_IRDA_RxCpltCallback() user callbacks will beexecuted respectively at the end of the Transmit or Receive process The HAL_IRDA_ErrorCallback() usercallback will be executed when a communication error is detected (#) Blocking mode APIs are : (++)HAL_IRDA_Transmit() (++) HAL_IRDA_Receive() (#) Non Blocking mode APIs with Interrupt are : (++)HAL_IRDA_Transmit_IT() (++) HAL_IRDA_Receive_IT() (++) HAL_IRDA_IRQHandler() (#) Non Blocking modefunctions with DMA are : (++) HAL_IRDA_Transmit_DMA() (++) HAL_IRDA_Receive_DMA() (++)HAL_IRDA_DMAPause() (++) HAL_IRDA_DMAResume() (++) HAL_IRDA_DMAStop() (#) A set of TransferComplete Callbacks are provided in Non Blocking mode: (++) HAL_IRDA_TxHalfCpltCallback() (++)HAL_IRDA_TxCpltCallback() (++) HAL_IRDA_RxHalfCpltCallback() (++) HAL_IRDA_RxCpltCallback() (++)HAL_IRDA_ErrorCallback() (#) Non-Blocking mode transfers could be aborted using Abort API's :
• HAL_IRDA_Abort()
• HAL_IRDA_AbortTransmit()
• HAL_IRDA_AbortReceive()
• HAL_IRDA_Abort_IT()
• HAL_IRDA_AbortTransmit_IT()
• HAL_IRDA_AbortReceive_IT() (#) For Abort services based on interrupts (HAL_IRDA_Abortxxx_IT), a set ofAbort Complete Callbacks are provided:
• HAL_IRDA_AbortCpltCallback()
• HAL_IRDA_AbortTransmitCpltCallback()
• HAL_IRDA_AbortReceiveCpltCallback() (#) In Non-Blocking mode transfers, possible errors are split into 2categories. Errors are handled as follows :
• Error is considered as Recoverable and non blocking : Transfer could go till end, but error severity is to beevaluated by user : this concerns Frame Error, Parity Error or Noise Error in Interrupt mode reception .Received character is then retrieved and stored in Rx buffer, Error code is set to allow user to identify errortype, and HAL_IRDA_ErrorCallback() user callback is executed. Transfer is kept ongoing on IRDA side. Ifuser wants to abort it, Abort services should be called by user.
• Error is considered as Blocking : Transfer could not be completed properly and is aborted. This concernsOverrun Error In Interrupt mode reception and all errors in DMA mode. Error code is set to allow user toidentify error type, and HAL_IRDA_ErrorCallback() user callback is executed.

This subsection provides a set of functions allowing to return the State of IrDA communication process and alsoreturn Peripheral Errors occurred during communication process
• HAL_IRDA_GetState() API can be helpful to check in run-time the state of the IrDA peripheral.
• HAL_IRDA_GetError() check in run-time errors that could be occurred during communication.


• hirda: Pointer to a IRDA_HandleTypeDef structure that contains the configuration information for thespecified IRDA module.
• pData: Pointer to data buffer (u8 or u16 data elements).
• Size: Amount of data elements (u8 or u16) to be sent.
• Timeout: Specify timeout value.


• When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01), thesent data is handled as a set of u16. In this case, Size must reflect the number of u16 available throughpData.


• hirda: Pointer to a IRDA_HandleTypeDef structure that contains the configuration information for thespecified IRDA module.
• pData: Pointer to data buffer (u8 or u16 data elements).
• Size: Amount of data elements (u8 or u16) to be received.
• Timeout: Specify timeout value


• When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01), thereceived data is handled as a set of u16. In this case, Size must reflect the number of u16 availablethrough pData.


• hirda: Pointer to a IRDA_HandleTypeDef structure that contains the configuration information for thespecified IRDA module.
• pData: Pointer to data buffer (u8 or u16 data elements).
• Size: Amount of data elements (u8 or u16) to be sent.


• When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01), thesent data is handled as a set of u16. In this case, Size must reflect the number of u16 available throughpData.


• hirda: Pointer to a IRDA_HandleTypeDef structure that contains the configuration information for thespecified IRDA module.
• pData: Pointer to data buffer (u8 or u16 data elements).
• Size: Amount of data elements (u8 or u16) to be received.


• When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01), thereceived data is handled as a set of u16. In this case, Size must reflect the number of u16 availablethrough pData.


• hirda: Pointer to a IRDA_HandleTypeDef structure that contains the configuration information for thespecified IRDA module.
• pData: Pointer to data buffer (u8 or u16 data elements).
• Size: Amount of data elements (u8 or u16) to be sent.


• When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01), thesent data is handled as a set of u16. In this case, Size must reflect the number of u16 available throughpData.


• hirda: Pointer to a IRDA_HandleTypeDef structure that contains the configuration information for thespecified IRDA module.
• pData: Pointer to data buffer (u8 or u16 data elements).
• Size: Amount of data elements (u8 or u16) to be received.


• When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01), thereceived data is handled as a set of u16. In this case, Size must reflect the number of u16 availablethrough pData.
• When the IRDA parity is enabled (PCE = 1) the data received contain the parity bit.


• This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode. Thisprocedure performs following operations : Disable PPP InterruptsDisable the DMA transfer in the peripheralregister (if enabled)Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)Sethandle State to READY
• This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.


• This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode. Thisprocedure performs following operations : Disable PPP InterruptsDisable the DMA transfer in the peripheralregister (if enabled)Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)Sethandle State to READY
• This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.


• This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode. Thisprocedure performs following operations : Disable PPP InterruptsDisable the DMA transfer in the peripheralregister (if enabled)Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)Sethandle State to READY
• This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.


• This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode. Thisprocedure performs following operations : Disable PPP InterruptsDisable the DMA transfer in the peripheralregister (if enabled)Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMAmode)Set handle State to READYAt abort completion, call user abort complete callback
• This procedure is executed in Interrupt mode, meaning that abort procedure could be considered ascompleted only when user abort complete callback is executed (not when exiting function).


• This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode. Thisprocedure performs following operations : Disable IRDA Interrupts (Tx)Disable the DMA transfer in theperipheral register (if enabled)Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer inDMA mode)Set handle State to READYAt abort completion, call user abort complete callback
• This procedure is executed in Interrupt mode, meaning that abort procedure could be considered ascompleted only when user abort complete callback is executed (not when exiting function).


• This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode. Thisprocedure performs following operations : Disable PPP InterruptsDisable the DMA transfer in the peripheralregister (if enabled)Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMAmode)Set handle State to READYAt abort completion, call user abort complete callback
• This procedure is executed in Interrupt mode, meaning that abort procedure could be considered ascompleted only when user abort complete callback is executed (not when exiting function).

Parameters:
• __HANDLE__: specifies the IRDA Handle. IRDA Handle selects the USARTx or UARTy peripheral(USART,UART availability and x,y values depending on device).
• __FLAG__: specifies the flag to check. This parameter can be any combination of the following values:–IRDA_FLAG_TC: Transmission Complete flag.–IRDA_FLAG_RXNE: Receive data register not empty flag.

Notes:
• PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun error) and IDLE (Idle line detected)flags are cleared by software sequence: a read operation to USART_SR register followed by a readoperation to USART_DR register. RXNE flag can be also cleared by a read to the USART_DR register. TCflag can be also cleared by software sequence: a read operation to USART_SR register followed by a writeoperation to USART_DR register. TXE flag is cleared only by a write to the USART_DR register.

Parameters:
• __HANDLE__: specifies the IRDA Handle. IRDA Handle selects the USARTx or UARTy peripheral(USART,UART availability and x,y values depending on device).
• __INTERRUPT__: specifies the IRDA interrupt source to enable. This parameter can be one of thefollowing values:–IRDA_IT_TXE: Transmit Data Register empty interrupt–IRDA_IT_TC: Transmission complete interrupt–IRDA_IT_RXNE: Receive Data register not empty interrupt–IRDA_IT_IDLE: Idle line detection interrupt–IRDA_IT_PE: Parity Error interrupt–IRDA_IT_ERR: Error interrupt(Frame error, noise error, overrun error)

Parameters:
• __HANDLE__: specifies the IRDA Handle. IRDA Handle selects the USARTx or UARTy peripheral(USART,UART availability and x,y values depending on device).
• __INTERRUPT__: specifies the IRDA interrupt source to disable. This parameter can be one of thefollowing values:–IRDA_IT_TXE: Transmit Data Register empty interrupt–IRDA_IT_TC: Transmission complete interrupt–IRDA_IT_RXNE: Receive Data register not empty interrupt–IRDA_IT_IDLE: Idle line detection interrupt–IRDA_IT_PE: Parity Error interrupt–IRDA_IT_ERR: Error interrupt(Frame error, noise error, overrun error)

Parameters:
• __HANDLE__: specifies the IRDA Handle. IRDA Handle selects the USARTx or UARTy peripheral(USART,UART availability and x,y values depending on device).
• __IT__: specifies the IRDA interrupt source to check. This parameter can be one of the following values:–IRDA_IT_TXE: Transmit Data Register empty interrupt–IRDA_IT_TC: Transmission complete interrupt–IRDA_IT_RXNE: Receive Data register not empty interrupt–IRDA_IT_IDLE: Idle line detection interrupt–IRDA_IT_ERR: Error interrupt–IRDA_IT_PE: Parity Error interrupt


• The IWDG can be started by either software or hardware (configurable through option byte).
• The IWDG is clocked by Low-Speed clock (LSI) and thus stays active even if the main clock fails.
• Once the IWDG is started, the LSI is forced ON and both can not be disabled. The counter starts countingdown from the reset value (0xFFF). When it reaches the end of count value (0x000) a reset signal isgenerated (IWDG reset).
• Whenever the key value 0x0000 AAAA is written in the IWDG_KR register, the IWDG_RLR value is reloadedin the counter and the watchdog reset is prevented.
• The IWDG is implemented in the VDD voltage domain that is still functional in STOP and STANDBY mode(IWDG reset can wake-up from STANDBY). IWDGRST flag in RCC_CSR register can be used to informwhen an IWDG reset occurs.
• Debug mode : When the microcontroller enters debug mode (core halted), the IWDG counter eithercontinues to work normally or stops, depending on DBG_IWDG_STOP configuration bit in DBG module,accessible through __HAL_DBGMCU_FREEZE_IWDG() and __HAL_DBGMCU_UNFREEZE_IWDG()macros

Min-max timeout value @32KHz (LSI): ~125us / ~32.7s The IWDG timeout may vary due to LSI frequencydispersion. STM32F1xx devices provide the capability to measure the LSI frequency (LSI clock connectedinternally to TIM5 CH4 input capture). The measured value can be used to have an IWDG timeout with anacceptable accuracy.

This section provides functions allowing to:
• Initialize the IWDG according to the specified parameters in the IWDG_InitTypeDef of associated handle.
• Once initialization is performed in HAL_IWDG_Init function, Watchdog is reloaded in order to exit functionwith correct time base.

After reset, the backup domain (RTC registers, RTC backup data registers) is protected against possibleunwanted write accesses. To enable access to the RTC Domain and RTC registers, proceed as follows:
• Enable the Power Controller (PWR) APB1 interface clock using the __HAL_RCC_PWR_CLK_ENABLE()macro.
• Enable access to RTC domain using the HAL_PWR_EnableBkUpAccess() function.


• The PVD is used to monitor the VDD power supply by comparing it to a threshold selected by the PVD Level(PLS[2:0] bits in the PWR_CR).
• A PVDO flag is available to indicate if VDD/VDDA is higher or lower than the PVD threshold. This event isinternally connected to the EXTI line16 and can generate an interrupt if enabled. This is done through__HAL_PVD_EXTI_ENABLE_IT() macro.
• The PVD is stopped in Standby mode.

The Standby mode allows to achieve the lowest power consumption. It is based on the Cortex-M3 deepsleepmode, with the voltage regulator disabled. The 1.8 V domain is consequently powered off. The PLL, the HSIoscillator and the HSE oscillator are also switched off. SRAM and register contents are lost except for registers inthe Backup domain and Standby circuitry
• Entry:–The Standby mode is entered using the HAL_PWR_EnterSTANDBYMode() function.
• Exit:–WKUP pin rising edge, RTC alarm event rising edge, external Reset in NRSTpin, IWDG Reset


• The MCU can be woken up from low-power mode by an RTC Alarm event, without depending on an externalinterrupt (Auto-wakeup mode).
• RTC auto-wakeup (AWU) from the Stop and Standby modes–To wake up from the Stop mode with an RTC alarm event, it is necessary to configure the RTC togenerate the RTC alarm using the HAL_RTC_SetAlarm_IT() function.


• In Stop mode, all I/O pins keep the same state as in Run mode.
• When exiting Stop mode by using an interrupt or a wakeup event, HSI RC oscillator is selected as systemclock.
• When the voltage regulator operates in low power mode, an additional startup delay is incurred whenwaking up from Stop mode. By keeping the internal regulator ON during Stop mode, the consumption ishigher although the startup time is reduced.


• Regulator: Regulator state as no effect in SLEEP mode - allows to support portability from legacy software
• SLEEPEntry: Specifies if SLEEP mode is entered with WFI or WFE instruction. When WFI entry is used,tick interrupt have to be disabled if not desired as the interrupt wake up source. This parameter can be oneof the following values:–PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction–PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction


• Set SLEEPONEXIT bit of SCR register. When this bit is set, the processor re-enters SLEEP mode when aninterruption handling is over. Setting this bit is useful when the processor is expected to run only oninterruptions handling.

Parameters:
• __FLAG__: specifies the flag to check. This parameter can be one of the following values:–PWR_FLAG_WU: Wake Up flag. This flag indicates that a wakeup event was received from theWKUP pin or from the RTC alarm An additional wakeup event is detected if the WKUP pin is enabled(by setting the EWUP bit) when the WKUP pin level is already high.–PWR_FLAG_SB: StandBy flag. This flag indicates that the system was resumed from StandBy mode.–PWR_FLAG_PVDO: PVD Output. This flag is valid only if PVD is enabled by theHAL_PWR_EnablePVD() function. The PVD is stopped by Standby mode For this reason, this bit isequal to 0 after Standby or reset until the PVDE bit is set.

After reset the device is running from Internal High Speed oscillator (HSI 8MHz) with Flash 0 wait state, Flashprefetch buffer is enabled, and all peripherals are off except internal SRAM, Flash and JTAG.
• There is no prescaler on High speed (AHB) and Low speed (APB) buses; all peripherals mapped on thesebuses are running at HSI speed.
• The clock for all peripherals is switched off, except the SRAM and FLASH.
• All GPIOs are in input floating state, except the JTAG pins which are assigned to be used for debugpurpose.

Once the device started from reset, the user application has to:
• Configure the clock source to be used to drive the System clock (if the application needs higher frequency/performance)
• Configure the System clock frequency and Flash settings
• Configure the AHB and APB buses prescalers
• Enable the clock for the peripheral(s) to be used
• Configure the clock source(s) for peripherals whose clocks are not derived from the System clock (I2S, RTC,ADC, USB OTG FS)

A delay between an RCC peripheral clock enable and the effective peripheral enabling should be taken intoaccount in order to manage the peripheral read/write from/to registers.
• This delay depends on the peripheral mapping.–AHB & APB peripherals, 1 dummy read is necessary


• The default reset state of the clock configuration is given below: HSI ON and used as system clocksourceHSE, PLL, PLL2 and PLL3 are OFFAHB, APB1 and APB2 prescaler set to 1.CSS and MCO1 OFFAllinterrupts disabledAll flags are cleared
• This function does not modify the configuration of the Peripheral clocksLSI, LSE and RTC clocks


• The PLL is not disabled when used as system clock.
• The PLL is not disabled when USB OTG FS clock is enabled (specific to devices with USB FS)
• Transitions LSE Bypass to LSE On and LSE On to LSE Bypass are not supported by this macro. Usershould request a transition to LSE Off first and then LSE On or LSE Bypass.
• Transition HSE Bypass to HSE On and HSE On to HSE Bypass are not supported by this macro. Usershould request a transition to HSE Off first and then HSE On or HSE Bypass.


• The SystemCoreClock CMSIS variable is used to store System Clock Frequency and updated byHAL_RCC_GetHCLKFreq() function called within this function
• The HSI is used (enabled by hardware) as system clock source after start-up from Reset, wake-up fromSTOP and STANDBY mode, or in case of failure of the HSE used directly or indirectly as system clock (ifthe Clock Security System CSS is enabled).
• A switch from one clock source to another occurs only if the target clock source is ready (clock stable afterstart-up delay or PLL locked). If a clock source which is not yet ready is selected, the switch will occurwhen the clock source will be ready. You can use HAL_RCC_GetClockConfig() function to know whichclock is currently used as system clock source.


• If a failure is detected on the HSE oscillator clock, this oscillator is automatically disabled and an interrupt isgenerated to inform the software about the failure (Clock Security System Interrupt, CSSI), allowing theMCU to perform rescue operations. The CSSI is linked to the Cortex-M3 NMI (Non-Maskable Interrupt)exception vector.


• The system frequency computed by this function is not the real frequency in the chip. It is calculated basedon the predefined constant and the selected clock source:
• If SYSCLK source is HSI, function returns values based on HSI_VALUE(*)
• If SYSCLK source is HSE, function returns a value based on HSE_VALUE divided by PREDIV factor(**)
• If SYSCLK source is PLL, function returns a value based on HSE_VALUE divided by PREDIV factor(**) orHSI_VALUE(*) multiplied by the PLL factor.
• (*) HSI_VALUE is a constant defined in stm32f1xx_hal_conf.h file (default value 8 MHz) but the real valuemay vary depending on the variations in voltage and temperature.
• (**) HSE_VALUE is a constant defined in stm32f1xx_hal_conf.h file (default value 8 MHz), user has toensure that HSE_VALUE is same as the real frequency of the crystal used. Otherwise, this function mayhave wrong result.
• The result of this function could be not correct when using fractional value for HSE crystal.
• This function can be used by the user application to compute the baud-rate for the communicationperipherals or configure other parameters.
• Each time SYSCLK changes, this function must be called to update the right SYSCLK value. Otherwise,any configuration based on this function will be incorrect.


• Each time HCLK changes, this function must be called to update the right HCLK value. Otherwise, anyconfiguration based on this function will be incorrect.
• The SystemCoreClock CMSIS variable is used to store System Clock Frequency and updated within thisfunction

Parameters:
• __STATE__: specifies the new state of the HSE. This parameter can be one of the following values:–RCC_HSE_OFF turn OFF the HSE oscillator, HSERDY flag goes low after 6 HSE oscillator clockcycles.–RCC_HSE_ON turn ON the HSE oscillator–RCC_HSE_BYPASS HSE oscillator bypassed with external clock

Notes:
• Transition HSE Bypass to HSE On and HSE On to HSE Bypass are not supported by this macro. Usershould request a transition to HSE Off first and then HSE On or HSE Bypass. After enabling the HSE(RCC_HSE_ON or RCC_HSE_Bypass), the application software should wait on HSERDY flag to be setindicating that HSE clock is stable and can be used to clock the PLL and/or system clock. HSE state cannot be changed if it is used directly or through the PLL as system clock. In this case, you have to selectanother source of the system clock then change the HSE state (ex. disable it). The HSE is stopped byhardware when entering STOP and STANDBY modes. This function reset the CSSON bit, so if the clocksecurity system(CSS) was previously enabled you have to enable it again after calling this function.

Notes:
• The HSI is stopped by hardware when entering STOP and STANDBY modes. HSI can not be stopped if itis used as system clock source. In this case, you have to select another source of the system clock thenstop the HSI. After enabling the HSI, the application software should wait on HSIRDY flag to be setindicating that HSI clock is stable and can be used as system clock source. When the HSI is stopped,HSIRDY flag goes low after 6 HSI oscillator clock cycles.

Parameters:
• __STATE__: specifies the new state of the LSE. This parameter can be one of the following values:–RCC_LSE_OFF turn OFF the LSE oscillator, LSERDY flag goes low after 6 LSE oscillator clockcycles.–RCC_LSE_ON turn ON the LSE oscillator.–RCC_LSE_BYPASS LSE oscillator bypassed with external clock.

Notes:
• Transitions LSE Bypass to LSE On and LSE On to LSE Bypass are not supported by this macro. As theLSE is in the Backup domain and write access is denied to this domain after reset, you have to enable writeaccess using HAL_PWR_EnableBkUpAccess() function before to configure the LSE (to be done once afterreset). After enabling the LSE (RCC_LSE_ON or RCC_LSE_BYPASS), the application software shouldwait on LSERDY flag to be set indicating that LSE clock is stable and can be used to clock the RTC.

Notes:
• After enabling the LSI, the application software should wait on LSIRDY flag to be set indicating that LSIclock is stable and can be used to clock the IWDG and/or the RTC.

Notes:
• After enabling the main PLL, the application software should wait on PLLRDY flag to be set indicating thatPLL clock is stable and can be used as system clock source. The main PLL is disabled by hardware whenentering STOP and STANDBY modes.

Notes:
• As the RTC clock configuration bits are in the Backup domain and write access is denied to this domainafter reset, you have to enable write access using the Power Backup Access macro before to configure theRTC clock source (to be done once after reset). Once the RTC clock is configured it can't be changedunless the Backup domain is reset using __HAL_RCC_BACKUPRESET_FORCE() macro, or by a PowerOn Reset (POR).
• If the LSE or LSI is used as RTC clock source, the RTC continues to work in STOP and STANDBY modes,and can be used as wakeup source. However, when the HSE clock is used as RTC clock source, the RTCcannot be used in STOP and STANDBY modes. The maximum input clock frequency for RTC is 1MHz(when using HSE as RTC clock source).

Note:Important note: Care must be taken when HAL_RCCEx_PeriphCLKConfig() is used to select the RTC clocksource; in this case the Backup domain will be reset in order to modify the RTC Clock source, as consequenceRTC registers (including the backup registers) are set to their reset values.This section contains the following APIs:
• HAL_RCCEx_PeriphCLKConfig


• Care must be taken when HAL_RCCEx_PeriphCLKConfig() is used to select the RTC clock source; in thiscase the Backup domain will be reset in order to modify the RTC Clock source, as consequence RTCregisters (including the backup registers) are set to their reset values.
• In case of STM32F105xC or STM32F107xC devices, PLLI2S will be enabled if requested on one of 2 I2Sinterfaces. When PLLI2S is enabled, you need to call HAL_RCCEx_DisablePLLI2S to manually disable it.

Notes:
• Predivision factor can not be changed if PLL is used as system clock In this case, you have to selectanother source of the system clock, disable the PLL and then change the HSE predivision factor.

Notes:
• Predivision factor can not be changed if PLL2 is used indirectly as system clock In this case, you have toselect another source of the system clock, disable the PLL2 and PLLI2S and then change the PREDIV2factor.

Notes:
• After enabling the main PLLI2S, the application software should wait on PLLI2SRDY flag to be setindicating that PLLI2S clock is stable and can be used as system clock source. The main PLLI2S isdisabled by hardware when entering STOP and STANDBY modes.

Notes:
• After enabling the main PLL2, the application software should wait on PLL2RDY flag to be set indicatingthat PLL2 clock is stable and can be used as system clock source. The main PLL2 is disabled by hardwarewhen entering STOP and STANDBY modes.

Field Documentation
• uint8_t RTC_TimeTypeDef::HoursSpecifies the RTC Time Hour. This parameter must be a number between Min_Data = 0 and Max_Data = 23
• uint8_t RTC_TimeTypeDef::MinutesSpecifies the RTC Time Minutes. This parameter must be a number between Min_Data = 0 and Max_Data =59
• uint8_t RTC_TimeTypeDef::SecondsSpecifies the RTC Time Seconds. This parameter must be a number between Min_Data = 0 and Max_Data= 59

Field Documentation
• uint32_t RTC_InitTypeDef::AsynchPredivSpecifies the RTC Asynchronous Predivider value. This parameter must be a number between Min_Data =0x00 and Max_Data = 0xFFFFF or RTC_AUTO_1_SECOND If RTC_AUTO_1_SECOND is selected,AsynchPrediv will be set automatically to get 1sec timebase
• uint32_t RTC_InitTypeDef::OutPutSpecifies which signal will be routed to the RTC Tamper pin. This parameter can be a value ofRTC_output_source_to_output_on_the_Tamper_pin


• uint8_t RTC_DateTypeDef::DateSpecifies the RTC Date. This parameter must be a number between Min_Data = 1 and Max_Data = 31
• uint8_t RTC_DateTypeDef::YearSpecifies the RTC Date Year. This parameter must be a number between Min_Data = 0 and Max_Data = 99


• Enable the RTC Tamper and configure the Tamper Level using the HAL_RTCEx_SetTamper() function. Youcan configure RTC Tamper with interrupt mode using HAL_RTCEx_SetTamper_IT() function.
• The TAMPER1 alternate function can be mapped to PC13

RTC version used on STM32F1 families is version V1. All the features supported by V2 (other families) will be notsupported on F1.As on V2, main RTC features are managed by HW. But on F1, date feature is completely managed by SW.Then, there are some restrictions compared to other families:
• Only format 24 hours supported in HAL (format 12 hours not supported)
• Date is saved in SRAM. Then, when MCU is in STOP or STANDBY mode, date will be lost. User shouldimplement a way to save date before entering in low power mode (an example is provided with firmwarepackage based on backup registers)
• Date is automatically updated each time a HAL_RTC_GetTime or HAL_RTC_GetDate is called.
• Alarm detection is limited to 1 day. It will expire only 1 time (no alarm repetition, need to program a newalarm)

The real-time clock (RTC) and the RTC backup registers can be powered from the VBAT voltage when the mainVDD supply is powered off. To retain the content of the RTC backup registers and supply the RTC when VDD isturned off, VBAT pin can be connected to an optional standby voltage supplied by a battery or by another source.To allow the RTC operating even when the main digital supply (VDD) is turned off, the VBAT pin powers thefollowing blocks:1.The RTC2.The LSE oscillator3.The backup SRAM when the low power backup regulator is enabled4.PC13 to PC15 I/Os, plus PI8 I/O (when available)When the backup domain is supplied by VDD (analog switch connected to VDD), the following pins are available:
• PC13 can be used as a Tamper pin

The MCU can be woken up from a low power mode by an RTC alternate function.The RTC alternate functions are the RTC alarms (Alarm A), and RTC tamper event detection. These RTCalternate functions can wake up the system from the Stop and Standby low power modes.The system can also wake up from low power modes without depending on an external interrupt (Auto-wakeupmode), by using the RTC alarm.

The compilation define USE_HAL_RTC_REGISTER_CALLBACKS when set to 1 allows the user to configuredynamically the driver callbacks. Use Function @ref HAL_RTC_RegisterCallback() to register an interruptcallback.Function @ref HAL_RTC_RegisterCallback() allows to register following callbacks:
• AlarmAEventCallback : RTC Alarm A Event callback.
• Tamper1EventCallback : RTC Tamper 1 Event callback.
• MspInitCallback : RTC MspInit callback.
• MspDeInitCallback : RTC MspDeInit callback.

This function takes as parameters the HAL peripheral handle, the Callback ID and a pointer to the user callbackfunction.Use function @ref HAL_RTC_UnRegisterCallback() to reset a callback to the default weak function. @refHAL_RTC_UnRegisterCallback() takes as parameters the HAL peripheral handle, and the Callback ID. Thisfunction allows to reset following callbacks:
• AlarmAEventCallback : RTC Alarm A Event callback.
• Tamper1EventCallback : RTC Tamper 1 Event callback.
• MspInitCallback : RTC MspInit callback.
• MspDeInitCallback : RTC MspDeInit callback.

By default, after the @ref HAL_RTC_Init() and when the state is HAL_RTC_STATE_RESET, all callbacks are setto the corresponding weak functions : example @ref AlarmAEventCallback(). Exception done for MspInit andMspDeInit callbacks that are reset to the legacy weak function in the @ref HAL_RTC_Init()/@refHAL_RTC_DeInit() only when these callbacks are null (not registered beforehand). If not, MspInit or MspDeInitare not null, @ref HAL_RTC_Init()/@ref HAL_RTC_DeInit() keep and use the user MspInit/MspDeInit callbacks(registered beforehand)Callbacks can be registered/unregistered in HAL_RTC_STATE_READY state only. Exception done MspInit/MspDeInit that can be registered/unregistered in HAL_RTC_STATE_READY or HAL_RTC_STATE_RESET state,thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit. In that case first register theMspInit/MspDeInit user callbacks using @ref HAL_RTC_RegisterCallback() before calling @refHAL_RTC_DeInit() or @ref HAL_RTC_Init() function.When The compilation define USE_HAL_RTC_REGISTER_CALLBACKS is set to 0 or not defined, the callbackregistration feature is not available and all callbacks are set to the corresponding weak functions.


• hrtc: pointer to a RTC_HandleTypeDef structure that contains the configuration information for RTC.
• sTime: Pointer to Time structure
• Format: Specifies the format of the entered parameters. This parameter can be one of the followingvalues:–RTC_FORMAT_BIN: Binary data format–RTC_FORMAT_BCD: BCD data format


• hrtc: pointer to a RTC_HandleTypeDef structure that contains the configuration information for RTC.
• sTime: Pointer to Time structure
• Format: Specifies the format of the entered parameters. This parameter can be one of the followingvalues:–RTC_FORMAT_BIN: Binary data format–RTC_FORMAT_BCD: BCD data format


• hrtc: pointer to a RTC_HandleTypeDef structure that contains the configuration information for RTC.
• sDate: Pointer to date structure
• Format: specifies the format of the entered parameters. This parameter can be one of the following values:–RTC_FORMAT_BIN: Binary data format–RTC_FORMAT_BCD: BCD data format


• hrtc: pointer to a RTC_HandleTypeDef structure that contains the configuration information for RTC.
• sDate: Pointer to Date structure
• Format: Specifies the format of the entered parameters. This parameter can be one of the followingvalues:–RTC_FORMAT_BIN: Binary data format–RTC_FORMAT_BCD: BCD data format


• hrtc: pointer to a RTC_HandleTypeDef structure that contains the configuration information for RTC.
• sAlarm: Pointer to Alarm structure
• Format: Specifies the format of the entered parameters. This parameter can be one of the followingvalues:–RTC_FORMAT_BIN: Binary data format–RTC_FORMAT_BCD: BCD data format


• hrtc: pointer to a RTC_HandleTypeDef structure that contains the configuration information for RTC.
• sAlarm: Pointer to Alarm structure
• Format: Specifies the format of the entered parameters. This parameter can be one of the followingvalues:–RTC_FORMAT_BIN: Binary data format–RTC_FORMAT_BCD: BCD data format


• hrtc: pointer to a RTC_HandleTypeDef structure that contains the configuration information for RTC.
• sAlarm: Pointer to Date structure
• Alarm: Specifies the Alarm. This parameter can be one of the following values:–RTC_ALARM_A: Alarm
• Format: Specifies the format of the entered parameters. This parameter can be one of the followingvalues:–RTC_FORMAT_BIN: Binary data format–RTC_FORMAT_BCD: BCD data format


• hrtc: pointer to a RTC_HandleTypeDef structure that contains the configuration information for RTC.
• BackupRegister: RTC Backup data Register number. This parameter can be: RTC_BKP_DRx where xcan be from 1 to 10 (or 42) to specify the register (depending devices).
• Data: Data to be written in the specified RTC Backup data register.


• hrtc: pointer to a RTC_HandleTypeDef structure that contains the configuration information for RTC.
• BackupRegister: RTC Backup data Register number. This parameter can be: RTC_BKP_DRx where xcan be from 1 to 10 (or 42) to specify the register (depending devices).


• hrtc: RTC handle
• SmoothCalibPeriod: Not used (only present for compatibility with another families)
• SmoothCalibPlusPulses: Not used (only present for compatibility with another families)
• SmouthCalibMinusPulsesValue: specifies the RTC Clock Calibration value. This parameter must be anumber between 0 and 0x7F.

Field Documentation
• uint32_t SMARTCARD_InitTypeDef::BaudRateThis member configures the SmartCard communication baud rate. The baud rate is computed using thefollowing formula:–IntegerDivider = ((PCLKx) / (16 * (hsc->Init.BaudRate)))–FractionalDivider = ((IntegerDivider - ((uint32_t) IntegerDivider)) * 16) + 0.5
• uint32_t SMARTCARD_InitTypeDef::WordLengthSpecifies the number of data bits transmitted or received in a frame. This parameter can be a value ofSMARTCARD_Word_Length


• uint32_t SMARTCARD_InitTypeDef::ParitySpecifies the parity mode. This parameter can be a value of SMARTCARD_ParityNote:–When parity is enabled, the computed parity is inserted at the MSB position of the transmitted data (9thbit when the word length is set to 9 data bits; 8th bit when the word length is set to 8 data bits).
• uint32_t SMARTCARD_InitTypeDef::ModeSpecifies whether the Receive or Transmit mode is enabled or disabled. This parameter can be a value ofSMARTCARD_Mode


• uint32_t SMARTCARD_InitTypeDef::CLKLastBitSpecifies whether the clock pulse corresponding to the last transmitted data bit (MSB) has to be output onthe SCLK pin in synchronous mode. This parameter can be a value of SMARTCARD_Last_Bit


• uint32_t SMARTCARD_InitTypeDef::PrescalerSpecifies the SmartCard Prescaler value used for dividing the system clock to provide the smartcard clock.The value given in the register (5 significant bits) is multiplied by 2 to give the division factor of the sourceclock frequency. This parameter can be a value of SMARTCARD_Prescaler

Note:The specific SMARTCARD interrupts (Transmission complete interrupt, RXNE interrupt and Error Interrupts) willbe managed using the macros __HAL_SMARTCARD_ENABLE_IT() and __HAL_SMARTCARD_DISABLE_IT()inside the transmit and receive process.Three operation modes are available within this driver :


• At transmission end of transfer HAL_SMARTCARD_TxCpltCallback is executed and user can add his owncode by customization of function pointer HAL_SMARTCARD_TxCpltCallback
• Receive an amount of data in non blocking mode using HAL_SMARTCARD_Receive_IT()
• At reception end of transfer HAL_SMARTCARD_RxCpltCallback is executed and user can add his own codeby customization of function pointer HAL_SMARTCARD_RxCpltCallback
• In case of transfer Error, HAL_SMARTCARD_ErrorCallback() function is executed and user can add his owncode by customization of function pointer HAL_SMARTCARD_ErrorCallback


• Send an amount of data in non blocking mode (DMA) using HAL_SMARTCARD_Transmit_DMA()
• At transmission end of transfer HAL_SMARTCARD_TxCpltCallback is executed and user can add his owncode by customization of function pointer HAL_SMARTCARD_TxCpltCallback
• Receive an amount of data in non blocking mode (DMA) using HAL_SMARTCARD_Receive_DMA()
• At reception end of transfer HAL_SMARTCARD_RxCpltCallback is executed and user can add his own codeby customization of function pointer HAL_SMARTCARD_RxCpltCallback
• In case of transfer Error, HAL_SMARTCARD_ErrorCallback() function is executed and user can add his owncode by customization of function pointer HAL_SMARTCARD_ErrorCallback

The compilation define USE_HAL_SMARTCARD_REGISTER_CALLBACKS when set to 1 allows the user toconfigure dynamically the driver callbacks.Use Function @ref HAL_SMARTCARD_RegisterCallback() to register a user callback. Function @refHAL_SMARTCARD_RegisterCallback() allows to register following callbacks:
• TxCpltCallback : Tx Complete Callback.
• RxCpltCallback : Rx Complete Callback.
• ErrorCallback : Error Callback.
• AbortCpltCallback : Abort Complete Callback.
• AbortTransmitCpltCallback : Abort Transmit Complete Callback.
• AbortReceiveCpltCallback : Abort Receive Complete Callback.
• MspInitCallback : SMARTCARD MspInit.
• MspDeInitCallback : SMARTCARD MspDeInit. This function takes as parameters the HAL peripheral handle,the Callback ID and a pointer to the user callback function.

Use function @ref HAL_SMARTCARD_UnRegisterCallback() to reset a callback to the default weak (surcharged)function. @ref HAL_SMARTCARD_UnRegisterCallback() takes as parameters the HAL peripheral handle, andthe Callback ID. This function allows to reset following callbacks:
• TxCpltCallback : Tx Complete Callback.
• RxCpltCallback : Rx Complete Callback.
• ErrorCallback : Error Callback.
• AbortCpltCallback : Abort Complete Callback.
• AbortTransmitCpltCallback : Abort Transmit Complete Callback.
• AbortReceiveCpltCallback : Abort Receive Complete Callback.

This subsection provides a set of functions allowing to initialize the USART in Smartcard mode.The Smartcard interface is designed to support asynchronous protocol Smartcards as defined in the ISO 7816-3standard.The USART can provide a clock to the smartcard through the SCLK output. In smartcard mode, SCLK is notassociated to the communication but is simply derived from the internal peripheral input clock through a 5-bitprescaler.
• For the Smartcard mode only these parameters can be configured:–Baud Rate–Word Length => Should be 9 bits (8 bits + parity)–Stop Bit–Parity: => Should be enabled–USART polarity–USART phase–USART LastBit–Receiver/transmitter modes–Prescaler–GuardTime–NACKState: The Smartcard NACK state
• Recommended SmartCard interface configuration to get the Answer to Reset from the Card:–Word Length = 9 Bits–1.5 Stop Bit–Even parity–BaudRate = 12096 baud–Tx and Rx enabled

Note:It is also possible to choose 0.5 stop bit for receiving but it is recommended to use 1.5 stop bits for bothtransmitting and receiving to avoid switching between the two configurations.The HAL_SMARTCARD_Init() function follows the USART SmartCard configuration procedures (details for theprocedures are available in reference manuals (RM0008 for STM32F10Xxx MCUs and RM0041 forSTM32F100xx MCUs)).This section contains the following APIs:
• HAL_SMARTCARD_Init

(#) Smartcard is a single wire half duplex communication protocol. The Smartcard interface is designed to supportasynchronous protocol Smartcards as defined in the ISO 7816-3 standard. (#) The USART should be configuredas: (++) 8 bits plus parity: where M=1 and PCE=1 in the USART_CR1 register (++) 1.5 stop bits when transmittingand receiving: where STOP=11 in the USART_CR2 register. (#) There are two modes of transfer: (++) Blockingmode: The communication is performed in polling mode. The HAL status of all data processing is returned by thesame function after finishing transfer. (++) Non Blocking mode: The communication is performed using Interruptsor DMA, These APIs return the HAL status. The end of the data processing will be indicated through thededicated SMARTCARD IRQ when using Interrupt mode or the DMA IRQ when using DMA mode. TheHAL_SMARTCARD_TxCpltCallback(), HAL_SMARTCARD_RxCpltCallback() user callbacks will be executedrespectively at the end of the Transmit or Receive process The HAL_SMARTCARD_ErrorCallback() user callbackwill be executed when a communication error is detected (#) Blocking mode APIs are : (++)HAL_SMARTCARD_Transmit() (++) HAL_SMARTCARD_Receive() (#) Non Blocking mode APIs with Interruptare : (++) HAL_SMARTCARD_Transmit_IT() (++) HAL_SMARTCARD_Receive_IT() (++)HAL_SMARTCARD_IRQHandler() (#) Non Blocking mode functions with DMA are : (++)HAL_SMARTCARD_Transmit_DMA() (++) HAL_SMARTCARD_Receive_DMA() (#) A set of Transfer CompleteCallbacks are provided in non Blocking mode: (++) HAL_SMARTCARD_TxCpltCallback() (++)HAL_SMARTCARD_RxCpltCallback() (++) HAL_SMARTCARD_ErrorCallback() (#) Non-Blocking mode transferscould be aborted using Abort API's :
• HAL_SMARTCARD_Abort()
• HAL_SMARTCARD_AbortTransmit()
• HAL_SMARTCARD_AbortReceive()
• HAL_SMARTCARD_Abort_IT()
• HAL_SMARTCARD_AbortTransmit_IT()
• HAL_SMARTCARD_AbortReceive_IT() (#) For Abort services based on interrupts(HAL_SMARTCARD_Abortxxx_IT), a set of Abort Complete Callbacks are provided:
• HAL_SMARTCARD_AbortCpltCallback()
• HAL_SMARTCARD_AbortTransmitCpltCallback()
• HAL_SMARTCARD_AbortReceiveCpltCallback() (#) In Non-Blocking mode transfers, possible errors aresplit into 2 categories. Errors are handled as follows :
• Error is considered as Recoverable and non blocking : Transfer could go till end, but error severity is to beevaluated by user : this concerns Frame Error, Parity Error or Noise Error in Interrupt mode reception .Received character is then retrieved and stored in Rx buffer, Error code is set to allow user to identify errortype, and HAL_SMARTCARD_ErrorCallback() user callback is executed. Transfer is kept ongoing onSMARTCARD side. If user wants to abort it, Abort services should be called by user.
• Error is considered as Blocking : Transfer could not be completed properly and is aborted. This concernsFrame Error in Interrupt mode tranmission, Overrun Error in Interrupt mode reception and all errors in DMAmode. Error code is set to allow user to identify error type, and HAL_SMARTCARD_ErrorCallback() usercallback is executed.

This subsection provides a set of functions allowing to control the SmartCard.
• HAL_SMARTCARD_GetState() API can be helpful to check in run-time the state of the SmartCardperipheral.
• HAL_SMARTCARD_GetError() check in run-time errors that could be occurred during communication.


• This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode. Thisprocedure performs following operations : Disable PPP InterruptsDisable the DMA transfer in the peripheralregister (if enabled)Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)Sethandle State to READY
• This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.


• This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode. Thisprocedure performs following operations : Disable SMARTCARD Interrupts (Tx)Disable the DMA transfer inthe peripheral register (if enabled)Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer inDMA mode)Set handle State to READY
• This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.


• This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode. Thisprocedure performs following operations : Disable PPP InterruptsDisable the DMA transfer in the peripheralregister (if enabled)Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)Sethandle State to READY
• This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.


• This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode. Thisprocedure performs following operations : Disable PPP InterruptsDisable the DMA transfer in the peripheralregister (if enabled)Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMAmode)Set handle State to READYAt abort completion, call user abort complete callback
• This procedure is executed in Interrupt mode, meaning that abort procedure could be considered ascompleted only when user abort complete callback is executed (not when exiting function).


• This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode. Thisprocedure performs following operations : Disable SMARTCARD Interrupts (Tx)Disable the DMA transfer inthe peripheral register (if enabled)Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer inDMA mode)Set handle State to READYAt abort completion, call user abort complete callback
• This procedure is executed in Interrupt mode, meaning that abort procedure could be considered ascompleted only when user abort complete callback is executed (not when exiting function).


• This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode. Thisprocedure performs following operations : Disable SMARTCARD Interrupts (Rx)Disable the DMA transfer inthe peripheral register (if enabled)Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer inDMA mode)Set handle State to READYAt abort completion, call user abort complete callback
• This procedure is executed in Interrupt mode, meaning that abort procedure could be considered ascompleted only when user abort complete callback is executed (not when exiting function).

Notes:
• PE (Parity error), FE (Framing error), NE (Noise error) and ORE (Overrun error) flags are cleared bysoftware sequence: a read operation to USART_SR register followed by a read operation to USART_DRregister. RXNE flag can be also cleared by a read to the USART_DR register. TC flag can be also clearedby software sequence: a read operation to USART_SR register followed by a write operation toUSART_DR register. TXE flag is cleared only by a write to the USART_DR register.


• uint32_t SPI_InitTypeDef::BaudRatePrescalerSpecifies the Baud Rate prescaler value which will be used to configure the transmit and receive SCK clock.This parameter can be a value of SPI_BaudRate_PrescalerNote:–The communication clock is derived from the master clock. The slave clock does not need to be set.
• uint32_t SPI_InitTypeDef::FirstBitSpecifies whether data transfers start from MSB or LSB bit. This parameter can be a value ofSPI_MSB_LSB_transmission

__SPI_HandleTypeDef is defined in the stm32f1xx_hal_spi.hData Fields
• SPI_TypeDef * Instance
• SPI_InitTypeDef Init
• uint8_t * pTxBuffPtr
• uint16_t TxXferSize
• __IO uint16_t TxXferCount
• uint8_t * pRxBuffPtr
• uint16_t RxXferSize
• __IO uint16_t RxXferCount
• void(* RxISR
• void(* TxISR
• DMA_HandleTypeDef * hdmatx
• DMA_HandleTypeDef * hdmarx
• HAL_LockTypeDef Lock
• __IO HAL_SPI_StateTypeDef State
• __IO uint32_t ErrorCode

This subsection provides a set of functions allowing to initialize and de-initialize the SPIx peripheral:
• User must implement HAL_SPI_MspInit() function in which he configures all related peripherals resources(CLOCK, GPIO, DMA, IT and NVIC ).


• Call the function HAL_SPI_Init() to configure the selected device with the selected configuration:–Mode–Direction–Data Size–Clock Polarity and Phase–NSS Management–BaudRate Prescaler–FirstBit–TIMode–CRC Calculation–CRC Polynomial if CRC enabled
• Call the function HAL_SPI_DeInit() to restore the default configuration of the selected SPIx peripheral.

This subsection provides a set of functions allowing to manage the SPI data transfers.The SPI supports master and slave mode :1.There are two modes of transfer:–Blocking mode: The communication is performed in polling mode. The HAL status of all dataprocessing is returned by the same function after finishing transfer.–No-Blocking mode: The communication is performed using Interrupts or DMA, These APIs return theHAL status. The end of the data processing will be indicated through the dedicated SPI IRQ whenusing Interrupt mode or the DMA IRQ when using DMA mode. The HAL_SPI_TxCpltCallback(),HAL_SPI_RxCpltCallback() and HAL_SPI_TxRxCpltCallback() user callbacks will be executedrespectively at the end of the transmit or Receive process The HAL_SPI_ErrorCallback()user callbackwill be executed when a communication error is detected2.APIs provided for these 2 transfer modes (Blocking mode or Non blocking mode using either Interrupt orDMA) exist for 1Line (simplex) and 2Lines (full duplex) modes.This section contains the following APIs:
• HAL_SPI_Transmit

This subsection provides a set of functions allowing to control the SPI.
• HAL_SPI_GetState() API can be helpful to check in run-time the state of the SPI peripheral
• HAL_SPI_GetError() check in run-time Errors occurring during communication


• hspi: pointer to a SPI_HandleTypeDef structure that contains the configuration information for SPI module.
• pTxData: pointer to transmission data buffer
• pRxData: pointer to reception data buffer
• Size: amount of data to be sent and received
• Timeout: Timeout duration


• hspi: pointer to a SPI_HandleTypeDef structure that contains the configuration information for SPI module.
• pTxData: pointer to transmission data buffer
• pRxData: pointer to reception data buffer
• Size: amount of data to be sent and received


• This procedure could be used for aborting any ongoing transfer (Tx and Rx), started in Interrupt or DMAmode. This procedure performs following operations : Disable SPI Interrupts (depending of transferdirection)Disable the DMA transfer in the peripheral register (if enabled)Abort DMA transfer by callingHAL_DMA_Abort (in case of transfer in DMA mode)Set handle State to READY
• This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.


• This procedure could be used for aborting any ongoing transfer (Tx and Rx), started in Interrupt or DMAmode. This procedure performs following operations : Disable SPI Interrupts (depending of transferdirection)Disable the DMA transfer in the peripheral register (if enabled)Abort DMA transfer by callingHAL_DMA_Abort_IT (in case of transfer in DMA mode)Set handle State to READYAt abort completion, calluser abort complete callback
• This procedure is executed in Interrupt mode, meaning that abort procedure could be considered ascompleted only when user abort complete callback is executed (not when exiting function).

Parameters:
• __HANDLE__: specifies the SPI Handle. This parameter can be SPI where x: 1, 2, or 3 to select the SPIperipheral.
• __INTERRUPT__: specifies the interrupt source to enable. This parameter can be one of the followingvalues:–SPI_IT_TXE: Tx buffer empty interrupt enable–SPI_IT_RXNE: RX buffer not empty interrupt enable–SPI_IT_ERR: Error interrupt enable

Parameters:
• __HANDLE__: specifies the SPI handle. This parameter can be SPIx where x: 1, 2, or 3 to select the SPIperipheral.
• __INTERRUPT__: specifies the interrupt source to disable. This parameter can be one of the followingvalues:–SPI_IT_TXE: Tx buffer empty interrupt enable–SPI_IT_RXNE: RX buffer not empty interrupt enable–SPI_IT_ERR: Error interrupt enable

Parameters:
• __HANDLE__: specifies the SPI Handle. This parameter can be SPI where x: 1, 2, or 3 to select the SPIperipheral.
• __INTERRUPT__: specifies the SPI interrupt source to check. This parameter can be one of the followingvalues:–SPI_IT_TXE: Tx buffer empty interrupt enable–SPI_IT_RXNE: RX buffer not empty interrupt enable–SPI_IT_ERR: Error interrupt enable

Field Documentation
• uint32_t TIM_Base_InitTypeDef::PrescalerSpecifies the prescaler value used to divide the TIM clock. This parameter can be a number betweenMin_Data = 0x0000 and Max_Data = 0xFFFF
• uint32_t TIM_Base_InitTypeDef::CounterModeSpecifies the counter mode. This parameter can be a value of TIM_Counter_Mode


• uint32_t TIM_Base_InitTypeDef::PeriodSpecifies the period value to be loaded into the active Auto-Reload Register at the next update event. Thisparameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF.
• uint32_t TIM_Base_InitTypeDef::ClockDivisionSpecifies the clock division. This parameter can be a value of TIM_ClockDivision


• uint32_t TIM_Base_InitTypeDef::RepetitionCounterSpecifies the repetition counter value. Each time the RCR downcounter reaches zero, an update event isgenerated and counting restarts from the RCR value (N). This means in PWM mode that (N+1) correspondsto:–the number of PWM periods in edge-aligned mode–the number of half PWM period in center-aligned mode GP timers: this parameter must be a numberbetween Min_Data = 0x00 and Max_Data = 0xFF. Advanced timers: this parameter must be a numberbetween Min_Data = 0x0000 and Max_Data = 0xFFFF.
• uint32_t TIM_Base_InitTypeDef::AutoReloadPreloadSpecifies the auto-reload preload. This parameter can be a value of TIM_AutoReloadPreload


• uint32_t TIM_OC_InitTypeDef::PulseSpecifies the pulse value to be loaded into the Capture Compare Register. This parameter can be a numberbetween Min_Data = 0x0000 and Max_Data = 0xFFFF
• uint32_t TIM_OC_InitTypeDef::OCPolaritySpecifies the output polarity. This parameter can be a value of TIM_Output_Compare_Polarity


• uint32_t TIM_OC_InitTypeDef::OCNPolaritySpecifies the complementary output polarity. This parameter can be a value ofTIM_Output_Compare_N_PolarityNote:–This parameter is valid only for timer instances supporting break feature.
• uint32_t TIM_OC_InitTypeDef::OCFastModeSpecifies the Fast mode state. This parameter can be a value of TIM_Output_Fast_StateNote:–This parameter is valid only in PWM1 and PWM2 mode.
• uint32_t TIM_OC_InitTypeDef::OCIdleStateSpecifies the TIM Output Compare pin state during Idle state. This parameter can be a value ofTIM_Output_Compare_Idle_StateNote:–This parameter is valid only for timer instances supporting break feature.
• uint32_t TIM_OC_InitTypeDef::OCNIdleStateSpecifies the TIM Output Compare pin state during Idle state. This parameter can be a value ofTIM_Output_Compare_N_Idle_StateNote:–This parameter is valid only for timer instances supporting break feature.


• uint32_t TIM_OnePulse_InitTypeDef::PulseSpecifies the pulse value to be loaded into the Capture Compare Register. This parameter can be a numberbetween Min_Data = 0x0000 and Max_Data = 0xFFFF
• uint32_t TIM_OnePulse_InitTypeDef::OCPolaritySpecifies the output polarity. This parameter can be a value of TIM_Output_Compare_Polarity


• uint32_t TIM_OnePulse_InitTypeDef::OCIdleStateSpecifies the TIM Output Compare pin state during Idle state. This parameter can be a value ofTIM_Output_Compare_Idle_StateNote:–This parameter is valid only for timer instances supporting break feature.
• uint32_t TIM_OnePulse_InitTypeDef::OCNIdleStateSpecifies the TIM Output Compare pin state during Idle state. This parameter can be a value ofTIM_Output_Compare_N_Idle_StateNote:–This parameter is valid only for timer instances supporting break feature.
• uint32_t TIM_OnePulse_InitTypeDef::ICPolaritySpecifies the active edge of the input signal. This parameter can be a value of TIM_Input_Capture_Polarity


• uint32_t TIM_Encoder_InitTypeDef::IC1FilterSpecifies the input capture filter. This parameter can be a number between Min_Data = 0x0 and Max_Data =0xF
• uint32_t TIM_Encoder_InitTypeDef::IC2PolaritySpecifies the active edge of the input signal. This parameter can be a value of TIM_Input_Capture_Polarity


• uint32_t TIM_ClearInputConfigTypeDef::ClearInputPrescalerTIM Clear Input prescaler This parameter must be 0: When OCRef clear feature is used with ETR source,ETR prescaler must be off
• uint32_t TIM_ClearInputConfigTypeDef::ClearInputFilterTIM Clear Input filter This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF


• uint32_t TIM_MasterConfigTypeDef::MasterSlaveModeMaster/slave mode selection This parameter can be a value of TIM_Master_Slave_ModeNote:–When the Master/slave mode is enabled, the effect of an event on the trigger input (TRGI) is delayed toallow a perfect synchronization between the current timer and its slaves (through TRGO). It is notmandatory in case of timer synchronization mode.


• uint32_t TIM_BreakDeadTimeConfigTypeDef::BreakFilterSpecifies the break input filter. This parameter can be a number between Min_Data = 0x0 and Max_Data =0xF
• uint32_t TIM_BreakDeadTimeConfigTypeDef::AutomaticOutputTIM Automatic Output Enable state This parameter can be a value of TIM_AOE_Bit_Set_Reset

The compilation define USE_HAL_TIM_REGISTER_CALLBACKS when set to 1 allows the user to configuredynamically the driver callbacks.Use Function @ref HAL_TIM_RegisterCallback() to register a callback. @ref HAL_TIM_RegisterCallback() takesas parameters the HAL peripheral handle, the Callback ID and a pointer to the user callback function.Use function @ref HAL_TIM_UnRegisterCallback() to reset a callback to the default weak function. @refHAL_TIM_UnRegisterCallback takes as parameters the HAL peripheral handle, and the Callback ID.These functions allow to register/unregister following callbacks:
• Base_MspInitCallback : TIM Base Msp Init Callback.
• Base_MspDeInitCallback : TIM Base Msp DeInit Callback.
• IC_MspInitCallback : TIM IC Msp Init Callback.
• IC_MspDeInitCallback : TIM IC Msp DeInit Callback.
• OC_MspInitCallback : TIM OC Msp Init Callback.
• OC_MspDeInitCallback : TIM OC Msp DeInit Callback.
• PWM_MspInitCallback : TIM PWM Msp Init Callback.
• PWM_MspDeInitCallback : TIM PWM Msp DeInit Callback.
• OnePulse_MspInitCallback : TIM One Pulse Msp Init Callback.
• OnePulse_MspDeInitCallback : TIM One Pulse Msp DeInit Callback.
• Encoder_MspInitCallback : TIM Encoder Msp Init Callback.
• Encoder_MspDeInitCallback : TIM Encoder Msp DeInit Callback.
• HallSensor_MspInitCallback : TIM Hall Sensor Msp Init Callback.
• HallSensor_MspDeInitCallback : TIM Hall Sensor Msp DeInit Callback.
• PeriodElapsedCallback : TIM Period Elapsed Callback.
• PeriodElapsedHalfCpltCallback : TIM Period Elapsed half complete Callback.
• TriggerCallback : TIM Trigger Callback.
• TriggerHalfCpltCallback : TIM Trigger half complete Callback.
• IC_CaptureCallback : TIM Input Capture Callback.
• IC_CaptureHalfCpltCallback : TIM Input Capture half complete Callback.
• OC_DelayElapsedCallback : TIM Output Compare Delay Elapsed Callback.
• PWM_PulseFinishedCallback : TIM PWM Pulse Finished Callback.
• PWM_PulseFinishedHalfCpltCallback : TIM PWM Pulse Finished half complete Callback.
• ErrorCallback : TIM Error Callback.
• CommutationCallback : TIM Commutation Callback.
• CommutationHalfCpltCallback : TIM Commutation half complete Callback.
• BreakCallback : TIM Break Callback.

Exception done for MspInit and MspDeInit functions that are reset to the legacy weak functionalities in the Init /DeInit only when these callbacks are null (not registered beforehand). If not, MspInit or MspDeInit are not null, theInit / DeInit keep and use the user MspInit / MspDeInit callbacks(registered beforehand)Callbacks can be registered / unregistered in HAL_TIM_STATE_READY state only. Exception done MspInit /MspDeInit that can be registered / unregistered in HAL_TIM_STATE_READY or HAL_TIM_STATE_RESET state,thus registered(user) MspInit / DeInit callbacks can be used during the Init / DeInit. In that case first register theMspInit/MspDeInit user callbacks using @ref HAL_TIM_RegisterCallback() before calling DeInit or Init function.When The compilation define USE_HAL_TIM_REGISTER_CALLBACKS is set to 0 or not defined, the callbackregistration feature is not available and all callbacks are set to the corresponding weak functions.

This section provides functions allowing to:
• Initialize and configure the TIM base.
• De-initialize the TIM base.
• Start the Time Base.
• Stop the Time Base.
• Start the Time Base and enable interrupt.
• Stop the Time Base and disable interrupt.
• Start the Time Base and enable DMA transfer.
• Stop the Time Base and disable DMA transfer.

This section provides functions allowing to:
• Initialize and configure the TIM Output Compare.
• De-initialize the TIM Output Compare.
• Start the TIM Output Compare.
• Stop the TIM Output Compare.
• Start the TIM Output Compare and enable interrupt.
• Stop the TIM Output Compare and disable interrupt.
• Start the TIM Output Compare and enable DMA transfer.
• Stop the TIM Output Compare and disable DMA transfer.

This section provides functions allowing to:
• Initialize and configure the TIM PWM.
• De-initialize the TIM PWM.
• Start the TIM PWM.
• Stop the TIM PWM.
• Start the TIM PWM and enable interrupt.
• Stop the TIM PWM and disable interrupt.
• Start the TIM PWM and enable DMA transfer.
• Stop the TIM PWM and disable DMA transfer.

This section provides functions allowing to:
• Initialize and configure the TIM Input Capture.
• De-initialize the TIM Input Capture.
• Start the TIM Input Capture.
• Stop the TIM Input Capture.
• Start the TIM Input Capture and enable interrupt.
• Stop the TIM Input Capture and disable interrupt.
• Start the TIM Input Capture and enable DMA transfer.
• Stop the TIM Input Capture and disable DMA transfer.

This section provides functions allowing to:
• Initialize and configure the TIM One Pulse.
• De-initialize the TIM One Pulse.
• Start the TIM One Pulse.
• Stop the TIM One Pulse.
• Start the TIM One Pulse and enable interrupt.
• Stop the TIM One Pulse and disable interrupt.
• Start the TIM One Pulse and enable DMA transfer.
• Stop the TIM One Pulse and disable DMA transfer.

This section provides functions allowing to:
• Initialize and configure the TIM Encoder.
• De-initialize the TIM Encoder.
• Start the TIM Encoder.
• Stop the TIM Encoder.
• Start the TIM Encoder and enable interrupt.
• Stop the TIM Encoder and disable interrupt.
• Start the TIM Encoder and enable DMA transfer.
• Stop the TIM Encoder and disable DMA transfer.


• Switching from Center Aligned counter mode to Edge counter mode (or reverse) requires a timer reset toavoid unexpected direction due to DIR bit readonly in center aligned mode. Ex: callHAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()


• Switching from Center Aligned counter mode to Edge counter mode (or reverse) requires a timer reset toavoid unexpected direction due to DIR bit readonly in center aligned mode. Ex: call HAL_TIM_OC_DeInit()before HAL_TIM_OC_Init()


• htim: TIM Output Compare handle
• Channel: TIM Channel to be enabled This parameter can be one of the following values:–TIM_CHANNEL_1: TIM Channel 1 selected–TIM_CHANNEL_2: TIM Channel 2 selected–TIM_CHANNEL_3: TIM Channel 3 selected–TIM_CHANNEL_4: TIM Channel 4 selected
• pData: The source Buffer address.
• Length: The length of data to be transferred from memory to TIM peripheral


• Switching from Center Aligned counter mode to Edge counter mode (or reverse) requires a timer reset toavoid unexpected direction due to DIR bit readonly in center aligned mode. Ex: callHAL_TIM_PWM_DeInit() before HAL_TIM_PWM_Init()


• htim: TIM PWM handle
• Channel: TIM Channels to be enabled This parameter can be one of the following values:–TIM_CHANNEL_1: TIM Channel 1 selected–TIM_CHANNEL_2: TIM Channel 2 selected–TIM_CHANNEL_3: TIM Channel 3 selected–TIM_CHANNEL_4: TIM Channel 4 selected
• pData: The source Buffer address.
• Length: The length of data to be transferred from memory to TIM peripheral


• Switching from Center Aligned counter mode to Edge counter mode (or reverse) requires a timer reset toavoid unexpected direction due to DIR bit readonly in center aligned mode. Ex: call HAL_TIM_IC_DeInit()before HAL_TIM_IC_Init()


• htim: TIM Input Capture handle
• Channel: TIM Channels to be enabled This parameter can be one of the following values:–TIM_CHANNEL_1: TIM Channel 1 selected–TIM_CHANNEL_2: TIM Channel 2 selected–TIM_CHANNEL_3: TIM Channel 3 selected–TIM_CHANNEL_4: TIM Channel 4 selected
• pData: The destination Buffer address.
• Length: The length of data to be transferred from TIM peripheral to memory.


• Switching from Center Aligned counter mode to Edge counter mode (or reverse) requires a timer reset toavoid unexpected direction due to DIR bit readonly in center aligned mode. Ex: callHAL_TIM_OnePulse_DeInit() before HAL_TIM_OnePulse_Init()


• Switching from Center Aligned counter mode to Edge counter mode (or reverse) requires a timer reset toavoid unexpected direction due to DIR bit readonly in center aligned mode. Ex: callHAL_TIM_Encoder_DeInit() before HAL_TIM_Encoder_Init()
• Encoder mode and External clock mode 2 are not compatible and must not be selected together Ex: A callfor HAL_TIM_Encoder_Init will erase the settings of HAL_TIM_ConfigClockSource usingTIM_CLOCKSOURCE_ETRMODE2 and vice versa


• htim: TIM Encoder Interface handle
• Channel: TIM Channels to be enabled This parameter can be one of the following values:–TIM_CHANNEL_1: TIM Channel 1 selected–TIM_CHANNEL_2: TIM Channel 2 selected–TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
• pData1: The destination Buffer address for IC1.
• pData2: The destination Buffer address for IC2.
• Length: The length of data to be transferred from TIM peripheral to memory.


• htim: TIM One Pulse handle
• sConfig: TIM One Pulse configuration structure
• OutputChannel: TIM output channel to configure This parameter can be one of the following values:–TIM_CHANNEL_1: TIM Channel 1 selected–TIM_CHANNEL_2: TIM Channel 2 selected
• InputChannel: TIM input Channel to configure This parameter can be one of the following values:–TIM_CHANNEL_1: TIM Channel 1 selected–TIM_CHANNEL_2: TIM Channel 2 selected


• To output a waveform with a minimum delay user can enable the fast mode by calling the__HAL_TIM_ENABLE_OCxFAST macro. Then CCx output is forced in response to the edge detection onTIx input, without taking in account the comparison.


• htim: TIM handle.
• sSlaveConfig: pointer to a TIM_SlaveConfigTypeDef structure that contains the selected trigger (internaltrigger input, filtered timer input or external trigger input) and the Slave mode (Disable, Reset, Gated,Trigger, External clock mode 1).


• htim: TIM handle.
• sSlaveConfig: pointer to a TIM_SlaveConfigTypeDef structure that contains the selected trigger (internaltrigger input, filtered timer input or external trigger input) and the Slave mode (Disable, Reset, Gated,Trigger, External clock mode 1).

Parameters:
• __HANDLE__: TIM handle.
• __CHANNEL__: TIM Channels to be configured. This parameter can be one of the following values:–TIM_CHANNEL_1: get input capture 1 prescaler value–TIM_CHANNEL_2: get input capture 2 prescaler value–TIM_CHANNEL_3: get input capture 3 prescaler value–TIM_CHANNEL_4: get input capture 4 prescaler value

Return value:
• The: input capture prescaler can be one of the following values:–TIM_ICPSC_DIV1: no prescaler–TIM_ICPSC_DIV2: capture is done once every 2 events–TIM_ICPSC_DIV4: capture is done once every 4 events–TIM_ICPSC_DIV8: capture is done once every 8 events

Parameters:
• __HANDLE__: TIM handle.
• __CHANNEL__: TIM Channel associated with the capture compare register This parameter can be one ofthe following values:–TIM_CHANNEL_1: get capture/compare 1 register value–TIM_CHANNEL_2: get capture/compare 2 register value–TIM_CHANNEL_3: get capture/compare 3 register value–TIM_CHANNEL_4: get capture/compare 4 register value

Notes:
• When fast mode is enabled an active edge on the trigger input acts like a compare match on CCx output.Delay to sample the trigger input and to activate CCx output is reduced to 3 clock cycles. Fast mode actsonly if the channel is configured in PWM1 or PWM2 mode.

Notes:
• When fast mode is disabled CCx output behaves normally depending on counter and CCRx values evenwhen the trigger is ON. The minimum delay to activate CCx output when an active edge occurs on thetrigger input is 5 clock cycles.

Notes:
• When the URS bit of the TIMx_CR1 register is reset, any of the following events generate an updateinterrupt or DMA request (if enabled): _ Counter overflow underflow _ Setting the UG bit _ Updategeneration through the slave mode controller


• uint32_t TIM_HallSensor_InitTypeDef::IC1FilterSpecifies the input capture filter. This parameter can be a number between Min_Data = 0x0 and Max_Data =0xF
• uint32_t TIM_HallSensor_InitTypeDef::Commutation_DelaySpecifies the pulse value to be loaded into the Capture Compare Register. This parameter can be a numberbetween Min_Data = 0x0000 and Max_Data = 0xFFFF

This section provides functions allowing to:
• Initialize and configure TIM HAL Sensor.
• De-initialize TIM HAL Sensor.
• Start the Hall Sensor Interface.
• Stop the Hall Sensor Interface.
• Start the Hall Sensor Interface and enable interrupts.
• Stop the Hall Sensor Interface and disable interrupts.
• Start the Hall Sensor Interface and enable DMA transfers.
• Stop the Hall Sensor Interface and disable DMA transfers.

This section provides functions allowing to:
• Start the Complementary Output Compare/PWM.
• Stop the Complementary Output Compare/PWM.
• Start the Complementary Output Compare/PWM and enable interrupts.
• Stop the Complementary Output Compare/PWM and disable interrupts.
• Start the Complementary Output Compare/PWM and enable DMA transfers.
• Stop the Complementary Output Compare/PWM and disable DMA transfers.

This section provides functions allowing to:
• Start the Complementary PWM.
• Stop the Complementary PWM.
• Start the Complementary PWM and enable interrupts.
• Stop the Complementary PWM and disable interrupts.
• Start the Complementary PWM and enable DMA transfers.
• Stop the Complementary PWM and disable DMA transfers.
• Start the Complementary Input Capture measurement.
• Stop the Complementary Input Capture.
• Start the Complementary Input Capture and enable interrupts.
• Stop the Complementary Input Capture and disable interrupts.
• Start the Complementary Input Capture and enable DMA transfers.
• Stop the Complementary Input Capture and disable DMA transfers.
• Start the Complementary One Pulse generation.
• Stop the Complementary One Pulse.
• Start the Complementary One Pulse and enable interrupts.
• Stop the Complementary One Pulse and disable interrupts.

This section provides functions allowing to:
• Configure the commutation event in case of use of the Hall sensor interface.
• Configure Output channels for OC and PWM mode.
• Configure Complementary channels, break features and dead time.


• htim: TIM Output Compare handle
• Channel: TIM Channel to be enabled This parameter can be one of the following values:–TIM_CHANNEL_1: TIM Channel 1 selected–TIM_CHANNEL_2: TIM Channel 2 selected–TIM_CHANNEL_3: TIM Channel 3 selected
• pData: The source Buffer address.
• Length: The length of data to be transferred from memory to TIM peripheral


• htim: TIM handle
• Channel: TIM Channel to be enabled This parameter can be one of the following values:–TIM_CHANNEL_1: TIM Channel 1 selected–TIM_CHANNEL_2: TIM Channel 2 selected–TIM_CHANNEL_3: TIM Channel 3 selected
• pData: The source Buffer address.
• Length: The length of data to be transferred from memory to TIM peripheral


• htim: TIM handle
• InputTrigger: the Internal trigger corresponding to the Timer Interfacing with the Hall sensor Thisparameter can be one of the following values:–TIM_TS_ITR0: Internal trigger 0 selected–TIM_TS_ITR1: Internal trigger 1 selected–TIM_TS_ITR2: Internal trigger 2 selected–TIM_TS_ITR3: Internal trigger 3 selected–TIM_TS_NONE: No trigger is needed
• CommutationSource: the Commutation Event source This parameter can be one of the following values:–TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer–TIM_COMMUTATION_SOFTWARE: Commutation source is set by software using the COMG bit


• This function is mandatory to use the commutation event in order to update the configuration at eachcommutation detection on the TRGI input of the Timer, the typical use of this feature is with the use ofanother Timer(interface Timer) configured in Hall sensor interface, this interface Timer will generate thecommutation at its TRGO output (connected to Timer used in this function) each time the TI1 of theInterface Timer detect a commutation at its input TI1.


• htim: TIM handle
• InputTrigger: the Internal trigger corresponding to the Timer Interfacing with the Hall sensor Thisparameter can be one of the following values:–TIM_TS_ITR0: Internal trigger 0 selected–TIM_TS_ITR1: Internal trigger 1 selected–TIM_TS_ITR2: Internal trigger 2 selected–TIM_TS_ITR3: Internal trigger 3 selected–TIM_TS_NONE: No trigger is needed
• CommutationSource: the Commutation Event source This parameter can be one of the following values:–TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer–TIM_COMMUTATION_SOFTWARE: Commutation source is set by software using the COMG bit


• This function is mandatory to use the commutation event in order to update the configuration at eachcommutation detection on the TRGI input of the Timer, the typical use of this feature is with the use ofanother Timer(interface Timer) configured in Hall sensor interface, this interface Timer will generate thecommutation at its TRGO output (connected to Timer used in this function) each time the TI1 of theInterface Timer detect a commutation at its input TI1.


• htim: TIM handle
• InputTrigger: the Internal trigger corresponding to the Timer Interfacing with the Hall sensor Thisparameter can be one of the following values:–TIM_TS_ITR0: Internal trigger 0 selected–TIM_TS_ITR1: Internal trigger 1 selected–TIM_TS_ITR2: Internal trigger 2 selected–TIM_TS_ITR3: Internal trigger 3 selected–TIM_TS_NONE: No trigger is needed
• CommutationSource: the Commutation Event source This parameter can be one of the following values:–TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer–TIM_COMMUTATION_SOFTWARE: Commutation source is set by software using the COMG bit


• This function is mandatory to use the commutation event in order to update the configuration at eachcommutation detection on the TRGI input of the Timer, the typical use of this feature is with the use ofanother Timer(interface Timer) configured in Hall sensor interface, this interface Timer will generate thecommutation at its TRGO output (connected to Timer used in this function) each time the TI1 of theInterface Timer detect a commutation at its input TI1.
• The user should configure the DMA in his own software, in This function only the COMDE bit is set


• Interrupts can be generated when an active level is detected on the break input, the break 2 input or thesystem break input. Break interrupt can be enabled by calling the __HAL_TIM_ENABLE_IT macro.

Field Documentation
• uint32_t UART_InitTypeDef::BaudRateThis member configures the UART communication baud rate. The baud rate is computed using the followingformula:–IntegerDivider = ((PCLKx) / (16 * (huart->Init.BaudRate)))–FractionalDivider = ((IntegerDivider - ((uint32_t) IntegerDivider)) * 16) + 0.5
• uint32_t UART_InitTypeDef::WordLengthSpecifies the number of data bits transmitted or received in a frame. This parameter can be a value ofUART_Word_Length


• uint32_t UART_InitTypeDef::ParitySpecifies the parity mode. This parameter can be a value of UART_ParityNote:–When parity is enabled, the computed parity is inserted at the MSB position of the transmitted data (9thbit when the word length is set to 9 data bits; 8th bit when the word length is set to 8 data bits).
• uint32_t UART_InitTypeDef::ModeSpecifies whether the Receive or Transmit mode is enabled or disabled. This parameter can be a value ofUART_Mode


• uint32_t UART_InitTypeDef::OverSamplingSpecifies whether the Over sampling 8 is enabled or disabled, to achieve higher speed (up to fPCLK/8). Thisparameter can be a value of UART_Over_Sampling. This feature is only available on STM32F100xx family,so OverSampling parameter should always be set to 16.

The compilation define USE_HAL_UART_REGISTER_CALLBACKS when set to 1 allows the user to configuredynamically the driver callbacks.Use Function @ref HAL_UART_RegisterCallback() to register a user callback. Function @refHAL_UART_RegisterCallback() allows to register following callbacks:
• TxHalfCpltCallback : Tx Half Complete Callback.
• TxCpltCallback : Tx Complete Callback.
• RxHalfCpltCallback : Rx Half Complete Callback.
• RxCpltCallback : Rx Complete Callback.
• ErrorCallback : Error Callback.
• AbortCpltCallback : Abort Complete Callback.
• AbortTransmitCpltCallback : Abort Transmit Complete Callback.
• AbortReceiveCpltCallback : Abort Receive Complete Callback.
• MspInitCallback : UART MspInit.
• MspDeInitCallback : UART MspDeInit. This function takes as parameters the HAL peripheral handle, theCallback ID and a pointer to the user callback function.

Use function @ref HAL_UART_UnRegisterCallback() to reset a callback to the default weak (surcharged)function. @ref HAL_UART_UnRegisterCallback() takes as parameters the HAL peripheral handle, and theCallback ID. This function allows to reset following callbacks:


• TxHalfCpltCallback : Tx Half Complete Callback.
• TxCpltCallback : Tx Complete Callback.
• RxHalfCpltCallback : Rx Half Complete Callback.
• RxCpltCallback : Rx Complete Callback.
• ErrorCallback : Error Callback.
• AbortCpltCallback : Abort Complete Callback.
• AbortTransmitCpltCallback : Abort Transmit Complete Callback.
• AbortReceiveCpltCallback : Abort Receive Complete Callback.
• MspInitCallback : UART MspInit.
• MspDeInitCallback : UART MspDeInit.

By default, after the @ref HAL_UART_Init() and when the state is HAL_UART_STATE_RESET all callbacks areset to the corresponding weak (surcharged) functions: examples @ref HAL_UART_TxCpltCallback(), @refHAL_UART_RxHalfCpltCallback(). Exception done for MspInit and MspDeInit functions that are respectively resetto the legacy weak (surcharged) functions in the @ref HAL_UART_Init() and @ref HAL_UART_DeInit() only whenthese callbacks are null (not registered beforehand). If not, MspInit or MspDeInit are not null, the @refHAL_UART_Init() and @ref HAL_UART_DeInit() keep and use the user MspInit/MspDeInit callbacks (registeredbeforehand).Callbacks can be registered/unregistered in HAL_UART_STATE_READY state only. Exception done MspInit/MspDeInit that can be registered/unregistered in HAL_UART_STATE_READY or HAL_UART_STATE_RESETstate, thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit. In that case first registerthe MspInit/MspDeInit user callbacks using @ref HAL_UART_RegisterCallback() before calling @refHAL_UART_DeInit() or @ref HAL_UART_Init() function.When The compilation define USE_HAL_UART_REGISTER_CALLBACKS is set to 0 or not defined, the callbackregistration feature is not available and weak (surcharged) callbacks are used.Three operation modes are available within this driver :


• Send an amount of data in non blocking mode using HAL_UART_Transmit_IT()
• At transmission end of transfer HAL_UART_TxCpltCallback is executed and user can add his own code bycustomization of function pointer HAL_UART_TxCpltCallback
• Receive an amount of data in non blocking mode using HAL_UART_Receive_IT()
• At reception end of transfer HAL_UART_RxCpltCallback is executed and user can add his own code bycustomization of function pointer HAL_UART_RxCpltCallback
• In case of transfer Error, HAL_UART_ErrorCallback() function is executed and user can add his own codeby customization of function pointer HAL_UART_ErrorCallback


• Send an amount of data in non blocking mode (DMA) using HAL_UART_Transmit_DMA()
• At transmission end of half transfer HAL_UART_TxHalfCpltCallback is executed and user can add his owncode by customization of function pointer HAL_UART_TxHalfCpltCallback
• At transmission end of transfer HAL_UART_TxCpltCallback is executed and user can add his own code bycustomization of function pointer HAL_UART_TxCpltCallback
• Receive an amount of data in non blocking mode (DMA) using HAL_UART_Receive_DMA()
• At reception end of half transfer HAL_UART_RxHalfCpltCallback is executed and user can add his owncode by customization of function pointer HAL_UART_RxHalfCpltCallback
• At reception end of transfer HAL_UART_RxCpltCallback is executed and user can add his own code bycustomization of function pointer HAL_UART_RxCpltCallback
• In case of transfer Error, HAL_UART_ErrorCallback() function is executed and user can add his own codeby customization of function pointer HAL_UART_ErrorCallback

This subsection provides a set of functions allowing to initialize the USARTx or the UARTy in asynchronous mode.
• For the asynchronous mode only these parameters can be configured:–Baud Rate–Word Length–Stop Bit–Parity: If the parity is enabled, then the MSB bit of the data written in the data register is transmitted butis changed by the parity bit. Depending on the frame length defined by the M bit (8-bits or 9-bits),please refer to Reference manual for possible UART frame formats.–Hardware flow control–Receiver/transmitter modes–Over Sampling Method

The HAL_UART_Init(), HAL_HalfDuplex_Init(), HAL_LIN_Init() and HAL_MultiProcessor_Init() APIs followrespectively the UART asynchronous, UART Half duplex, LIN and Multi-Processor configuration procedures(details for the procedures are available in reference manuals (RM0008 for STM32F10Xxx MCUs and RM0041for STM32F100xx MCUs)).This section contains the following APIs:
• HAL_UART_Init

This subsection provides a set of functions allowing to control the UART:
• HAL_LIN_SendBreak() API can be helpful to transmit the break character.
• HAL_MultiProcessor_EnterMuteMode() API can be helpful to enter the UART in mute mode.
• HAL_MultiProcessor_ExitMuteMode() API can be helpful to exit the UART mute mode by software.
• HAL_HalfDuplex_EnableTransmitter() API to enable the UART transmitter and disables the UART receiverin Half Duplex mode
• HAL_HalfDuplex_EnableReceiver() API to enable the UART receiver and disables the UART transmitter inHalf Duplex mode

This subsection provides a set of functions allowing to return the State of UART communication process, returnPeripheral Errors occurred during communication process
• HAL_UART_GetState() API can be helpful to check in run-time the state of the UART peripheral.
• HAL_UART_GetError() check in run-time errors that could be occurred during communication.


• huart: Pointer to a UART_HandleTypeDef structure that contains the configuration information for thespecified UART module.
• BreakDetectLength: Specifies the LIN break detection length. This parameter can be one of the followingvalues:–UART_LINBREAKDETECTLENGTH_10B: 10-bit break detection–UART_LINBREAKDETECTLENGTH_11B: 11-bit break detection


• huart: Pointer to a UART_HandleTypeDef structure that contains the configuration information for thespecified UART module.
• pData: Pointer to data buffer (u8 or u16 data elements).
• Size: Amount of data elements (u8 or u16) to be sent
• Timeout: Timeout duration


• When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01), thesent data is handled as a set of u16. In this case, Size must indicate the number of u16 provided throughpData.


• huart: Pointer to a UART_HandleTypeDef structure that contains the configuration information for thespecified UART module.
• pData: Pointer to data buffer (u8 or u16 data elements).
• Size: Amount of data elements (u8 or u16) to be received.
• Timeout: Timeout duration


• When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01), thereceived data is handled as a set of u16. In this case, Size must indicate the number of u16 availablethrough pData.


• huart: Pointer to a UART_HandleTypeDef structure that contains the configuration information for thespecified UART module.
• pData: Pointer to data buffer (u8 or u16 data elements).
• Size: Amount of data elements (u8 or u16) to be sent


• When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01), thesent data is handled as a set of u16. In this case, Size must indicate the number of u16 provided throughpData.


• huart: Pointer to a UART_HandleTypeDef structure that contains the configuration information for thespecified UART module.
• pData: Pointer to data buffer (u8 or u16 data elements).
• Size: Amount of data elements (u8 or u16) to be received.


• When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01), thereceived data is handled as a set of u16. In this case, Size must indicate the number of u16 availablethrough pData.


• huart: Pointer to a UART_HandleTypeDef structure that contains the configuration information for thespecified UART module.
• pData: Pointer to data buffer (u8 or u16 data elements).
• Size: Amount of data elements (u8 or u16) to be sent


• When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01), thesent data is handled as a set of u16. In this case, Size must indicate the number of u16 provided throughpData.


• huart: Pointer to a UART_HandleTypeDef structure that contains the configuration information for thespecified UART module.
• pData: Pointer to data buffer (u8 or u16 data elements).
• Size: Amount of data elements (u8 or u16) to be received.


• When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01), thereceived data is handled as a set of u16. In this case, Size must indicate the number of u16 availablethrough pData.
• When the UART parity is enabled (PCE = 1) the received data contains the parity bit.


• This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode. Thisprocedure performs following operations : Disable UART Interrupts (Tx and Rx)Disable the DMA transfer inthe peripheral register (if enabled)Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer inDMA mode)Set handle State to READY
• This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.


• This procedure could be used for aborting any ongoing Tx transfer started in Interrupt or DMA mode. Thisprocedure performs following operations : Disable UART Interrupts (Tx)Disable the DMA transfer in theperipheral register (if enabled)Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMAmode)Set handle State to READY
• This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.


• This procedure could be used for aborting any ongoing Rx transfer started in Interrupt or DMA mode. Thisprocedure performs following operations : Disable UART Interrupts (Rx)Disable the DMA transfer in theperipheral register (if enabled)Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMAmode)Set handle State to READY
• This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.


• This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode. Thisprocedure performs following operations : Disable UART Interrupts (Tx and Rx)Disable the DMA transfer inthe peripheral register (if enabled)Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer inDMA mode)Set handle State to READYAt abort completion, call user abort complete callback
• This procedure is executed in Interrupt mode, meaning that abort procedure could be considered ascompleted only when user abort complete callback is executed (not when exiting function).


• This procedure could be used for aborting any ongoing Tx transfer started in Interrupt or DMA mode. Thisprocedure performs following operations : Disable UART Interrupts (Tx)Disable the DMA transfer in theperipheral register (if enabled)Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer inDMA mode)Set handle State to READYAt abort completion, call user abort complete callback
• This procedure is executed in Interrupt mode, meaning that abort procedure could be considered ascompleted only when user abort complete callback is executed (not when exiting function).


• This procedure could be used for aborting any ongoing Rx transfer started in Interrupt or DMA mode. Thisprocedure performs following operations : Disable UART Interrupts (Rx)Disable the DMA transfer in theperipheral register (if enabled)Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer inDMA mode)Set handle State to READYAt abort completion, call user abort complete callback
• This procedure is executed in Interrupt mode, meaning that abort procedure could be considered ascompleted only when user abort complete callback is executed (not when exiting function).

Notes:
• PE (Parity error), FE (Framing error), NE (Noise error), ORE (Overrun error) and IDLE (Idle line detected)flags are cleared by software sequence: a read operation to USART_SR register followed by a readoperation to USART_DR register. RXNE flag can be also cleared by a read to the USART_DR register. TCflag can be also cleared by software sequence: a read operation to USART_SR register followed by a writeoperation to USART_DR register. TXE flag is cleared only by a write to the USART_DR register.

Parameters:
• __HANDLE__: specifies the UART Handle. The Handle Instance can be any USARTx (supporting the HWFlow control feature). It is used to select the USART peripheral (USART availability and x value dependingon device).

Notes:
• This macro allows to enable CTS hardware flow control for a given UART instance, without need to callHAL_UART_Init() function. As involving direct access to UART registers, usage of this macro should befully endorsed by user. As macro is expected to be used for modifying CTS Hw flow control featureactivation, without need for USART instance Deinit/Init, following conditions for macro call should befulfilled : UART instance should have already been initialised (through call of HAL_UART_Init() )macrocould only be called when corresponding UART instance is disabled (i.e__HAL_UART_DISABLE(__HANDLE__)) and should be followed by an Enable macro (i.e__HAL_UART_ENABLE(__HANDLE__)).

Parameters:
• __HANDLE__: specifies the UART Handle. The Handle Instance can be any USARTx (supporting the HWFlow control feature). It is used to select the USART peripheral (USART availability and x value dependingon device).

Notes:
• This macro allows to disable CTS hardware flow control for a given UART instance, without need to callHAL_UART_Init() function. As involving direct access to UART registers, usage of this macro should befully endorsed by user. As macro is expected to be used for modifying CTS Hw flow control featureactivation, without need for USART instance Deinit/Init, following conditions for macro call should befulfilled : UART instance should have already been initialised (through call of HAL_UART_Init() )macrocould only be called when corresponding UART instance is disabled (i.e__HAL_UART_DISABLE(__HANDLE__)) and should be followed by an Enable macro (i.e__HAL_UART_ENABLE(__HANDLE__)).

Parameters:
• __HANDLE__: specifies the UART Handle. The Handle Instance can be any USARTx (supporting the HWFlow control feature). It is used to select the USART peripheral (USART availability and x value dependingon device).

Notes:
• As macro is expected to be used for modifying RTS Hw flow control feature activation, without need forUSART instance Deinit/Init, following conditions for macro call should be fulfilled : UART instance shouldhave already been initialised (through call of HAL_UART_Init() )macro could only be called whencorresponding UART instance is disabled (i.e __HAL_UART_DISABLE(__HANDLE__)) and should befollowed by an Enable macro (i.e __HAL_UART_ENABLE(__HANDLE__)).

Parameters:
• __HANDLE__: specifies the UART Handle. The Handle Instance can be any USARTx (supporting the HWFlow control feature). It is used to select the USART peripheral (USART availability and x value dependingon device).

Notes:
• As macro is expected to be used for modifying RTS Hw flow control feature activation, without need forUSART instance Deinit/Init, following conditions for macro call should be fulfilled : UART instance shouldhave already been initialised (through call of HAL_UART_Init() )macro could only be called whencorresponding UART instance is disabled (i.e __HAL_UART_DISABLE(__HANDLE__)) and should befollowed by an Enable macro (i.e __HAL_UART_ENABLE(__HANDLE__)).

Field Documentation
• uint32_t USART_InitTypeDef::BaudRateThis member configures the Usart communication baud rate. The baud rate is computed using the followingformula:–IntegerDivider = ((PCLKx) / (16 * (husart->Init.BaudRate)))–FractionalDivider = ((IntegerDivider - ((uint32_t) IntegerDivider)) * 16) + 0.5
• uint32_t USART_InitTypeDef::WordLengthSpecifies the number of data bits transmitted or received in a frame. This parameter can be a value ofUSART_Word_Length


• uint32_t USART_InitTypeDef::ParitySpecifies the parity mode. This parameter can be a value of USART_ParityNote:–When parity is enabled, the computed parity is inserted at the MSB position of the transmitted data (9thbit when the word length is set to 9 data bits; 8th bit when the word length is set to 8 data bits).
• uint32_t USART_InitTypeDef::ModeSpecifies whether the Receive or Transmit mode is enabled or disabled. This parameter can be a value ofUSART_Mode


• uint32_t USART_InitTypeDef::CLKLastBitSpecifies whether the clock pulse corresponding to the last transmitted data bit (MSB) has to be output onthe SCLK pin in synchronous mode. This parameter can be a value of USART_Last_Bit


• Send an amount of data in non blocking mode using HAL_USART_Transmit_IT()
• At transmission end of transfer HAL_USART_TxHalfCpltCallback is executed and user can add his owncode by customization of function pointer HAL_USART_TxCpltCallback
• Receive an amount of data in non blocking mode using HAL_USART_Receive_IT()
• At reception end of transfer HAL_USART_RxCpltCallback is executed and user can add his own code bycustomization of function pointer HAL_USART_RxCpltCallback
• In case of transfer Error, HAL_USART_ErrorCallback() function is executed and user can add his own codeby customization of function pointer HAL_USART_ErrorCallback


• Send an amount of data in non blocking mode (DMA) using HAL_USART_Transmit_DMA()
• At transmission end of half transfer HAL_USART_TxHalfCpltCallback is executed and user can add his owncode by customization of function pointer HAL_USART_TxHalfCpltCallback
• At transmission end of transfer HAL_USART_TxCpltCallback is executed and user can add his own code bycustomization of function pointer HAL_USART_TxCpltCallback
• Receive an amount of data in non blocking mode (DMA) using HAL_USART_Receive_DMA()


• At reception end of half transfer HAL_USART_RxHalfCpltCallback is executed and user can add his owncode by customization of function pointer HAL_USART_RxHalfCpltCallback
• At reception end of transfer HAL_USART_RxCpltCallback is executed and user can add his own code bycustomization of function pointer HAL_USART_RxCpltCallback
• In case of transfer Error, HAL_USART_ErrorCallback() function is executed and user can add his own codeby customization of function pointer HAL_USART_ErrorCallback
• Pause the DMA Transfer using HAL_USART_DMAPause()
• Resume the DMA Transfer using HAL_USART_DMAResume()
• Stop the DMA Transfer using HAL_USART_DMAStop()

The compilation define USE_HAL_USART_REGISTER_CALLBACKS when set to 1 allows the user to configuredynamically the driver callbacks.Use Function @ref HAL_USART_RegisterCallback() to register a user callback. Function @refHAL_USART_RegisterCallback() allows to register following callbacks:
• TxHalfCpltCallback : Tx Half Complete Callback.
• TxCpltCallback : Tx Complete Callback.
• RxHalfCpltCallback : Rx Half Complete Callback.
• RxCpltCallback : Rx Complete Callback.
• TxRxCpltCallback : Tx Rx Complete Callback.
• ErrorCallback : Error Callback.
• AbortCpltCallback : Abort Complete Callback.
• MspInitCallback : USART MspInit.
• MspDeInitCallback : USART MspDeInit. This function takes as parameters the HAL peripheral handle, theCallback ID and a pointer to the user callback function.

Use function @ref HAL_USART_UnRegisterCallback() to reset a callback to the default weak (surcharged)function. @ref HAL_USART_UnRegisterCallback() takes as parameters the HAL peripheral handle, and theCallback ID. This function allows to reset following callbacks:
• TxHalfCpltCallback : Tx Half Complete Callback.
• TxCpltCallback : Tx Complete Callback.
• RxHalfCpltCallback : Rx Half Complete Callback.
• RxCpltCallback : Rx Complete Callback.
• TxRxCpltCallback : Tx Rx Complete Callback.
• ErrorCallback : Error Callback.
• AbortCpltCallback : Abort Complete Callback.
• MspInitCallback : USART MspInit.
• MspDeInitCallback : USART MspDeInit.

By default, after the @ref HAL_USART_Init() and when the state is HAL_USART_STATE_RESET all callbacksare set to the corresponding weak (surcharged) functions: examples @ref HAL_USART_TxCpltCallback(), @refHAL_USART_RxHalfCpltCallback(). Exception done for MspInit and MspDeInit functions that are respectivelyreset to the legacy weak (surcharged) functions in the @ref HAL_USART_Init() and @ref HAL_USART_DeInit()only when these callbacks are null (not registered beforehand). If not, MspInit or MspDeInit are not null, the @refHAL_USART_Init() and @ref HAL_USART_DeInit() keep and use the user MspInit/MspDeInit callbacks(registered beforehand).Callbacks can be registered/unregistered in HAL_USART_STATE_READY state only. Exception done MspInit/MspDeInit that can be registered/unregistered in HAL_USART_STATE_READY or HAL_USART_STATE_RESETstate, thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit. In that case first registerthe MspInit/MspDeInit user callbacks using @ref HAL_USART_RegisterCallback() before calling @refHAL_USART_DeInit() or @ref HAL_USART_Init() function.When The compilation define USE_HAL_USART_REGISTER_CALLBACKS is set to 0 or not defined, thecallback registration feature is not available and weak (surcharged) callbacks are used.

This subsection provides a set of functions allowing to initialize the USART in asynchronous and in synchronousmodes.
• For the asynchronous mode only these parameters can be configured:–Baud Rate–Word Length–Stop Bit–Parity: If the parity is enabled, then the MSB bit of the data written in the data register is transmitted butis changed by the parity bit. Depending on the frame length defined by the M bit (8-bits or 9-bits),please refer to Reference manual for possible USART frame formats.–USART polarity–USART phase–USART LastBit–Receiver/transmitter modes

This subsection provides a set of functions allowing to manage the USART synchronous data transfers.The USART supports master mode only: it cannot receive or send data related to an input clock (SCLK is alwaysan output).

This subsection provides a set of functions allowing to return the State of USART communication process, returnPeripheral Errors occurred during communication process
• HAL_USART_GetState() API can be helpful to check in run-time the state of the USART peripheral.
• HAL_USART_GetError() check in run-time errors that could be occurred during communication.


• husart: Pointer to a USART_HandleTypeDef structure that contains the configuration information for thespecified USART module.
• pTxData: Pointer to data buffer (u8 or u16 data elements).
• Size: Amount of data elements (u8 or u16) to be sent.
• Timeout: Timeout duration.


• When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01), thesent data is handled as a set of u16. In this case, Size must indicate the number of u16 provided throughpTxData.


• husart: Pointer to a USART_HandleTypeDef structure that contains the configuration information for thespecified USART module.
• pRxData: Pointer to data buffer (u8 or u16 data elements).
• Size: Amount of data elements (u8 or u16) to be received.
• Timeout: Timeout duration.


• To receive synchronous data, dummy data are simultaneously transmitted.
• When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01), thereceived data is handled as a set of u16. In this case, Size must indicate the number of u16 availablethrough pRxData.


• husart: Pointer to a USART_HandleTypeDef structure that contains the configuration information for thespecified USART module.
• pTxData: Pointer to TX data buffer (u8 or u16 data elements).
• pRxData: Pointer to RX data buffer (u8 or u16 data elements).
• Size: Amount of data elements (u8 or u16) to be sent (same amount to be received).
• Timeout: Timeout duration


• When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01), thesent data and the received data are handled as sets of u16. In this case, Size must indicate the number ofu16 available through pTxData and through pRxData.


• husart: Pointer to a USART_HandleTypeDef structure that contains the configuration information for thespecified USART module.
• pTxData: Pointer to data buffer (u8 or u16 data elements).
• Size: Amount of data elements (u8 or u16) to be sent.


• When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01), thesent data is handled as a set of u16. In this case, Size must indicate the number of u16 provided throughpTxData.
• The USART errors are not managed to avoid the overrun error.


• husart: Pointer to a USART_HandleTypeDef structure that contains the configuration information for thespecified USART module.
• pRxData: Pointer to data buffer (u8 or u16 data elements).
• Size: Amount of data elements (u8 or u16) to be received.


• To receive synchronous data, dummy data are simultaneously transmitted.
• When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01), thereceived data is handled as a set of u16. In this case, Size must indicate the number of u16 availablethrough pRxData.


• husart: Pointer to a USART_HandleTypeDef structure that contains the configuration information for thespecified USART module.
• pTxData: Pointer to TX data buffer (u8 or u16 data elements).
• pRxData: Pointer to RX data buffer (u8 or u16 data elements).
• Size: Amount of data elements (u8 or u16) to be sent (same amount to be received).


• When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01), thesent data and the received data are handled as sets of u16. In this case, Size must indicate the number ofu16 available through pTxData and through pRxData.


• husart: Pointer to a USART_HandleTypeDef structure that contains the configuration information for thespecified USART module.
• pTxData: Pointer to data buffer (u8 or u16 data elements).
• Size: Amount of data elements (u8 or u16) to be sent.


• When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01), thesent data is handled as a set of u16. In this case, Size must indicate the number of u16 provided throughpTxData.


• husart: Pointer to a USART_HandleTypeDef structure that contains the configuration information for thespecified USART module.
• pRxData: Pointer to data buffer (u8 or u16 data elements).
• Size: Amount of data elements (u8 or u16) to be received.


• When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01), thereceived data is handled as a set of u16. In this case, Size must indicate the number of u16 availablethrough pRxData.
• The USART DMA transmit channel must be configured in order to generate the clock for the slave.
• When the USART parity is enabled (PCE = 1) the data received contain the parity bit.


• husart: Pointer to a USART_HandleTypeDef structure that contains the configuration information for thespecified USART module.
• pTxData: Pointer to TX data buffer (u8 or u16 data elements).
• pRxData: Pointer to RX data buffer (u8 or u16 data elements).
• Size: Amount of data elements (u8 or u16) to be received/sent.


• When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01), thesent data and the received data are handled as sets of u16. In this case, Size must indicate the number ofu16 available through pTxData and through pRxData.
• When the USART parity is enabled (PCE = 1) the data received contain the parity bit.


• This procedure could be used for aborting any ongoing transfer (either Tx or Rx, as described byTransferType parameter) started in Interrupt or DMA mode. This procedure performs following operations :Disable PPP Interrupts (depending of transfer direction)Disable the DMA transfer in the peripheral register(if enabled)Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)Set handleState to READY
• This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.


• This procedure could be used for aborting any ongoing transfer (either Tx or Rx, as described byTransferType parameter) started in Interrupt or DMA mode. This procedure performs following operations :Disable PPP Interrupts (depending of transfer direction)Disable the DMA transfer in the peripheral register(if enabled)Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMA mode)Set handleState to READYAt abort completion, call user abort complete callback
• This procedure is executed in Interrupt mode, meaning that abort procedure could be considered ascompleted only when user abort complete callback is executed (not when exiting function).

Parameters:
• __HANDLE__: specifies the USART Handle. USART Handle selects the USARTx peripheral (USARTavailability and x value depending on device).
• __FLAG__: specifies the flag to check. This parameter can be any combination of the following values:–USART_FLAG_TC: Transmission Complete flag.–USART_FLAG_RXNE: Receive data register not empty flag.

Notes:
• PE (Parity error), FE (Framing error), NE (Noise error), ORE (Overrun error) and IDLE (Idle line detected)flags are cleared by software sequence: a read operation to USART_SR register followed by a readoperation to USART_DR register. RXNE flag can be also cleared by a read to the USART_DR register. TCflag can be also cleared by software sequence: a read operation to USART_SR register followed by a writeoperation to USART_DR register. TXE flag is cleared only by a write to the USART_DR register.

Parameters:
• __HANDLE__: specifies the USART Handle. USART Handle selects the USARTx peripheral (USARTavailability and x value depending on device).
• __INTERRUPT__: specifies the USART interrupt source to check. This parameter can be one of thefollowing values:–USART_IT_TXE: Transmit Data Register empty interrupt–USART_IT_TC: Transmission complete interrupt–USART_IT_RXNE: Receive Data register not empty interrupt–USART_IT_IDLE: Idle line detection interrupt–USART_IT_PE: Parity Error interrupt–USART_IT_ERR: Error interrupt(Frame error, noise error, overrun error)

Parameters:
• __HANDLE__: specifies the USART Handle. USART Handle selects the USARTx peripheral (USARTavailability and x value depending on device).
• __IT__: specifies the USART interrupt source to check. This parameter can be one of the following values:–USART_IT_TXE: Transmit Data Register empty interrupt–USART_IT_TC: Transmission complete interrupt–USART_IT_RXNE: Receive Data register not empty interrupt–USART_IT_IDLE: Idle line detection interrupt–USART_IT_ERR: Error interrupt–USART_IT_PE: Parity Error interrupt


• uint32_t WWDG_InitTypeDef::WindowSpecifies the WWDG window value to be compared to the downcounter. This parameter must be a numberMin_Data = 0x40 and Max_Data = 0x7F
• uint32_t WWDG_InitTypeDef::CounterSpecifies the WWDG free-running downcounter value. This parameter must be a number between Min_Data= 0x40 and Max_Data = 0x7F
• uint32_t WWDG_InitTypeDef::EWIModeSpecifies if WWDG Early Wakeup Interupt is enable or not. This parameter can be a value ofWWDG_EWI_Mode

Once enabled the WWDG generates a system reset on expiry of a programmed time period, unless the programrefreshes the counter (downcounter) before reaching 0x3F value (i.e. a reset is generated when the counter valuerolls over from 0x40 to 0x3F).
• An MCU reset is also generated if the counter value is refreshed before the counter has reached the refreshwindow value. This implies that the counter must be refreshed in a limited window.
• Once enabled the WWDG cannot be disabled except by a system reset.
• WWDGRST flag in RCC_CSR register can be used to inform when a WWDG reset occurs.
• The WWDG counter input clock is derived from the APB clock divided by a programmable prescaler.
• WWDG clock (Hz) = PCLK1 / (4096 * Prescaler)


• WWDG timeout (mS) = 1000 * Counter / WWDG clock
• WWDG Counter refresh is allowed between the following limits :–min time (mS) = 1000 * (Counter _ Window) / WWDG clock–max time (mS) = 1000 * (Counter _ 0x40) / WWDG clock
• Min-max timeout value at 36 MHz(PCLK1): 910 us / 58.25 ms
• The Early Wakeup Interrupt (EWI) can be used if specific safety operations or data logging must beperformed before the actual reset is generated. When the downcounter reaches the value 0x40, an EWIinterrupt is generated and the corresponding interrupt service routine (ISR) can be used to trigger specificactions (such as communications or data logging), before resetting the device. In some applications, theEWI interrupt can be used to manage a software system check and/or system recovery/gracefuldegradation, without generating a WWDG reset. In this case, the corresponding interrupt service routine(ISR) should reload the WWDG counter to avoid the WWDG reset, then trigger the required actions.Note:When the EWI interrupt cannot be served, e.g. due to a system lock in a higher priority task, theWWDG reset will eventually be generated.
• Debug mode : When the microcontroller enters debug mode (core halted), the WWDG counter eithercontinues to work normally or stops, depending on DBG_WWDG_STOP configuration bit in DBG module,accessible through __HAL_DBGMCU_FREEZE_WWDG() and __HAL_DBGMCU_UNFREEZE_WWDG()macros


• Enable WWDG APB1 clock using __HAL_RCC_WWDG_CLK_ENABLE().
• Set the WWDG prescaler, refresh window, counter value and Early Wakeup Interrupt mode using usingHAL_WWDG_Init() function. This enables WWDG peripheral and the downcounter starts downcounting fromgiven counter value. Init function can be called again to modify all watchdog parameters, however if EWImode has been set once, it can't be clear until next reset.
• The application program must refresh the WWDG counter at regular intervals during normal operation toprevent an MCU reset using HAL_WWDG_Refresh() function. This operation must occur only when thecounter is lower than the window value already programmed.
• if Early Wakeup Interrupt mode is enable an interrupt is generated when the counter reaches 0x40. User canadd his own code in weak function HAL_WWDG_EarlyWakeupCallback().


• The Early Wakeup Interrupt (EWI) can be used if specific safety operations or data logging must beperformed before the actual reset is generated. The EWI interrupt is enabled by calling HAL_WWDG_Initfunction with EWIMode set to WWDG_EWI_ENABLE. When the downcounter reaches the value 0x40, andEWI interrupt is generated and the corresponding Interrupt Service Routine (ISR) can be used to triggerspecific actions (such as communications or data logging), before resetting the device.

Field Documentation
• uint32_t LL_ADC_CommonInitTypeDef::MultimodeSet ADC multimode configuration to operate in independent mode or multimode (for devices with severalADC instances). This parameter can be a value of ADC_LL_EC_MULTI_MODEThis feature can be modifiedafterwards using unitary function LL_ADC_SetMultimode().

Field Documentation
• uint32_t LL_ADC_InitTypeDef::DataAlignmentSet ADC conversion data alignment. This parameter can be a value of ADC_LL_EC_DATA_ALIGNThisfeature can be modified afterwards using unitary function LL_ADC_SetDataAlignment().
• uint32_t LL_ADC_InitTypeDef::SequencersScanModeSet ADC scan selection. This parameter can be a value of ADC_LL_EC_SCAN_SELECTIONThis featurecan be modified afterwards using unitary function LL_ADC_SetSequencersScanMode().

Field Documentation
• uint32_t LL_ADC_REG_InitTypeDef::TriggerSourceSet ADC group regular conversion trigger source: internal (SW start) or from external IP (timer event,external interrupt line). This parameter can be a value of ADC_LL_EC_REG_TRIGGER_SOURCENote:–On this STM32 serie, external trigger is set with trigger polarity: rising edge (only trigger polarityavailable on this STM32 serie).

This feature can be modified afterwards using unitary function LL_ADC_REG_SetSequencerLength().
• uint32_t LL_ADC_REG_InitTypeDef::SequencerDiscontSet ADC group regular sequencer discontinuous mode: sequence subdivided and scan conversionsinterrupted every selected number of ranks. This parameter can be a value ofADC_LL_EC_REG_SEQ_DISCONT_MODENote:–This parameter has an effect only if group regular sequencer is enabled (scan length of 2 ranks ormore).

This feature can be modified afterwards using unitary function LL_ADC_REG_SetSequencerDiscont().
• uint32_t LL_ADC_REG_InitTypeDef::ContinuousModeSet ADC continuous conversion mode on ADC group regular, whether ADC conversions are performed insingle mode (one conversion per trigger) or in continuous mode (after the first trigger, following conversionslaunched successively automatically). This parameter can be a value ofADC_LL_EC_REG_CONTINUOUS_MODE Note: It is not possible to enable both ADC group regularcontinuous mode and discontinuous mode.This feature can be modified afterwards using unitary functionLL_ADC_REG_SetContinuousMode().
• uint32_t LL_ADC_REG_InitTypeDef::DMATransferSet ADC group regular conversion data transfer: no transfer or transfer by DMA, and DMA requests mode.This parameter can be a value of ADC_LL_EC_REG_DMA_TRANSFERThis feature can be modifiedafterwards using unitary function LL_ADC_REG_SetDMATransfer().

Field Documentation
• uint32_t LL_ADC_INJ_InitTypeDef::TriggerSourceSet ADC group injected conversion trigger source: internal (SW start) or from external IP (timer event,external interrupt line). This parameter can be a value of ADC_LL_EC_INJ_TRIGGER_SOURCENote:–On this STM32 serie, external trigger is set with trigger polarity: rising edge (only trigger polarityavailable on this STM32 serie).

This feature can be modified afterwards using unitary function LL_ADC_INJ_SetTriggerSource().
• uint32_t LL_ADC_INJ_InitTypeDef::SequencerLengthSet ADC group injected sequencer length. This parameter can be a value ofADC_LL_EC_INJ_SEQ_SCAN_LENGTHNote:–This parameter is discarded if scan mode is disabled (refer to parameter'ADC_SequencersScanMode').


• uint32_t LL_ADC_INJ_InitTypeDef::SequencerDiscontSet ADC group injected sequencer discontinuous mode: sequence subdivided and scan conversionsinterrupted every selected number of ranks. This parameter can be a value ofADC_LL_EC_INJ_SEQ_DISCONT_MODENote:–This parameter has an effect only if group injected sequencer is enabled (scan length of 2 ranks ormore).

This feature can be modified afterwards using unitary function LL_ADC_INJ_SetSequencerDiscont().
• uint32_t LL_ADC_INJ_InitTypeDef::TrigAutoSet ADC group injected conversion trigger: independent or from ADC group regular. This parameter can bea value of ADC_LL_EC_INJ_TRIG_AUTO Note: This parameter must be set to set to independent trigger ifinjected trigger source is set to an external trigger.This feature can be modified afterwards using unitaryfunction LL_ADC_INJ_SetTrigAuto().

Function to help to configure DMA transfer from ADC: retrieve the ADC register address from ADC instance anda list of ADC registers intended to be used (most commonly) with DMA transfer.


• These ADC registers are data registers: when ADC conversion data is available in ADC data registers,ADC generates a DMA transfer request.
• This macro is intended to be used with LL DMA driver, refer to function "LL_DMA_ConfigAddresses()".Example: LL_DMA_ConfigAddresses(DMA1, LL_DMA_CHANNEL_1, LL_ADC_DMA_GetRegAddr(ADC1,LL_ADC_DMA_REG_REGULAR_DATA), (uint32_t)&< array or variable >,LL_DMA_DIRECTION_PERIPH_TO_MEMORY);
• For devices with several ADC: in multimode, some devices use a different data register outside of ADCinstance scope (common data register). This macro manages this register difference, only ADC instancehas to be set as parameter.
• On STM32F1, only ADC instances ADC1 and ADC3 have DMA transfer capability, not ADC2 (ADC2 andADC3 instances not available on all devices).
• On STM32F1, multimode can be used only with ADC1 and ADC2, not ADC3. Therefore, the correspondingparameter of data transfer for multimode can be used only with ADC1 and ADC2. (ADC2 and ADC3instances not available on all devices).


• One or several values can be selected. Example: (LL_ADC_PATH_INTERNAL_VREFINT |LL_ADC_PATH_INTERNAL_TEMPSENSOR)
• Stabilization time of measurement path to internal channel: After enabling internal paths, before startingADC conversion, a delay is required for internal voltage reference and temperature sensor stabilizationtime. Refer to device datasheet. Refer to literal LL_ADC_DELAY_TEMPSENSOR_STAB_US.
• ADC internal channel sampling time constraint: For ADC conversion of internal channels, a sampling timeminimum value is required. Refer to device datasheet.

(1) On STM32F1, parameter available on all ADC instances: ADC1, ADC2, ADC3 (for ADC instancesADCx available on the selected device).
• (2) On STM32F1, parameter available only on ADC instances: ADC1, ADC2 (for ADC instances ADCxavailable on the selected device).
• (3) On STM32F1, parameter available only on ADC instances: ADC3 (for ADC instances ADCx availableon the selected device).
• (4) On STM32F1, parameter available only on high-density and XL-density devices. A remap of triggermust be done at top level (refer to AFIO peripheral).


• On this STM32 serie, external trigger is set with trigger polarity: rising edge (only trigger polarity availableon this STM32 serie).
• Availability of parameters of trigger sources from timer depends on timers availability on the selecteddevice.

(1) On STM32F1, parameter available on all ADC instances: ADC1, ADC2, ADC3 (for ADC instancesADCx available on the selected device).
• (2) On STM32F1, parameter available only on ADC instances: ADC1, ADC2 (for ADC instances ADCxavailable on the selected device).
• (3) On STM32F1, parameter available only on ADC instances: ADC3 (for ADC instances ADCx availableon the selected device).
• (4) On STM32F1, parameter available only on high-density and XL-density devices. A remap of triggermust be done at top level (refer to AFIO peripheral).


• To determine whether group regular trigger source is internal (SW start) or external, without detail of whichperipheral is selected as external trigger, (equivalent to "if(LL_ADC_REG_GetTriggerSource(ADC1) ==LL_ADC_REG_TRIG_SOFTWARE)") use function LL_ADC_REG_IsTriggerSourceSWStart.
• Availability of parameters of trigger sources from timer depends on timers availability on the selecteddevice.


• It is not possible to enable both ADC group regular continuous mode and sequencer discontinuous mode.
• It is not possible to enable both ADC auto-injected mode and ADC group regular sequencer discontinuousmode.


• On this STM32 serie, ADC group regular sequencer is fully configurable: sequencer length and each rankaffectation to a channel are configurable. Refer to description of functionLL_ADC_REG_SetSequencerLength().
• Depending on devices and packages, some channels may not be available. Refer to device datasheet forchannels availability.
• Usage of the returned channel number: To reinject this channel into another function LL_ADC_xxx: thereturned channel number is only partly formatted on definition of literals LL_ADC_CHANNEL_x. Therefore,it has to be compared with parts of literals LL_ADC_CHANNEL_x or using helper macro__LL_ADC_CHANNEL_TO_DECIMAL_NB(). Then the selected literal LL_ADC_CHANNEL_x can be usedas parameter for another function.To get the channel number in decimal format: process the returned valuewith the helper macro __LL_ADC_CHANNEL_TO_DECIMAL_NB().


• Description of ADC continuous conversion mode: single mode: one conversion per triggercontinuousmode: after the first trigger, following conversions launched successively automatically.
• It is not possible to enable both ADC group regular continuous mode and sequencer discontinuous mode.


• If transfer by DMA selected, specifies the DMA requests mode: Limited mode (One shot mode): DMAtransfer requests are stopped when number of DMA data transfers (number of ADC conversions) isreached. This ADC mode is intended to be used with DMA mode non-circular.Unlimited mode: DMAtransfer requests are unlimited, whatever number of DMA data transfers (number of ADC conversions).This ADC mode is intended to be used with DMA mode circular.
• If ADC DMA requests mode is set to unlimited and DMA is set to mode non-circular: when DMA transferssize will be reached, DMA will stop transfers of ADC conversions data ADC will raise an overrun error(overrun flag and interruption if enabled).
• To configure DMA source address (peripheral address), use function LL_ADC_DMA_GetRegAddr().


• If transfer by DMA selected, specifies the DMA requests mode: Limited mode (One shot mode): DMAtransfer requests are stopped when number of DMA data transfers (number of ADC conversions) isreached. This ADC mode is intended to be used with DMA mode non-circular.Unlimited mode: DMAtransfer requests are unlimited, whatever number of DMA data transfers (number of ADC conversions).This ADC mode is intended to be used with DMA mode circular.
• If ADC DMA requests mode is set to unlimited and DMA is set to mode non-circular: when DMA transferssize will be reached, DMA will stop transfers of ADC conversions data ADC will raise an overrun error(overrun flag and interruption if enabled).
• To configure DMA source address (peripheral address), use function LL_ADC_DMA_GetRegAddr().

(1) On STM32F1, parameter available on all ADC instances: ADC1, ADC2, ADC3 (for ADC instancesADCx available on the selected device).
• (2) On STM32F1, parameter available only on ADC instances: ADC1, ADC2 (for ADC instances ADCxavailable on the selected device).
• (3) On STM32F1, parameter available only on ADC instances: ADC3 (for ADC instances ADCx availableon the selected device).
• (4) On STM32F1, parameter available only on high-density and XL-density devices. A remap of triggermust be done at top level (refer to AFIO peripheral).


• On this STM32 serie, external trigger is set with trigger polarity: rising edge (only trigger polarity availableon this STM32 serie).
• Availability of parameters of trigger sources from timer depends on timers availability on the selecteddevice.

(1) On STM32F1, parameter available on all ADC instances: ADC1, ADC2, ADC3 (for ADC instancesADCx available on the selected device).
• (2) On STM32F1, parameter available only on ADC instances: ADC1, ADC2 (for ADC instances ADCxavailable on the selected device).
• (3) On STM32F1, parameter available only on ADC instances: ADC3 (for ADC instances ADCx availableon the selected device).
• (4) On STM32F1, parameter available only on high-density and XL-density devices. A remap of triggermust be done at top level (refer to AFIO peripheral).


• To determine whether group injected trigger source is internal (SW start) or external, without detail of whichperipheral is selected as external trigger, (equivalent to "if(LL_ADC_INJ_GetTriggerSource(ADC1) ==LL_ADC_INJ_TRIG_SOFTWARE)") use function LL_ADC_INJ_IsTriggerSourceSWStart.
• Availability of parameters of trigger sources from timer depends on timers availability on the selecteddevice.


• This function performs configuration of: Sequence length: Number of ranks in the scansequence.Sequence direction: Unless specified in parameters, sequencer scan direction is forward (fromrank 1 to rank n).
• On this STM32 serie, group injected sequencer configuration is conditioned to ADC instance sequencermode. If ADC instance sequencer mode is disabled, sequencers of all groups (group regular, groupinjected) can be configured but their execution is disabled (limited to rank 1). Refer to functionLL_ADC_SetSequencersScanMode().
• Sequencer disabled is equivalent to sequencer of 1 rank: ADC conversion on only 1 channel.


• This function retrieves: Sequence length: Number of ranks in the scan sequence.Sequence direction:Unless specified in parameters, sequencer scan direction is forward (from rank 1 to rank n).
• On this STM32 serie, group injected sequencer configuration is conditioned to ADC instance sequencermode. If ADC instance sequencer mode is disabled, sequencers of all groups (group regular, groupinjected) can be configured but their execution is disabled (limited to rank 1). Refer to functionLL_ADC_SetSequencersScanMode().
• Sequencer disabled is equivalent to sequencer of 1 rank: ADC conversion on only 1 channel.


• Depending on devices and packages, some channels may not be available. Refer to device datasheet forchannels availability.
• Usage of the returned channel number: To reinject this channel into another function LL_ADC_xxx: thereturned channel number is only partly formatted on definition of literals LL_ADC_CHANNEL_x. Therefore,it has to be compared with parts of literals LL_ADC_CHANNEL_x or using helper macro__LL_ADC_CHANNEL_TO_DECIMAL_NB(). Then the selected literal LL_ADC_CHANNEL_x can be usedas parameter for another function.To get the channel number in decimal format: process the returned valuewith the helper macro __LL_ADC_CHANNEL_TO_DECIMAL_NB().


• This mode can be used to extend number of data registers updated after one ADC conversion trigger andwith data permanently kept (not erased by successive conversions of scan of ADC sequencer ranks), up to5 data registers: 1 data register on ADC group regular, 4 data registers on ADC group injected.
• If ADC group injected injected trigger source is set to an external trigger, this feature must be must be setto independent trigger. ADC group injected automatic trigger is compliant only with group injected triggersource set to SW start, without any further action on ADC group injected conversion start or stop: in thiscase, ADC group injected is controlled only from ADC group regular.
• It is not possible to enable both ADC group injected auto-injected mode and sequencer discontinuousmode.


• It sets: ADC group injected rank to which the offset programmed will be appliedOffset level (offset to besubtracted from the raw converted data). Caution: Offset format is dependent to ADC resolution: offset hasto be left-aligned on bit 11, the LSB (right bits) are set to 0.
• Offset cannot be enabled or disabled. To emulate offset disabled, set an offset value equal to 0.


• It gives offset level (offset to be subtracted from the raw converted data). Caution: Offset format isdependent to ADC resolution: offset has to be left-aligned on bit 11, the LSB (right bits) are set to 0.


• On this device, sampling time is on channel scope: independently of channel mapped on ADC groupregular or injected.
• Conversion time is the addition of sampling time and processing time. Refer to reference manual for ADCprocessing time of this STM32 serie.


• Once monitored channels are selected, analog watchdog is enabled.
• In case of need to define a single channel to monitor with analog watchdog from sequencer channeldefinition, use helper macro __LL_ADC_ANALOGWD_CHANNEL_GROUP().
• On this STM32 serie, there is only 1 kind of analog watchdog instance: AWD standard (instance AWD1):channels monitored: can monitor 1 channel or all channels.groups monitored: ADC groups regular and-orinjected.resolution: resolution is not limited (corresponds to ADC resolution configured).


• Usage of the returned channel number: To reinject this channel into another function LL_ADC_xxx: thereturned channel number is only partly formatted on definition of literals LL_ADC_CHANNEL_x. Therefore,it has to be compared with parts of literals LL_ADC_CHANNEL_x or using helper macro__LL_ADC_CHANNEL_TO_DECIMAL_NB(). Then the selected literal LL_ADC_CHANNEL_x can be usedas parameter for another function.To get the channel number in decimal format: process the returned valuewith the helper macro __LL_ADC_CHANNEL_TO_DECIMAL_NB(). Applicable only when the analogwatchdog is set to monitor one channel.
• On this STM32 serie, there is only 1 kind of analog watchdog instance: AWD standard (instance AWD1):channels monitored: can monitor 1 channel or all channels.groups monitored: ADC groups regular and-orinjected.resolution: resolution is not limited (corresponds to ADC resolution configured).


• On this STM32 serie, there is only 1 kind of analog watchdog instance: AWD standard (instance AWD1):channels monitored: can monitor 1 channel or all channels.groups monitored: ADC groups regular and-orinjected.resolution: resolution is not limited (corresponds to ADC resolution configured).


• On this STM32 serie, before starting a calibration, ADC must be disabled. A minimum number of ADCclock cycles are required between ADC disable state and calibration start. Refer to literalLL_ADC_DELAY_DISABLE_CALIB_ADC_CYCLES.
• On this STM32 serie, hardware prerequisite before starting a calibration: the ADC must have been inpower-on state for at least two ADC clock cycles.


• On this STM32 serie, this function is relevant only for internal trigger (SW start), not for external trigger: IfADC trigger has been set to software start, ADC conversion starts immediately.If ADC trigger has been setto external trigger, ADC conversion start must be performed using functionLL_ADC_REG_StartConversionExtTrig(). (if external trigger edge would have been set during ADC othersettings, ADC conversion would start at trigger event as soon as ADC is enabled).


• ADC conversion will start at next trigger event (on the selected trigger edge) following the ADC startconversion command.
• On this STM32 serie, this function is relevant for ADC conversion start from external trigger. If internaltrigger (SW start) is needed, perform ADC conversion start using functionLL_ADC_REG_StartConversionSWStart().


• No more ADC conversion will start at next trigger event following the ADC stop conversion command. If aconversion is on-going, it will be completed.
• On this STM32 serie, there is no specific command to stop a conversion on-going or to stop ADCconverting in continuous mode. These actions can be performed using function LL_ADC_Disable().


• If raw data with ADC master and slave concatenated is retrieved, a macro is available to get the conversiondata of ADC master or ADC slave: see helper macro__LL_ADC_MULTI_CONV_DATA_MASTER_SLAVE(). (however this macro is mainly intended formultimode transfer by DMA, because this function can do the same by getting multimode conversion dataof ADC master or ADC slave separately).


• On this STM32 serie, this function is relevant only for internal trigger (SW start), not for external trigger: IfADC trigger has been set to software start, ADC conversion starts immediately.If ADC trigger has been setto external trigger, ADC conversion start must be performed using functionLL_ADC_INJ_StartConversionExtTrig(). (if external trigger edge would have been set during ADC othersettings, ADC conversion would start at trigger event as soon as ADC is enabled).


• ADC conversion will start at next trigger event (on the selected trigger edge) following the ADC startconversion command.
• On this STM32 serie, this function is relevant for ADC conversion start from external trigger. If internaltrigger (SW start) is needed, perform ADC conversion start using functionLL_ADC_INJ_StartConversionSWStart().


• No more ADC conversion will start at next trigger event following the ADC stop conversion command. If aconversion is on-going, it will be completed.
• On this STM32 serie, there is no specific command to stop a conversion on-going or to stop ADCconverting in continuous mode. These actions can be performed using function LL_ADC_Disable().

ADC flag ADC group regular end of sequence conversions (Note: on this STM32 serie, there is no flag ADCgroup regular end of unitary conversion. Flag noted as "EOC" is corresponding to flag "EOS" in other STM32families)

ADC flag ADC group injected end of sequence conversions (Note: on this STM32 serie, there is no flag ADCgroup injected end of unitary conversion. Flag noted as "JEOC" is corresponding to flag "JEOS" in other STM32families)

ADC flag ADC multimode master group regular end of sequence conversions (Note: on this STM32 serie, thereis no flag ADC group regular end of unitary conversion. Flag noted as "EOC" is corresponding to flag "EOS" inother STM32 families)

ADC flag ADC multimode slave group regular end of sequence conversions (Note: on this STM32 serie, there isno flag ADC group regular end of unitary conversion. Flag noted as "EOC" is corresponding to flag "EOS" inother STM32 families) (on STM32F1, this flag must be read from ADC instance slave: ADC2)

ADC flag ADC multimode master group injected end of sequence conversions (Note: on this STM32 serie, thereis no flag ADC group injected end of unitary conversion. Flag noted as "JEOC" is corresponding to flag "JEOS"in other STM32 families)

ADC flag ADC multimode slave group injected end of sequence conversions (Note: on this STM32 serie, there isno flag ADC group injected end of unitary conversion. Flag noted as "JEOC" is corresponding to flag "JEOS" inother STM32 families) (on STM32F1, this flag must be read from ADC instance slave: ADC2)

ADC group injected conversion trigger from external IP: TIM8 channel 4 event (capture compare: input captureor output capture). Trigger edge set to rising edge (default setting). Available only on high-density and XL-densitydevices. A remap of trigger must be done at top level (refer to AFIO peripheral).

ADC group injected conversion trigger from ADC group regular. Setting compliant only with group injected triggersource set to SW start, without any further action on ADC group injected conversion start or stop: in this case,ADC group injected is controlled only from ADC group regular.

ADC interruption ADC group regular end of sequence conversions (Note: on this STM32 serie, there is no flagADC group regular end of unitary conversion. Flag noted as "EOC" is corresponding to flag "EOS" in otherSTM32 families)

ADC interruption ADC group injected end of sequence conversions (Note: on this STM32 serie, there is no flagADC group injected end of unitary conversion. Flag noted as "JEOC" is corresponding to flag "JEOS" in otherSTM32 families)

ADC conversion data are transferred by DMA, in unlimited mode: DMA transfer requests are unlimited, whatevernumber of DMA data transferred (number of ADC conversions). This ADC mode is intended to be used withDMA mode circular.

ADC group regular conversion trigger from external IP: TIM8 TRGO. Trigger edge set to rising edge (defaultsetting). Available only on high-density and XL-density devices. A remap of trigger must be done at top level(refer to AFIO peripheral).

Notes:
• Example: __LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_CHANNEL_4) will return decimal number"4". The input can be a value from functions where a channel number is returned, either defined withnumber or with bitfield (only one bit must be set).

Return value:
• Value: "0" if the channel corresponds to a parameter definition of a ADC external channel (channelconnected to a GPIO pin). Value "1" if the channel corresponds to a parameter definition of a ADC internalchannel.

Notes:
• This macro is intended to be used when multimode transfer by DMA is enabled. In this case the transferreddata need to processed with this macro to separate the conversion data of ADC master and ADC slave.

Notes:
• ADC common register instance can be used for: Set parameters common to several ADCinstancesMultimode (for devices with several ADC instances) Refer to functions having argument"ADCxy_COMMON" as parameter. On STM32F1, there is no common ADC instance. However, ADCinstance ADC1 has a role of common ADC instance for ADC1 and ADC2: this instance is used to manageinternal channels and multimode (these features are managed in ADC common instances on some otherSTM32 devices). ADC instance ADC3 (if available on the selected device) has no ADC common instance.

Notes:
• This check is required by functions with setting conditioned to ADC state: All ADC instances of the ADCcommon group must be disabled. Refer to functions having argument "ADCxy_COMMON" as parameter.On devices with only 1 ADC common instance, parameter of this macro is useless and can be ignored(parameter kept for compatibility with devices featuring several ADC common instances). On STM32F1,there is no common ADC instance. However, ADC instance ADC1 has a role of common ADC instance forADC1 and ADC2: this instance is used to manage internal channels and multimode (these features aremanaged in ADC common instances on some other STM32 devices). ADC instance ADC3 (if available onthe selected device) has no ADC common instance.

Parameters:
• __TEMPSENSOR_TYP_AVGSLOPE__: Device datasheet data: Temperature sensor slope typical value(unit: uV/DegCelsius). On STM32F1, refer to device datasheet parameter "Avg_Slope".
• __TEMPSENSOR_TYP_CALX_V__: Device datasheet data: Temperature sensor voltage typical value (attemperature and Vref+ defined in parameters below) (unit: mV). On STM32F1, refer to device datasheetparameter "V25".
• __TEMPSENSOR_CALX_TEMP__: Device datasheet data: Temperature at which temperature sensorvoltage (see parameter above) is corresponding (unit: mV)
• __VREFANALOG_VOLTAGE__: Analog voltage reference (Vref+) voltage (unit: mV)
• __TEMPSENSOR_ADC_DATA__: ADC conversion data of internal temperature sensor (unit: digital value).
• __ADC_RESOLUTION__: ADC resolution at which internal temperature sensor voltage has beenmeasured. This parameter can be one of the following values:–LL_ADC_RESOLUTION_12B

Notes:
• Computation is using temperature sensor typical values (refer to device datasheet). Calculation formula:Temperature = (TS_TYP_CALx_VOLT(uV) - TS_ADC_DATA * Conversion_uV) / Avg_Slope + CALx_TEMPwith TS_ADC_DATA = temperature sensor raw data measured by ADC (unit: digital value) Avg_Slope =temperature sensor slope (unit: uV/Degree Celsius) TS_TYP_CALx_VOLT = temperature sensor digitalvalue at temperature CALx_TEMP (unit: mV) Caution: Calculation relevancy under reserve the temperaturesensor of the current device has characteristics in line with datasheet typical values. If temperature sensorcalibration values are available on on this device (presence of macro__LL_ADC_CALC_TEMPERATURE()), temperature calculation will be more accurate using helper macro__LL_ADC_CALC_TEMPERATURE(). As calculation input, the analog reference voltage (Vref+) must bedefined as it impacts the ADC LSB equivalent voltage. Analog reference voltage (Vref+) must be knownfrom user board environment or can be calculated using ADC measurement. ADC measurement data mustcorrespond to a resolution of 12bits (full scale digital value 4095). If not the case, the data must bepreliminarily rescaled to an equivalent resolution of 12 bits.

Field Documentation
• uint32_t LL_DAC_InitTypeDef::TriggerSourceSet the conversion trigger source for the selected DAC channel: internal (SW start) or from externalperipheral (timer event, external interrupt line). This parameter can be a value ofDAC_LL_EC_TRIGGER_SOURCEThis feature can be modified afterwards using unitary functionLL_DAC_SetTriggerSource().
• uint32_t LL_DAC_InitTypeDef::WaveAutoGenerationSet the waveform automatic generation mode for the selected DAC channel. This parameter can be a valueof DAC_LL_EC_WAVE_AUTO_GENERATION_MODEThis feature can be modified afterwards using unitaryfunction LL_DAC_SetWaveAutoGeneration().
• uint32_t LL_DAC_InitTypeDef::WaveAutoGenerationConfigSet the waveform automatic generation mode for the selected DAC channel. If waveform automaticgeneration mode is set to noise, this parameter can be a value ofDAC_LL_EC_WAVE_NOISE_LFSR_UNMASK_BITS If waveform automatic generation mode is set totriangle, this parameter can be a value of DAC_LL_EC_WAVE_TRIANGLE_AMPLITUDENote:–If waveform automatic generation mode is disabled, this parameter is discarded.

This feature can be modified afterwards using unitary function LL_DAC_SetWaveNoiseLFSR(),LL_DAC_SetWaveTriangleAmplitude() depending on the wave automatic generation selected.
• uint32_t LL_DAC_InitTypeDef::OutputBufferSet the output buffer for the selected DAC channel. This parameter can be a value ofDAC_LL_EC_OUTPUT_BUFFERThis feature can be modified afterwards using unitary functionLL_DAC_SetOutputBuffer().


• For conversion trigger source to be effective, DAC trigger must be enabled using functionLL_DAC_EnableTrigger().
• To set conversion trigger source, DAC channel must be disabled. Otherwise, the setting is discarded.
• Availability of parameters of trigger sources from timer depends on timers availability on the selecteddevice.


• For wave generation to be effective, DAC channel wave generation mode must be enabled using functionLL_DAC_SetWaveAutoGeneration().
• This setting can be set when the selected DAC channel is disabled (otherwise, the setting operation isignored).


• For wave generation to be effective, DAC channel wave generation mode must be enabled using functionLL_DAC_SetWaveAutoGeneration().
• This setting can be set when the selected DAC channel is disabled (otherwise, the setting operation isignored).

Function to help to configure DMA transfer to DAC: retrieve the DAC register address from DAC instance and alist of DAC registers intended to be used (most commonly) with DMA transfer.


• Preliminarily, DAC trigger must be set to software trigger using function LL_DAC_Init()LL_DAC_SetTriggerSource() with parameter "LL_DAC_TRIGGER_SOFTWARE". and DAC trigger must beenabled using function LL_DAC_EnableTrigger().
• For devices featuring DAC with 2 channels: this function can perform a SW start of both DAC channelssimultaneously. Two channels can be selected as parameter. Example: (LL_DAC_CHANNEL_1 |LL_DAC_CHANNEL_2)


• LL_DAC_Init() aims to ease basic configuration of a DAC channel. Leaving it ready to be enabled andoutput: a level by calling one of LL_DAC_ConvertData12RightAligned LL_DAC_ConvertData12LeftAlignedLL_DAC_ConvertData8RightAligned or one of the supported autogenerated wave.
• This function allows configuration of: Output modeTriggerWave generation
• The setting of these parameters by function LL_DAC_Init() is conditioned to DAC state: DAC channel mustbe disabled.

Notes:
• This helper macro is intended to provide input data in voltage rather than digital value, to be used with LLDAC functions such as LL_DAC_ConvertData12RightAligned(). Analog reference voltage (Vref+) must beeither known from user board environment or can be calculated using ADC measurement and ADC helpermacro __LL_ADC_CALC_VREFANALOG_VOLTAGE().

Field Documentation
• uint32_t LL_DMA_InitTypeDef::PeriphOrM2MSrcAddressSpecifies the peripheral base address for DMA transfer or as Source base address in case of memory tomemory transfer direction.This parameter must be a value between Min_Data = 0 and Max_Data =0xFFFFFFFF.
• uint32_t LL_DMA_InitTypeDef::MemoryOrM2MDstAddressSpecifies the memory base address for DMA transfer or as Destination base address in case of memory tomemory transfer direction.This parameter must be a value between Min_Data = 0 and Max_Data =0xFFFFFFFF.
• uint32_t LL_DMA_InitTypeDef::DirectionSpecifies if the data will be transferred from memory to peripheral, from memory to memory or fromperipheral to memory. This parameter can be a value of DMA_LL_EC_DIRECTIONThis feature can bemodified afterwards using unitary function LL_DMA_SetDataTransferDirection().
• uint32_t LL_DMA_InitTypeDef::ModeSpecifies the normal or circular operation mode. This parameter can be a value of DMA_LL_EC_MODENote:–: The circular buffer mode cannot be used if the memory to memory data transfer direction isconfigured on the selected Channel

This feature can be modified afterwards using unitary function LL_DMA_SetMode().
• uint32_t LL_DMA_InitTypeDef::PeriphOrM2MSrcIncModeSpecifies whether the Peripheral address or Source address in case of memory to memory transfer directionis incremented or not. This parameter can be a value of DMA_LL_EC_PERIPHThis feature can be modifiedafterwards using unitary function LL_DMA_SetPeriphIncMode().
• uint32_t LL_DMA_InitTypeDef::MemoryOrM2MDstIncModeSpecifies whether the Memory address or Destination address in case of memory to memory transferdirection is incremented or not. This parameter can be a value of DMA_LL_EC_MEMORYThis feature canbe modified afterwards using unitary function LL_DMA_SetMemoryIncMode().
• uint32_t LL_DMA_InitTypeDef::PeriphOrM2MSrcDataSizeSpecifies the Peripheral data size alignment or Source data size alignment (byte, half word, word) in case ofmemory to memory transfer direction. This parameter can be a value of DMA_LL_EC_PDATAALIGNThisfeature can be modified afterwards using unitary function LL_DMA_SetPeriphSize().


• uint32_t LL_DMA_InitTypeDef::MemoryOrM2MDstDataSizeSpecifies the Memory data size alignment or Destination data size alignment (byte, half word, word) in caseof memory to memory transfer direction. This parameter can be a value of DMA_LL_EC_MDATAALIGNThisfeature can be modified afterwards using unitary function LL_DMA_SetMemorySize().
• uint32_t LL_DMA_InitTypeDef::NbDataSpecifies the number of data to transfer, in data unit. The data unit is equal to the source buffer configurationset in PeripheralSize or MemorySize parameters depending in the transfer direction. This parameter must bea value between Min_Data = 0 and Max_Data = 0x0000FFFFThis feature can be modified afterwards usingunitary function LL_DMA_SetDataLength().
• uint32_t LL_DMA_InitTypeDef::PrioritySpecifies the channel priority level. This parameter can be a value of DMA_LL_EC_PRIORITYThis featurecan be modified afterwards using unitary function LL_DMA_SetChannelPriorityLevel().


• The reset value for the direct or internal lines (see RM) is set to 1 in order to enable the interrupt by default.Bits are set automatically at Power on.
• Please check each device line mapping for EXTI Line availability


• The reset value for the direct or internal lines (see RM) is set to 1 in order to enable the interrupt by default.Bits are set automatically at Power on.
• Please check each device line mapping for EXTI Line availability


• The reset value for the direct or internal lines (see RM) is set to 1 in order to enable the interrupt by default.Bits are set automatically at Power on.
• Please check each device line mapping for EXTI Line availability


• The configurable wakeup lines are edge-triggered. No glitch must be generated on these lines. If a risingedge on a configurable interrupt line occurs during a write operation in the EXTI_RTSR register, thepending bit is not set. Rising and falling edge triggers can be set for the same interrupt line. In this case,both generate a trigger condition.
• Please check each device line mapping for EXTI Line availability


• The configurable wakeup lines are edge-triggered. No glitch must be generated on these lines. If a risingedge on a configurable interrupt line occurs during a write operation in the EXTI_RTSR register, thepending bit is not set. Rising and falling edge triggers can be set for the same interrupt line. In this case,both generate a trigger condition.
• Please check each device line mapping for EXTI Line availability


• The configurable wakeup lines are edge-triggered. No glitch must be generated on these lines. If a fallingedge on a configurable interrupt line occurs during a write operation in the EXTI_FTSR register, thepending bit is not set. Rising and falling edge triggers can be set for the same interrupt line. In this case,both generate a trigger condition.
• Please check each device line mapping for EXTI Line availability


• The configurable wakeup lines are edge-triggered. No glitch must be generated on these lines. If a Fallingedge on a configurable interrupt line occurs during a write operation in the EXTI_FTSR register, thepending bit is not set. Rising and falling edge triggers can be set for the same interrupt line. In this case,both generate a trigger condition.
• Please check each device line mapping for EXTI Line availability


• If the interrupt is enabled on this line in the EXTI_IMR, writing a 1 to this bit when it is at '0' sets thecorresponding pending bit in EXTI_PR resulting in an interrupt request generation. This bit is cleared byclearing the corresponding bit in the EXTI_PR register (by writing a 1 into the bit)
• Please check each device line mapping for EXTI Line availability


• This bit is set when the selected edge event arrives on the interrupt line. This bit is cleared by writing a 1 tothe bit.
• Please check each device line mapping for EXTI Line availability


• This bit is set when the selected edge event arrives on the interrupt line. This bit is cleared by writing a 1 tothe bit.
• Please check each device line mapping for EXTI Line availability


• This bit is set when the selected edge event arrives on the interrupt line. This bit is cleared by writing a 1 tothe bit.
• Please check each device line mapping for EXTI Line availability


• uint32_t LL_GPIO_InitTypeDef::ModeSpecifies the operating mode for the selected pins. This parameter can be a value ofGPIO_LL_EC_MODE.GPIO HW configuration can be modified afterwards using unitary functionLL_GPIO_SetPinMode().
• uint32_t LL_GPIO_InitTypeDef::SpeedSpecifies the speed for the selected pins. This parameter can be a value of GPIO_LL_EC_SPEED.GPIOHW configuration can be modified afterwards using unitary function LL_GPIO_SetPinSpeed().
• uint32_t LL_GPIO_InitTypeDef::OutputTypeSpecifies the operating output type for the selected pins. This parameter can be a value ofGPIO_LL_EC_OUTPUT.GPIO HW configuration can be modified afterwards using unitary functionLL_GPIO_SetPinOutputType().
• uint32_t LL_GPIO_InitTypeDef::PullSpecifies the operating Pull-up/Pull down for the selected pins. This parameter can be a value ofGPIO_LL_EC_PULL.GPIO HW configuration can be modified afterwards using unitary functionLL_GPIO_SetPinPull().


• I/O speed can be Low, Medium or Fast speed.
• Warning: only one pin can be passed as parameter.
• Refer to datasheet for frequency specifications and the power supply and load conditions for each speed.


• I/O speed can be Low, Medium, Fast or High speed.
• Warning: only one pin can be passed as parameter.
• Refer to datasheet for frequency specifications and the power supply and load conditions for each speed.


• When the lock sequence has been applied on a port bit, the value of this port bit can no longer be modifieduntil the next reset.
• Each lock bit freezes a specific configuration register (control and alternate function registers).

Field Documentation
• uint32_t LL_I2C_InitTypeDef::PeripheralModeSpecifies the peripheral mode. This parameter can be a value of I2C_LL_EC_PERIPHERAL_MODEThisfeature can be modified afterwards using unitary function LL_I2C_SetMode().
• uint32_t LL_I2C_InitTypeDef::ClockSpeedSpecifies the clock frequency. This parameter must be set to a value lower than 400kHz (in Hz)This featurecan be modified afterwards using unitary function LL_I2C_SetClockPeriod() or LL_I2C_SetDutyCycle() orLL_I2C_SetClockSpeedMode() or LL_I2C_ConfigSpeed().
• uint32_t LL_I2C_InitTypeDef::DutyCycleSpecifies the I2C fast mode duty cycle. This parameter can be a value of I2C_LL_EC_DUTYCYCLEThisfeature can be modified afterwards using unitary function LL_I2C_SetDutyCycle().
• uint32_t LL_I2C_InitTypeDef::OwnAddress1Specifies the device own address 1. This parameter must be a value between Min_Data = 0x00 andMax_Data = 0x3FFThis feature can be modified afterwards using unitary functionLL_I2C_SetOwnAddress1().
• uint32_t LL_I2C_InitTypeDef::TypeAcknowledgeSpecifies the ACKnowledge or Non ACKnowledge condition after the address receive match code or nextreceived byte. This parameter can be a value of I2C_LL_EC_I2C_ACKNOWLEDGEThis feature can bemodified afterwards using unitary function LL_I2C_AcknowledgeNextData().
• uint32_t LL_I2C_InitTypeDef::OwnAddrSizeSpecifies the device own address 1 size (7-bit or 10-bit). This parameter can be a value ofI2C_LL_EC_OWNADDRESS1This feature can be modified afterwards using unitary functionLL_I2C_SetOwnAddress1().


• Macro IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not SMBus feature issupported by the I2Cx Instance.
• SMBus Device mode: SMBus Alert pin is drived low and Alert Response Address Header acknowledge isenabled. SMBus Host mode:SMBus Alert pin management is supported.


• Macro IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not SMBus feature issupported by the I2Cx Instance.
• SMBus Device mode: SMBus Alert pin is not drived (can be used as a standard GPIO) and Alert ResponseAddress Header acknowledge is disabled. SMBus Host mode:SMBus Alert pin management is notsupported.


• Any of these events will generate interrupt : Start Bit (SB) Address sent, Address matched (ADDR) 10-bitheader sent (ADD10) Stop detection (STOPF) Byte transfer finished (BTF)
• Any of these events will generate interrupt if Buffer interrupts are enabled too(using unitary functionLL_I2C_EnableIT_BUF()) : Receive buffer not empty (RXNE) Transmit buffer empty (TXE)


• Any of these events will generate interrupt : Start Bit (SB) Address sent, Address matched (ADDR) 10-bitheader sent (ADD10) Stop detection (STOPF) Byte transfer finished (BTF) Receive buffer not empty(RXNE) Transmit buffer empty (TXE)


• Macro IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not SMBus feature issupported by the I2Cx Instance.
• RESET: No SMBus Host address SET: SMBus Host address received.
• This status is cleared by hardware after a STOP condition or repeated START condition.


• Macro IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not SMBus feature issupported by the I2Cx Instance.
• RESET: No SMBus Device default address SET: SMBus Device default address received.
• This status is cleared by hardware after a STOP condition or repeated START condition.


• Macro IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not SMBus feature issupported by the I2Cx Instance.
• This feature is cleared by hardware when the PEC byte is transferred or compared, or by a START orSTOP condition, it is also cleared by software.

Parameters:
• __PCLK__: This parameter must be a value of peripheral clock (in Hz).
• __SPEED__: This parameter must be a value lower than 400kHz (in Hz).
• __DUTYCYCLE__: This parameter can be one of the following values:–LL_I2C_DUTYCYCLE_2–LL_I2C_DUTYCYCLE_16_9

Parameters:
• __PCLK__: This parameter must be a value of peripheral clock (in Hz).
• __SPEED__: This parameter must be a value between Min_Data=100Khz and Max_Data=400Khz (in Hz).
• __DUTYCYCLE__: This parameter can be one of the following values:–LL_I2C_DUTYCYCLE_2–LL_I2C_DUTYCYCLE_16_9


• The default reset state of the clock configuration is given below: HSI ON and used as system clocksourceHSE PLL, PLL2 & PLL3 are OFFAHB, APB1 and APB2 prescaler set to 1.CSS, MCO OFFAllinterrupts disabled
• This function doesn't modify the configuration of the Peripheral clocksLSI, LSE and RTC clocks

Field Documentation
• uint32_t LL_RTC_InitTypeDef::AsynchPrescalerSpecifies the RTC Asynchronous Predivider value. This parameter must be a number between Min_Data =0x00 and Max_Data = 0xFFFFFThis feature can be modified afterwards using unitary functionLL_RTC_SetAsynchPrescaler().
• uint32_t LL_RTC_InitTypeDef::OutPutSourceSpecifies which signal will be routed to the RTC Tamper pin. This parameter can be a value ofLL_RTC_Output_SourceThis feature can be modified afterwards using unitary functionLL_RTC_SetOutputSource().

Field Documentation
• uint8_t LL_RTC_TimeTypeDef::HoursSpecifies the RTC Time Hours. This parameter must be a number between Min_Data = 0 and Max_Data =23
• uint8_t LL_RTC_TimeTypeDef::MinutesSpecifies the RTC Time Minutes. This parameter must be a number between Min_Data = 0 and Max_Data =59
• uint8_t LL_RTC_TimeTypeDef::SecondsSpecifies the RTC Time Seconds. This parameter must be a number between Min_Data = 0 and Max_Data= 59


• Bit is write-protected. LL_RTC_DisableWriteProtection function should be called before.
• It can be written in initialization mode only (LL_RTC_EnterInitMode function)
• This Calibration value should be between 0 and 121 when using positive sign with a 4-ppm step.


• The RTC Prescaler register is write protected and can be written in initialization mode only.
• the user should call LL_RTC_StructInit() or the structure of Prescaler need to be initialized before RTC init()

Field Documentation
• uint32_t LL_SPI_InitTypeDef::TransferDirectionSpecifies the SPI unidirectional or bidirectional data mode. This parameter can be a value ofSPI_LL_EC_TRANSFER_MODE.This feature can be modified afterwards using unitary functionLL_SPI_SetTransferDirection().
• uint32_t LL_SPI_InitTypeDef::ModeSpecifies the SPI mode (Master/Slave). This parameter can be a value of SPI_LL_EC_MODE.This featurecan be modified afterwards using unitary function LL_SPI_SetMode().
• uint32_t LL_SPI_InitTypeDef::DataWidthSpecifies the SPI data width. This parameter can be a value of SPI_LL_EC_DATAWIDTH.This feature canbe modified afterwards using unitary function LL_SPI_SetDataWidth().
• uint32_t LL_SPI_InitTypeDef::ClockPolaritySpecifies the serial clock steady state. This parameter can be a value of SPI_LL_EC_POLARITY.Thisfeature can be modified afterwards using unitary function LL_SPI_SetClockPolarity().
• uint32_t LL_SPI_InitTypeDef::ClockPhaseSpecifies the clock active edge for the bit capture. This parameter can be a value ofSPI_LL_EC_PHASE.This feature can be modified afterwards using unitary functionLL_SPI_SetClockPhase().
• uint32_t LL_SPI_InitTypeDef::NSSSpecifies whether the NSS signal is managed by hardware (NSS pin) or by software using the SSI bit. Thisparameter can be a value of SPI_LL_EC_NSS_MODE.This feature can be modified afterwards using unitaryfunction LL_SPI_SetNSSMode().
• uint32_t LL_SPI_InitTypeDef::BaudRateSpecifies the BaudRate prescaler value which will be used to configure the transmit and receive SCK clock.This parameter can be a value of SPI_LL_EC_BAUDRATEPRESCALER.Note:–The communication clock is derived from the master clock. The slave clock does not need to be set.

This feature can be modified afterwards using unitary function LL_SPI_SetBaudRatePrescaler().
• uint32_t LL_SPI_InitTypeDef::BitOrderSpecifies whether data transfers start from MSB or LSB bit. This parameter can be a value ofSPI_LL_EC_BIT_ORDER.This feature can be modified afterwards using unitary functionLL_SPI_SetTransferBitOrder().


• uint32_t LL_SPI_InitTypeDef::CRCCalculationSpecifies if the CRC calculation is enabled or not. This parameter can be a value ofSPI_LL_EC_CRC_CALCULATION.This feature can be modified afterwards using unitary functionsLL_SPI_EnableCRC() and LL_SPI_DisableCRC().
• uint32_t LL_SPI_InitTypeDef::CRCPolySpecifies the polynomial used for the CRC calculation. This parameter must be a number between Min_Data= 0x00 and Max_Data = 0xFFFF.This feature can be modified afterwards using unitary functionLL_SPI_SetCRCPolynomial().

Field Documentation
• uint32_t LL_I2S_InitTypeDef::ModeSpecifies the I2S operating mode. This parameter can be a value of I2S_LL_EC_MODEThis feature can bemodified afterwards using unitary function LL_I2S_SetTransferMode().
• uint32_t LL_I2S_InitTypeDef::StandardSpecifies the standard used for the I2S communication. This parameter can be a value ofI2S_LL_EC_STANDARD.This feature can be modified afterwards using unitary functionLL_I2S_SetStandard().
• uint32_t LL_I2S_InitTypeDef::DataFormatSpecifies the data format for the I2S communication. This parameter can be a value ofI2S_LL_EC_DATA_FORMAT.This feature can be modified afterwards using unitary functionLL_I2S_SetDataFormat().
• uint32_t LL_I2S_InitTypeDef::MCLKOutputSpecifies whether the I2S MCLK output is enabled or not. This parameter can be a value ofI2S_LL_EC_MCLK_OUTPUTThis feature can be modified afterwards using unitary functionsLL_I2S_EnableMasterClock() or LL_I2S_DisableMasterClock.
• uint32_t LL_I2S_InitTypeDef::AudioFreqSpecifies the frequency selected for the I2S communication. This parameter can be a value ofI2S_LL_EC_AUDIO_FREQAudio Frequency can be modified afterwards using Reference manual formulasto calculate Prescaler Linear, Parity and unitary functions LL_I2S_SetPrescalerLinear() andLL_I2S_SetPrescalerParity() to set it.
• uint32_t LL_I2S_InitTypeDef::ClockPolaritySpecifies the idle state of the I2S clock. This parameter can be a value of I2S_LL_EC_POLARITYThisfeature can be modified afterwards using unitary function LL_I2S_SetClockPolarity().


• The BSY flag is cleared under any one of the following conditions: -When the SPI is correctly disabled -When a fault is detected in Master mode (MODF bit set to 1) -In Master mode, when it finishes a datatransmission and no new data is ready to be sent -In Slave mode, when the BSY flag is set to '0' for at leastone SPI clock cycle between each data transfer.


• As some bits in SPI configuration registers can only be written when the SPI is disabled (SPI_CR1_SPE bit=0), SPI peripheral should be in disabled state prior calling this function. Otherwise, ERROR result will bereturned.


• As some bits in SPI configuration registers can only be written when the SPI is disabled (SPI_CR1_SPE bit=0), SPI peripheral should be in disabled state prior calling this function. Otherwise, ERROR result will bereturned.


• For Low Density devices, the device ID is 0x412
• For Medium Density devices, the device ID is 0x410
• For High Density devices, the device ID is 0x414
• For XL Density devices, the device ID is 0x430
• For Connectivity Line devices, the device ID is 0x418


• This field indicates the revision of the device. For example, it is read as revA -> 0x1000,for Low Densitydevices For example, it is read as revA -> 0x0000, revB -> 0x2000, revZ -> 0x2001, rev1,2,3,X or Y ->0x2003,for Medium Density devices For example, it is read as revA or 1 -> 0x1000, revZ ->0x1001,rev1,2,3,X or Y -> 0x1003,for Medium Density devices For example, it is read as revA or 1 ->0x1003,for XL Density devices For example, it is read as revA -> 0x1000, revZ -> 0x1001 for Connectivityline devices

Field Documentation
• uint16_t LL_TIM_InitTypeDef::PrescalerSpecifies the prescaler value used to divide the TIM clock. This parameter can be a number betweenMin_Data=0x0000 and Max_Data=0xFFFF.This feature can be modified afterwards using unitary functionLL_TIM_SetPrescaler().
• uint32_t LL_TIM_InitTypeDef::CounterModeSpecifies the counter mode. This parameter can be a value of TIM_LL_EC_COUNTERMODE.This featurecan be modified afterwards using unitary function LL_TIM_SetCounterMode().
• uint32_t LL_TIM_InitTypeDef::AutoreloadSpecifies the auto reload value to be loaded into the active Auto-Reload Register at the next update event.This parameter must be a number between Min_Data=0x0000 and Max_Data=0xFFFF. Some timerinstances may support 32 bits counters. In that case this parameter must be a number between 0x0000 and0xFFFFFFFF.This feature can be modified afterwards using unitary function LL_TIM_SetAutoReload().
• uint32_t LL_TIM_InitTypeDef::ClockDivisionSpecifies the clock division. This parameter can be a value of TIM_LL_EC_CLOCKDIVISION.This featurecan be modified afterwards using unitary function LL_TIM_SetClockDivision().
• uint8_t LL_TIM_InitTypeDef::RepetitionCounterSpecifies the repetition counter value. Each time the RCR downcounter reaches zero, an update event isgenerated and counting restarts from the RCR value (N). This means in PWM mode that (N+1) correspondsto:–the number of PWM periods in edge-aligned mode–the number of half PWM period in center-aligned mode This parameter must be a number between0x00 and 0xFF.

Field Documentation
• uint32_t LL_TIM_IC_InitTypeDef::ICPolaritySpecifies the active edge of the input signal. This parameter can be a value ofTIM_LL_EC_IC_POLARITY.This feature can be modified afterwards using unitary functionLL_TIM_IC_SetPolarity().
• uint32_t LL_TIM_IC_InitTypeDef::ICActiveInputSpecifies the input. This parameter can be a value of TIM_LL_EC_ACTIVEINPUT.This feature can bemodified afterwards using unitary function LL_TIM_IC_SetActiveInput().
• uint32_t LL_TIM_IC_InitTypeDef::ICPrescalerSpecifies the Input Capture Prescaler. This parameter can be a value of TIM_LL_EC_ICPSC.This featurecan be modified afterwards using unitary function LL_TIM_IC_SetPrescaler().
• uint32_t LL_TIM_IC_InitTypeDef::ICFilterSpecifies the input capture filter. This parameter can be a value of TIM_LL_EC_IC_FILTER.This feature canbe modified afterwards using unitary function LL_TIM_IC_SetFilter().


• uint32_t LL_TIM_HALLSENSOR_InitTypeDef::IC1PolaritySpecifies the active edge of TI1 input. This parameter can be a value of TIM_LL_EC_IC_POLARITY.Thisfeature can be modified afterwards using unitary function LL_TIM_IC_SetPolarity().
• uint32_t LL_TIM_HALLSENSOR_InitTypeDef::IC1PrescalerSpecifies the TI1 input prescaler value. Prescaler must be set to get a maximum counter period longer thanthe time interval between 2 consecutive changes on the Hall inputs. This parameter can be a value ofTIM_LL_EC_ICPSC.This feature can be modified afterwards using unitary functionLL_TIM_IC_SetPrescaler().
• uint32_t LL_TIM_HALLSENSOR_InitTypeDef::IC1FilterSpecifies the TI1 input filter. This parameter can be a value of TIM_LL_EC_IC_FILTER.This feature can bemodified afterwards using unitary function LL_TIM_IC_SetFilter().
• uint32_t LL_TIM_HALLSENSOR_InitTypeDef::CommutationDelaySpecifies the compare value to be loaded into the Capture Compare Register. A positive pulse (TRGOevent) is generated with a programmable delay every time a change occurs on the Hall inputs. Thisparameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF.This feature can bemodified afterwards using unitary function LL_TIM_OC_SetCompareCH2().

Field Documentation
• uint32_t LL_TIM_BDTR_InitTypeDef::OSSRStateSpecifies the Off-State selection used in Run mode. This parameter can be a value ofTIM_LL_EC_OSSRThis feature can be modified afterwards using unitary function LL_TIM_SetOffStates()Note:–This bit-field cannot be modified as long as LOCK level 2 has been programmed.
• uint32_t LL_TIM_BDTR_InitTypeDef::OSSIStateSpecifies the Off-State used in Idle state. This parameter can be a value of TIM_LL_EC_OSSIThis featurecan be modified afterwards using unitary function LL_TIM_SetOffStates()Note:–This bit-field cannot be modified as long as LOCK level 2 has been programmed.
• uint32_t LL_TIM_BDTR_InitTypeDef::LockLevelSpecifies the LOCK level parameters. This parameter can be a value of TIM_LL_EC_LOCKLEVELNote:–The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has beenwritten, their content is frozen until the next reset.
• uint8_t LL_TIM_BDTR_InitTypeDef::DeadTimeSpecifies the delay time between the switching-off and the switching-on of the outputs. This parameter canbe a number between Min_Data = 0x00 and Max_Data = 0xFF.This feature can be modified afterwardsusing unitary function LL_TIM_OC_SetDeadTime()Note:–This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed.


• uint16_t LL_TIM_BDTR_InitTypeDef::BreakStateSpecifies whether the TIM Break input is enabled or not. This parameter can be a value ofTIM_LL_EC_BREAK_ENABLEThis feature can be modified afterwards using unitary functionsLL_TIM_EnableBRK() or LL_TIM_DisableBRK()Note:–This bit-field can not be modified as long as LOCK level 1 has been programmed.
• uint32_t LL_TIM_BDTR_InitTypeDef::BreakPolaritySpecifies the TIM Break Input pin polarity. This parameter can be a value ofTIM_LL_EC_BREAK_POLARITYThis feature can be modified afterwards using unitary functionLL_TIM_ConfigBRK()Note:–This bit-field can not be modified as long as LOCK level 1 has been programmed.
• uint32_t LL_TIM_BDTR_InitTypeDef::AutomaticOutputSpecifies whether the TIM Automatic Output feature is enabled or not. This parameter can be a value ofTIM_LL_EC_AUTOMATICOUTPUT_ENABLEThis feature can be modified afterwards using unitaryfunctions LL_TIM_EnableAutomaticOutput() or LL_TIM_DisableAutomaticOutput()Note:–This bit-field can not be modified as long as LOCK level 1 has been programmed.


• Update event source set to LL_TIM_UPDATESOURCE_REGULAR: any of the following events generatean update interrupt or DMA request if enabled: Counter overflow/underflowSetting the UG bitUpdategeneration through the slave mode controller
• Update event source set to LL_TIM_UPDATESOURCE_COUNTER: only counter overflow/underflowgenerates an update interrupt or DMA request if enabled.


• Macro IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx) can be used to check whether or not thecounter mode selection feature is supported by a timer instance.
• Switching from Center Aligned counter mode to Edge counter mode (or reverse) requires a timer reset toavoid unexpected direction due to DIR bit readonly in center aligned mode.


• The counter clock frequency CK_CNT is equal to fCK_PSC / (PSC[15:0] + 1).
• The prescaler can be changed on the fly as this control register is buffered. The new prescaler ratio istaken into account at the next update event.
• Helper macro __LL_TIM_CALC_PSC can be used to calculate the Prescaler parameter


• CCxE, CCxNE and OCxM bits are preloaded, after having been written, they are updated only when acommutation event (COM) occurs.
• Only on channels that have a complementary output.
• Macro IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check whether or not a timerinstance is able to generate a commutation event.


• This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
• Macro IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether or not a timer instancecan clear the OCxREF signal on an external event.


• This function enables clearing the output channel on an external event.
• This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
• Macro IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether or not a timer instancecan clear the OCxREF signal on an external event.


• When external clock mode 2 is enabled the counter is clocked by any active edge on the ETRF signal.
• Macro IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check whether or not atimer instance supports external clock mode2.


• when selected clock source is external clock mode 1, the timer input the external clock is applied isselected by calling the LL_TIM_SetTriggerInput() function. This timer input must be configured by callingthe LL_TIM_IC_Config() function.
• Macro IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(TIMx) can be used to check whether or not atimer instance supports external clock mode1.
• Macro IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check whether or not atimer instance supports external clock mode2.


• The MOE bit in TIMx_BDTR register allows to enable /disable the outputs by software and is reset in caseof break or break2 event
• Macro IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not a timer instance provides abreak input.


• The MOE bit in TIMx_BDTR register allows to enable /disable the outputs by software and is reset in caseof break or break2 event.
• Macro IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not a timer instance provides abreak input.


• TIMx CH1, CH2 and CH3 inputs connected through a XOR to the TI1 input channel
• TIMx slave mode controller is configured in reset mode. Selected internal trigger is TI1F_ED.
• Channel 1 is configured as input, IC1 is mapped on TRC.
• Captured value stored in TIMx_CCR1 correspond to the time elapsed between 2 changes on the inputs. Itgives information about motor speed.
• Channel 2 is configured in output PWM 2 mode.
• Compare value stored in TIMx_CCR2 corresponds to the commutation delay.
• OC2REF is selected as trigger output on TRGO.


• As the bits AOE, BKP, BKE, OSSR, OSSI and DTG[7:0] can be write-locked depending on the LOCKconfiguration, it can be necessary to configure all of them during the first write access to the TIMx_BDTRregister.
• Macro IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not a timer instance provides abreak input.

Field Documentation
• uint32_t LL_USART_InitTypeDef::BaudRateThis field defines expected Usart communication baud rate.This feature can be modified afterwards usingunitary function LL_USART_SetBaudRate().
• uint32_t LL_USART_InitTypeDef::DataWidthSpecifies the number of data bits transmitted or received in a frame. This parameter can be a value ofUSART_LL_EC_DATAWIDTH.This feature can be modified afterwards using unitary functionLL_USART_SetDataWidth().
• uint32_t LL_USART_InitTypeDef::StopBitsSpecifies the number of stop bits transmitted. This parameter can be a value ofUSART_LL_EC_STOPBITS.This feature can be modified afterwards using unitary functionLL_USART_SetStopBitsLength().
• uint32_t LL_USART_InitTypeDef::ParitySpecifies the parity mode. This parameter can be a value of USART_LL_EC_PARITY.This feature can bemodified afterwards using unitary function LL_USART_SetParity().
• uint32_t LL_USART_InitTypeDef::TransferDirectionSpecifies whether the Receive and/or Transmit mode is enabled or disabled. This parameter can be a valueof USART_LL_EC_DIRECTION.This feature can be modified afterwards using unitary functionLL_USART_SetTransferDirection().
• uint32_t LL_USART_InitTypeDef::HardwareFlowControlSpecifies whether the hardware flow control mode is enabled or disabled. This parameter can be a value ofUSART_LL_EC_HWCONTROL.This feature can be modified afterwards using unitary functionLL_USART_SetHWFlowCtrl().
• uint32_t LL_USART_InitTypeDef::OverSamplingSpecifies whether USART oversampling mode is 16 or 8. This parameter can be a value ofUSART_LL_EC_OVERSAMPLING.This feature can be modified afterwards using unitary functionLL_USART_SetOverSampling().

Field Documentation
• uint32_t LL_USART_ClockInitTypeDef::ClockOutputSpecifies whether the USART clock is enabled or disabled. This parameter can be a value ofUSART_LL_EC_CLOCK.USART HW configuration can be modified afterwards using unitary functionsLL_USART_EnableSCLKOutput() or LL_USART_DisableSCLKOutput(). For more details, refer todescription of this function.
• uint32_t LL_USART_ClockInitTypeDef::ClockPolaritySpecifies the steady state of the serial clock. This parameter can be a value ofUSART_LL_EC_POLARITY.USART HW configuration can be modified afterwards using unitary functionsLL_USART_SetClockPolarity(). For more details, refer to description of this function.
• uint32_t LL_USART_ClockInitTypeDef::ClockPhaseSpecifies the clock transition on which the bit capture is made. This parameter can be a value ofUSART_LL_EC_PHASE.USART HW configuration can be modified afterwards using unitary functionsLL_USART_SetClockPhase(). For more details, refer to description of this function.
• uint32_t LL_USART_ClockInitTypeDef::LastBitClockPulseSpecifies whether the clock pulse corresponding to the last transmitted data bit (MSB) has to be output onthe SCLK pin in synchronous mode. This parameter can be a value ofUSART_LL_EC_LASTCLKPULSE.USART HW configuration can be modified afterwards using unitaryfunctions LL_USART_SetLastClkPulseOutput(). For more details, refer to description of this function.


• When USART is disabled, USART prescalers and outputs are stopped immediately, and current operationsare discarded. The configuration of the USART is kept, but all the status flags, in the USARTx_SR are setto their default values.


• This function selects if hardware parity control (generation and detection) is enabled or disabled. When theparity control is enabled (Odd or Even), computed parity bit is inserted at the MSB position (9th or 8th bitdepending on data width) and parity is checked on the received data.


• Macro IS_USART_INSTANCE(USARTx) can be used to check whether or not Synchronous mode issupported by the USARTx instance.
• Call of this function is equivalent to following function call sequence : Clock Phase configuration usingLL_USART_SetClockPhase() functionClock Polarity configuration using LL_USART_SetClockPolarity()functionOutput of Last bit Clock pulse configuration using LL_USART_SetLastClkPulseOutput() function


• Compute and set USARTDIV value in BRR Register (full BRR content) according to used Peripheral Clock,Oversampling mode, and expected Baud Rate values
• Peripheral clock and Baud rate values provided as function parameters should be valid (Baud rate value !=0)

Perform basic configuration of USART for enabling use in Multi processor Mode (several USARTs connected ina network, one of the USARTs can be the master, its TX output connected to the RX inputs of the other slavesUSARTs).


• Clearing this flag is done by a read access to the USARTx_SR register followed by a read access to theUSARTx_DR register.
• Please also consider that when clearing this flag, other flags as NE, FE, ORE, IDLE would also be cleared.


• Clearing this flag is done by a read access to the USARTx_SR register followed by a read access to theUSARTx_DR register.
• Please also consider that when clearing this flag, other flags as PE, NE, ORE, IDLE would also be cleared.


• Clearing this flag is done by a read access to the USARTx_SR register followed by a read access to theUSARTx_DR register.
• Please also consider that when clearing this flag, other flags as PE, FE, ORE, IDLE would also be cleared.


• Clearing this flag is done by a read access to the USARTx_SR register followed by a read access to theUSARTx_DR register.
• Please also consider that when clearing this flag, other flags as PE, NE, FE, IDLE would also be cleared.


• Clearing this flag is done by a read access to the USARTx_SR register followed by a read access to theUSARTx_DR register.
• Please also consider that when clearing this flag, other flags as PE, NE, FE, ORE would also be cleared.


• When set, Error Interrupt Enable Bit is enabling interrupt generation in case of a framing error, overrunerror or noise flag (FE=1 or ORE=1 or NF=1 in the USARTx_SR register). 0: Interrupt is inhibited 1: Aninterrupt is generated when FE=1 or ORE=1 or NF=1 in the USARTx_SR register.


• When set, Error Interrupt Enable Bit is enabling interrupt generation in case of a framing error, overrunerror or noise flag (FE=1 or ORE=1 or NF=1 in the USARTx_SR register). 0: Interrupt is inhibited 1: Aninterrupt is generated when FE=1 or ORE=1 or NF=1 in the USARTx_SR register.


• As some bits in USART configuration registers can only be written when the USART is disabled(USART_CR1_UE bit =0), USART IP should be in disabled state prior calling this function. Otherwise,ERROR result will be returned.
• Baud rate value stored in USART_InitStruct BaudRate field, should be valid (different from 0).


• As some bits in USART configuration registers can only be written when the USART is disabled(USART_CR1_UE bit =0), USART IP should be in disabled state prior calling this function. Otherwise,ERROR result will be returned.


• When a RTOS is used, it is recommended to avoid changing the Systick configuration by calling thisfunction, for a delay use rather osDelay RTOS service.
• HCLK frequency can be calculated thanks to RCC helper macro or functionLL_RCC_GetSystemClocksFreq


• When a RTOS is used, it is recommended to avoid using blocking delay and use rather osDelay service.
• To respect 1ms timebase, user should call LL_Init1msTick function which will configure Systick to 1ms


• The application need to ensure that PLL is disabled.
• Function is based on the following formula: PLL output frequency = ((HSI frequency / PREDIV) *PLLMUL)PREDIV: Set to 2 for few devicesPLLMUL: The application software must set correctly the PLLmultiplication factor to not exceed 72MHz
• FLASH latency can be modified through this function.


• The application need to ensure that PLL is disabled.
• Function is based on the following formula: PLL output frequency = ((HSI frequency / PREDIV) *PLLMUL)PREDIV: Set to 2 for few devicesPLLMUL: The application software must set correctly the PLLmultiplication factor to not exceed UTILS_PLL_OUTPUT_MAX
• FLASH latency can be modified through this function.


• It is enabled by setting the WDGA bit in the WWDG_CR register, then it cannot be disabled again exceptby a reset. This bit is set by software and only cleared by hardware after a reset. When WDGA = 1, thewatchdog can generate a reset.


• When writing to the WWDG_CR register, always write 1 in the MSB b6 to avoid generating an immediatereset This counter is decremented every (4096 x 2expWDGTB) PCLK cycles A reset is produced when itrolls over from 0x40 to 0x3F (bit T6 becomes cleared) Setting the counter lower then 0x40 causes animmediate reset (if WWDG enabled)


• This window value defines when write in the WWDG_CR register to program Watchdog counter is allowed.Watchdog counter value update must occur only when the counter value is lower than the Watchdogwindow register value. Otherwise, a MCU reset is generated if the 7-bit Watchdog counter value (in thecontrol register) is refreshed before the downcounter has reached the watchdog window register value.Physically is possible to set the Window lower then 0x40 but it is not recommended. To generate animmediate reset, it is possible to set the Counter lower than 0x40.


• This bit is set by hardware when the counter has reached the value 0x40. It must be cleared by software bywriting 0. A write of 1 has no effect. This bit is also set if the interrupt is not enabled.

There are many advantages in using the HAL drivers:
• Ease of use: you can use the HAL drivers to configure and control any peripheral embedded within yourSTM32 MCU without prior in-depth knowledge of the product.
• HAL drivers provide intuitive and ready-to-use APIs to configure the peripherals and support polling, interruptand DMA programming model to accommodate all application requirements, thus allowing the end-user tobuild a complete application by calling a few APIs.
• Higher level of abstraction than a standard peripheral library allowing to transparently manage:–Data transfers and processing using blocking mode (polling) or non-blocking mode (interrupt or DMA)–Error management through peripheral error detection and timeout mechanism.
• Generic architecture speeding up initialization and porting, thus allowing customers to focus on innovation.
• Generic set of APIs with full compatibility across the STM32 Series/lines, to ease the porting task betweenSTM32 MCUs.
• The APIs provided within the HAL drivers are feature-oriented and do not require in-depth knowledge ofperipheral operation.
• The APIs provided are modular. They include initialization, IO operation and control functions. The end-userhas to call init function, then start the process by calling one IO operation functions (write, read, transmit,receive, …). Most of the peripherals have the same architecture.
• The number of functions required to build a complete and useful application is very reduced. As an example,to build a UART communication process, the user only has to call HAL_UART_Init() thenHAL_UART_Transmit() or HAL_UART_Receive().

The HAL drivers are developed to support all STM32F1 devices. To ensure compatibility between all devices andportability with others Series and lines, the API is split into the generic and the extension APIs . For more details,please refer to section Devices supported by the HAL drivers.

Like generic architecture drivers, the HAL drivers may induce firmware overhead.This is due to the high abstraction level and ready-to-use APIs which allow data transfers, errors managementand offloads the user application from implementation details.

Only one file needs to be modified: stm32f1xx_hal_conf.h. You can modify this file by disabling unused modules,or adjusting some parameters (i.e. HSE value, System configuration…)A template is provided in the HAL drivers folders (stm32f1xx_hal_conf_template.c).

The HAL driver architecture supports common features across STM32 Series/lines. To support specific features,the drivers are split into two groups.
• The generic APIs (stm32f1xx_hal_ppp.c): It includes the common set of APIs across all the STM32 productlines

Unlike the standard library, the system clock configuration is not performed in CMSIS drivers file(system_stm32f1xx.c) but in the main user application by calling the two main functions, HAL_RCC_OscConfig()and HAL_RCC_ClockConfig(). It can be modified in any user application section.

These function are called within HAL_PPP_Init() and HAL_PPP_DeInit(), respectively. They are used to performthe low level Initialization/de-initialization related to the additional hardware resources (RCC, GPIO, NVIC andDMA).These functions are declared in stm32f1xx_hal_msp.c. A template is provided in the HAL driver folders(stm32f1xx_hal_msp_template.c).

Use callback functions for the I/O operations used in DMA or interrupt mode. The PPP process completecallbacks are called to inform the user about process completion in real-time event mode (interrupts).The Errors callbacks are called when a processing error occurs in DMA or interrupt mode. These callbacks arecustomized by the user to add user proprietary code. They can be declared in the application. Note that the sameprocess completion callbacks are used for DMA and interrupt mode.

It is mandatory to use HAL_Init() function to enable the system configuration (Prefetch, Data instruction cache,…),configure the systTick and the NVIC priority grouping and the hardware low level initialization.The SysTick configuration shall be adjusted by calling HAL_RCC_ClockConfig() function, to obtain 1 mswhatever the system clock.

The SysTick timer is configured to be used to generate variable increments by calling HAL_IncTick() function inSysTick ISR and retrieve the value of this variable by calling HAL_GetTick() function.The call HAL_GetTick() function is mandatory when using HAL drivers with Polling Process or when usingHAL_Delay().

Care must be taken when using HAL_Delay() since this function provides accurate delay based on a variableincremented in SysTick ISR. This implies that if HAL_Delay() is called from a peripheral ISR process, then theSysTick interrupt must have higher priority (numerically lower) than the peripheral interrupt, otherwise the callerISR process will be blocked. Use HAL_NVIC_SetPriority() function to change the SysTick interrupt priority.

HAL_PPP_IRQHandler() is used to handle interrupt process. It is called under PPP_IRQHandler() function instm32f1xx_it.c. In this case, the end-user has to implement only the callbacks functions (prefixed by __weak) toperform the appropriate action when an interrupt is detected. Advanced users can implement their own code inPPP_IRQHandler() without calling HAL_PPP_IRQHandler().

PPP_HandleTypedef structure peripheral handler must be declared as a global variable, so that all the structurefields are set to 0 by default. In this way, the peripheral handler default state are set to HAL_PPP_STATE_RESET,which is the default state for each peripheral after a system reset.

HAL drivers offer high-level and function-oriented APIs, with a high level of portability. Product/IPs complexity ishidden for end users. LL drivers offer low-level APIs at registers level, with a better optimization but lessportability. They require a deep knowledge of product/IPs specifications.

It is possible to use both HAL and LL drivers. One can handle the IP initialization phase with HAL and thenmanage the I/O operations with LL drivers. The major difference between HAL and LL is that HAL drivers requireto create and use handles for operation management while LL drivers operates directly on peripheral registers.Mixing HAL and LL is illustrated in Examples_MIX example.

When using LL drivers in standalone mode, you do not need to enable SysTick interrupts because they are notused in LL APIs, while HAL functions requires SysTick interrupts to manage timeouts.

STMicroelectronics NV and its subsidiaries (“ST”) reserve the right to make changes, corrections, enhancements, modifications, and improvements to STproducts and/or to this document at any time without notice. Purchasers should obtain the latest relevant information on ST products before placing orders. STproducts are sold pursuant to ST’s terms and conditions of sale in place at the time of order acknowledgement.

ST and the ST logo are trademarks of ST. For additional information about ST trademarks, please refer to www.st.com/trademarks. All other product or servicenames are the property of their respective owners.
